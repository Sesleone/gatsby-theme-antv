(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "+3V6":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__("X6VK");

$export($export.S, 'Array', { isArray: __webpack_require__("Xfku") });


/***/ }),

/***/ "+3YS":
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "+H3U":
/***/ (function(module, exports) {

module.exports = function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }

    idx += 1;
  }

  return result;
};

/***/ }),

/***/ "+Ltg":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

__webpack_require__("GkPX");

__webpack_require__("Z8gF");

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (false) {}

  if (!condition) {
    var error;

    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame

    throw error;
  }
};

module.exports = invariant;

/***/ }),

/***/ "+Sw5":
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "+Yd0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "onServiceWorkerUpdateFound", function() { return /* binding */ gatsby_browser_onServiceWorkerUpdateFound; });

// EXTERNAL MODULE: ../node_modules/antd/es/button/style/index.js
var style = __webpack_require__("sbMj");

// EXTERNAL MODULE: ../node_modules/antd/es/button/index.js + 2 modules
var es_button = __webpack_require__("H4M2");

// EXTERNAL MODULE: ../node_modules/antd/es/style/index.less
var es_style = __webpack_require__("SwVN");

// EXTERNAL MODULE: ../node_modules/antd/es/notification/style/index.less
var notification_style = __webpack_require__("FNAz");

// CONCATENATED MODULE: ../node_modules/antd/es/notification/style/index.js


// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__("DbwS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/rc-notification/es/index.js + 1 modules
var es = __webpack_require__("qtgu");

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/CloseOutlined.js
var CloseOutlined = __webpack_require__("EWXb");
var CloseOutlined_default = /*#__PURE__*/__webpack_require__.n(CloseOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/CheckCircleOutlined.js
var CheckCircleOutlined = __webpack_require__("fqg9");
var CheckCircleOutlined_default = /*#__PURE__*/__webpack_require__.n(CheckCircleOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/CloseCircleOutlined.js
var CloseCircleOutlined = __webpack_require__("aLAR");
var CloseCircleOutlined_default = /*#__PURE__*/__webpack_require__.n(CloseCircleOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/ExclamationCircleOutlined.js
var ExclamationCircleOutlined = __webpack_require__("ASIu");
var ExclamationCircleOutlined_default = /*#__PURE__*/__webpack_require__.n(ExclamationCircleOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/InfoCircleOutlined.js
var InfoCircleOutlined = __webpack_require__("Avyj");
var InfoCircleOutlined_default = /*#__PURE__*/__webpack_require__.n(InfoCircleOutlined);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.is-array.js
var es6_array_is_array = __webpack_require__("+3V6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.to-string.js
var es6_date_to_string = __webpack_require__("M/4x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/rc-notification/es/useNotification.js
var es_useNotification = __webpack_require__("bIG9");

// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/context.js + 4 modules
var context = __webpack_require__("Bfez");

// CONCATENATED MODULE: ../node_modules/antd/es/notification/hooks/useNotification.js










function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}




function createUseNotification(getNotificationInstance, getRCNoticeProps) {
  var useNotification = function useNotification() {
    // We can only get content by render
    var getPrefixCls; // We create a proxy to handle delay created instance

    var innerInstance = null;
    var proxy = {
      add: function add(noticeProps, holderCallback) {
        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);
      }
    };

    var _useRCNotification = Object(es_useNotification["a" /* default */])(proxy),
        _useRCNotification2 = _slicedToArray(_useRCNotification, 2),
        hookNotify = _useRCNotification2[0],
        holder = _useRCNotification2[1];

    function notify(args) {
      var customizePrefixCls = args.prefixCls;
      var mergedPrefixCls = getPrefixCls('notification', customizePrefixCls);
      getNotificationInstance(_extends(_extends({}, args), {
        prefixCls: mergedPrefixCls
      }), function (_ref) {
        var prefixCls = _ref.prefixCls,
            instance = _ref.instance;
        innerInstance = instance;
        hookNotify(getRCNoticeProps(args, prefixCls));
      });
    } // Fill functions


    var hookAPI = {
      open: notify
    };
    ['success', 'info', 'warning', 'error'].forEach(function (type) {
      hookAPI[type] = function (args) {
        return hookAPI.open(_extends(_extends({}, args), {
          type: type
        }));
      };
    });
    return [hookAPI, react["createElement"](context["a" /* ConfigConsumer */], {
      key: "holder"
    }, function (context) {
      getPrefixCls = context.getPrefixCls;
      return holder;
    })];
  };

  return useNotification;
}
// CONCATENATED MODULE: ../node_modules/antd/es/notification/index.js








function notification_extends() {
  notification_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return notification_extends.apply(this, arguments);
}









var notificationInstance = {};
var defaultDuration = 4.5;
var defaultTop = 24;
var defaultBottom = 24;
var defaultPlacement = 'topRight';
var defaultGetContainer;
var defaultCloseIcon;

function setNotificationConfig(options) {
  var duration = options.duration,
      placement = options.placement,
      bottom = options.bottom,
      top = options.top,
      getContainer = options.getContainer,
      closeIcon = options.closeIcon;

  if (duration !== undefined) {
    defaultDuration = duration;
  }

  if (placement !== undefined) {
    defaultPlacement = placement;
  }

  if (bottom !== undefined) {
    defaultBottom = bottom;
  }

  if (top !== undefined) {
    defaultTop = top;
  }

  if (getContainer !== undefined) {
    defaultGetContainer = getContainer;
  }

  if (closeIcon !== undefined) {
    defaultCloseIcon = closeIcon;
  }
}

function getPlacementStyle(placement) {
  var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTop;
  var bottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultBottom;
  var style;

  switch (placement) {
    case 'topLeft':
      style = {
        left: 0,
        top: top,
        bottom: 'auto'
      };
      break;

    case 'topRight':
      style = {
        right: 0,
        top: top,
        bottom: 'auto'
      };
      break;

    case 'bottomLeft':
      style = {
        left: 0,
        top: 'auto',
        bottom: bottom
      };
      break;

    default:
      style = {
        right: 0,
        top: 'auto',
        bottom: bottom
      };
      break;
  }

  return style;
}

function notification_getNotificationInstance(args, callback) {
  var _args$placement = args.placement,
      placement = _args$placement === void 0 ? defaultPlacement : _args$placement,
      top = args.top,
      bottom = args.bottom,
      _args$getContainer = args.getContainer,
      getContainer = _args$getContainer === void 0 ? defaultGetContainer : _args$getContainer,
      _args$closeIcon = args.closeIcon,
      closeIcon = _args$closeIcon === void 0 ? defaultCloseIcon : _args$closeIcon;
  var outerPrefixCls = args.prefixCls || 'ant-notification';
  var prefixCls = "".concat(outerPrefixCls, "-notice");
  var cacheKey = "".concat(outerPrefixCls, "-").concat(placement);
  var cacheInstance = notificationInstance[cacheKey];

  if (cacheInstance) {
    Promise.resolve(cacheInstance).then(function (instance) {
      callback({
        prefixCls: prefixCls,
        instance: instance
      });
    });
    return;
  }

  var closeIconToRender = react["createElement"]("span", {
    className: "".concat(outerPrefixCls, "-close-x")
  }, closeIcon || react["createElement"](CloseOutlined_default.a, {
    className: "".concat(outerPrefixCls, "-close-icon")
  }));
  notificationInstance[cacheKey] = new Promise(function (resolve) {
    es["a" /* default */].newInstance({
      prefixCls: outerPrefixCls,
      className: "".concat(outerPrefixCls, "-").concat(placement),
      style: getPlacementStyle(placement, top, bottom),
      getContainer: getContainer,
      closeIcon: closeIconToRender
    }, function (notification) {
      resolve(notification);
      callback({
        prefixCls: prefixCls,
        instance: notification
      });
    });
  });
}

var typeToIcon = {
  success: CheckCircleOutlined_default.a,
  info: InfoCircleOutlined_default.a,
  error: CloseCircleOutlined_default.a,
  warning: ExclamationCircleOutlined_default.a
};

function notification_getRCNoticeProps(args, prefixCls) {
  var duration = args.duration === undefined ? defaultDuration : args.duration;
  var iconNode = null;

  if (args.icon) {
    iconNode = react["createElement"]("span", {
      className: "".concat(prefixCls, "-icon")
    }, args.icon);
  } else if (args.type) {
    iconNode = react["createElement"](typeToIcon[args.type] || null, {
      className: "".concat(prefixCls, "-icon ").concat(prefixCls, "-icon-").concat(args.type)
    });
  }

  var autoMarginTag = !args.description && iconNode ? react["createElement"]("span", {
    className: "".concat(prefixCls, "-message-single-line-auto-margin")
  }) : null;
  return {
    content: react["createElement"]("div", {
      className: iconNode ? "".concat(prefixCls, "-with-icon") : ''
    }, iconNode, react["createElement"]("div", {
      className: "".concat(prefixCls, "-message")
    }, autoMarginTag, args.message), react["createElement"]("div", {
      className: "".concat(prefixCls, "-description")
    }, args.description), args.btn ? react["createElement"]("span", {
      className: "".concat(prefixCls, "-btn")
    }, args.btn) : null),
    duration: duration,
    closable: true,
    onClose: args.onClose,
    onClick: args.onClick,
    key: args.key,
    style: args.style || {},
    className: args.className
  };
}

var api = {
  open: function open(args) {
    notification_getNotificationInstance(args, function (_ref) {
      var prefixCls = _ref.prefixCls,
          instance = _ref.instance;
      instance.notice(notification_getRCNoticeProps(args, prefixCls));
    });
  },
  close: function close(key) {
    Object.keys(notificationInstance).forEach(function (cacheKey) {
      return Promise.resolve(notificationInstance[cacheKey]).then(function (instance) {
        instance.removeNotice(key);
      });
    });
  },
  config: setNotificationConfig,
  destroy: function destroy() {
    Object.keys(notificationInstance).forEach(function (cacheKey) {
      Promise.resolve(notificationInstance[cacheKey]).then(function (instance) {
        instance.destroy();
      });
      delete notificationInstance[cacheKey]; // lgtm[js/missing-await]
    });
  }
};
['success', 'info', 'warning', 'error'].forEach(function (type) {
  api[type] = function (args) {
    return api.open(notification_extends(notification_extends({}, args), {
      type: type
    }));
  };
});
api.warn = api.warning;
api.useNotification = createUseNotification(notification_getNotificationInstance, notification_getRCNoticeProps);
/* harmony default export */ var notification = (api);
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.starts-with.js
var es6_string_starts_with = __webpack_require__("FEHE");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__("oMRA");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __webpack_require__("6d4m");

// EXTERNAL MODULE: ../node_modules/codemirror/mode/javascript/javascript.js
var javascript = __webpack_require__("Bi0q");

// EXTERNAL MODULE: ../node_modules/codemirror/mode/jsx/jsx.js
var jsx = __webpack_require__("XUZz");

// EXTERNAL MODULE: ../node_modules/codemirror/mode/htmlembedded/htmlembedded.js
var htmlembedded = __webpack_require__("HAof");

// EXTERNAL MODULE: ../node_modules/codemirror/addon/selection/active-line.js
var active_line = __webpack_require__("oLHe");

// EXTERNAL MODULE: ../node_modules/codemirror/addon/edit/matchbrackets.js
var matchbrackets = __webpack_require__("wyB9");

// EXTERNAL MODULE: ../node_modules/codemirror/addon/edit/closebrackets.js
var closebrackets = __webpack_require__("94DX");

// EXTERNAL MODULE: ../node_modules/codemirror/addon/edit/matchtags.js
var matchtags = __webpack_require__("FUg+");

// EXTERNAL MODULE: ../node_modules/normalize.css/normalize.css
var normalize = __webpack_require__("1UZS");

// EXTERNAL MODULE: ../node_modules/prism-themes/themes/prism-base16-ateliersulphurpool.light.css
var prism_base16_ateliersulphurpool_light = __webpack_require__("SAwA");

// EXTERNAL MODULE: ../node_modules/prismjs/plugins/command-line/prism-command-line.css
var prism_command_line = __webpack_require__("wYtd");

// EXTERNAL MODULE: ../node_modules/codemirror/lib/codemirror.css
var codemirror = __webpack_require__("OLqI");

// EXTERNAL MODULE: ../node_modules/codemirror/theme/mdn-like.css
var mdn_like = __webpack_require__("fqqo");

// EXTERNAL MODULE: ../node_modules/rc-drawer/assets/index.css
var assets = __webpack_require__("ffXq");

// EXTERNAL MODULE: ../node_modules/docsearch.js/dist/cdn/docsearch.min.css
var docsearch_min = __webpack_require__("lAJ1");

// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/global.less
var global = __webpack_require__("qca1");

// EXTERNAL MODULE: ../node_modules/insert-css/index.js
var insert_css = __webpack_require__("3Q0B");
var insert_css_default = /*#__PURE__*/__webpack_require__.n(insert_css);

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/gatsby-browser.js
/**
 * Implement Gatsby's Browser APIs in this file.
 *
 * See: https://www.gatsbyjs.org/docs/browser-apis/
 */ // You can delete this file if you're not using it
window.insertCss=insert_css_default.a;if(window.location.host.includes('antv')){// prettier-ignore
/* eslint-disable */!function(t,e,a,r,c){t.TracertCmdCache=t.TracertCmdCache||[],t[c]=window[c]||{_isRenderInit:!0,call:function call(){t.TracertCmdCache.push(arguments);},start:function start(t){this.call('start',t);}},t[c].l=new Date();var n=e.createElement(a),s=e.getElementsByTagName(a)[0];n.async=!0,n.src=r,s.parentNode.insertBefore(n,s);n.onerror=function(){console.warn(decodeURI('Tracert%20%E8%84%9A%E6%9C%AC%E6%9C%AA%E6%88%90%E5%8A%9F%E5%8A%A0%E8%BD%BD,%20%E8%AF%B7%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E4%BB%A5%E5%8F%8A%20A%20%E4%BD%8D%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B9%9D%E8%89%B2%E9%B9%BF%E5%BB%BA%E7%AB%8B%E6%B4%9E%E5%AF%9F'));var fallback=function fallback(){console.warn(decodeURI('Tracert%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%EF%BC%8C%E8%AF%B7%E6%A3%80%E6%9F%A5%20JS%20%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E5%BC%95%E5%85%A5'));};for(var fnlist=["call","start","config","logPv","info","err","click","expo","pageName","pageState","time","timeEnd","parse","checkExpo","stringify","report","set","before"],i=0;i<fnlist.length;i++){t[c][fnlist[i]]=fallback;}};}(window,document,'script','https://ur.alipay.com/tracert_a369.js','Tracert');// 启动脚本
Tracert.start();}// gatsby-browser.js
var gatsby_browser_onServiceWorkerUpdateFound=function onServiceWorkerUpdateFound(){var lang=window.location.pathname.startsWith('/zh')?'zh':'en';notification.info({message:lang==='zh'?'站点更新':'Site Updated',description:lang==='zh'?'发现新的网站版本数据，是否需要重载页面以更新。':'This site has been updated with new data. Do you wish to reload the site to get the new data?',btn:react_default.a.createElement(es_button["a" /* default */],{type:"primary",size:"small",onClick:function onClick(){return window.location.reload(true);}},lang==='zh'?'重载页面':'Refresh'),key:'onServiceWorkerUpdateFound',placement:'bottomRight'});};

/***/ }),

/***/ "+bRE":
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "+eav":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("zWQs");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "+edc":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("sU/p");
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ "+jjx":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("z6KD")('asyncIterator');


/***/ }),

/***/ "+yb+":
/***/ (function(module, exports, __webpack_require__) {

var pipe = __webpack_require__("IycE");

var reverse = __webpack_require__("kku+");
/**
 * Performs right-to-left function composition. The rightmost function may have
 * any arity; the remaining functions must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 */


module.exports = function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }

  return pipe.apply(this, reverse(arguments));
};

/***/ }),

/***/ "/6KZ":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("41F1");
var core = __webpack_require__("TaGV");
var ctx = __webpack_require__("8Xl/");
var hide = __webpack_require__("PPkd");
var has = __webpack_require__("qA3Z");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "/6rt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("E7Vc");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ "/7QA":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("gVqz");
/* harmony import */ var _antv_g2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_g2__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ __webpack_exports__["default"] = (_antv_g2__WEBPACK_IMPORTED_MODULE_0___default.a);

/***/ }),

/***/ "/Lgp":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("Qqke");
var enumBugKeys = __webpack_require__("miGZ");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "/Vl9":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "/dwC":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__("X6VK");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),

/***/ "/hZi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CloseCircleOutlined = {
  "name": "close-circle",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }]
  }
};
exports["default"] = CloseCircleOutlined;

/***/ }),

/***/ "/l6L":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("uUP6"),
    Just = _require.Just,
    Nothing = _require.Nothing;
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 *
 * type: |
 *   forall a, b:
 *     (Result a b) => Maybe b
 */


var resultToMaybe = function resultToMaybe(aResult) {
  return aResult.matchWith({
    Error: function Error(_ref) {
      var _ = _ref.value;
      return Nothing();
    },
    Ok: function Ok(_ref2) {
      var value = _ref2.value;
      return Just(value);
    }
  });
};

module.exports = resultToMaybe;

/***/ }),

/***/ "/sSm":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("+3V6");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("75LO");

__webpack_require__("7lGJ");

__webpack_require__("DbwS");

__webpack_require__("t91x");

exports.__esModule = true;
exports["default"] = void 0;

var _off = _interopRequireDefault(__webpack_require__("EDUi"));

var _on = _interopRequireDefault(__webpack_require__("3Yb6"));

var _scrollLeft = _interopRequireDefault(__webpack_require__("UNIm"));

var _scrollTop = _interopRequireDefault(__webpack_require__("0eot"));

var _requestAnimationFrame = _interopRequireDefault(__webpack_require__("IsBi"));

var _invariant = _interopRequireDefault(__webpack_require__("+Ltg"));

var _utils = __webpack_require__("o7mQ");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* eslint-disable no-underscore-dangle */
// Try at most this many times to scroll, to avoid getting stuck.


var MAX_SCROLL_ATTEMPTS = 2;

var ScrollBehavior = /*#__PURE__*/function () {
  function ScrollBehavior(_ref) {
    var _this = this;

    var addTransitionHook = _ref.addTransitionHook,
        stateStorage = _ref.stateStorage,
        getCurrentLocation = _ref.getCurrentLocation,
        shouldUpdateScroll = _ref.shouldUpdateScroll;

    this._restoreScrollRestoration = function () {
      /* istanbul ignore if: not supported by any browsers on Travis */
      if (_this._oldScrollRestoration) {
        try {
          window.history.scrollRestoration = _this._oldScrollRestoration;
        } catch (e) {
          /* silence */
        }
      }
    };

    this._onWindowScroll = function () {
      if (_this._ignoreScrollEvents) {
        // Don't save the scroll position until the transition is complete
        return;
      } // It's possible that this scroll operation was triggered by what will be a
      // `POP` transition. Instead of updating the saved location immediately, we
      // have to enqueue the update, then potentially cancel it if we observe a
      // location update.


      if (!_this._saveWindowPositionHandle) {
        _this._saveWindowPositionHandle = (0, _requestAnimationFrame["default"])(_this._saveWindowPosition);
      }

      if (_this._windowScrollTarget) {
        var _this$_windowScrollTa = _this._windowScrollTarget,
            xTarget = _this$_windowScrollTa[0],
            yTarget = _this$_windowScrollTa[1];
        var x = (0, _scrollLeft["default"])(window);
        var y = (0, _scrollTop["default"])(window);

        if (x === xTarget && y === yTarget) {
          _this._windowScrollTarget = null;

          _this._cancelCheckWindowScroll();
        }
      }
    };

    this._saveWindowPosition = function () {
      _this._saveWindowPositionHandle = null;

      _this._savePosition(null, window);
    };

    this._checkWindowScrollPosition = function () {
      _this._checkWindowScrollHandle = null; // We can only get here if scrollTarget is set. Every code path that unsets
      // scroll target also cancels the handle to avoid calling this handler.
      // Still, check anyway just in case.

      /* istanbul ignore if: paranoid guard */

      if (!_this._windowScrollTarget) {
        return Promise.resolve();
      }

      _this.scrollToTarget(window, _this._windowScrollTarget);

      ++_this._numWindowScrollAttempts;
      /* istanbul ignore if: paranoid guard */

      if (_this._numWindowScrollAttempts >= MAX_SCROLL_ATTEMPTS) {
        // This might happen if the scroll position was already set to the target
        _this._windowScrollTarget = null;
        return Promise.resolve();
      }

      return new Promise(function (resolve) {
        _this._checkWindowScrollHandle = (0, _requestAnimationFrame["default"])(function () {
          return resolve(_this._checkWindowScrollPosition());
        });
      });
    };

    this._stateStorage = stateStorage;
    this._getCurrentLocation = getCurrentLocation;
    this._shouldUpdateScroll = shouldUpdateScroll; // This helps avoid some jankiness in fighting against the browser's
    // default scroll behavior on `POP` transitions.

    /* istanbul ignore else: Travis browsers all support this */

    if ('scrollRestoration' in window.history && // Unfortunately, Safari on iOS freezes for 2-6s after the user swipes to
    // navigate through history with scrollRestoration being 'manual', so we
    // need to detect this browser and exclude it from the following code
    // until this bug is fixed by Apple.
    !(0, _utils.isMobileSafari)()) {
      this._oldScrollRestoration = window.history.scrollRestoration;

      try {
        window.history.scrollRestoration = 'manual'; // Scroll restoration persists across page reloads. We want to reset
        // this to the original value, so that we can let the browser handle
        // restoring the initial scroll position on server-rendered pages.

        (0, _on["default"])(window, 'beforeunload', this._restoreScrollRestoration);
      } catch (e) {
        this._oldScrollRestoration = null;
      }
    } else {
      this._oldScrollRestoration = null;
    }

    this._saveWindowPositionHandle = null;
    this._checkWindowScrollHandle = null;
    this._windowScrollTarget = null;
    this._numWindowScrollAttempts = 0;
    this._ignoreScrollEvents = false;
    this._scrollElements = {}; // We have to listen to each window scroll update rather than to just
    // location updates, because some browsers will update scroll position
    // before emitting the location change.

    (0, _on["default"])(window, 'scroll', this._onWindowScroll);
    this._removeTransitionHook = addTransitionHook(function () {
      _requestAnimationFrame["default"].cancel(_this._saveWindowPositionHandle);

      _this._saveWindowPositionHandle = null;
      Object.keys(_this._scrollElements).forEach(function (key) {
        var scrollElement = _this._scrollElements[key];

        _requestAnimationFrame["default"].cancel(scrollElement.savePositionHandle);

        scrollElement.savePositionHandle = null; // It's fine to save element scroll positions here, though; the browser
        // won't modify them.

        if (!_this._ignoreScrollEvents) {
          _this._saveElementPosition(key);
        }
      });
    });
  }

  var _proto = ScrollBehavior.prototype;

  _proto.registerElement = function registerElement(key, element, shouldUpdateScroll, context) {
    var _this2 = this;

    !!this._scrollElements[key] ?  false ? undefined : invariant(false) : void 0;

    var saveElementPosition = function saveElementPosition() {
      _this2._saveElementPosition(key);
    };

    var scrollElement = {
      element: element,
      shouldUpdateScroll: shouldUpdateScroll,
      savePositionHandle: null,
      onScroll: function onScroll() {
        if (!scrollElement.savePositionHandle && !_this2._ignoreScrollEvents) {
          scrollElement.savePositionHandle = (0, _requestAnimationFrame["default"])(saveElementPosition);
        }
      }
    }; // In case no scrolling occurs, save the initial position

    if (!scrollElement.savePositionHandle && !this._ignoreScrollEvents) {
      scrollElement.savePositionHandle = (0, _requestAnimationFrame["default"])(saveElementPosition);
    }

    this._scrollElements[key] = scrollElement;
    (0, _on["default"])(element, 'scroll', scrollElement.onScroll);

    this._updateElementScroll(key, null, context);
  };

  _proto.unregisterElement = function unregisterElement(key) {
    !this._scrollElements[key] ?  false ? undefined : invariant(false) : void 0;
    var _this$_scrollElements = this._scrollElements[key],
        element = _this$_scrollElements.element,
        onScroll = _this$_scrollElements.onScroll,
        savePositionHandle = _this$_scrollElements.savePositionHandle;
    (0, _off["default"])(element, 'scroll', onScroll);

    _requestAnimationFrame["default"].cancel(savePositionHandle);

    delete this._scrollElements[key];
  };

  _proto.updateScroll = function updateScroll(prevContext, context) {
    var _this3 = this;

    this._updateWindowScroll(prevContext, context).then(function () {
      // Save the position immediately after a transition so that if no
      // scrolling occurs, there is still a saved position
      if (!_this3._saveWindowPositionHandle) {
        _this3._saveWindowPositionHandle = (0, _requestAnimationFrame["default"])(_this3._saveWindowPosition);
      }
    });

    Object.keys(this._scrollElements).forEach(function (key) {
      _this3._updateElementScroll(key, prevContext, context);
    });
  };

  _proto.stop = function stop() {
    this._restoreScrollRestoration();

    (0, _off["default"])(window, 'scroll', this._onWindowScroll);

    this._cancelCheckWindowScroll();

    this._removeTransitionHook();
  };

  _proto.startIgnoringScrollEvents = function startIgnoringScrollEvents() {
    this._ignoreScrollEvents = true;
  };

  _proto.stopIgnoringScrollEvents = function stopIgnoringScrollEvents() {
    this._ignoreScrollEvents = false;
  };

  _proto._cancelCheckWindowScroll = function _cancelCheckWindowScroll() {
    _requestAnimationFrame["default"].cancel(this._checkWindowScrollHandle);

    this._checkWindowScrollHandle = null;
  };

  _proto._saveElementPosition = function _saveElementPosition(key) {
    var scrollElement = this._scrollElements[key];
    scrollElement.savePositionHandle = null;

    this._savePosition(key, scrollElement.element);
  };

  _proto._savePosition = function _savePosition(key, element) {
    this._stateStorage.save(this._getCurrentLocation(), key, [(0, _scrollLeft["default"])(element), (0, _scrollTop["default"])(element)]);
  };

  _proto._updateWindowScroll = function _updateWindowScroll(prevContext, context) {
    // Whatever we were doing before isn't relevant any more.
    this._cancelCheckWindowScroll();

    this._windowScrollTarget = this._getScrollTarget(null, this._shouldUpdateScroll, prevContext, context); // Updating the window scroll position is really flaky. Just trying to
    // scroll it isn't enough. Instead, try to scroll a few times until it
    // works.

    this._numWindowScrollAttempts = 0;
    return this._checkWindowScrollPosition();
  };

  _proto._updateElementScroll = function _updateElementScroll(key, prevContext, context) {
    var _this$_scrollElements2 = this._scrollElements[key],
        element = _this$_scrollElements2.element,
        shouldUpdateScroll = _this$_scrollElements2.shouldUpdateScroll;

    var scrollTarget = this._getScrollTarget(key, shouldUpdateScroll, prevContext, context);

    if (!scrollTarget) {
      return;
    } // Unlike with the window, there shouldn't be any flakiness to deal with
    // here.


    this.scrollToTarget(element, scrollTarget);
  };

  _proto._getDefaultScrollTarget = function _getDefaultScrollTarget(location) {
    var hash = location.hash;

    if (hash && hash !== '#') {
      return hash.charAt(0) === '#' ? hash.slice(1) : hash;
    }

    return [0, 0];
  };

  _proto._getScrollTarget = function _getScrollTarget(key, shouldUpdateScroll, prevContext, context) {
    var scrollTarget = shouldUpdateScroll ? shouldUpdateScroll.call(this, prevContext, context) : true;

    if (!scrollTarget || Array.isArray(scrollTarget) || typeof scrollTarget === 'string') {
      return scrollTarget;
    }

    var location = this._getCurrentLocation();

    return this._getSavedScrollTarget(key, location) || this._getDefaultScrollTarget(location);
  };

  _proto._getSavedScrollTarget = function _getSavedScrollTarget(key, location) {
    if (location.action === 'PUSH') {
      return null;
    }

    return this._stateStorage.read(location, key);
  };

  _proto.scrollToTarget = function scrollToTarget(element, target) {
    if (typeof target === 'string') {
      var targetElement = document.getElementById(target) || document.getElementsByName(target)[0];

      if (targetElement) {
        targetElement.scrollIntoView();
        return;
      } // Fallback to scrolling to top when target fragment doesn't exist.


      target = [0, 0]; // eslint-disable-line no-param-reassign
    }

    var _target = target,
        left = _target[0],
        top = _target[1];
    (0, _scrollLeft["default"])(element, left);
    (0, _scrollTop["default"])(element, top);
  };

  return ScrollBehavior;
}();

exports["default"] = ScrollBehavior;
module.exports = exports["default"];

/***/ }),

/***/ "0942":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "0HwX":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("kBaS");
var createDesc = __webpack_require__("zJT+");
var toIObject = __webpack_require__("T/1i");
var toPrimitive = __webpack_require__("HbTz");
var has = __webpack_require__("qA3Z");
var IE8_DOM_DEFINE = __webpack_require__("UTwT");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("lBnu") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "0ONX":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("7lGJ");

__webpack_require__("d3/y");

__webpack_require__("ABKx");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

var keys = Object.keys;
var symbols = Object.getOwnPropertySymbols;
var defineProperty = Object.defineProperty;
var property = Object.getOwnPropertyDescriptor;
/*
 * Extends an objects with own enumerable key/value pairs from other sources.
 *
 * This is used to define objects for the ADTs througout this file, and there
 * are some important differences from Object.assign:
 *
 *   - This code is only concerned with own enumerable property *names*.
 *   - Additionally this code copies all own symbols (important for tags).
 *
 * When copying, this function copies **whole property descriptors**, which
 * means getters/setters are not executed during the copying. The only
 * exception is when the property name is `prototype`, which is not
 * configurable in functions by default.
 *
 * This code only special cases `prototype` because any other non-configurable
 * property is considered an error, and should crash the program so it can be
 * fixed.
 */

function extend(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (source) {
    keys(source).forEach(function (key) {
      if (key === 'prototype') {
        target[key] = source[key];
      } else {
        defineProperty(target, key, property(source, key));
      }
    });
    symbols(source).forEach(function (symbol) {
      defineProperty(target, symbol, property(source, symbol));
    });
  });
  return target;
}

module.exports = extend;

/***/ }),

/***/ "0Sp3":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("67sl")('wks');
var uid = __webpack_require__("ct/D");
var Symbol = __webpack_require__("41F1").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "0eot":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports["default"] = scrollTop;

var _isWindow = _interopRequireDefault(__webpack_require__("wiq9"));

function scrollTop(node, val) {
  var win = (0, _isWindow["default"])(node);
  if (val === undefined) return win ? 'pageYOffset' in win ? win.pageYOffset : win.document.documentElement.scrollTop : node.scrollTop;
  if (win) win.scrollTo('pageXOffset' in win ? win.pageXOffset : win.document.documentElement.scrollLeft, val);else node.scrollTop = val;
}

module.exports = exports["default"];

/***/ }),

/***/ "0oPD":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "1Alt":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "1Tj+":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("IdFN");
var createDesc = __webpack_require__("WWmS");
var toIObject = __webpack_require__("ml72");
var toPrimitive = __webpack_require__("5MU4");
var has = __webpack_require__("ezc+");
var IE8_DOM_DEFINE = __webpack_require__("HWsP");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("GGqZ") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "1qKx":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__("X6VK");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__("3ydu").set });


/***/ }),

/***/ "1qWy":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("Z8gF");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getUserLangKey = __webpack_require__("nsWf");

var _getUserLangKey2 = _interopRequireDefault(_getUserLangKey);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Redirect to user language home page, from: / to: /langKey/
 * @param {[String]} langs allowed lang keys ['en', 'fr', 'pt']
 * @param {String} defaultLangKey default browser language key
 * @return {void}
 */


var redirectToHome = function redirectToHome(langs, defaultLangKey) {
  if (typeof window === 'undefined') {
    return;
  }

  var langKey = (0, _getUserLangKey2["default"])(langs, defaultLangKey);
  var newUrl = '/' + langKey + '/';
  window.location.replace(newUrl);
};

exports["default"] = redirectToHome;

/***/ }),

/***/ "1rpk":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");
/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */


module.exports = _curry2(function identical(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});

/***/ }),

/***/ "1wfo":
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__("9liC");
var IObject = __webpack_require__("Cmsx");
var toObject = __webpack_require__("UnHL");
var toLength = __webpack_require__("Sp5b");
var asc = __webpack_require__("C5nI");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "2Hgx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("GkPX");

__webpack_require__("9ovy");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("J8hF");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("+3V6");

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
var hasElementType = typeof Element !== 'undefined';

function equal(a, b) {
  // fast-deep-equal index.js 2.0.1
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a),
        arrB = isArray(b),
        i,
        length,
        key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!equal(a[i], b[i])) return false;
      }

      return true;
    }

    if (arrA != arrB) return false;
    var dateA = a instanceof Date,
        dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();
    var regexpA = a instanceof RegExp,
        regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();
    var keys = keyList(a);
    length = keys.length;
    if (length !== keyList(b).length) return false;

    for (i = length; i-- !== 0;) {
      if (!hasProp.call(b, keys[i])) return false;
    } // end fast-deep-equal
    // start react-fast-compare
    // custom handling for DOM elements


    if (hasElementType && a instanceof Element && b instanceof Element) return a === b; // custom handling for React

    for (i = length; i-- !== 0;) {
      key = keys[i];

      if (key === '_owner' && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner.
        //  _owner contains circular references
        // and is not needed when comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of a react element
        continue;
      } else {
        // all other properties should be traversed as usual
        if (!equal(a[key], b[key])) return false;
      }
    } // end react-fast-compare
    // fast-deep-equal index.js 2.0.1


    return true;
  }

  return a !== a && b !== b;
} // end fast-deep-equal


module.exports = function exportedEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);
      return false;
    } // some other error. we should definitely know about these


    throw error;
  }
};

/***/ }),

/***/ "2LOZ":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("Ibj2");
var ITERATOR = __webpack_require__("9dxi")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "2Tod":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__("X6VK");
var ownKeys = __webpack_require__("j/vf");
var toIObject = __webpack_require__("ml72");
var gOPD = __webpack_require__("1Tj+");
var createProperty = __webpack_require__("CIiV");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ "2UZ+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__("X6VK");
var $find = __webpack_require__("1wfo")(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__("OfmW")(KEY);


/***/ }),

/***/ "2agF":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Dependencies

__webpack_require__("V7cS");

__webpack_require__("+3V6");

var protocols = __webpack_require__("30gj");
/**
 * isSsh
 * Checks if an input value is a ssh url or not.
 *
 * @name isSsh
 * @function
 * @param {String|Array} input The input url or an array of protocols.
 * @return {Boolean} `true` if the input is a ssh url, `false` otherwise.
 */


function isSsh(input) {
  if (Array.isArray(input)) {
    return input.indexOf("ssh") !== -1 || input.indexOf("rsync") !== -1;
  }

  if (typeof input !== "string") {
    return false;
  }

  var prots = protocols(input);
  input = input.substring(input.indexOf("://") + 3);

  if (isSsh(prots)) {
    return true;
  } // TODO This probably could be improved :)


  return input.indexOf("@") < input.indexOf(":");
}

module.exports = isSsh;

/***/ }),

/***/ "2lBV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__("yO+b");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2["default"])(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "2y5g":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9ovy");

__webpack_require__("V7cS");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  "use strict";

  CodeMirror.multiplexingMode = function (outer
  /*, others */
  ) {
    // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects
    var others = Array.prototype.slice.call(arguments, 1);

    function indexOf(string, pattern, from, returnEnd) {
      if (typeof pattern == "string") {
        var found = string.indexOf(pattern, from);
        return returnEnd && found > -1 ? found + pattern.length : found;
      }

      var m = pattern.exec(from ? string.slice(from) : string);
      return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;
    }

    return {
      startState: function startState() {
        return {
          outer: CodeMirror.startState(outer),
          innerActive: null,
          inner: null
        };
      },
      copyState: function copyState(state) {
        return {
          outer: CodeMirror.copyState(outer, state.outer),
          innerActive: state.innerActive,
          inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)
        };
      },
      token: function token(stream, state) {
        if (!state.innerActive) {
          var cutOff = Infinity,
              oldContent = stream.string;

          for (var i = 0; i < others.length; ++i) {
            var other = others[i];
            var found = indexOf(oldContent, other.open, stream.pos);

            if (found == stream.pos) {
              if (!other.parseDelimiters) stream.match(other.open);
              state.innerActive = other; // Get the outer indent, making sure to handle CodeMirror.Pass

              var outerIndent = 0;

              if (outer.indent) {
                var possibleOuterIndent = outer.indent(state.outer, "", "");
                if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;
              }

              state.inner = CodeMirror.startState(other.mode, outerIndent);
              return other.delimStyle && other.delimStyle + " " + other.delimStyle + "-open";
            } else if (found != -1 && found < cutOff) {
              cutOff = found;
            }
          }

          if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);
          var outerToken = outer.token(stream, state.outer);
          if (cutOff != Infinity) stream.string = oldContent;
          return outerToken;
        } else {
          var curInner = state.innerActive,
              oldContent = stream.string;

          if (!curInner.close && stream.sol()) {
            state.innerActive = state.inner = null;
            return this.token(stream, state);
          }

          var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;

          if (found == stream.pos && !curInner.parseDelimiters) {
            stream.match(curInner.close);
            state.innerActive = state.inner = null;
            return curInner.delimStyle && curInner.delimStyle + " " + curInner.delimStyle + "-close";
          }

          if (found > -1) stream.string = oldContent.slice(0, found);
          var innerToken = curInner.mode.token(stream, state.inner);
          if (found > -1) stream.string = oldContent;
          if (found == stream.pos && curInner.parseDelimiters) state.innerActive = state.inner = null;

          if (curInner.innerStyle) {
            if (innerToken) innerToken = innerToken + " " + curInner.innerStyle;else innerToken = curInner.innerStyle;
          }

          return innerToken;
        }
      },
      indent: function indent(state, textAfter, line) {
        var mode = state.innerActive ? state.innerActive.mode : outer;
        if (!mode.indent) return CodeMirror.Pass;
        return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);
      },
      blankLine: function blankLine(state) {
        var mode = state.innerActive ? state.innerActive.mode : outer;

        if (mode.blankLine) {
          mode.blankLine(state.innerActive ? state.inner : state.outer);
        }

        if (!state.innerActive) {
          for (var i = 0; i < others.length; ++i) {
            var other = others[i];

            if (other.open === "\n") {
              state.innerActive = other;
              state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "", "") : 0);
            }
          }
        } else if (state.innerActive.close === "\n") {
          state.innerActive = state.inner = null;
        }
      },
      electricChars: outer.electricChars,
      innerMode: function innerMode(state) {
        return state.inner ? {
          state: state.inner,
          mode: state.innerActive.mode
        } : {
          state: state.outer,
          mode: outer
        };
      }
    };
  };
});

/***/ }),

/***/ "30gj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * protocols
 * Returns the protocols of an input url.
 *
 * @name protocols
 * @function
 * @param {String} input The input url.
 * @param {Boolean|Number} first If `true`, the first protocol will be returned. If number, it will represent the zero-based index of the protocols array.
 * @return {Array|String} The array of protocols or the specified protocol.
 */

__webpack_require__("asZ9");

__webpack_require__("9p7t");

__webpack_require__("V7cS");

module.exports = function protocols(input, first) {
  if (first === true) {
    first = 0;
  }

  var index = input.indexOf("://"),
      splits = input.substring(0, index).split("+").filter(Boolean);

  if (typeof first === "number") {
    return splits[first];
  }

  return splits;
};

/***/ }),

/***/ "3AxU":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * stability: stable
 * authors:
 *   - Quildreen Motta
 *
 * complexity: O(n), n is the number of own enumerable properties.
 * type: |
 *   (Object 'a, ('a) => 'b) => Object 'b
 */

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

var mapValues = function mapValues(object, transformation) {
  var keys = Object.keys(object);
  var result = {};

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    result[key] = transformation(object[key]);
  }

  return result;
}; // --[ Convenience ]---------------------------------------------------

/*~
 * stability: stable
 * authors:
 *   - Quildreen Motta
 * 
 * complexity: O(n), n is the number of own enumerable properties.
 * type: |
 *   (Object 'a) . (('a) => 'b) => Object 'b
 */


mapValues.infix = function (transformation) {
  return mapValues(this, transformation);
}; // --[ Exports ]-------------------------------------------------------


module.exports = mapValues;

/***/ }),

/***/ "3D/W":
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__("r/sL");

var _curry1 = __webpack_require__("AN6r");

var _curry2 = __webpack_require__("OFPg");

var _curryN = __webpack_require__("ZWs+");
/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      var sumArgs = (...args) => R.sum(args);
 *
 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */


module.exports = _curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }

  return _arity(length, _curryN(length, [], fn));
});

/***/ }),

/***/ "3DBk":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__("X6VK");
var $values = __webpack_require__("pGW6")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),

/***/ "3PM6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("mthV"),
    Success = _require.Success,
    Failure = _require.Failure;
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   forall a, b:
 *     (Maybe a, b) => Validation b a
 */


var maybeToValidation = function maybeToValidation(aMaybe, failureValue) {
  return aMaybe.matchWith({
    Nothing: function Nothing() {
      return Failure(failureValue);
    },
    Just: function Just(_ref) {
      var value = _ref.value;
      return Success(value);
    }
  });
};

module.exports = maybeToValidation;

/***/ }),

/***/ "3Q0B":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("V7cS");

var containers = []; // will store container HTMLElement references

var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';

function insertCss(css, options) {
  options = options || {};

  if (css === undefined) {
    throw new Error(usage);
  }

  var position = options.prepend === true ? 'prepend' : 'append';
  var container = options.container !== undefined ? options.container : document.querySelector('head');
  var containerId = containers.indexOf(container); // first time we see this container, create the necessary entries

  if (containerId === -1) {
    containerId = containers.push(container) - 1;
    styleElements[containerId] = {};
  } // try to get the correponding container + position styleElement, create it otherwise


  var styleElement;

  if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
    styleElement = styleElements[containerId][position];
  } else {
    styleElement = styleElements[containerId][position] = createStyleElement();

    if (position === 'prepend') {
      container.insertBefore(styleElement, container.childNodes[0]);
    } else {
      container.appendChild(styleElement);
    }
  } // strip potential UTF-8 BOM if css was read from a file


  if (css.charCodeAt(0) === 0xFEFF) {
    css = css.substr(1, css.length);
  } // actually add the stylesheet


  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText += css;
  } else {
    styleElement.textContent += css;
  }

  return styleElement;
}

;

function createStyleElement() {
  var styleElement = document.createElement('style');
  styleElement.setAttribute('type', 'text/css');
  return styleElement;
}

module.exports = insertCss;
module.exports.insertCss = insertCss;

/***/ }),

/***/ "3Yb6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports["default"] = void 0;

var _inDOM = _interopRequireDefault(__webpack_require__("Dhpq"));

var on = function on() {};

if (_inDOM["default"]) {
  on = function () {
    if (document.addEventListener) return function (node, eventName, handler, capture) {
      return node.addEventListener(eventName, handler, capture || false);
    };else if (document.attachEvent) return function (node, eventName, handler) {
      return node.attachEvent('on' + eventName, function (e) {
        e = e || window.event;
        e.target = e.target || e.srcElement;
        e.currentTarget = node;
        handler.call(node, e);
      });
    };
  }();
}

var _default = on;
exports["default"] = _default;
module.exports = exports["default"];

/***/ }),

/***/ "3y5y":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var $reduce = __webpack_require__("9Bb+");

$export($export.P + $export.F * !__webpack_require__("/6rt")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "3ydu":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__("Bsg+");
var anObject = __webpack_require__("PAFS");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__("9liC")(Function.call, __webpack_require__("1Tj+").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "41F1":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "46Dl":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("3y5y");

__webpack_require__("GkPX");

function attrString(attrs) {
  var buff = [];

  for (var key in attrs) {
    buff.push(key + '="' + attrs[key] + '"');
  }

  if (!buff.length) {
    return '';
  }

  return ' ' + buff.join(' ');
}

function stringify(buff, doc) {
  switch (doc.type) {
    case 'text':
      return buff + doc.content;

    case 'tag':
      buff += '<' + doc.name + (doc.attrs ? attrString(doc.attrs) : '') + (doc.voidElement ? '/>' : '>');

      if (doc.voidElement) {
        return buff;
      }

      return buff + doc.children.reduce(stringify, '') + '</' + doc.name + '>';
  }
}

module.exports = function (doc) {
  return doc.reduce(function (token, rootEl) {
    return token + stringify('', rootEl);
  }, '');
};

/***/ }),

/***/ "4Alm":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEventListenerWrap; });
/* harmony import */ var add_dom_event_listener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("BJf6");
/* harmony import */ var add_dom_event_listener__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(add_dom_event_listener__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("xARA");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);


function addEventListenerWrap(target, eventType, cb, option) {
  /* eslint camelcase: 2 */
  var callback = react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.unstable_batchedUpdates ? function run(e) {
    react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.unstable_batchedUpdates(cb, e);
  } : cb;
  return add_dom_event_listener__WEBPACK_IMPORTED_MODULE_0___default()(target, eventType, callback, option);
}

/***/ }),

/***/ "4N2q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @ignore
 * event object for dom
 * @author yiminghe@gmail.com
 */


__webpack_require__("7t+O");

__webpack_require__("9ovy");

__webpack_require__("7lGJ");

__webpack_require__("d3/y");

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _EventBaseObject = __webpack_require__("B3fu");

var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

var _objectAssign = __webpack_require__("IL7q");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var TRUE = true;
var FALSE = false;
var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

function isNullOrUndefined(w) {
  return w === null || w === undefined;
}

var eventNormalizers = [{
  reg: /^key/,
  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
  fix: function fix(event, nativeEvent) {
    if (isNullOrUndefined(event.which)) {
      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
    } // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)


    if (event.metaKey === undefined) {
      event.metaKey = event.ctrlKey;
    }
  }
}, {
  reg: /^touch/,
  props: ['touches', 'changedTouches', 'targetTouches']
}, {
  reg: /^hashchange$/,
  props: ['newURL', 'oldURL']
}, {
  reg: /^gesturechange$/i,
  props: ['rotation', 'scale']
}, {
  reg: /^(mousewheel|DOMMouseScroll)$/,
  props: [],
  fix: function fix(event, nativeEvent) {
    var deltaX = undefined;
    var deltaY = undefined;
    var delta = undefined;
    var wheelDelta = nativeEvent.wheelDelta;
    var axis = nativeEvent.axis;
    var wheelDeltaY = nativeEvent.wheelDeltaY;
    var wheelDeltaX = nativeEvent.wheelDeltaX;
    var detail = nativeEvent.detail; // ie/webkit

    if (wheelDelta) {
      delta = wheelDelta / 120;
    } // gecko


    if (detail) {
      // press control e.detail == 1 else e.detail == 3
      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
    } // Gecko


    if (axis !== undefined) {
      if (axis === event.HORIZONTAL_AXIS) {
        deltaY = 0;
        deltaX = 0 - delta;
      } else if (axis === event.VERTICAL_AXIS) {
        deltaX = 0;
        deltaY = delta;
      }
    } // Webkit


    if (wheelDeltaY !== undefined) {
      deltaY = wheelDeltaY / 120;
    }

    if (wheelDeltaX !== undefined) {
      deltaX = -1 * wheelDeltaX / 120;
    } // 默认 deltaY (ie)


    if (!deltaX && !deltaY) {
      deltaY = delta;
    }

    if (deltaX !== undefined) {
      /**
       * deltaX of mousewheel event
       * @property deltaX
       * @member Event.DomEvent.Object
       */
      event.deltaX = deltaX;
    }

    if (deltaY !== undefined) {
      /**
       * deltaY of mousewheel event
       * @property deltaY
       * @member Event.DomEvent.Object
       */
      event.deltaY = deltaY;
    }

    if (delta !== undefined) {
      /**
       * delta of mousewheel event
       * @property delta
       * @member Event.DomEvent.Object
       */
      event.delta = delta;
    }
  }
}, {
  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
  fix: function fix(event, nativeEvent) {
    var eventDoc = undefined;
    var doc = undefined;
    var body = undefined;
    var target = event.target;
    var button = nativeEvent.button; // Calculate pageX/Y if missing and clientX/Y available

    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
      eventDoc = target.ownerDocument || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    } // which for click: 1 === left; 2 === middle; 3 === right
    // do not use button


    if (!event.which && button !== undefined) {
      if (button & 1) {
        event.which = 1;
      } else if (button & 2) {
        event.which = 3;
      } else if (button & 4) {
        event.which = 2;
      } else {
        event.which = 0;
      }
    } // add relatedTarget, if necessary


    if (!event.relatedTarget && event.fromElement) {
      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
    }

    return event;
  }
}];

function retTrue() {
  return TRUE;
}

function retFalse() {
  return FALSE;
}

function DomEventObject(nativeEvent) {
  var type = nativeEvent.type;
  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

  _EventBaseObject2['default'].call(this);

  this.nativeEvent = nativeEvent; // in case dom event has been mark as default prevented by lower dom node

  var isDefaultPrevented = retFalse;

  if ('defaultPrevented' in nativeEvent) {
    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
  } else if ('getPreventDefault' in nativeEvent) {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
  } else if ('returnValue' in nativeEvent) {
    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
  }

  this.isDefaultPrevented = isDefaultPrevented;
  var fixFns = [];
  var fixFn = undefined;
  var l = undefined;
  var prop = undefined;
  var props = commonProps.concat();
  eventNormalizers.forEach(function (normalizer) {
    if (type.match(normalizer.reg)) {
      props = props.concat(normalizer.props);

      if (normalizer.fix) {
        fixFns.push(normalizer.fix);
      }
    }
  });
  l = props.length; // clone properties of the original event object

  while (l) {
    prop = props[--l];
    this[prop] = nativeEvent[prop];
  } // fix target property, if necessary


  if (!this.target && isNative) {
    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
  } // check if target is a text node (safari)


  if (this.target && this.target.nodeType === 3) {
    this.target = this.target.parentNode;
  }

  l = fixFns.length;

  while (l) {
    fixFn = fixFns[--l];
    fixFn(this, nativeEvent);
  }

  this.timeStamp = nativeEvent.timeStamp || Date.now();
}

var EventBaseObjectProto = _EventBaseObject2['default'].prototype;
(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
  constructor: DomEventObject,
  preventDefault: function preventDefault() {
    var e = this.nativeEvent; // if preventDefault exists run it on the original event

    if (e.preventDefault) {
      e.preventDefault();
    } else {
      // otherwise set the returnValue property of the original event to FALSE (IE)
      e.returnValue = FALSE;
    }

    EventBaseObjectProto.preventDefault.call(this);
  },
  stopPropagation: function stopPropagation() {
    var e = this.nativeEvent; // if stopPropagation exists run it on the original event

    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      // otherwise set the cancelBubble property of the original event to TRUE (IE)
      e.cancelBubble = TRUE;
    }

    EventBaseObjectProto.stopPropagation.call(this);
  }
});
exports['default'] = DomEventObject;
module.exports = exports['default'];

/***/ }),

/***/ "4NbO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CheckCircleFilled = {
  "name": "check-circle",
  "theme": "filled",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"
      }
    }]
  }
};
exports["default"] = CheckCircleFilled;

/***/ }),

/***/ "4SiD":
/***/ (function(module, exports, __webpack_require__) {

var nth = __webpack_require__("HCJm");
/**
 * Returns the first element of the given list or string. In some libraries
 * this function is named `first`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {Array|String} list
 * @return {*}
 * @see R.tail, R.init, R.last
 * @example
 *
 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
 *      R.head([]); //=> undefined
 *
 *      R.head('abc'); //=> 'a'
 *      R.head(''); //=> ''
 */


module.exports = nth(0);

/***/ }),

/***/ "4T8+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("+3V6");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

__webpack_require__("W1QL");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTwoToneColor = setTwoToneColor;
exports.getTwoToneColor = getTwoToneColor;

var _IconBase = _interopRequireDefault(__webpack_require__("SfRV"));

var _utils = __webpack_require__("OgXt");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = (0, _utils.normalizeTwoToneColors)(twoToneColor),
      _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
      primaryColor = _normalizeTwoToneColo2[0],
      secondaryColor = _normalizeTwoToneColo2[1];

  return _IconBase["default"].setTwoToneColors({
    primaryColor: primaryColor,
    secondaryColor: secondaryColor
  });
}

function getTwoToneColor() {
  var colors = _IconBase["default"].getTwoToneColors();

  if (!colors.calculated) {
    return colors.primaryColor;
  }

  return [colors.primaryColor, colors.secondaryColor];
}

/***/ }),

/***/ "4Xtu":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("YlUf")('asyncIterator');


/***/ }),

/***/ "4aJ6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__("iur1");
var anObject = __webpack_require__("PAFS");
var $flags = __webpack_require__("MBcE");
var DESCRIPTORS = __webpack_require__("GGqZ");
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__("sU/p")(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__("E7Vc")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ "4dnM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var deprecated = __webpack_require__("GFZo");

module.exports = function (methodName) {
  return function (result) {
    deprecated('Type.' + methodName + '() is being deprecated in favour of Type[\'fantasy-land/' + methodName + '\'](). \n    Your data structure is using the old-style fantasy-land methods,\n    and these won\'t be supported in Folktale 3');
    return result;
  };
};

/***/ }),

/***/ "5BMI":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("9liC");
var invoke = __webpack_require__("KFSm");
var html = __webpack_require__("CLuC");
var cel = __webpack_require__("mggL");
var global = __webpack_require__("P56o");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__("n+VH")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "5BpW":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("PPkd");


/***/ }),

/***/ "5CuE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

__webpack_require__("Z8gF");

var warning = function warning() {};

if (false) {}

module.exports = warning;

/***/ }),

/***/ "5ERL":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var DownOutlined = {
  "name": "down",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"
      }
    }]
  }
};
exports["default"] = DownOutlined;

/***/ }),

/***/ "5Fu2":
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__("PAFS");
var aFunction = __webpack_require__("b8Rm");
var SPECIES = __webpack_require__("9dxi")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "5IsQ":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "5LHb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

var _ScrollBehaviorContext = _interopRequireDefault(__webpack_require__("trMS"));

var _ScrollContainer = _interopRequireDefault(__webpack_require__("O6Bp"));

exports.ScrollContainer = _ScrollContainer["default"];
exports.ScrollContext = _ScrollBehaviorContext["default"];

/***/ }),

/***/ "5MU4":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("Bsg+");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "5WRv":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__("iNmH");

var iterableToArray = __webpack_require__("Qatm");

var unsupportedIterableToArray = __webpack_require__("Zhxd");

var nonIterableSpread = __webpack_require__("kluZ");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "5gKE":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("41F1").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "5hJT":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("X6VK");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("NR3o") });


/***/ }),

/***/ "5xfP":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__("Z8gF");

__webpack_require__("J8hF");

__webpack_require__("V7cS");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License
(function (Math) {
  var trimLeft = /^\s+/,
      trimRight = /\s+$/,
      tinyCounter = 0,
      mathRound = Math.round,
      mathMin = Math.min,
      mathMax = Math.max,
      mathRandom = Math.random;

  function tinycolor(color, opts) {
    color = color ? color : '';
    opts = opts || {}; // If input is already a tinycolor, return itself

    if (color instanceof tinycolor) {
      return color;
    } // If we are called as a function, call using new instead


    if (!(this instanceof tinycolor)) {
      return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType; // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`

    if (this._r < 1) {
      this._r = mathRound(this._r);
    }

    if (this._g < 1) {
      this._g = mathRound(this._g);
    }

    if (this._b < 1) {
      this._b = mathRound(this._b);
    }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
  }

  tinycolor.prototype = {
    isDark: function isDark() {
      return this.getBrightness() < 128;
    },
    isLight: function isLight() {
      return !this.isDark();
    },
    isValid: function isValid() {
      return this._ok;
    },
    getOriginalInput: function getOriginalInput() {
      return this._originalInput;
    },
    getFormat: function getFormat() {
      return this._format;
    },
    getAlpha: function getAlpha() {
      return this._a;
    },
    getBrightness: function getBrightness() {
      //http://www.w3.org/TR/AERT#color-contrast
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function getLuminance() {
      //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
      var rgb = this.toRgb();
      var RsRGB, GsRGB, BsRGB, R, G, B;
      RsRGB = rgb.r / 255;
      GsRGB = rgb.g / 255;
      BsRGB = rgb.b / 255;

      if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
      } else {
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }

      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }

      if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
      } else {
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }

      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    },
    setAlpha: function setAlpha(value) {
      this._a = boundAlpha(value);
      this._roundA = mathRound(100 * this._a) / 100;
      return this;
    },
    toHsv: function toHsv() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v,
        a: this._a
      };
    },
    toHsvString: function toHsvString() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      var h = mathRound(hsv.h * 360),
          s = mathRound(hsv.s * 100),
          v = mathRound(hsv.v * 100);
      return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
    },
    toHsl: function toHsl() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      return {
        h: hsl.h * 360,
        s: hsl.s,
        l: hsl.l,
        a: this._a
      };
    },
    toHslString: function toHslString() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      var h = mathRound(hsl.h * 360),
          s = mathRound(hsl.s * 100),
          l = mathRound(hsl.l * 100);
      return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
    },
    toHex: function toHex(allow3Char) {
      return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function toHexString(allow3Char) {
      return '#' + this.toHex(allow3Char);
    },
    toHex8: function toHex8(allow4Char) {
      return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function toHex8String(allow4Char) {
      return '#' + this.toHex8(allow4Char);
    },
    toRgb: function toRgb() {
      return {
        r: mathRound(this._r),
        g: mathRound(this._g),
        b: mathRound(this._b),
        a: this._a
      };
    },
    toRgbString: function toRgbString() {
      return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function toPercentageRgb() {
      return {
        r: mathRound(bound01(this._r, 255) * 100) + "%",
        g: mathRound(bound01(this._g, 255) * 100) + "%",
        b: mathRound(bound01(this._b, 255) * 100) + "%",
        a: this._a
      };
    },
    toPercentageRgbString: function toPercentageRgbString() {
      return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function toName() {
      if (this._a === 0) {
        return "transparent";
      }

      if (this._a < 1) {
        return false;
      }

      return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function toFilter(secondColor) {
      var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
      var secondHex8String = hex8String;
      var gradientType = this._gradientType ? "GradientType = 1, " : "";

      if (secondColor) {
        var s = tinycolor(secondColor);
        secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
      }

      return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
    },
    toString: function toString(format) {
      var formatSet = !!format;
      format = format || this._format;
      var formattedString = false;
      var hasAlpha = this._a < 1 && this._a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

      if (needsAlphaFormat) {
        // Special case for "transparent", all other non-alpha formats
        // will return rgba when there is transparency.
        if (format === "name" && this._a === 0) {
          return this.toName();
        }

        return this.toRgbString();
      }

      if (format === "rgb") {
        formattedString = this.toRgbString();
      }

      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }

      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }

      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }

      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }

      if (format === "hex8") {
        formattedString = this.toHex8String();
      }

      if (format === "name") {
        formattedString = this.toName();
      }

      if (format === "hsl") {
        formattedString = this.toHslString();
      }

      if (format === "hsv") {
        formattedString = this.toHsvString();
      }

      return formattedString || this.toHexString();
    },
    clone: function clone() {
      return tinycolor(this.toString());
    },
    _applyModification: function _applyModification(fn, args) {
      var color = fn.apply(null, [this].concat([].slice.call(args)));
      this._r = color._r;
      this._g = color._g;
      this._b = color._b;
      this.setAlpha(color._a);
      return this;
    },
    lighten: function lighten() {
      return this._applyModification(_lighten, arguments);
    },
    brighten: function brighten() {
      return this._applyModification(_brighten, arguments);
    },
    darken: function darken() {
      return this._applyModification(_darken, arguments);
    },
    desaturate: function desaturate() {
      return this._applyModification(_desaturate, arguments);
    },
    saturate: function saturate() {
      return this._applyModification(_saturate, arguments);
    },
    greyscale: function greyscale() {
      return this._applyModification(_greyscale, arguments);
    },
    spin: function spin() {
      return this._applyModification(_spin, arguments);
    },
    _applyCombination: function _applyCombination(fn, args) {
      return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function analogous() {
      return this._applyCombination(_analogous, arguments);
    },
    complement: function complement() {
      return this._applyCombination(_complement, arguments);
    },
    monochromatic: function monochromatic() {
      return this._applyCombination(_monochromatic, arguments);
    },
    splitcomplement: function splitcomplement() {
      return this._applyCombination(_splitcomplement, arguments);
    },
    triad: function triad() {
      return this._applyCombination(_triad, arguments);
    },
    tetrad: function tetrad() {
      return this._applyCombination(_tetrad, arguments);
    }
  }; // If input is an object, force 1 into "1.0" to handle ratios properly
  // String input requires "1.0" as input, so 1 will be treated as 1

  tinycolor.fromRatio = function (color, opts) {
    if (typeof color == "object") {
      var newColor = {};

      for (var i in color) {
        if (color.hasOwnProperty(i)) {
          if (i === "a") {
            newColor[i] = color[i];
          } else {
            newColor[i] = convertToPercentage(color[i]);
          }
        }
      }

      color = newColor;
    }

    return tinycolor(color, opts);
  }; // Given a string or object, convert that input to RGB
  // Possible string inputs:
  //
  //     "red"
  //     "#f00" or "f00"
  //     "#ff0000" or "ff0000"
  //     "#ff000000" or "ff000000"
  //     "rgb 255 0 0" or "rgb (255, 0, 0)"
  //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
  //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
  //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
  //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
  //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
  //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
  //


  function inputToRGB(color) {
    var rgb = {
      r: 0,
      g: 0,
      b: 0
    };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
      color = stringInputToObject(color);
    }

    if (typeof color == "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v);
        ok = true;
        format = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l);
        ok = true;
        format = "hsl";
      }

      if (color.hasOwnProperty("a")) {
        a = color.a;
      }
    }

    a = boundAlpha(a);
    return {
      ok: ok,
      format: color.format || format,
      r: mathMin(255, mathMax(rgb.r, 0)),
      g: mathMin(255, mathMax(rgb.g, 0)),
      b: mathMin(255, mathMax(rgb.b, 0)),
      a: a
    };
  } // Conversion Functions
  // --------------------
  // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
  // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
  // `rgbToRgb`
  // Handle bounds / percentage checking to conform to CSS color spec
  // <http://www.w3.org/TR/css3-color/>
  // *Assumes:* r, g, b in [0, 255] or [0, 1]
  // *Returns:* { r, g, b } in [0, 255]


  function rgbToRgb(r, g, b) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b, 255) * 255
    };
  } // `rgbToHsl`
  // Converts an RGB color value to HSL.
  // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
  // *Returns:* { h, s, l } in [0,1]


  function rgbToHsl(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = mathMax(r, g, b),
        min = mathMin(r, g, b);
    var h,
        s,
        l = (max + min) / 2;

    if (max == min) {
      h = s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h,
      s: s,
      l: l
    };
  } // `hslToRgb`
  // Converts an HSL color value to RGB.
  // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
  // *Returns:* { r, g, b } in the set [0, 255]


  function hslToRgb(h, s, l) {
    var r, g, b;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  } // `rgbToHsv`
  // Converts an RGB color value to HSV
  // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
  // *Returns:* { h, s, v } in [0,1]


  function rgbToHsv(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = mathMax(r, g, b),
        min = mathMin(r, g, b);
    var h,
        s,
        v = max;
    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max == min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h,
      s: s,
      v: v
    };
  } // `hsvToRgb`
  // Converts an HSV color value to RGB.
  // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
  // *Returns:* { r, g, b } in the set [0, 255]


  function hsvToRgb(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];
    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  } // `rgbToHex`
  // Converts an RGB color to hex
  // Assumes r, g, and b are contained in the set [0, 255]
  // Returns a 3 or 6 character hex


  function rgbToHex(r, g, b, allow3Char) {
    var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))]; // Return a 3 character hex if possible

    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
  } // `rgbaToHex`
  // Converts an RGBA color plus alpha transparency to hex
  // Assumes r, g, b are contained in the set [0, 255] and
  // a in [0, 1]. Returns a 4 or 8 character rgba hex


  function rgbaToHex(r, g, b, a, allow4Char) {
    var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a))]; // Return a 4 character hex if possible

    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
  } // `rgbaToArgbHex`
  // Converts an RGBA color to an ARGB Hex8 string
  // Rarely used, but required for "toFilter()"


  function rgbaToArgbHex(r, g, b, a) {
    var hex = [pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];
    return hex.join("");
  } // `equals`
  // Can be called with any tinycolor input


  tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) {
      return false;
    }

    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
  };

  tinycolor.random = function () {
    return tinycolor.fromRatio({
      r: mathRandom(),
      g: mathRandom(),
      b: mathRandom()
    });
  }; // Modification Functions
  // ----------------------
  // Thanks to less.js for some of the basics here
  // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>


  function _desaturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }

  function _saturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }

  function _greyscale(color) {
    return tinycolor(color).desaturate(100);
  }

  function _lighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  }

  function _brighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
    return tinycolor(rgb);
  }

  function _darken(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  } // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
  // Values outside of this range will be wrapped into this range.


  function _spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
  } // Combination Functions
  // ---------------------
  // Thanks to jQuery xColor for some of the ideas behind these
  // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>


  function _complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
  }

  function _triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h + 120) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 240) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }

  function _tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h + 90) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 180) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 270) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }

  function _splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }

  function _analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;
    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(tinycolor(hsl));
    }

    return ret;
  }

  function _monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h,
        s = hsv.s,
        v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
      ret.push(tinycolor({
        h: h,
        s: s,
        v: v
      }));
      v = (v + modification) % 1;
    }

    return ret;
  } // Utility Functions
  // ---------------------


  tinycolor.mix = function (color1, color2, amount) {
    amount = amount === 0 ? 0 : amount || 50;
    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();
    var p = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b,
      a: (rgb2.a - rgb1.a) * p + rgb1.a
    };
    return tinycolor(rgba);
  }; // Readability Functions
  // ---------------------
  // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)
  // `contrast`
  // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)


  tinycolor.readability = function (color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
  }; // `isReadable`
  // Ensure that foreground and background color combinations meet WCAG2 guidelines.
  // The third argument is an optional Object.
  //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
  //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
  // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.
  // *Example*
  //    tinycolor.isReadable("#000", "#111") => false
  //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false


  tinycolor.isReadable = function (color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;
    out = false;
    wcag2Parms = validateWCAG2Parms(wcag2);

    switch (wcag2Parms.level + wcag2Parms.size) {
      case "AAsmall":
      case "AAAlarge":
        out = readability >= 4.5;
        break;

      case "AAlarge":
        out = readability >= 3;
        break;

      case "AAAsmall":
        out = readability >= 7;
        break;
    }

    return out;
  }; // `mostReadable`
  // Given a base color and a list of possible foreground or background
  // colors for that base, returns the most readable color.
  // Optionally returns Black or White if the most readable color is unreadable.
  // *Example*
  //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
  //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
  //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
  //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"


  tinycolor.mostReadable = function (baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors;
    level = args.level;
    size = args.size;

    for (var i = 0; i < colorList.length; i++) {
      readability = tinycolor.readability(baseColor, colorList[i]);

      if (readability > bestScore) {
        bestScore = readability;
        bestColor = tinycolor(colorList[i]);
      }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {
      "level": level,
      "size": size
    }) || !includeFallbackColors) {
      return bestColor;
    } else {
      args.includeFallbackColors = false;
      return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
    }
  }; // Big List of Colors
  // ------------------
  // <http://www.w3.org/TR/css3-color/#svg-color>


  var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  }; // Make it easy to access colors via `hexNames[hex]`

  var hexNames = tinycolor.hexNames = flip(names); // Utilities
  // ---------
  // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`

  function flip(o) {
    var flipped = {};

    for (var i in o) {
      if (o.hasOwnProperty(i)) {
        flipped[o[i]] = i;
      }
    }

    return flipped;
  } // Return a valid alpha value [0,1] with all invalid values being set to 1


  function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }

    return a;
  } // Take input from [0, n] and return it as [0, 1]


  function bound01(n, max) {
    if (isOnePointZero(n)) {
      n = "100%";
    }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n))); // Automatically convert percentage into number

    if (processPercent) {
      n = parseInt(n * max, 10) / 100;
    } // Handle floating point rounding errors


    if (Math.abs(n - max) < 0.000001) {
      return 1;
    } // Convert into [0, 1] range if it isn't already


    return n % max / parseFloat(max);
  } // Force a number between 0 and 1


  function clamp01(val) {
    return mathMin(1, mathMax(0, val));
  } // Parse a base-16 hex value into a base-10 integer


  function parseIntFromHex(val) {
    return parseInt(val, 16);
  } // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
  // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>


  function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
  } // Check to see if string passed in is a percentage


  function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
  } // Force a hex value to have 2 characters


  function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
  } // Replace a decimal with it's percentage value


  function convertToPercentage(n) {
    if (n <= 1) {
      n = n * 100 + "%";
    }

    return n;
  } // Converts a decimal to a hex value


  function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
  } // Converts a hex value to a decimal


  function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
  }

  var matchers = function () {
    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?"; // <http://www.w3.org/TR/css3-values/#number-value>

    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?"; // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.

    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")"; // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren

    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    return {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
  }(); // `isValidCSSUnit`
  // Take in a single string / number and check to see if it looks like a CSS unit
  // (see `matchers` above for definition).


  function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
  } // `stringInputToObject`
  // Permissive string parsing.  Take in a number of formats, and output an object
  // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`


  function stringInputToObject(color) {
    color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
    var named = false;

    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color == 'transparent') {
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
      };
    } // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.


    var match;

    if (match = matchers.rgb.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3]
      };
    }

    if (match = matchers.rgba.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3],
        a: match[4]
      };
    }

    if (match = matchers.hsl.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3]
      };
    }

    if (match = matchers.hsla.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3],
        a: match[4]
      };
    }

    if (match = matchers.hsv.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3]
      };
    }

    if (match = matchers.hsva.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3],
        a: match[4]
      };
    }

    if (match = matchers.hex8.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named ? "name" : "hex8"
      };
    }

    if (match = matchers.hex6.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named ? "name" : "hex"
      };
    }

    if (match = matchers.hex4.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + '' + match[1]),
        g: parseIntFromHex(match[2] + '' + match[2]),
        b: parseIntFromHex(match[3] + '' + match[3]),
        a: convertHexToDecimal(match[4] + '' + match[4]),
        format: named ? "name" : "hex8"
      };
    }

    if (match = matchers.hex3.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + '' + match[1]),
        g: parseIntFromHex(match[2] + '' + match[2]),
        b: parseIntFromHex(match[3] + '' + match[3]),
        format: named ? "name" : "hex"
      };
    }

    return false;
  }

  function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {
      "level": "AA",
      "size": "small"
    };
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();

    if (level !== "AA" && level !== "AAA") {
      level = "AA";
    }

    if (size !== "small" && size !== "large") {
      size = "small";
    }

    return {
      "level": level,
      "size": size
    };
  } // Node: Export function


  if ( true && module.exports) {
    module.exports = tinycolor;
  } // AMD/requirejs: Define the module
  else if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return tinycolor;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } // Browser: Expose to window
    else {}
})(Math);

/***/ }),

/***/ "5yr3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// CONCATENATED MODULE: ../node_modules/mitt/dist/mitt.es.js




//      
// An event handler can take an optional event argument
// and should not return a value
// An array of all currently registered event handlers for a type
// A map of event types and their corresponding event handlers.

/** Mitt: Tiny (~200b) functional event emitter / pubsub.
 *  @name mitt
 *  @returns {Mitt}
 */
function mitt(all) {
  all = all || Object.create(null);
  return {
    /**
     * Register an event handler for the given type.
     *
     * @param  {String} type	Type of event to listen for, or `"*"` for all events
     * @param  {Function} handler Function to call in response to given event
     * @memberOf mitt
     */
    on: function on(type, handler) {
      (all[type] || (all[type] = [])).push(handler);
    },

    /**
     * Remove an event handler for the given type.
     *
     * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
     * @param  {Function} handler Handler function to remove
     * @memberOf mitt
     */
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },

    /**
     * Invoke all handlers for the given type.
     * If present, `"*"` handlers are invoked after type-matched handlers.
     *
     * @param {String} type  The event type to invoke
     * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */
    emit: function emit(type, evt) {
      (all[type] || []).slice().map(function (handler) {
        handler(evt);
      });
      (all['*'] || []).slice().map(function (handler) {
        handler(type, evt);
      });
    }
  };
}

/* harmony default export */ var mitt_es = (mitt);
// CONCATENATED MODULE: ./.cache/emitter.js
var emitter=mitt_es();/* harmony default export */ var _cache_emitter = __webpack_exports__["a"] = (emitter);

/***/ }),

/***/ "6/FK":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__("GGqZ"), 'Object', { defineProperties: __webpack_require__("pU1/") });


/***/ }),

/***/ "63Ad":
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "67sl":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("TaGV");
var global = __webpack_require__("41F1");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("gtwY") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "67vp":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MotionPropTypes; });
/* unused harmony export genCSSMotion */
/* harmony import */ var babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("TcPG");
/* harmony import */ var babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Kz1y");
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("Zv/C");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("2lBV");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("Dkg+");
/* harmony import */ var babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("Gjrs");
/* harmony import */ var babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("W0B4");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("94VI");
/* harmony import */ var react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var rc_util_es_Dom_findDOMNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("vXvS");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("8Jek");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("rQBY");
/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(raf__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _util_motion__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("vmon");






/* eslint-disable react/default-props-match-prop-types, react/no-multi-comp */








var STATUS_NONE = 'none';
var STATUS_APPEAR = 'appear';
var STATUS_ENTER = 'enter';
var STATUS_LEAVE = 'leave';
var MotionPropTypes = {
  eventProps: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.object,
  // Internal usage. Only pass by CSSMotionList
  visible: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.bool,
  children: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  motionName: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.object]),
  motionAppear: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.bool,
  motionEnter: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.bool,
  motionLeave: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.bool,
  motionLeaveImmediately: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.bool,
  // Trigger leave motion immediately
  removeOnLeave: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.bool,
  leavedClassName: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.string,
  onAppearStart: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onAppearActive: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onAppearEnd: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onEnterStart: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onEnterActive: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onEnterEnd: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onLeaveStart: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onLeaveActive: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func,
  onLeaveEnd: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func
};
/**
 * `transitionSupport` is used for none transition test case.
 * Default we use browser transition event support check.
 */

function genCSSMotion(config) {
  var transitionSupport = config;
  var forwardRef = !!react__WEBPACK_IMPORTED_MODULE_6___default.a.forwardRef;

  if (typeof config === 'object') {
    transitionSupport = config.transitionSupport;
    forwardRef = 'forwardRef' in config ? config.forwardRef : forwardRef;
  }

  function isSupportTransition(props) {
    return !!(props.motionName && transitionSupport);
  }

  var CSSMotion = function (_React$Component) {
    babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CSSMotion, _React$Component);

    function CSSMotion() {
      babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, CSSMotion);

      var _this = babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, (CSSMotion.__proto__ || Object.getPrototypeOf(CSSMotion)).call(this));

      _this.onDomUpdate = function () {
        var _this$state = _this.state,
            status = _this$state.status,
            newStatus = _this$state.newStatus;
        var _this$props = _this.props,
            onAppearStart = _this$props.onAppearStart,
            onEnterStart = _this$props.onEnterStart,
            onLeaveStart = _this$props.onLeaveStart,
            onAppearActive = _this$props.onAppearActive,
            onEnterActive = _this$props.onEnterActive,
            onLeaveActive = _this$props.onLeaveActive,
            motionAppear = _this$props.motionAppear,
            motionEnter = _this$props.motionEnter,
            motionLeave = _this$props.motionLeave;

        if (!isSupportTransition(_this.props)) {
          return;
        } // Event injection


        var $ele = _this.getElement();

        if (_this.$cacheEle !== $ele) {
          _this.removeEventListener(_this.$cacheEle);

          _this.addEventListener($ele);

          _this.$cacheEle = $ele;
        } // Init status


        if (newStatus && status === STATUS_APPEAR && motionAppear) {
          _this.updateStatus(onAppearStart, null, null, function () {
            _this.updateActiveStatus(onAppearActive, STATUS_APPEAR);
          });
        } else if (newStatus && status === STATUS_ENTER && motionEnter) {
          _this.updateStatus(onEnterStart, null, null, function () {
            _this.updateActiveStatus(onEnterActive, STATUS_ENTER);
          });
        } else if (newStatus && status === STATUS_LEAVE && motionLeave) {
          _this.updateStatus(onLeaveStart, null, null, function () {
            _this.updateActiveStatus(onLeaveActive, STATUS_LEAVE);
          });
        }
      };

      _this.onMotionEnd = function (event) {
        var _this$state2 = _this.state,
            status = _this$state2.status,
            statusActive = _this$state2.statusActive;
        var _this$props2 = _this.props,
            onAppearEnd = _this$props2.onAppearEnd,
            onEnterEnd = _this$props2.onEnterEnd,
            onLeaveEnd = _this$props2.onLeaveEnd;

        if (status === STATUS_APPEAR && statusActive) {
          _this.updateStatus(onAppearEnd, {
            status: STATUS_NONE
          }, event);
        } else if (status === STATUS_ENTER && statusActive) {
          _this.updateStatus(onEnterEnd, {
            status: STATUS_NONE
          }, event);
        } else if (status === STATUS_LEAVE && statusActive) {
          _this.updateStatus(onLeaveEnd, {
            status: STATUS_NONE
          }, event);
        }
      };

      _this.setNodeRef = function (node) {
        var internalRef = _this.props.internalRef;
        _this.node = node;

        if (typeof internalRef === 'function') {
          internalRef(node);
        } else if (internalRef && 'current' in internalRef) {
          internalRef.current = node;
        }
      };

      _this.getElement = function () {
        return Object(rc_util_es_Dom_findDOMNode__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"])(_this.node || _this);
      };

      _this.addEventListener = function ($ele) {
        if (!$ele) return;
        $ele.addEventListener(_util_motion__WEBPACK_IMPORTED_MODULE_12__[/* transitionEndName */ "d"], _this.onMotionEnd);
        $ele.addEventListener(_util_motion__WEBPACK_IMPORTED_MODULE_12__[/* animationEndName */ "a"], _this.onMotionEnd);
      };

      _this.removeEventListener = function ($ele) {
        if (!$ele) return;
        $ele.removeEventListener(_util_motion__WEBPACK_IMPORTED_MODULE_12__[/* transitionEndName */ "d"], _this.onMotionEnd);
        $ele.removeEventListener(_util_motion__WEBPACK_IMPORTED_MODULE_12__[/* animationEndName */ "a"], _this.onMotionEnd);
      };

      _this.updateStatus = function (styleFunc, additionalState, event, callback) {
        var statusStyle = styleFunc ? styleFunc(_this.getElement(), event) : null;
        if (statusStyle === false || _this._destroyed) return;
        var nextStep = void 0;

        if (callback) {
          nextStep = function nextStep() {
            _this.nextFrame(callback);
          };
        }

        _this.setState(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default()({
          statusStyle: typeof statusStyle === 'object' ? statusStyle : null,
          newStatus: false
        }, additionalState), nextStep); // Trigger before next frame & after `componentDidMount`

      };

      _this.updateActiveStatus = function (styleFunc, currentStatus) {
        // `setState` use `postMessage` to trigger at the end of frame.
        // Let's use requestAnimationFrame to update new state in next frame.
        _this.nextFrame(function () {
          var status = _this.state.status;
          if (status !== currentStatus) return;

          _this.updateStatus(styleFunc, {
            statusActive: true
          });
        });
      };

      _this.nextFrame = function (func) {
        _this.cancelNextFrame();

        _this.raf = raf__WEBPACK_IMPORTED_MODULE_11___default()(func);
      };

      _this.cancelNextFrame = function () {
        if (_this.raf) {
          raf__WEBPACK_IMPORTED_MODULE_11___default.a.cancel(_this.raf);
          _this.raf = null;
        }
      };

      _this.state = {
        status: STATUS_NONE,
        statusActive: false,
        newStatus: false,
        statusStyle: null
      };
      _this.$cacheEle = null;
      _this.node = null;
      _this.raf = null;
      return _this;
    }

    babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(CSSMotion, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.onDomUpdate();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this.onDomUpdate();
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this._destroyed = true;
        this.removeEventListener(this.$cacheEle);
        this.cancelNextFrame();
      }
    }, {
      key: 'render',
      value: function render() {
        var _classNames;

        var _state = this.state,
            status = _state.status,
            statusActive = _state.statusActive,
            statusStyle = _state.statusStyle;
        var _props = this.props,
            children = _props.children,
            motionName = _props.motionName,
            visible = _props.visible,
            removeOnLeave = _props.removeOnLeave,
            leavedClassName = _props.leavedClassName,
            eventProps = _props.eventProps;
        if (!children) return null;

        if (status === STATUS_NONE || !isSupportTransition(this.props)) {
          if (visible) {
            return children(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default()({}, eventProps), this.setNodeRef);
          } else if (!removeOnLeave) {
            return children(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default()({}, eventProps, {
              className: leavedClassName
            }), this.setNodeRef);
          }

          return null;
        }

        return children(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default()({}, eventProps, {
          className: classnames__WEBPACK_IMPORTED_MODULE_10___default()((_classNames = {}, babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(_classNames, Object(_util_motion__WEBPACK_IMPORTED_MODULE_12__[/* getTransitionName */ "b"])(motionName, status), status !== STATUS_NONE), babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(_classNames, Object(_util_motion__WEBPACK_IMPORTED_MODULE_12__[/* getTransitionName */ "b"])(motionName, status + '-active'), status !== STATUS_NONE && statusActive), babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(_classNames, motionName, typeof motionName === 'string'), _classNames)),
          style: statusStyle
        }), this.setNodeRef);
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, _ref) {
        var prevProps = _ref.prevProps,
            prevStatus = _ref.status;
        if (!isSupportTransition(props)) return {};
        var visible = props.visible,
            motionAppear = props.motionAppear,
            motionEnter = props.motionEnter,
            motionLeave = props.motionLeave,
            motionLeaveImmediately = props.motionLeaveImmediately;
        var newState = {
          prevProps: props
        }; // Clean up status if prop set to false

        if (prevStatus === STATUS_APPEAR && !motionAppear || prevStatus === STATUS_ENTER && !motionEnter || prevStatus === STATUS_LEAVE && !motionLeave) {
          newState.status = STATUS_NONE;
          newState.statusActive = false;
          newState.newStatus = false;
        } // Appear


        if (!prevProps && visible && motionAppear) {
          newState.status = STATUS_APPEAR;
          newState.statusActive = false;
          newState.newStatus = true;
        } // Enter


        if (prevProps && !prevProps.visible && visible && motionEnter) {
          newState.status = STATUS_ENTER;
          newState.statusActive = false;
          newState.newStatus = true;
        } // Leave


        if (prevProps && prevProps.visible && !visible && motionLeave || !prevProps && motionLeaveImmediately && !visible && motionLeave) {
          newState.status = STATUS_LEAVE;
          newState.statusActive = false;
          newState.newStatus = true;
        }

        return newState;
      }
    }]);

    return CSSMotion;
  }(react__WEBPACK_IMPORTED_MODULE_6___default.a.Component);

  CSSMotion.propTypes = babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default()({}, MotionPropTypes, {
    internalRef: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func])
  });
  CSSMotion.defaultProps = {
    visible: true,
    motionEnter: true,
    motionAppear: true,
    motionLeave: true,
    removeOnLeave: true
  };
  Object(react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_8__["polyfill"])(CSSMotion);

  if (!forwardRef) {
    return CSSMotion;
  }

  return react__WEBPACK_IMPORTED_MODULE_6___default.a.forwardRef(function (props, ref) {
    return react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(CSSMotion, babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default()({
      internalRef: ref
    }, props));
  });
}
/* harmony default export */ __webpack_exports__["b"] = (genCSSMotion(_util_motion__WEBPACK_IMPORTED_MODULE_12__[/* supportTransition */ "c"]));

/***/ }),

/***/ "68WS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------
// --[ Dependencies ]---------------------------------------------------

__webpack_require__("lQyR");

__webpack_require__("m1Dn");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("75LO");

__webpack_require__("+3V6");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

var assertType = __webpack_require__("yCBR");

var flEquals = __webpack_require__("Uy6E");

var fl = __webpack_require__("nl0c");

var provideAliases = __webpack_require__("JiyH");

var copyDocs = __webpack_require__("E6WT");

var _require = __webpack_require__("vgDc"),
    tagSymbol = _require.tagSymbol,
    typeSymbol = _require.typeSymbol;

var toString = Object.prototype.toString;
var prototypeOf = Object.getPrototypeOf; // --[ Helpers ]--------------------------------------------------------

/*~
 * type: (Any) => Boolean
 */

var isSetoid = function isSetoid(value) {
  return value != null && (typeof value[fl.equals] === 'function' || typeof value.equals === 'function');
};
/*~
 * type: (Variant, Variant) => Boolean
 */


var sameType = function sameType(a, b) {
  return a[typeSymbol] === b[typeSymbol] && a[tagSymbol] === b[tagSymbol];
};

var isPlainObject = function isPlainObject(object) {
  if (Object(object) !== object) return false;
  return !prototypeOf(object) || !object.toString || toString.call(object) === object.toString();
};

var deepEquals = function deepEquals(a, b) {
  if (a === b) return true;
  var leftSetoid = isSetoid(a);
  var rightSetoid = isSetoid(b);

  if (leftSetoid) {
    if (rightSetoid) return flEquals(a, b);else return false;
  }

  if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every(function (x, i) {
      return deepEquals(x, b[i]);
    });
  }

  if (isPlainObject(a) && isPlainObject(b)) {
    var keysA = Object.keys(a);
    var keysB = Object.keys(b);
    var setB = new Set(keysB);
    return keysA.length === keysB.length && prototypeOf(a) === prototypeOf(b) && keysA.every(function (k) {
      return setB.has(k) && a[k] === b[k];
    });
  }

  return false;
}; // --[ Implementation ]------------------------------------------------

/*~
 * stability: experimental
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   (('a, 'a) => Boolean) => (Variant, Union) => Void
 */


var createDerivation = function createDerivation(valuesEqual) {
  /*~
   * type: ('a, 'a) => Boolean
   */
  var equals = function equals(a, b) {
    // identical objects must be equal
    if (a === b) return true; // we require both values to be setoids if one of them is

    var leftSetoid = isSetoid(a);
    var rightSetoid = isSetoid(b);

    if (leftSetoid) {
      if (rightSetoid) return flEquals(a, b);else return false;
    } // fall back to the provided equality


    return valuesEqual(a, b);
  };
  /*~
   * type: (Object Any, Object Any, Array String) => Boolean
   */


  var compositesEqual = function compositesEqual(a, b, keys) {
    for (var i = 0; i < keys.length; ++i) {
      var keyA = a[keys[i]];
      var keyB = b[keys[i]];

      if (!equals(keyA, keyB)) {
        return false;
      }
    }

    return true;
  };

  var derivation = function derivation(variant, adt) {
    /*~
     * stability: experimental
     * module: null
     * authors:
     *   - "@boris-marinov"
     *   - Quildreen Motta
     * 
     * type: |
     *   forall S, a:
     *     (S a).(S a) => Boolean
     *   where S is Setoid
     */
    variant.prototype.equals = function (value) {
      assertType(adt)(this[tagSymbol] + '#equals', value);
      return sameType(this, value) && compositesEqual(this, value, Object.keys(this));
    };

    provideAliases(variant.prototype);
    return variant;
  };

  copyDocs(createDerivation, derivation, {
    type: '(Variant, Union) => Void'
  });
  return derivation;
}; // --[ Exports ]-------------------------------------------------------

/*~~inheritsMeta: createDerivation */


module.exports = createDerivation(deepEquals);
module.exports.withCustomComparison = createDerivation;

/***/ }),

/***/ "6CzD":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _toConsumableArray; });

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
var arrayLikeToArray = __webpack_require__("YZeP");

// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(arrayLikeToArray["a" /* default */])(arr);
}
// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
var unsupportedIterableToArray = __webpack_require__("TJjZ");

// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || Object(unsupportedIterableToArray["a" /* default */])(arr) || _nonIterableSpread();
}

/***/ }),

/***/ "6Dst":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _LeftOutlined = _interopRequireDefault(__webpack_require__("tWFn"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _LeftOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "6K2M":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var _interopRequireDefault=__webpack_require__("63Ad");var _gatsby=__webpack_require__("Wbzz");var _catchLinks=_interopRequireDefault(__webpack_require__("TCCx"));exports.onClientEntry=function(_,pluginOptions){if(pluginOptions===void 0){pluginOptions={};}(0,_catchLinks.default)(window,pluginOptions,function(href){(0,_gatsby.navigate)(href);});};

/***/ }),

/***/ "6d4m":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__("X6VK");
var context = __webpack_require__("Alw5");
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__("Fl7L")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "6kVO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _LoadingOutlined = _interopRequireDefault(__webpack_require__("q7lU"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var LoadingOutlined = function LoadingOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _LoadingOutlined["default"]
  }));
};

LoadingOutlined.displayName = 'LoadingOutlined';

var _default = _react["default"].forwardRef(LoadingOutlined);

exports["default"] = _default;

/***/ }),

/***/ "6vZ6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var _interopRequireDefault=__webpack_require__("63Ad");var _gatsby=__webpack_require__("Wbzz");var _getManifestPathname=_interopRequireDefault(__webpack_require__("Prd0"));/* global __MANIFEST_PLUGIN_HAS_LOCALISATION__ */ // when we don't have localisation in our manifest, we tree shake everything away
if(undefined){var withPrefix=_gatsby.withAssetPrefix||_gatsby.withPrefix;exports.onRouteUpdate=function(_ref,pluginOptions){var location=_ref.location;var localize=pluginOptions.localize;var manifestFilename=(0,_getManifestPathname.default)(location.pathname,localize);var manifestEl=document.head.querySelector("link[rel=\"manifest\"]");if(manifestEl){manifestEl.setAttribute("href",withPrefix(manifestFilename));}};}

/***/ }),

/***/ "6wgB":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("g2rQ");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "6z9p":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9ovy");

module.exports = function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
};

/***/ }),

/***/ "74ju":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

module.exports = function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
};

/***/ }),

/***/ "75LO":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("UnHL");
var $keys = __webpack_require__("LuBU");

__webpack_require__("gRlk")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "7S3h":
/***/ (function(module) {

module.exports = JSON.parse("{\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Ucan\",\"description\":\"Ucan -robust staff transport solution\"}}}}");

/***/ }),

/***/ "7UOo":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("asZ9");

__webpack_require__("Z8gF");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

/**
 * Module dependencies.
 */
try {
  var index = __webpack_require__("9RCm");
} catch (err) {
  var index = __webpack_require__("9RCm");
}
/**
 * Whitespace regexp.
 */


var re = /\s+/;
/**
 * toString reference.
 */

var toString = Object.prototype.toString;
/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function (el) {
  return new ClassList(el);
};
/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */


function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }

  this.el = el;
  this.list = el.classList;
}
/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.add = function (name) {
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  } // fallback


  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};
/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.remove = function (name) {
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  } // classList


  if (this.list) {
    this.list.remove(name);
    return this;
  } // fallback


  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};
/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */


ClassList.prototype.removeMatching = function (re) {
  var arr = this.array();

  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }

  return this;
};
/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.toggle = function (name, force) {
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }

    return this;
  } // fallback


  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};
/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */


ClassList.prototype.array = function () {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};
/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.has = ClassList.prototype.contains = function (name) {
  return this.list ? this.list.contains(name) : !!~index(this.array(), name);
};

/***/ }),

/***/ "7lGJ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var $forEach = __webpack_require__("1wfo")(0);
var STRICT = __webpack_require__("/6rt")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "7oj+":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("GyeN"), __esModule: true };

/***/ }),

/***/ "7t+O":
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__("X6VK");

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),

/***/ "87BP":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _DownOutlined = _interopRequireDefault(__webpack_require__("bh9w"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _DownOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "893G":
/***/ (function(module, exports, __webpack_require__) {

var _contains = __webpack_require__("io9E");

var _curry2 = __webpack_require__("OFPg");
/**
 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
 * terms, to at least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.contains([42], [[42]]); //=> true
 */


module.exports = _curry2(_contains);

/***/ }),

/***/ "8Jek":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__("+3V6");

/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

/* global define */
(function () {
  'use strict';

  var hasOwn = {}.hasOwnProperty;

  function classNames() {
    var classes = [];

    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) continue;
      var argType = typeof arg;

      if (argType === 'string' || argType === 'number') {
        classes.push(arg);
      } else if (Array.isArray(arg) && arg.length) {
        var inner = classNames.apply(null, arg);

        if (inner) {
          classes.push(inner);
        }
      } else if (argType === 'object') {
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes.push(key);
          }
        }
      }
    }

    return classes.join(' ');
  }

  if ( true && module.exports) {
    classNames["default"] = classNames;
    module.exports = classNames;
  } else if (true) {
    // register as 'classnames', consistent with npm package name
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return classNames;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})();

/***/ }),

/***/ "8VmE":
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "8Xl/":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("HD3J");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "8kJd":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("ZVIm")('keys');
var uid = __webpack_require__("1Alt");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "8rx3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _RightOutlined = _interopRequireDefault(__webpack_require__("GYOe"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var RightOutlined = function RightOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _RightOutlined["default"]
  }));
};

RightOutlined.displayName = 'RightOutlined';

var _default = _react["default"].forwardRef(RightOutlined);

exports["default"] = _default;

/***/ }),

/***/ "8tsl":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var locale = {
  locale: 'en_US',
  today: 'Today',
  now: 'Now',
  backToToday: 'Back to today',
  ok: 'Ok',
  clear: 'Clear',
  month: 'Month',
  year: 'Year',
  timeSelect: 'select time',
  dateSelect: 'select date',
  weekSelect: 'Choose a week',
  monthSelect: 'Choose a month',
  yearSelect: 'Choose a year',
  decadeSelect: 'Choose a decade',
  yearFormat: 'YYYY',
  dateFormat: 'M/D/YYYY',
  dayFormat: 'D',
  dateTimeFormat: 'M/D/YYYY HH:mm:ss',
  monthBeforeYear: true,
  previousMonth: 'Previous month (PageUp)',
  nextMonth: 'Next month (PageDown)',
  previousYear: 'Last year (Control + left)',
  nextYear: 'Next year (Control + right)',
  previousDecade: 'Last decade',
  nextDecade: 'Next decade',
  previousCentury: 'Last century',
  nextCentury: 'Next century'
};
exports["default"] = locale;

/***/ }),

/***/ "94DX":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("dtzt");

__webpack_require__("V7cS");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  var defaults = {
    pairs: "()[]{}''\"\"",
    closeBefore: ")]}'\":;>",
    triples: "",
    explode: "[]{}"
  };
  var Pos = CodeMirror.Pos;
  CodeMirror.defineOption("autoCloseBrackets", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }

    if (val) {
      ensureBound(getOption(val, "pairs"));
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });

  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }

  var keyMap = {
    Backspace: handleBackspace,
    Enter: handleEnter
  };

  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i),
          key = "'" + ch + "'";
      if (!keyMap[key]) keyMap[key] = handler(ch);
    }
  }

  ensureBound(defaults.pairs + "`");

  function handler(ch) {
    return function (cm) {
      return handleChar(cm, ch);
    };
  }

  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }

  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();

    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }

    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }

  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;
    var ranges = cm.listSelections();

    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }

    cm.operation(function () {
      var linesep = cm.lineSeparator() || "\n";
      cm.replaceSelection(linesep + linesep, null);
      cm.execCommand("goCharLeft");
      ranges = cm.listSelections();

      for (var i = 0; i < ranges.length; i++) {
        var line = ranges[i].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }

  function contractSelection(sel) {
    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
    return {
      anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
      head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
    };
  }

  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror.Pass;
    var closeBefore = getOption(conf, "closeBefore");
    var triples = getOption(conf, "triples");
    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;
    var type;

    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
          cur = range.head,
          curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));

      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur)) curType = "both";else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch) curType = "skipThree";else curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";else return CodeMirror.Pass;
      } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
        curType = "both";
      } else {
        return CodeMirror.Pass;
      }

      if (!type) type = curType;else if (type != curType) return CodeMirror.Pass;
    }

    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function () {
      if (type == "skip") {
        cm.execCommand("goCharRight");
      } else if (type == "skipThree") {
        for (var i = 0; i < 3; i++) {
          cm.execCommand("goCharRight");
        }
      } else if (type == "surround") {
        var sels = cm.getSelections();

        for (var i = 0; i < sels.length; i++) {
          sels[i] = left + sels[i] + right;
        }

        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();

        for (var i = 0; i < sels.length; i++) {
          sels[i] = contractSelection(sels[i]);
        }

        cm.setSelections(sels);
      } else if (type == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        cm.execCommand("goCharLeft");
      } else if (type == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        cm.execCommand("goCharRight");
      }
    });
  }

  function charsAround(cm, pos) {
    var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));
    return str.length == 2 ? str : null;
  }

  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
    return /\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)));
  }
});

/***/ }),

/***/ "94VI":
/***/ (function(module, exports) {

exports.polyfill=function(Component){return Component;};

/***/ }),

/***/ "9Bb+":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("b8Rm");
var toObject = __webpack_require__("UnHL");
var IObject = __webpack_require__("Cmsx");
var toLength = __webpack_require__("Sp5b");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "9K2m":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


__webpack_require__("+jjx");

__webpack_require__("ABKx");

var b = "function" === typeof Symbol && Symbol["for"],
    c = b ? Symbol["for"]("react.element") : 60103,
    d = b ? Symbol["for"]("react.portal") : 60106,
    e = b ? Symbol["for"]("react.fragment") : 60107,
    f = b ? Symbol["for"]("react.strict_mode") : 60108,
    g = b ? Symbol["for"]("react.profiler") : 60114,
    h = b ? Symbol["for"]("react.provider") : 60109,
    k = b ? Symbol["for"]("react.context") : 60110,
    l = b ? Symbol["for"]("react.async_mode") : 60111,
    m = b ? Symbol["for"]("react.concurrent_mode") : 60111,
    n = b ? Symbol["for"]("react.forward_ref") : 60112,
    p = b ? Symbol["for"]("react.suspense") : 60113,
    q = b ? Symbol["for"]("react.suspense_list") : 60120,
    r = b ? Symbol["for"]("react.memo") : 60115,
    t = b ? Symbol["for"]("react.lazy") : 60116,
    v = b ? Symbol["for"]("react.block") : 60121,
    w = b ? Symbol["for"]("react.fundamental") : 60117,
    x = b ? Symbol["for"]("react.responder") : 60118,
    y = b ? Symbol["for"]("react.scope") : 60119;

function z(a) {
  if ("object" === typeof a && null !== a) {
    var u = a.$$typeof;

    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;

              default:
                return u;
            }

        }

      case d:
        return u;
    }
  }
}

function A(a) {
  return z(a) === m;
}

exports.AsyncMode = l;
exports.ConcurrentMode = m;
exports.ContextConsumer = k;
exports.ContextProvider = h;
exports.Element = c;
exports.ForwardRef = n;
exports.Fragment = e;
exports.Lazy = t;
exports.Memo = r;
exports.Portal = d;
exports.Profiler = g;
exports.StrictMode = f;
exports.Suspense = p;

exports.isAsyncMode = function (a) {
  return A(a) || z(a) === l;
};

exports.isConcurrentMode = A;

exports.isContextConsumer = function (a) {
  return z(a) === k;
};

exports.isContextProvider = function (a) {
  return z(a) === h;
};

exports.isElement = function (a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};

exports.isForwardRef = function (a) {
  return z(a) === n;
};

exports.isFragment = function (a) {
  return z(a) === e;
};

exports.isLazy = function (a) {
  return z(a) === t;
};

exports.isMemo = function (a) {
  return z(a) === r;
};

exports.isPortal = function (a) {
  return z(a) === d;
};

exports.isProfiler = function (a) {
  return z(a) === g;
};

exports.isStrictMode = function (a) {
  return z(a) === f;
};

exports.isSuspense = function (a) {
  return z(a) === p;
};

exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};

exports.typeOf = z;

/***/ }),

/***/ "9RCm":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("V7cS");

module.exports = function (arr, obj) {
  if (arr.indexOf) return arr.indexOf(obj);

  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }

  return -1;
};

/***/ }),

/***/ "9ZkT":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__("1Tj+");
var getPrototypeOf = __webpack_require__("A1KM");
var has = __webpack_require__("ezc+");
var $export = __webpack_require__("X6VK");
var isObject = __webpack_require__("Bsg+");
var anObject = __webpack_require__("PAFS");

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),

/***/ "9cvu":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("Z8gF");

var attrRE = /([\w-]+)|=|(['"])([.\s\S]*?)\2/g;

var voidElements = __webpack_require__("y/N9");

module.exports = function (tag) {
  var i = 0;
  var key;
  var expectingValueAfterEquals = true;
  var res = {
    type: 'tag',
    name: '',
    voidElement: false,
    attrs: {},
    children: []
  };
  tag.replace(attrRE, function (match) {
    if (match === '=') {
      expectingValueAfterEquals = true;
      i++;
      return;
    }

    if (!expectingValueAfterEquals) {
      if (key) {
        res.attrs[key] = key; // boolean attribute
      }

      key = match;
    } else {
      if (i === 0) {
        if (voidElements[match] || tag.charAt(tag.length - 2) === '/') {
          res.voidElement = true;
        }

        res.name = match;
      } else {
        res.attrs[key] = match.replace(/^['"]|['"]$/g, '');
        key = undefined;
      }
    }

    i++;
    expectingValueAfterEquals = false;
  });
  return res;
};

/***/ }),

/***/ "9dxi":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("ZVIm")('wks');
var uid = __webpack_require__("1Alt");
var Symbol = __webpack_require__("P56o").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "9liC":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("b8Rm");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "9ovy":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__("PAFS");
var toLength = __webpack_require__("Sp5b");
var advanceStringIndex = __webpack_require__("dVhv");
var regExpExec = __webpack_require__("Fu0I");

// @@match logic
__webpack_require__("Wifh")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "9p7t":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var $filter = __webpack_require__("1wfo")(2);

$export($export.P + $export.F * !__webpack_require__("/6rt")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "A1KM":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("ezc+");
var toObject = __webpack_require__("UnHL");
var IE_PROTO = __webpack_require__("8kJd")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "ABKx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__("P56o");
var has = __webpack_require__("ezc+");
var DESCRIPTORS = __webpack_require__("GGqZ");
var $export = __webpack_require__("X6VK");
var redefine = __webpack_require__("sU/p");
var META = __webpack_require__("zIP/").KEY;
var $fails = __webpack_require__("E7Vc");
var shared = __webpack_require__("ZVIm");
var setToStringTag = __webpack_require__("jPEw");
var uid = __webpack_require__("1Alt");
var wks = __webpack_require__("9dxi");
var wksExt = __webpack_require__("fxUj");
var wksDefine = __webpack_require__("z6KD");
var enumKeys = __webpack_require__("ltS6");
var isArray = __webpack_require__("Xfku");
var anObject = __webpack_require__("PAFS");
var isObject = __webpack_require__("Bsg+");
var toObject = __webpack_require__("UnHL");
var toIObject = __webpack_require__("ml72");
var toPrimitive = __webpack_require__("5MU4");
var createDesc = __webpack_require__("WWmS");
var _create = __webpack_require__("Vx+c");
var gOPNExt = __webpack_require__("UYXy");
var $GOPD = __webpack_require__("1Tj+");
var $GOPS = __webpack_require__("0oPD");
var $DP = __webpack_require__("U1KF");
var $keys = __webpack_require__("LuBU");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("zIds").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("IdFN").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("wEu9")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("tjmq")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "ACU4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var toObject = __webpack_require__("UnHL");
var toPrimitive = __webpack_require__("5MU4");

$export($export.P + $export.F * __webpack_require__("E7Vc")(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),

/***/ "ADe/":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("fGh/");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "AFnJ":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("CAwg");
module.exports = __webpack_require__("TaGV").Object.assign;


/***/ }),

/***/ "AN6r":
/***/ (function(module, exports, __webpack_require__) {

var _isPlaceholder = __webpack_require__("SaPD");
/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


module.exports = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

/***/ }),

/***/ "ASIu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ExclamationCircleOutlined = _interopRequireDefault(__webpack_require__("EgEt"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _ExclamationCircleOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "AkS8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("P56o");
var $export = __webpack_require__("X6VK");
var redefine = __webpack_require__("sU/p");
var redefineAll = __webpack_require__("+edc");
var meta = __webpack_require__("zIP/");
var forOf = __webpack_require__("HqX2");
var anInstance = __webpack_require__("EusA");
var isObject = __webpack_require__("Bsg+");
var fails = __webpack_require__("E7Vc");
var $iterDetect = __webpack_require__("zlqh");
var setToStringTag = __webpack_require__("jPEw");
var inheritIfRequired = __webpack_require__("jEou");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "Alw5":
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__("NVL/");
var defined = __webpack_require__("GCOZ");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "Avyj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _InfoCircleOutlined = _interopRequireDefault(__webpack_require__("r8tM"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _InfoCircleOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "Awoh":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _CheckCircleFilled = _interopRequireDefault(__webpack_require__("ZGup"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _CheckCircleFilled;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "B3VA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var InfoCircleFilled = {
  "name": "info-circle",
  "theme": "filled",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
      }
    }]
  }
};
exports["default"] = InfoCircleFilled;

/***/ }),

/***/ "B3fu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @ignore
 * base event object for custom and dom event.
 * @author yiminghe@gmail.com
 */


__webpack_require__("7t+O");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

function EventBaseObject() {
  this.timeStamp = Date.now();
  this.target = undefined;
  this.currentTarget = undefined;
}

EventBaseObject.prototype = {
  isEventObject: 1,
  constructor: EventBaseObject,
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse,
  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue; // fixed 1.2
    // call stopPropagation implicitly

    this.stopPropagation();
  },
  halt: function halt(immediate) {
    if (immediate) {
      this.stopImmediatePropagation();
    } else {
      this.stopPropagation();
    }

    this.preventDefault();
  }
};
exports["default"] = EventBaseObject;
module.exports = exports["default"];

/***/ }),

/***/ "BDzi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__("X6VK");
var toLength = __webpack_require__("Sp5b");
var context = __webpack_require__("Alw5");
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__("Fl7L")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ "BJf6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = addEventListener;

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _EventObject = __webpack_require__("4N2q");

var _EventObject2 = _interopRequireDefault(_EventObject);

function addEventListener(target, eventType, callback, option) {
  function wrapCallback(e) {
    var ne = new _EventObject2['default'](e);
    callback.call(target, ne);
  }

  if (target.addEventListener) {
    var _ret = function () {
      var useCapture = false;

      if (typeof option === 'object') {
        useCapture = option.capture || false;
      } else if (typeof option === 'boolean') {
        useCapture = option;
      }

      target.addEventListener(eventType, wrapCallback, option || false);
      return {
        v: {
          remove: function remove() {
            target.removeEventListener(eventType, wrapCallback, useCapture);
          }
        }
      };
    }();

    if (typeof _ret === 'object') return _ret.v;
  } else if (target.attachEvent) {
    target.attachEvent('on' + eventType, wrapCallback);
    return {
      remove: function remove() {
        target.detachEvent('on' + eventType, wrapCallback);
      }
    };
  }
}

module.exports = exports['default'];

/***/ }),

/***/ "BTfu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__("LEAW")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),

/***/ "BUlT":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("mvii");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "BYsm":
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__("mXGw");

function Translation (props) {
    return React.createElement("svg",props,React.createElement("path",{"d":"M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"}));
}

Translation.defaultProps = {"width":"24","height":"24","viewBox":"0 0 24 24"};

module.exports = Translation;

Translation.default = Translation;


/***/ }),

/***/ "Bfez":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ ConfigContext; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ ConfigConsumer; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ withConfigConsumer; });

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__("GkPX");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ../node_modules/antd/es/locale-provider/LocaleReceiver.js + 1 modules
var LocaleReceiver = __webpack_require__("fj6J");

// CONCATENATED MODULE: ../node_modules/antd/es/empty/empty.js



var empty_Empty = function Empty() {
  var _React$useContext = react["useContext"](ConfigContext),
      getPrefixCls = _React$useContext.getPrefixCls;

  var prefixCls = getPrefixCls('empty-img-default');
  return react["createElement"]("svg", {
    className: prefixCls,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, react["createElement"]("g", {
    fill: "none",
    fillRule: "evenodd"
  }, react["createElement"]("g", {
    transform: "translate(24 31.67)"
  }, react["createElement"]("ellipse", {
    className: "".concat(prefixCls, "-ellipse"),
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), react["createElement"]("path", {
    className: "".concat(prefixCls, "-path-1"),
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
  }), react["createElement"]("path", {
    className: "".concat(prefixCls, "-path-2"),
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    transform: "translate(13.56)"
  }), react["createElement"]("path", {
    className: "".concat(prefixCls, "-path-3"),
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
  }), react["createElement"]("path", {
    className: "".concat(prefixCls, "-path-4"),
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
  })), react["createElement"]("path", {
    className: "".concat(prefixCls, "-path-5"),
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
  }), react["createElement"]("g", {
    className: "".concat(prefixCls, "-g"),
    transform: "translate(149.65 15.383)"
  }, react["createElement"]("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), react["createElement"]("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};

/* harmony default export */ var empty = (empty_Empty);
// CONCATENATED MODULE: ../node_modules/antd/es/empty/simple.js



var simple_Simple = function Simple() {
  var _React$useContext = react["useContext"](ConfigContext),
      getPrefixCls = _React$useContext.getPrefixCls;

  var prefixCls = getPrefixCls('empty-img-simple');
  return react["createElement"]("svg", {
    className: prefixCls,
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, react["createElement"]("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, react["createElement"]("ellipse", {
    className: "".concat(prefixCls, "-ellipse"),
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), react["createElement"]("g", {
    className: "".concat(prefixCls, "-g"),
    fillRule: "nonzero"
  }, react["createElement"]("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), react["createElement"]("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    className: "".concat(prefixCls, "-path")
  }))));
};

/* harmony default export */ var simple = (simple_Simple);
// CONCATENATED MODULE: ../node_modules/antd/es/empty/index.js





function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







var defaultEmptyImg = react["createElement"](empty, null);
var simpleEmptyImg = react["createElement"](simple, null);

var es_empty_Empty = function Empty(props) {
  return react["createElement"](ConfigConsumer, null, function (_ref) {
    var getPrefixCls = _ref.getPrefixCls,
        direction = _ref.direction;

    var className = props.className,
        customizePrefixCls = props.prefixCls,
        _props$image = props.image,
        image = _props$image === void 0 ? defaultEmptyImg : _props$image,
        description = props.description,
        children = props.children,
        imageStyle = props.imageStyle,
        restProps = __rest(props, ["className", "prefixCls", "image", "description", "children", "imageStyle"]);

    return react["createElement"](LocaleReceiver["a" /* default */], {
      componentName: "Empty"
    }, function (locale) {
      var _classNames;

      var prefixCls = getPrefixCls('empty', customizePrefixCls);
      var des = typeof description !== 'undefined' ? description : locale.description;
      var alt = typeof des === 'string' ? des : 'empty';
      var imageNode = null;

      if (typeof image === 'string') {
        imageNode = react["createElement"]("img", {
          alt: alt,
          src: image
        });
      } else {
        imageNode = image;
      }

      return react["createElement"]("div", _extends({
        className: classnames_default()(prefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-normal"), image === simpleEmptyImg), _defineProperty(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames), className)
      }, restProps), react["createElement"]("div", {
        className: "".concat(prefixCls, "-image"),
        style: imageStyle
      }, imageNode), des && react["createElement"]("p", {
        className: "".concat(prefixCls, "-description")
      }, des), children && react["createElement"]("div", {
        className: "".concat(prefixCls, "-footer")
      }, children));
    });
  });
};

es_empty_Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
es_empty_Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
/* harmony default export */ var es_empty = (es_empty_Empty);
// CONCATENATED MODULE: ../node_modules/antd/es/config-provider/renderEmpty.js




var renderEmpty_renderEmpty = function renderEmpty(componentName) {
  return react["createElement"](ConfigConsumer, null, function (_ref) {
    var getPrefixCls = _ref.getPrefixCls;
    var prefix = getPrefixCls('empty');

    switch (componentName) {
      case 'Table':
      case 'List':
        return react["createElement"](es_empty, {
          image: es_empty.PRESENTED_IMAGE_SIMPLE
        });

      case 'Select':
      case 'TreeSelect':
      case 'Cascader':
      case 'Transfer':
      case 'Mentions':
        return react["createElement"](es_empty, {
          image: es_empty.PRESENTED_IMAGE_SIMPLE,
          className: "".concat(prefix, "-small")
        });

      default:
        return react["createElement"](es_empty, null);
    }
  });
};

/* harmony default export */ var config_provider_renderEmpty = (renderEmpty_renderEmpty);
// CONCATENATED MODULE: ../node_modules/antd/es/config-provider/context.js



function context_extends() {
  context_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return context_extends.apply(this, arguments);
}



var ConfigContext = react["createContext"]({
  // We provide a default function for Context without provider
  getPrefixCls: function getPrefixCls(suffixCls, customizePrefixCls) {
    if (customizePrefixCls) return customizePrefixCls;
    return "ant-".concat(suffixCls);
  },
  renderEmpty: config_provider_renderEmpty
});
var ConfigConsumer = ConfigContext.Consumer;
function withConfigConsumer(config) {
  return function withConfigConsumerFunc(Component) {
    // Wrap with ConfigConsumer. Since we need compatible with react 15, be care when using ref methods
    var SFC = function SFC(props) {
      return react["createElement"](ConfigConsumer, null, function (configProps) {
        var basicPrefixCls = config.prefixCls;
        var getPrefixCls = configProps.getPrefixCls;
        var customizePrefixCls = props.prefixCls;
        var prefixCls = getPrefixCls(basicPrefixCls, customizePrefixCls);
        return react["createElement"](Component, context_extends({}, configProps, props, {
          prefixCls: prefixCls
        }));
      });
    };

    var cons = Component.constructor;
    var name = cons && cons.displayName || Component.name || 'Component';
    SFC.displayName = "withConfigConsumer(".concat(name, ")");
    return SFC;
  };
}

/***/ }),

/***/ "Bi0q":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("GkPX");

__webpack_require__("V7cS");

__webpack_require__("9ovy");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("javascript", function (config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/; // Tokenizer

    var keywords = function () {
      function kw(type) {
        return {
          type: type,
          style: "keyword"
        };
      }

      var A = kw("keyword a"),
          B = kw("keyword b"),
          C = kw("keyword c"),
          D = kw("keyword d");
      var operator = kw("operator"),
          atom = {
        type: "atom",
        style: "atom"
      };
      return {
        "if": kw("if"),
        "while": A,
        "with": A,
        "else": B,
        "do": B,
        "try": B,
        "finally": B,
        "return": D,
        "break": D,
        "continue": D,
        "new": kw("new"),
        "delete": C,
        "void": C,
        "throw": C,
        "debugger": kw("debugger"),
        "var": kw("var"),
        "const": kw("var"),
        "let": kw("var"),
        "function": kw("function"),
        "catch": kw("catch"),
        "for": kw("for"),
        "switch": kw("switch"),
        "case": kw("case"),
        "default": kw("default"),
        "in": operator,
        "typeof": operator,
        "instanceof": operator,
        "true": atom,
        "false": atom,
        "null": atom,
        "undefined": atom,
        "NaN": atom,
        "Infinity": atom,
        "this": kw("this"),
        "class": kw("class"),
        "super": kw("atom"),
        "yield": C,
        "export": kw("export"),
        "import": kw("import"),
        "extends": C,
        "await": C
      };
    }();

    var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

    function readRegexp(stream) {
      var escaped = false,
          next,
          inSet = false;

      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet) return;
          if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;
        }

        escaped = !escaped && next == "\\";
      }
    } // Used as scratch variables to communicate multiple values without
    // consing up tons of objects.


    var type, content;

    function ret(tp, style, cont) {
      type = tp;
      content = cont;
      return style;
    }

    function tokenBase(stream, state) {
      var ch = stream.next();

      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
        return ret("number", "number");
      } else if (/\d/.test(ch)) {
        stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, 1)) {
          readRegexp(stream);
          stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
          return ret("regexp", "string-2");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#") {
        stream.skipToEnd();
        return ret("error", "error");
      } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=") stream.eat("=");
          } else if (/[<>*+\-]/.test(ch)) {
            stream.eat(ch);
            if (ch == ">") stream.eat(ch);
          }
        }

        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current();

        if (state.lastType != ".") {
          if (keywords.propertyIsEnumerable(word)) {
            var kw = keywords[word];
            return ret(kw.type, kw.style, word);
          }

          if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false)) return ret("async", "keyword", word);
        }

        return ret("variable", "variable", word);
      }
    }

    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false,
            next;

        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }

        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) break;
          escaped = !escaped && next == "\\";
        }

        if (!escaped) state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false,
          ch;

      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }

        maybeEnd = ch == "*";
      }

      return ret("comment", "comment");
    }

    function tokenQuasi(stream, state) {
      var escaped = false,
          next;

      while ((next = stream.next()) != null) {
        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }

        escaped = !escaped && next == "\\";
      }

      return ret("quasi", "string-2", stream.current());
    }

    var brackets = "([{}])"; // This is a crude lookahead trick to try and notice that we're
    // parsing the argument patterns for a fat-arrow function before we
    // actually hit the arrow token. It only works if the arrow is on
    // the same line as the arguments and there's no strange noise
    // (comments) in between. Fallback is to only notice when we hit the
    // arrow, and not declare the arguments as locals for the arrow
    // body.

    function findFatArrow(stream, state) {
      if (state.fatArrowAt) state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < 0) return;

      if (isTS) {
        // Try to skip TypeScript return type declarations after the arguments
        var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
        if (m) arrow = m.index;
      }

      var depth = 0,
          sawSomething = false;

      for (var pos = arrow - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);

        if (bracket >= 0 && bracket < 3) {
          if (!depth) {
            ++pos;
            break;
          }

          if (--depth == 0) {
            if (ch == "(") sawSomething = true;
            break;
          }
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\/`]/.test(ch)) {
          for (;; --pos) {
            if (pos == 0) return;
            var next = stream.string.charAt(pos - 1);

            if (next == ch && stream.string.charAt(pos - 2) != "\\") {
              pos--;
              break;
            }
          }
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }

      if (sawSomething && !depth) state.fatArrowAt = pos;
    } // Parser


    var atomicTypes = {
      "atom": true,
      "number": true,
      "variable": true,
      "string": true,
      "regexp": true,
      "this": true,
      "jsonld-keyword": true
    };

    function JSLexical(indented, column, type, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.prev = prev;
      this.info = info;
      if (align != null) this.align = align;
    }

    function inScope(state, varname) {
      for (var v = state.localVars; v; v = v.next) {
        if (v.name == varname) return true;
      }

      for (var cx = state.context; cx; cx = cx.prev) {
        for (var v = cx.vars; v; v = v.next) {
          if (v.name == varname) return true;
        }
      }
    }

    function parseJS(state, style, type, content, stream) {
      var cc = state.cc; // Communicate our context to the combinators.
      // (Less wasteful than consing up a hundred closures on every call.)

      cx.state = state;
      cx.stream = stream;
      cx.marked = null, cx.cc = cc;
      cx.style = style;
      if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;

      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;

        if (combinator(type, content)) {
          while (cc.length && cc[cc.length - 1].lex) {
            cc.pop()();
          }

          if (cx.marked) return cx.marked;
          if (type == "variable" && inScope(state, content)) return "variable-2";
          return style;
        }
      }
    } // Combinator utils


    var cx = {
      state: null,
      column: null,
      marked: null,
      cc: null
    };

    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) {
        cx.cc.push(arguments[i]);
      }
    }

    function cont() {
      pass.apply(null, arguments);
      return true;
    }

    function inList(name, list) {
      for (var v = list; v; v = v.next) {
        if (v.name == name) return true;
      }

      return false;
    }

    function register(varname) {
      var state = cx.state;
      cx.marked = "def";

      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          // FIXME function decls are also not block scoped
          var newContext = registerVarScoped(varname, state.context);

          if (newContext != null) {
            state.context = newContext;
            return;
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars);
          return;
        }
      } // Fall through means this is global


      if (parserConfig.globalVars && !inList(varname, state.globalVars)) state.globalVars = new Var(varname, state.globalVars);
    }

    function registerVarScoped(varname, context) {
      if (!context) {
        return null;
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev);
        if (!inner) return null;
        if (inner == context.prev) return context;
        return new Context(inner, context.vars, true);
      } else if (inList(varname, context.vars)) {
        return context;
      } else {
        return new Context(context.prev, new Var(varname, context.vars), false);
      }
    }

    function isModifier(name) {
      return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
    } // Combinators


    function Context(prev, vars, block) {
      this.prev = prev;
      this.vars = vars;
      this.block = block;
    }

    function Var(name, next) {
      this.name = name;
      this.next = next;
    }

    var defaultVars = new Var("this", new Var("arguments", null));

    function pushcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
      cx.state.localVars = defaultVars;
    }

    function pushblockcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
      cx.state.localVars = null;
    }

    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }

    popcontext.lex = true;

    function pushlex(type, info) {
      var result = function result() {
        var state = cx.state,
            indent = state.indented;
        if (state.lexical.type == "stat") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) {
          indent = outer.indented;
        }
        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
      };

      result.lex = true;
      return result;
    }

    function poplex() {
      var state = cx.state;

      if (state.lexical.prev) {
        if (state.lexical.type == ")") state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }

    poplex.lex = true;

    function expect(wanted) {
      function exp(type) {
        if (type == wanted) return cont();else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();else return cont(exp);
      }

      ;
      return exp;
    }

    function statement(type, value) {
      if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
      if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
      if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type == "debugger") return cont(expect(";"));
      if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type == ";") return cont();

      if (type == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }

      if (type == "function") return cont(functiondef);
      if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);

      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form", type == "class" ? type : value), className, poplex);
      }

      if (type == "variable") {
        if (isTS && value == "declare") {
          cx.marked = "keyword";
          return cont(statement);
        } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
          cx.marked = "keyword";
          if (value == "enum") return cont(enumdef);else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
        } else if (isTS && value == "namespace") {
          cx.marked = "keyword";
          return cont(pushlex("form"), expression, statement, poplex);
        } else if (isTS && value == "abstract") {
          cx.marked = "keyword";
          return cont(statement);
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }

      if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
      if (type == "case") return cont(expression, expect(":"));
      if (type == "default") return cont(expect(":"));
      if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
      if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
      if (type == "async") return cont(statement);
      if (value == "@") return cont(expression, statement);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }

    function maybeCatchBinding(type) {
      if (type == "(") return cont(funarg, expect(")"));
    }

    function expression(type, value) {
      return expressionInner(type, value, false);
    }

    function expressionNoComma(type, value) {
      return expressionInner(type, value, true);
    }

    function parenExpr(type) {
      if (type != "(") return pass();
      return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
    }

    function expressionInner(type, value, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }

      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
      if (type == "function") return cont(functiondef, maybeop);

      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form"), classExpression, poplex);
      }

      if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
      if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
      if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type == "{") return contCommasep(objprop, "}", null, maybeop);
      if (type == "quasi") return pass(quasi, maybeop);
      if (type == "new") return cont(maybeTarget(noComma));
      if (type == "import") return cont(expression);
      return cont();
    }

    function maybeexpression(type) {
      if (type.match(/[;\}\)\],]/)) return pass();
      return pass(expression);
    }

    function maybeoperatorComma(type, value) {
      if (type == ",") return cont(maybeexpression);
      return maybeoperatorNoComma(type, value, false);
    }

    function maybeoperatorNoComma(type, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);

      if (type == "operator") {
        if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
        if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false)) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value == "?") return cont(expression, expect(":"), expr);
        return cont(expr);
      }

      if (type == "quasi") {
        return pass(quasi, me);
      }

      if (type == ";") return;
      if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
      if (type == ".") return cont(property, me);
      if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);

      if (isTS && value == "as") {
        cx.marked = "keyword";
        return cont(typeexpr, me);
      }

      if (type == "regexp") {
        cx.state.lastType = cx.marked = "operator";
        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
        return cont(expr);
      }
    }

    function quasi(type, value) {
      if (type != "quasi") return pass();
      if (value.slice(value.length - 2) != "${") return cont(quasi);
      return cont(expression, continueQuasi);
    }

    function continueQuasi(type) {
      if (type == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }

    function arrowBody(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expression);
    }

    function arrowBodyNoComma(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expressionNoComma);
    }

    function maybeTarget(noComma) {
      return function (type) {
        if (type == ".") return cont(noComma ? targetNoComma : target);else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);else return pass(noComma ? expressionNoComma : expression);
      };
    }

    function target(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorComma);
      }
    }

    function targetNoComma(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorNoComma);
      }
    }

    function maybelabel(type) {
      if (type == ":") return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }

    function property(type) {
      if (type == "variable") {
        cx.marked = "property";
        return cont();
      }
    }

    function objprop(type, value) {
      if (type == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(getterSetter);
        var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params

        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false))) cx.state.fatArrowAt = cx.stream.pos + m[0].length;
        return cont(afterprop);
      } else if (type == "number" || type == "string") {
        cx.marked = jsonldMode ? "property" : cx.style + " property";
        return cont(afterprop);
      } else if (type == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value == "*") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == ":") {
        return pass(afterprop);
      }
    }

    function getterSetter(type) {
      if (type != "variable") return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }

    function afterprop(type) {
      if (type == ":") return cont(expressionNoComma);
      if (type == "(") return pass(functiondef);
    }

    function commasep(what, end, sep) {
      function proceed(type, value) {
        if (sep ? sep.indexOf(type) > -1 : type == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
          return cont(function (type, value) {
            if (type == end || value == end) return pass();
            return pass(what);
          }, proceed);
        }

        if (type == end || value == end) return cont();
        if (sep && sep.indexOf(";") > -1) return pass(what);
        return cont(expect(end));
      }

      return function (type, value) {
        if (type == end || value == end) return cont();
        return pass(what, proceed);
      };
    }

    function contCommasep(what, end, info) {
      for (var i = 3; i < arguments.length; i++) {
        cx.cc.push(arguments[i]);
      }

      return cont(pushlex(end, info), commasep(what, end), poplex);
    }

    function block(type) {
      if (type == "}") return cont();
      return pass(statement, block);
    }

    function maybetype(type, value) {
      if (isTS) {
        if (type == ":") return cont(typeexpr);
        if (value == "?") return cont(maybetype);
      }
    }

    function maybetypeOrIn(type, value) {
      if (isTS && (type == ":" || value == "in")) return cont(typeexpr);
    }

    function mayberettype(type) {
      if (isTS && type == ":") {
        if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr);else return cont(typeexpr);
      }
    }

    function isKW(_, value) {
      if (value == "is") {
        cx.marked = "keyword";
        return cont();
      }
    }

    function typeexpr(type, value) {
      if (value == "keyof" || value == "typeof" || value == "infer") {
        cx.marked = "keyword";
        return cont(value == "typeof" ? expressionNoComma : typeexpr);
      }

      if (type == "variable" || value == "void") {
        cx.marked = "type";
        return cont(afterType);
      }

      if (value == "|" || value == "&") return cont(typeexpr);
      if (type == "string" || type == "number" || type == "atom") return cont(afterType);
      if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
      if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType);
      if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
      if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr);
    }

    function maybeReturnType(type) {
      if (type == "=>") return cont(typeexpr);
    }

    function typeprop(type, value) {
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(typeprop);
      } else if (value == "?" || type == "number" || type == "string") {
        return cont(typeprop);
      } else if (type == ":") {
        return cont(typeexpr);
      } else if (type == "[") {
        return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
      } else if (type == "(") {
        return pass(functiondecl, typeprop);
      }
    }

    function typearg(type, value) {
      if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg);
      if (type == ":") return cont(typeexpr);
      if (type == "spread") return cont(typearg);
      return pass(typeexpr);
    }

    function afterType(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      if (value == "|" || type == "." || value == "&") return cont(typeexpr);
      if (type == "[") return cont(typeexpr, expect("]"), afterType);

      if (value == "extends" || value == "implements") {
        cx.marked = "keyword";
        return cont(typeexpr);
      }

      if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
    }

    function maybeTypeArgs(_, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
    }

    function typeparam() {
      return pass(typeexpr, maybeTypeDefault);
    }

    function maybeTypeDefault(_, value) {
      if (value == "=") return cont(typeexpr);
    }

    function vardef(_, value) {
      if (value == "enum") {
        cx.marked = "keyword";
        return cont(enumdef);
      }

      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }

    function pattern(type, value) {
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(pattern);
      }

      if (type == "variable") {
        register(value);
        return cont();
      }

      if (type == "spread") return cont(pattern);
      if (type == "[") return contCommasep(eltpattern, "]");
      if (type == "{") return contCommasep(proppattern, "}");
    }

    function proppattern(type, value) {
      if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
        register(value);
        return cont(maybeAssign);
      }

      if (type == "variable") cx.marked = "property";
      if (type == "spread") return cont(pattern);
      if (type == "}") return pass();
      if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
      return cont(expect(":"), pattern, maybeAssign);
    }

    function eltpattern() {
      return pass(pattern, maybeAssign);
    }

    function maybeAssign(_type, value) {
      if (value == "=") return cont(expressionNoComma);
    }

    function vardefCont(type) {
      if (type == ",") return cont(vardef);
    }

    function maybeelse(type, value) {
      if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
    }

    function forspec(type, value) {
      if (value == "await") return cont(forspec);
      if (type == "(") return cont(pushlex(")"), forspec1, poplex);
    }

    function forspec1(type) {
      if (type == "var") return cont(vardef, forspec2);
      if (type == "variable") return cont(forspec2);
      return pass(forspec2);
    }

    function forspec2(type, value) {
      if (type == ")") return cont();
      if (type == ";") return cont(forspec2);

      if (value == "in" || value == "of") {
        cx.marked = "keyword";
        return cont(expression, forspec2);
      }

      return pass(expression, forspec2);
    }

    function functiondef(type, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(functiondef);
      }

      if (type == "variable") {
        register(value);
        return cont(functiondef);
      }

      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
    }

    function functiondecl(type, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(functiondecl);
      }

      if (type == "variable") {
        register(value);
        return cont(functiondecl);
      }

      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
    }

    function typename(type, value) {
      if (type == "keyword" || type == "variable") {
        cx.marked = "type";
        return cont(typename);
      } else if (value == "<") {
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
      }
    }

    function funarg(type, value) {
      if (value == "@") cont(expression, funarg);
      if (type == "spread") return cont(funarg);

      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(funarg);
      }

      if (isTS && type == "this") return cont(maybetype, maybeAssign);
      return pass(pattern, maybetype, maybeAssign);
    }

    function classExpression(type, value) {
      // Class expressions may have an optional name.
      if (type == "variable") return className(type, value);
      return classNameAfter(type, value);
    }

    function className(type, value) {
      if (type == "variable") {
        register(value);
        return cont(classNameAfter);
      }
    }

    function classNameAfter(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);

      if (value == "extends" || value == "implements" || isTS && type == ",") {
        if (value == "implements") cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }

      if (type == "{") return cont(pushlex("}"), classBody, poplex);
    }

    function classBody(type, value) {
      if (type == "async" || type == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
        cx.marked = "keyword";
        return cont(classBody);
      }

      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(isTS ? classfield : functiondef, classBody);
      }

      if (type == "number" || type == "string") return cont(isTS ? classfield : functiondef, classBody);
      if (type == "[") return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody);

      if (value == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }

      if (isTS && type == "(") return pass(functiondecl, classBody);
      if (type == ";" || type == ",") return cont(classBody);
      if (type == "}") return cont();
      if (value == "@") return cont(expression, classBody);
    }

    function classfield(type, value) {
      if (value == "?") return cont(classfield);
      if (type == ":") return cont(typeexpr, maybeAssign);
      if (value == "=") return cont(expressionNoComma);
      var context = cx.state.lexical.prev,
          isInterface = context && context.info == "interface";
      return pass(isInterface ? functiondecl : functiondef);
    }

    function afterExport(type, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(maybeFrom, expect(";"));
      }

      if (value == "default") {
        cx.marked = "keyword";
        return cont(expression, expect(";"));
      }

      if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }

    function exportField(type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(expect("variable"));
      }

      if (type == "variable") return pass(expressionNoComma, exportField);
    }

    function afterImport(type) {
      if (type == "string") return cont();
      if (type == "(") return pass(expression);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }

    function importSpec(type, value) {
      if (type == "{") return contCommasep(importSpec, "}");
      if (type == "variable") register(value);
      if (value == "*") cx.marked = "keyword";
      return cont(maybeAs);
    }

    function maybeMoreImports(type) {
      if (type == ",") return cont(importSpec, maybeMoreImports);
    }

    function maybeAs(_type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(importSpec);
      }
    }

    function maybeFrom(_type, value) {
      if (value == "from") {
        cx.marked = "keyword";
        return cont(expression);
      }
    }

    function arrayLiteral(type) {
      if (type == "]") return cont();
      return pass(commasep(expressionNoComma, "]"));
    }

    function enumdef() {
      return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
    }

    function enummember() {
      return pass(pattern, maybeAssign);
    }

    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
    }

    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
    } // Interface


    return {
      startState: function startState(basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context(null, null, false),
          indented: basecolumn || 0
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object") state.globalVars = parserConfig.globalVars;
        return state;
      },
      token: function token(stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }

        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (type == "comment") return style;
        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
        return parseJS(state, style, type, content, stream);
      },
      indent: function indent(state, textAfter) {
        if (state.tokenize == tokenComment) return CodeMirror.Pass;
        if (state.tokenize != tokenBase) return 0;
        var firstChar = textAfter && textAfter.charAt(0),
            lexical = state.lexical,
            top; // Kludge to prevent 'maybelse' from blocking lexical scope pops

        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
          var c = state.cc[i];
          if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;
        }

        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter))) {
          lexical = lexical.prev;
        }

        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
        var type = lexical.type,
            closing = firstChar == type;
        if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
      },
      electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      blockCommentContinue: jsonMode ? null : " * ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\"\"``",
      helperType: jsonMode ? "json" : "javascript",
      jsonldMode: jsonldMode,
      jsonMode: jsonMode,
      expressionAllowed: expressionAllowed,
      skipExpression: function skipExpression(state) {
        var top = state.cc[state.cc.length - 1];
        if (top == expression || top == expressionNoComma) state.cc.pop();
      }
    };
  });
  CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
  CodeMirror.defineMIME("text/javascript", "javascript");
  CodeMirror.defineMIME("text/ecmascript", "javascript");
  CodeMirror.defineMIME("application/javascript", "javascript");
  CodeMirror.defineMIME("application/x-javascript", "javascript");
  CodeMirror.defineMIME("application/ecmascript", "javascript");
  CodeMirror.defineMIME("application/json", {
    name: "javascript",
    json: true
  });
  CodeMirror.defineMIME("application/x-json", {
    name: "javascript",
    json: true
  });
  CodeMirror.defineMIME("application/ld+json", {
    name: "javascript",
    jsonld: true
  });
  CodeMirror.defineMIME("text/typescript", {
    name: "javascript",
    typescript: true
  });
  CodeMirror.defineMIME("application/typescript", {
    name: "javascript",
    typescript: true
  });
});

/***/ }),

/***/ "Bsg+":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "ByO0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("uUP6"),
    Just = _require.Just,
    Nothing = _require.Nothing;
/*~
 * stability: stable
 * authors: 
 *   - "@boris-marinov"
 * 
 * type: |
 *   forall a, b:
 *     (Validation a b) => Maybe b
 */


var validationToMaybe = function validationToMaybe(aValidation) {
  return aValidation.matchWith({
    Failure: function Failure() {
      return Nothing();
    },
    Success: function Success(_ref) {
      var value = _ref.value;
      return Just(value);
    }
  });
};

module.exports = validationToMaybe;

/***/ }),

/***/ "C5nI":
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__("Qno1");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "CAwg":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("/6KZ");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("tbIA") });


/***/ }),

/***/ "CE6G":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ useTranslation; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ withTranslation; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ initReactI18next; });

// UNUSED EXPORTS: Trans, Translation, I18nextProvider, withSSR, useSSR, I18nContext, setDefaults, getDefaults, setI18n, getI18n, composeInitialProps, getInitialProps

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.bind.js
var es6_function_bind = __webpack_require__("o7PZ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.number.constructor.js
var es6_number_constructor = __webpack_require__("e2Kn");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.number.is-nan.js
var es6_number_is_nan = __webpack_require__("MYxt");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__("GkPX");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.reduce.js
var es6_array_reduce = __webpack_require__("3y5y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.constructor.js
var es6_regexp_constructor = __webpack_require__("J8hF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.is-array.js
var es6_array_is_array = __webpack_require__("+3V6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.to-string.js
var es6_date_to_string = __webpack_require__("M/4x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-properties.js
var es6_object_define_properties = __webpack_require__("6/FK");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("2Tod");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__("RiSW");
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties);

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__("OvAC");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__("e+GP");
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/html-parse-stringify2/index.js
var html_parse_stringify2 = __webpack_require__("fACT");
var html_parse_stringify2_default = /*#__PURE__*/__webpack_require__.n(html_parse_stringify2);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__("DbwS");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__("SDJZ");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__("NToG");
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/context.js















function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        defineProperty_default()(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}


var defaultOptions = {
  bindI18n: 'languageChanged',
  bindI18nStore: '',
  // nsMode: 'fallback' // loop through all namespaces given to hook, HOC, render prop for key lookup
  transEmptyNodeValue: '',
  transSupportBasicHtmlNodes: true,
  transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],
  // hashTransKey: key => key // calculate a key for Trans component based on defaultValue
  useSuspense: true
};
var i18nInstance;
var hasUsedI18nextProvider;
var I18nContext = react_default.a.createContext();
function usedI18nextProvider(used) {
  hasUsedI18nextProvider = used;
}
function getHasUsedI18nextProvider() {
  return hasUsedI18nextProvider;
}
function setDefaults() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  defaultOptions = _objectSpread({}, defaultOptions, {}, options);
}
function getDefaults() {
  return defaultOptions;
}
var context_ReportNamespaces = /*#__PURE__*/function () {
  function ReportNamespaces() {
    classCallCheck_default()(this, ReportNamespaces);

    this.usedNamespaces = {};
  }

  createClass_default()(ReportNamespaces, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;

      namespaces.forEach(function (ns) {
        if (!_this.usedNamespaces[ns]) _this.usedNamespaces[ns] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);

  return ReportNamespaces;
}();
function setI18n(instance) {
  i18nInstance = instance;
}
function getI18n() {
  return i18nInstance;
}
var initReactI18next = {
  type: '3rdParty',
  init: function init(instance) {
    setDefaults(instance.options.react);
    setI18n(instance);
  }
};
function composeInitialProps(ForComponent) {
  return function (ctx) {
    return new Promise(function (resolve) {
      var i18nInitialProps = getInitialProps();

      if (ForComponent.getInitialProps) {
        ForComponent.getInitialProps(ctx).then(function (componentsInitialProps) {
          resolve(_objectSpread({}, componentsInitialProps, {}, i18nInitialProps));
        });
      } else {
        resolve(i18nInitialProps);
      }
    });
  }; // Avoid async for now - so we do not need to pull in regenerator
  // return async ctx => {
  //   const componentsInitialProps = ForComponent.getInitialProps
  //     ? await ForComponent.getInitialProps(ctx)
  //     : {};
  //   const i18nInitialProps = getInitialProps();
  //   return {
  //     ...componentsInitialProps,
  //     ...i18nInitialProps,
  //   };
  // };
}
function getInitialProps() {
  var i18n = getI18n();
  var namespaces = i18n.reportNamespaces ? i18n.reportNamespaces.getUsedNamespaces() : [];
  var ret = {};
  var initialI18nStore = {};
  i18n.languages.forEach(function (l) {
    initialI18nStore[l] = {};
    namespaces.forEach(function (ns) {
      initialI18nStore[l][ns] = i18n.getResourceBundle(l, ns) || {};
    });
  });
  ret.initialI18nStore = initialI18nStore;
  ret.initialLanguage = i18n.language;
  return ret;
}
// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/utils.js


function warn() {
  if (console && console.warn) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (typeof args[0] === 'string') args[0] = "react-i18next:: ".concat(args[0]);

    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  if (typeof args[0] === 'string' && alreadyWarned[args[0]]) return;
  if (typeof args[0] === 'string') alreadyWarned[args[0]] = new Date();
  warn.apply(void 0, args);
} // not needed right now
//
// export function deprecated(...args) {
//   if (process && process.env && (!process.env.NODE_ENV || process.env.NODE_ENV === 'development')) {
//     if (typeof args[0] === 'string') args[0] = `deprecation warning -> ${args[0]}`;
//     warnOnce(...args);
//   }
// }

function loadNamespaces(i18n, ns, cb) {
  i18n.loadNamespaces(ns, function () {
    // delay ready if not yet initialized i18n instance
    if (i18n.isInitialized) {
      cb();
    } else {
      var initialized = function initialized() {
        // due to emitter removing issue in i18next we need to delay remove
        setTimeout(function () {
          i18n.off('initialized', initialized);
        }, 0);
        cb();
      };

      i18n.on('initialized', initialized);
    }
  });
}
function hasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!i18n.languages || !i18n.languages.length) {
    warnOnce('i18n.languages were undefined or empty', i18n.languages);
    return true;
  }

  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1]; // we're in cimode so this shall pass

  if (lng.toLowerCase() === 'cimode') return true;

  var loadNotPending = function loadNotPending(l, n) {
    var loadState = i18n.services.backendConnector.state["".concat(l, "|").concat(n)];
    return loadState === -1 || loadState === 2;
  }; // bound to trigger on event languageChanging
  // so set ready to false while we are changing the language
  // and namespace pending (depends on having a backend)


  if (options.bindI18n && options.bindI18n.indexOf('languageChanging') > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns)) return false; // loaded -> SUCCESS

  if (i18n.hasResourceBundle(lng, ns)) return true; // were not loading at all -> SEMI SUCCESS

  if (!i18n.services.backendConnector.backend) return true; // failed loading ns - but at least fallback is not pending -> SEMI SUCCESS

  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
  return false;
}
function getDisplayName(Component) {
  return Component.displayName || Component.name || (typeof Component === 'string' && Component.length > 0 ? Component : 'Unknown');
}
// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/Trans.js

























function Trans_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function Trans_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      Trans_ownKeys(source, true).forEach(function (key) {
        defineProperty_default()(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      Trans_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}






function hasChildren(node) {
  return node && (node.children || node.props && node.props.children);
}

function getChildren(node) {
  if (!node) return [];
  return node && node.children ? node.children : node.props && node.props.children;
}

function hasValidReactChildren(children) {
  if (Object.prototype.toString.call(children) !== '[object Array]') return false;
  return children.every(function (child) {
    return react_default.a.isValidElement(child);
  });
}

function getAsArray(data) {
  return Array.isArray(data) ? data : [data];
}

function nodesToString(startingString, children, index, i18nOptions) {
  if (!children) return '';
  var stringNode = startingString;
  var childrenArray = getAsArray(children);
  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  childrenArray.forEach(function (child, i) {
    var elementKey = "".concat(i);

    if (typeof child === 'string') {
      stringNode = "".concat(stringNode).concat(child);
    } else if (hasChildren(child)) {
      var elementTag = keepArray.indexOf(child.type) > -1 && Object.keys(child.props).length === 1 && typeof hasChildren(child) === 'string' ? child.type : elementKey;

      if (child.props && child.props.i18nIsDynamicList) {
        // we got a dynamic list like "<ul>{['a', 'b'].map(item => ( <li key={item}>{item}</li> ))}</ul>""
        // the result should be "<0></0>" and not "<0><0>a</0><1>b</1></0>"
        stringNode = "".concat(stringNode, "<").concat(elementTag, "></").concat(elementTag, ">");
      } else {
        // regular case mapping the inner children
        stringNode = "".concat(stringNode, "<").concat(elementTag, ">").concat(nodesToString('', getChildren(child), i + 1, i18nOptions), "</").concat(elementTag, ">");
      }
    } else if (react_default.a.isValidElement(child)) {
      if (keepArray.indexOf(child.type) > -1 && Object.keys(child.props).length === 0) {
        stringNode = "".concat(stringNode, "<").concat(child.type, "/>");
      } else {
        stringNode = "".concat(stringNode, "<").concat(elementKey, "></").concat(elementKey, ">");
      }
    } else if (typeof_default()(child) === 'object') {
      var clone = Trans_objectSpread({}, child);

      var format = clone.format;
      delete clone.format;
      var keys = Object.keys(clone);

      if (format && keys.length === 1) {
        stringNode = "".concat(stringNode, "{{").concat(keys[0], ", ").concat(format, "}}");
      } else if (keys.length === 1) {
        stringNode = "".concat(stringNode, "{{").concat(keys[0], "}}");
      } else {
        // not a valid interpolation object (can only contain one value plus format)
        warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
      }
    } else {
      warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
    }
  });
  return stringNode;
}

function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts) {
  if (targetString === '') return []; // check if contains tags we need to replace from html string to react nodes

  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join('|')).test(targetString); // no need to replace tags in the targetstring

  if (!children && !emptyChildrenButNeedsHandling) return [targetString]; // v2 -> interpolates upfront no need for "some <0>{{var}}</0>"" -> will be just "some {{var}}" in translation file

  var data = {};

  function getData(childs) {
    var childrenArray = getAsArray(childs);
    childrenArray.forEach(function (child) {
      if (typeof child === 'string') return;
      if (hasChildren(child)) getData(getChildren(child));else if (typeof_default()(child) === 'object' && !react_default.a.isValidElement(child)) Object.assign(data, child);
    });
  }

  getData(children);
  var interpolatedString = i18n.services.interpolator.interpolate(targetString, Trans_objectSpread({}, data, {}, combinedTOpts), i18n.language); // parse ast from string with additional wrapper tag
  // -> avoids issues in parser removing prepending text nodes

  var ast = html_parse_stringify2_default.a.parse("<0>".concat(interpolatedString, "</0>"));

  function mapAST(reactNode, astNode) {
    var reactNodes = getAsArray(reactNode);
    var astNodes = getAsArray(astNode);
    return astNodes.reduce(function (mem, node, i) {
      var translationContent = node.children && node.children[0] && node.children[0].content;

      if (node.type === 'tag') {
        var child = reactNodes[parseInt(node.name, 10)] || {};
        var isElement = react_default.a.isValidElement(child);

        if (typeof child === 'string') {
          mem.push(child);
        } else if (hasChildren(child)) {
          var childs = getChildren(child);
          var mappedChildren = mapAST(childs, node.children);
          var inner = hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
          if (child.dummy) child.children = inner; // needed on preact!

          mem.push(react_default.a.cloneElement(child, Trans_objectSpread({}, child.props, {
            key: i
          }), inner));
        } else if (emptyChildrenButNeedsHandling && typeof_default()(child) === 'object' && child.dummy && !isElement) {
          // we have a empty Trans node (the dummy element) with a targetstring that contains html tags needing
          // conversion to react nodes
          // so we just need to map the inner stuff
          var _inner = mapAST(reactNodes
          /* wrong but we need something */
          , node.children);

          mem.push(react_default.a.cloneElement(child, Trans_objectSpread({}, child.props, {
            key: i
          }), _inner));
        } else if (Number.isNaN(parseFloat(node.name))) {
          if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {
            if (node.voidElement) {
              mem.push(react_default.a.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i)
              }));
            } else {
              var _inner2 = mapAST(reactNodes
              /* wrong but we need something */
              , node.children);

              mem.push(react_default.a.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i)
              }, _inner2));
            }
          } else if (node.voidElement) {
            mem.push("<".concat(node.name, " />"));
          } else {
            var _inner3 = mapAST(reactNodes
            /* wrong but we need something */
            , node.children);

            mem.push("<".concat(node.name, ">").concat(_inner3, "</").concat(node.name, ">"));
          }
        } else if (typeof_default()(child) === 'object' && !isElement) {
          var content = node.children[0] ? translationContent : null; // v1
          // as interpolation was done already we just have a regular content node
          // in the translation AST while having an object in reactNodes
          // -> push the content no need to interpolate again

          if (content) mem.push(content);
        } else if (node.children.length === 1 && translationContent) {
          // If component does not have children, but translation - has
          // with this in component could be components={[<span class='make-beautiful'/>]} and in translation - 'some text <0>some highlighted message</0>'
          mem.push(react_default.a.cloneElement(child, Trans_objectSpread({}, child.props, {
            key: i
          }), translationContent));
        } else {
          mem.push(react_default.a.cloneElement(child, Trans_objectSpread({}, child.props, {
            key: i
          })));
        }
      } else if (node.type === 'text') {
        mem.push(node.content);
      }

      return mem;
    }, []);
  } // call mapAST with having react nodes nested into additional node like
  // we did for the string ast from translation
  // return the children of that extra node to get expected result


  var result = mapAST([{
    dummy: true,
    children: children
  }], ast);
  return getChildren(result[0]);
}

function Trans(_ref) {
  var children = _ref.children,
      count = _ref.count,
      parent = _ref.parent,
      i18nKey = _ref.i18nKey,
      tOptions = _ref.tOptions,
      values = _ref.values,
      defaults = _ref.defaults,
      components = _ref.components,
      ns = _ref.ns,
      i18nFromProps = _ref.i18n,
      tFromProps = _ref.t,
      additionalProps = objectWithoutProperties_default()(_ref, ["children", "count", "parent", "i18nKey", "tOptions", "values", "defaults", "components", "ns", "i18n", "t"]);

  var ReactI18nContext = Object(react["useContext"])(I18nContext);

  var _ref2 = getHasUsedI18nextProvider() ? ReactI18nContext || {} : {},
      i18nFromContext = _ref2.i18n,
      defaultNSFromContext = _ref2.defaultNS;

  var i18n = i18nFromProps || i18nFromContext || getI18n();

  if (!i18n) {
    warnOnce('You will need pass in an i18next instance by using i18nextReactModule');
    return children;
  }

  var t = tFromProps || i18n.t.bind(i18n) || function (k) {
    return k;
  };

  var reactI18nextOptions = Trans_objectSpread({}, getDefaults(), {}, i18n.options && i18n.options.react);

  var useAsParent = parent !== undefined ? parent : reactI18nextOptions.defaultTransParent; // prepare having a namespace

  var namespaces = ns || t.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];
  var defaultValue = defaults || nodesToString('', children, 0, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue;
  var hashTransKey = reactI18nextOptions.hashTransKey;
  var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue);
  var interpolationOverride = values ? {} : {
    interpolation: {
      prefix: '#$?',
      suffix: '?$#'
    }
  };

  var combinedTOpts = Trans_objectSpread({}, tOptions, {
    count: count
  }, values, {}, interpolationOverride, {
    defaultValue: defaultValue,
    ns: namespaces
  });

  var translation = key ? t(key, combinedTOpts) : defaultValue;
  if (!useAsParent) return renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts);
  return react_default.a.createElement(useAsParent, additionalProps, renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts));
}
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__("asZ9");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__("nxTg");
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/useTranslation.js
















function useTranslation_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function useTranslation_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      useTranslation_ownKeys(source, true).forEach(function (key) {
        defineProperty_default()(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      useTranslation_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}




function useTranslation(ns) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // assert we have the needed i18nInstance

  var i18nFromProps = props.i18n;
  var ReactI18nContext = Object(react["useContext"])(I18nContext);

  var _ref = getHasUsedI18nextProvider() ? ReactI18nContext || {} : {},
      i18nFromContext = _ref.i18n,
      defaultNSFromContext = _ref.defaultNS;

  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new context_ReportNamespaces();

  if (!i18n) {
    warnOnce('You will need pass in an i18next instance by using initReactI18next');

    var notReadyT = function notReadyT(k) {
      return Array.isArray(k) ? k[k.length - 1] : k;
    };

    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }

  var i18nOptions = useTranslation_objectSpread({}, getDefaults(), {}, i18n.options.react, {}, props);

  var useSuspense = i18nOptions.useSuspense; // prepare having a namespace

  var namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation']; // report namespaces as used

  if (i18n.reportNamespaces.addUsedNamespaces) i18n.reportNamespaces.addUsedNamespaces(namespaces); // are we ready? yes if all namespaces in first language are loaded already (either with data or empty object on failed load)

  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function (n) {
    return hasLoadedNamespace(n, i18n, i18nOptions);
  }); // binding t function to namespace (acts also as rerender trigger)

  function getT() {
    return {
      t: i18n.getFixedT(null, i18nOptions.nsMode === 'fallback' ? namespaces : namespaces[0])
    };
  }

  var _useState = Object(react["useState"])(getT()),
      _useState2 = slicedToArray_default()(_useState, 2),
      t = _useState2[0],
      setT = _useState2[1]; // seems we can't have functions as value -> wrap it in obj


  var isMounted = Object(react["useRef"])(true);
  Object(react["useEffect"])(function () {
    var bindI18n = i18nOptions.bindI18n,
        bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true; // if not ready and not using suspense load the namespaces
    // in side effect and do not call resetT if unmounted

    if (!ready && !useSuspense) {
      loadNamespaces(i18n, namespaces, function () {
        if (isMounted.current) setT(getT());
      });
    }

    function boundReset() {
      if (isMounted.current) setT(getT());
    } // bind events to trigger change, like languageChanged


    if (bindI18n && i18n) i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n) i18n.store.on(bindI18nStore, boundReset); // unbinding on unmount

    return function () {
      isMounted.current = false;
      if (bindI18n && i18n) bindI18n.split(' ').forEach(function (e) {
        return i18n.off(e, boundReset);
      });
      if (bindI18nStore && i18n) bindI18nStore.split(' ').forEach(function (e) {
        return i18n.store.off(e, boundReset);
      });
    };
  }, [namespaces.join()]); // re-run effect whenever list of namespaces changes

  var ret = [t.t, i18n, ready];
  ret.t = t.t;
  ret.i18n = i18n;
  ret.ready = ready; // return hook stuff if ready

  if (ready) return ret; // not yet loaded namespaces -> load them -> and return if useSuspense option set false

  if (!ready && !useSuspense) return ret; // not yet loaded namespaces -> load them -> and trigger suspense

  throw new Promise(function (resolve) {
    loadNamespaces(i18n, namespaces, function () {
      if (isMounted.current) setT(getT());
      resolve();
    });
  });
}
// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/withTranslation.js















function withTranslation_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function withTranslation_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      withTranslation_ownKeys(source, true).forEach(function (key) {
        defineProperty_default()(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      withTranslation_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}




function withTranslation(ns) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function Extend(WrappedComponent) {
    function I18nextWithTranslation(_ref) {
      var forwardedRef = _ref.forwardedRef,
          rest = objectWithoutProperties_default()(_ref, ["forwardedRef"]);

      var _useTranslation = useTranslation(ns, rest),
          _useTranslation2 = slicedToArray_default()(_useTranslation, 3),
          t = _useTranslation2[0],
          i18n = _useTranslation2[1],
          ready = _useTranslation2[2];

      var passDownProps = withTranslation_objectSpread({}, rest, {
        t: t,
        i18n: i18n,
        tReady: ready
      });

      if (options.withRef && forwardedRef) {
        passDownProps.ref = forwardedRef;
      } else if (!options.withRef && forwardedRef) {
        passDownProps.forwardedRef = forwardedRef;
      }

      return react_default.a.createElement(WrappedComponent, passDownProps);
    }

    I18nextWithTranslation.displayName = "withI18nextTranslation(".concat(getDisplayName(WrappedComponent), ")");
    I18nextWithTranslation.WrappedComponent = WrappedComponent;

    var forwardRef = function forwardRef(props, ref) {
      return react_default.a.createElement(I18nextWithTranslation, Object.assign({}, props, {
        forwardedRef: ref
      }));
    };

    return options.withRef ? react_default.a.forwardRef(forwardRef) : I18nextWithTranslation;
  };
}
// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/Translation.js



function Translation(props) {
  var ns = props.ns,
      children = props.children,
      options = objectWithoutProperties_default()(props, ["ns", "children"]);

  var _useTranslation = useTranslation(ns, options),
      _useTranslation2 = slicedToArray_default()(_useTranslation, 3),
      t = _useTranslation2[0],
      i18n = _useTranslation2[1],
      ready = _useTranslation2[2];

  return children(t, {
    i18n: i18n,
    lng: i18n.language
  }, ready);
}
// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/I18nextProvider.js


function I18nextProvider(_ref) {
  var i18n = _ref.i18n,
      defaultNS = _ref.defaultNS,
      children = _ref.children;
  usedI18nextProvider(true);
  return react_default.a.createElement(I18nContext.Provider, {
    value: {
      i18n: i18n,
      defaultNS: defaultNS
    }
  }, children);
}
// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.values.js
var es7_object_values = __webpack_require__("3DBk");

// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/useSSR.js










function useSSR(initialI18nStore, initialLanguage) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var i18nFromProps = props.i18n;
  var ReactI18nContext = Object(react["useContext"])(I18nContext);

  var _ref = getHasUsedI18nextProvider() ? ReactI18nContext || {} : {},
      i18nFromContext = _ref.i18n;

  var i18n = i18nFromProps || i18nFromContext || getI18n(); // opt out if is a cloned instance, eg. created by i18next-express-middleware on request
  // -> do not set initial stuff on server side

  if (i18n.options && i18n.options.isClone) return; // nextjs / SSR: getting data from next.js or other ssr stack

  if (initialI18nStore && !i18n.initializedStoreOnce) {
    i18n.services.resourceStore.data = initialI18nStore; // add namespaces to the config - so a languageChange call loads all namespaces needed

    i18n.options.ns = Object.values(initialI18nStore).reduce(function (mem, lngResources) {
      Object.keys(lngResources).forEach(function (ns) {
        if (mem.indexOf(ns) < 0) mem.push(ns);
      });
      return mem;
    }, i18n.options.ns);
    i18n.initializedStoreOnce = true;
    i18n.isInitialized = true;
  }

  if (initialLanguage && !i18n.initializedLanguageOnce) {
    i18n.changeLanguage(initialLanguage);
    i18n.initializedLanguageOnce = true;
  }
}
// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/withSSR.js













function withSSR_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function withSSR_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      withSSR_ownKeys(source, true).forEach(function (key) {
        defineProperty_default()(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      withSSR_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}





function withSSR() {
  return function Extend(WrappedComponent) {
    function I18nextWithSSR(_ref) {
      var initialI18nStore = _ref.initialI18nStore,
          initialLanguage = _ref.initialLanguage,
          rest = objectWithoutProperties_default()(_ref, ["initialI18nStore", "initialLanguage"]);

      useSSR(initialI18nStore, initialLanguage);
      return react_default.a.createElement(WrappedComponent, withSSR_objectSpread({}, rest));
    }

    I18nextWithSSR.getInitialProps = composeInitialProps(WrappedComponent);
    I18nextWithSSR.displayName = "withI18nextSSR(".concat(getDisplayName(WrappedComponent), ")");
    I18nextWithSSR.WrappedComponent = WrappedComponent;
    return I18nextWithSSR;
  };
}
// CONCATENATED MODULE: ../node_modules/react-i18next/dist/es/index.js









/***/ }),

/***/ "CHlC":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _inherits; });

// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

/***/ }),

/***/ "CIiV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__("U1KF");
var createDesc = __webpack_require__("WWmS");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "CL0D":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");
/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */


module.exports = _curry1(function isNil(x) {
  return x == null;
});

/***/ }),

/***/ "CLuC":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("P56o").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "CXzI":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

var _curry1 = __webpack_require__("AN6r");
/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 */


module.exports = _curry1(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});

/***/ }),

/***/ "CZpP":
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__("r/sL");

var _curry2 = __webpack_require__("OFPg");
/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      var log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */


module.exports = _curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});

/***/ }),

/***/ "Cbd+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("V7cS");

__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports["default"] = create;

function create(initialState) {
  var state = initialState;
  var listeners = [];

  function setState(partial) {
    state = _extends({}, state, partial);

    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }
  }

  function getState() {
    return state;
  }

  function subscribe(listener) {
    listeners.push(listener);
    return function unsubscribe() {
      var index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    };
  }

  return {
    setState: setState,
    getState: getState,
    subscribe: subscribe
  };
}

/***/ }),

/***/ "Cmsx":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("n+VH");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "CnhP":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("Z8gF");exports.registerServiceWorker=function(){return true;};// only cache relevant resources for this page
var whiteListLinkRels=/^(stylesheet|preload)$/;var prefetchedPathnames=[];exports.onServiceWorkerActive=function(_ref){var getResourceURLsForPathname=_ref.getResourceURLsForPathname,serviceWorker=_ref.serviceWorker;// if the SW has just updated then clear the path dependencies and don't cache
// stuff, since we're on the old revision until we navigate to another page
if(window.___swUpdated){serviceWorker.active.postMessage({gatsbyApi:"clearPathResources"});return;}// grab nodes from head of document
var nodes=document.querySelectorAll("\n    head > script[src],\n    head > link[href],\n    head > style[data-href]\n  ");// get all resource URLs
var headerResources=[].slice.call(nodes)// don't include preconnect/prefetch/prerender resources
.filter(function(node){return node.tagName!=="LINK"||whiteListLinkRels.test(node.getAttribute("rel"));}).map(function(node){return node.src||node.href||node.getAttribute("data-href");});// Loop over prefetched pages and add their resources to an array,
// plus specify which resources are required for those paths.
var prefetchedResources=[];prefetchedPathnames.forEach(function(path){var resources=getResourceURLsForPathname(path);prefetchedResources.push.apply(prefetchedResources,resources);serviceWorker.active.postMessage({gatsbyApi:"setPathResources",path:path,resources:resources});});// Loop over all resources and fetch the page component + JSON data
// to add it to the SW cache.
var resources=[].concat(headerResources,prefetchedResources);resources.forEach(function(resource){// Create a prefetch link for each resource, so Workbox runtime-caches them
var link=document.createElement("link");link.rel="prefetch";link.href=resource;link.onload=link.remove;link.onerror=link.remove;document.head.appendChild(link);});};function setPathResources(path,getResourceURLsForPathname){// do nothing if the SW has just updated, since we still have old pages in
// memory which we don't want to be whitelisted
if(window.___swUpdated)return;if("serviceWorker"in navigator){var _navigator=navigator,serviceWorker=_navigator.serviceWorker;if(serviceWorker.controller===null){// if SW is not installed, we need to record any prefetches
// that happen so we can then add them to SW cache once installed
prefetchedPathnames.push(path);}else{var resources=getResourceURLsForPathname(path);serviceWorker.controller.postMessage({gatsbyApi:"setPathResources",path:path,resources:resources});}}}exports.onRouteUpdate=function(_ref2){var location=_ref2.location,getResourceURLsForPathname=_ref2.getResourceURLsForPathname;var pathname=location.pathname.replace("/ucanlanding","");setPathResources(pathname,getResourceURLsForPathname);if("serviceWorker"in navigator&&navigator.serviceWorker.controller!==null){navigator.serviceWorker.controller.postMessage({gatsbyApi:"enableOfflineShell"});}};exports.onPostPrefetchPathname=function(_ref3){var pathname=_ref3.pathname,getResourceURLsForPathname=_ref3.getResourceURLsForPathname;setPathResources(pathname,getResourceURLsForPathname);};

/***/ }),

/***/ "Cs9m":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("o3C2");
var step = __webpack_require__("TTxG");
var Iterators = __webpack_require__("N9zW");
var toIObject = __webpack_require__("T/1i");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("gMWQ")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "CsEj":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _xfBase = __webpack_require__("K8HH");

module.exports = function () {
  function XDrop(n, xf) {
    this.xf = xf;
    this.n = n;
  }

  XDrop.prototype['@@transducer/init'] = _xfBase.init;
  XDrop.prototype['@@transducer/result'] = _xfBase.result;

  XDrop.prototype['@@transducer/step'] = function (result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }

    return this.xf['@@transducer/step'](result, input);
  };

  return _curry2(function _xdrop(n, xf) {
    return new XDrop(n, xf);
  });
}();

/***/ }),

/***/ "CxZ5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("GkPX");

__webpack_require__("K/PF");

__webpack_require__("75LO");

__webpack_require__("V7cS");

__webpack_require__("+3V6");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

__webpack_require__("W1QL");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _classnames = _interopRequireDefault(__webpack_require__("8Jek"));

var _IconBase = _interopRequireDefault(__webpack_require__("SfRV"));

var _twoTonePrimaryColor = __webpack_require__("4T8+");

var _utils = __webpack_require__("OgXt");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
} // Initial setting
// should move it to antd main repo?


(0, _twoTonePrimaryColor.setTwoToneColor)('#1890ff');

var Icon = _react["default"].forwardRef(function (props, ref) {
  var className = props.className,
      icon = props.icon,
      spin = props.spin,
      rotate = props.rotate,
      tabIndex = props.tabIndex,
      onClick = props.onClick,
      twoToneColor = props.twoToneColor,
      restProps = _objectWithoutProperties(props, ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"]);

  var classString = (0, _classnames["default"])('anticon', _defineProperty({}, "anticon-".concat(icon.name), Boolean(icon.name)), className);
  var svgClassString = (0, _classnames["default"])({
    'anticon-spin': !!spin || icon.name === 'loading'
  });
  var iconTabIndex = tabIndex;

  if (iconTabIndex === undefined && onClick) {
    iconTabIndex = -1;
  }

  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : undefined;

  var _normalizeTwoToneColo = (0, _utils.normalizeTwoToneColors)(twoToneColor),
      _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
      primaryColor = _normalizeTwoToneColo2[0],
      secondaryColor = _normalizeTwoToneColo2[1];

  return _react["default"].createElement("span", Object.assign({
    role: "img",
    "aria-label": icon.name
  }, restProps, {
    ref: ref,
    tabIndex: iconTabIndex,
    onClick: onClick,
    className: classString
  }), _react["default"].createElement(_IconBase["default"], {
    className: svgClassString,
    icon: icon,
    primaryColor: primaryColor,
    secondaryColor: secondaryColor,
    style: svgStyle
  }));
});

Icon.displayName = 'AntdIcon';
Icon.getTwoToneColor = _twoTonePrimaryColor.getTwoToneColor;
Icon.setTwoToneColor = _twoTonePrimaryColor.setTwoToneColor;
var _default = Icon;
exports["default"] = _default;

/***/ }),

/***/ "CyNN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Dependencies

__webpack_require__("Z8gF");

__webpack_require__("asZ9");

var parseUrl = __webpack_require__("W2ws"),
    isSsh = __webpack_require__("2agF");
/**
 * gitUp
 * Parses the input url.
 *
 * @name gitUp
 * @function
 * @param {String} input The input url.
 * @return {Object} An object containing the following fields:
 *
 *  - `protocols` (Array): An array with the url protocols (usually it has one element).
 *  - `port` (null|Number): The domain port.
 *  - `resource` (String): The url domain (including subdomains).
 *  - `user` (String): The authentication user (usually for ssh urls).
 *  - `pathname` (String): The url pathname.
 *  - `hash` (String): The url hash.
 *  - `search` (String): The url querystring value.
 *  - `href` (String): The input url.
 *  - `protocol` (String): The git url protocol.
 *  - `token` (String): The oauth token (could appear in the https urls).
 */


function gitUp(input) {
  var output = parseUrl(input);
  output.token = "";
  var splits = output.user.split(":");

  if (splits.length === 2) {
    if (splits[1] === "x-oauth-basic") {
      output.token = splits[0];
    } else if (splits[0] === "x-token-auth") {
      output.token = splits[1];
    }
  }

  if (isSsh(output.protocols) || isSsh(input)) {
    output.protocol = "ssh";
  } else if (output.protocols.length) {
    output.protocol = output.protocols[0];
  } else {
    output.protocol = "file";
  }

  output.href = output.href.replace(/\/$/, "");
  return output;
}

module.exports = gitUp;

/***/ }),

/***/ "DGR3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-properties.js
var es6_object_define_properties = __webpack_require__("6/FK");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("2Tod");

// EXTERNAL MODULE: ../node_modules/rc-trigger/es/index.js + 11 modules
var es = __webpack_require__("mPTt");

// CONCATENATED MODULE: ../node_modules/rc-tooltip/es/placements.js
var placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  right: {
    points: ['cl', 'cr'],
    overflow: placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  }
};
/* harmony default export */ var es_placements = (placements);
// CONCATENATED MODULE: ../node_modules/rc-tooltip/es/Content.js


var Content_Content = function Content(props) {
  var overlay = props.overlay,
      prefixCls = props.prefixCls,
      id = props.id;
  return react_default.a.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    id: id,
    role: "tooltip"
  }, typeof overlay === 'function' ? overlay() : overlay);
};

/* harmony default export */ var es_Content = (Content_Content);
// CONCATENATED MODULE: ../node_modules/rc-tooltip/es/Tooltip.js













function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}






var Tooltip_Tooltip = function Tooltip(props, ref) {
  var overlayClassName = props.overlayClassName,
      _props$trigger = props.trigger,
      trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
      _props$mouseEnterDela = props.mouseEnterDelay,
      mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela,
      _props$mouseLeaveDela = props.mouseLeaveDelay,
      mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela,
      overlayStyle = props.overlayStyle,
      _props$prefixCls = props.prefixCls,
      prefixCls = _props$prefixCls === void 0 ? 'rc-tooltip' : _props$prefixCls,
      children = props.children,
      onVisibleChange = props.onVisibleChange,
      afterVisibleChange = props.afterVisibleChange,
      transitionName = props.transitionName,
      animation = props.animation,
      _props$placement = props.placement,
      placement = _props$placement === void 0 ? 'right' : _props$placement,
      _props$align = props.align,
      align = _props$align === void 0 ? {} : _props$align,
      _props$destroyTooltip = props.destroyTooltipOnHide,
      destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip,
      defaultVisible = props.defaultVisible,
      getTooltipContainer = props.getTooltipContainer,
      restProps = _objectWithoutProperties(props, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer"]);

  var domRef = Object(react["useRef"])(null);
  Object(react["useImperativeHandle"])(ref, function () {
    return domRef.current;
  });

  var extraProps = _objectSpread({}, restProps);

  if ('visible' in props) {
    extraProps.popupVisible = props.visible;
  }

  var getPopupElement = function getPopupElement() {
    var _props$arrowContent = props.arrowContent,
        arrowContent = _props$arrowContent === void 0 ? null : _props$arrowContent,
        overlay = props.overlay,
        id = props.id;
    return [react_default.a.createElement("div", {
      className: "".concat(prefixCls, "-arrow"),
      key: "arrow"
    }, arrowContent), react_default.a.createElement(es_Content, {
      key: "content",
      prefixCls: prefixCls,
      id: id,
      overlay: overlay
    })];
  };

  return react_default.a.createElement(es["a" /* default */], Object.assign({
    popupClassName: overlayClassName,
    prefixCls: prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: placements,
    popupPlacement: placement,
    ref: domRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    defaultPopupVisible: defaultVisible,
    destroyPopupOnHide: destroyTooltipOnHide,
    mouseLeaveDelay: mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay: mouseEnterDelay
  }, extraProps), children);
};

/* harmony default export */ var es_Tooltip = (Object(react["forwardRef"])(Tooltip_Tooltip));
// CONCATENATED MODULE: ../node_modules/rc-tooltip/es/index.js

/* harmony default export */ var rc_tooltip_es = (es_Tooltip);
// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// CONCATENATED MODULE: ../node_modules/antd/es/tooltip/placements.js







function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}


var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var placements_targetOffset = [0, 0];
function getOverflowOptions(autoAdjustOverflow) {
  if (typeof autoAdjustOverflow === 'boolean') {
    return autoAdjustOverflow ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }

  return _extends(_extends({}, autoAdjustOverflowDisabled), autoAdjustOverflow);
}
function placements_getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth,
      arrowWidth = _config$arrowWidth === void 0 ? 5 : _config$arrowWidth,
      _config$horizontalArr = config.horizontalArrowShift,
      horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr,
      _config$verticalArrow = config.verticalArrowShift,
      verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow,
      autoAdjustOverflow = config.autoAdjustOverflow;
  var placementMap = {
    left: {
      points: ['cr', 'cl'],
      offset: [-4, 0]
    },
    right: {
      points: ['cl', 'cr'],
      offset: [4, 0]
    },
    top: {
      points: ['bc', 'tc'],
      offset: [0, -4]
    },
    bottom: {
      points: ['tc', 'bc'],
      offset: [0, 4]
    },
    topLeft: {
      points: ['bl', 'tc'],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ['tr', 'cl'],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ['br', 'tc'],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ['tl', 'cr'],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ['tr', 'bc'],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ['bl', 'cr'],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ['tl', 'bc'],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ['br', 'cl'],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function (key) {
    placementMap[key] = config.arrowPointAtCenter ? _extends(_extends({}, placementMap[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow),
      targetOffset: placements_targetOffset
    }) : _extends(_extends({}, placements[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow)
    });
    placementMap[key].ignoreShake = true;
  });
  return placementMap;
}
// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/context.js + 4 modules
var context = __webpack_require__("Bfez");

// CONCATENATED MODULE: ../node_modules/antd/es/tooltip/index.js














function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function tooltip_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function tooltip_extends() {
  tooltip_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return tooltip_extends.apply(this, arguments);
}







var splitObject = function splitObject(obj, keys) {
  var picked = {};

  var omitted = tooltip_extends({}, obj);

  keys.forEach(function (key) {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return {
    picked: picked,
    omitted: omitted
  };
}; // Fix Tooltip won't hide at disabled button
// mouse events don't trigger at disabled button in Chrome
// https://github.com/react-component/tooltip/issues/18


function getDisabledCompatibleChildren(element) {
  var elementType = element.type;

  if ((elementType.__ANT_BUTTON === true || elementType.__ANT_SWITCH === true || elementType.__ANT_CHECKBOX === true || element.type === 'button') && element.props.disabled) {
    // Pick some layout related style properties up to span
    // Prevent layout bugs like https://github.com/ant-design/ant-design/issues/5254
    var _splitObject = splitObject(element.props.style, ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex']),
        picked = _splitObject.picked,
        omitted = _splitObject.omitted;

    var spanStyle = tooltip_extends(tooltip_extends({
      display: 'inline-block'
    }, picked), {
      cursor: 'not-allowed',
      width: element.props.block ? '100%' : null
    });

    var buttonStyle = tooltip_extends(tooltip_extends({}, omitted), {
      pointerEvents: 'none'
    });

    var child = react["cloneElement"](element, {
      style: buttonStyle,
      className: null
    });
    return react["createElement"]("span", {
      style: spanStyle,
      className: element.props.className
    }, child);
  }

  return element;
}

var tooltip_Tooltip = /*#__PURE__*/function (_React$Component) {
  _inherits(Tooltip, _React$Component);

  function Tooltip(props) {
    var _this;

    _classCallCheck(this, Tooltip);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tooltip).call(this, props));

    _this.onVisibleChange = function (visible) {
      var onVisibleChange = _this.props.onVisibleChange;

      if (!('visible' in _this.props)) {
        _this.setState({
          visible: _this.isNoTitle() ? false : visible
        });
      }

      if (onVisibleChange && !_this.isNoTitle()) {
        onVisibleChange(visible);
      }
    };

    _this.saveTooltip = function (node) {
      _this.tooltip = node;
    }; // 动态设置动画点


    _this.onPopupAlign = function (domNode, align) {
      var placements = _this.getPlacements(); // 当前返回的位置


      var placement = Object.keys(placements).filter(function (key) {
        return placements[key].points[0] === align.points[0] && placements[key].points[1] === align.points[1];
      })[0]; // 根据当前坐标设置动画点

      var rect = domNode.getBoundingClientRect();
      var transformOrigin = {
        top: '50%',
        left: '50%'
      };

      if (placement.indexOf('top') >= 0 || placement.indexOf('Bottom') >= 0) {
        transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
      } else if (placement.indexOf('Top') >= 0 || placement.indexOf('bottom') >= 0) {
        transformOrigin.top = "".concat(-align.offset[1], "px");
      }

      if (placement.indexOf('left') >= 0 || placement.indexOf('Right') >= 0) {
        transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
      } else if (placement.indexOf('right') >= 0 || placement.indexOf('Left') >= 0) {
        transformOrigin.left = "".concat(-align.offset[0], "px");
      }

      domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
    };

    _this.renderTooltip = function (_ref) {
      var getContextPopupContainer = _ref.getPopupContainer,
          getPrefixCls = _ref.getPrefixCls,
          direction = _ref.direction;

      var _assertThisInitialize = _assertThisInitialized(_this),
          props = _assertThisInitialize.props,
          state = _assertThisInitialize.state;

      var customizePrefixCls = props.prefixCls,
          openClassName = props.openClassName,
          getPopupContainer = props.getPopupContainer,
          getTooltipContainer = props.getTooltipContainer,
          overlayClassName = props.overlayClassName;
      var children = props.children;
      var prefixCls = getPrefixCls('tooltip', customizePrefixCls);
      var visible = state.visible; // Hide tooltip when there is no title

      if (!('visible' in props) && _this.isNoTitle()) {
        visible = false;
      }

      var child = getDisabledCompatibleChildren(react["isValidElement"](children) ? children : react["createElement"]("span", null, children));
      var childProps = child.props;
      var childCls = classnames_default()(childProps.className, tooltip_defineProperty({}, openClassName || "".concat(prefixCls, "-open"), true));
      var customOverlayClassName = classnames_default()(overlayClassName, tooltip_defineProperty({}, "".concat(prefixCls, "-rtl"), direction === 'rtl'));
      return react["createElement"](rc_tooltip_es, tooltip_extends({}, _this.props, {
        prefixCls: prefixCls,
        overlayClassName: customOverlayClassName,
        getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
        ref: _this.saveTooltip,
        builtinPlacements: _this.getPlacements(),
        overlay: _this.getOverlay(),
        visible: visible,
        onVisibleChange: _this.onVisibleChange,
        onPopupAlign: _this.onPopupAlign
      }), visible ? react["cloneElement"](child, {
        className: childCls
      }) : child);
    };

    _this.state = {
      visible: !!props.visible || !!props.defaultVisible
    };
    return _this;
  }

  _createClass(Tooltip, [{
    key: "getPopupDomNode",
    value: function getPopupDomNode() {
      return this.tooltip.getPopupDomNode();
    }
  }, {
    key: "getPlacements",
    value: function getPlacements() {
      var _this$props = this.props,
          builtinPlacements = _this$props.builtinPlacements,
          arrowPointAtCenter = _this$props.arrowPointAtCenter,
          autoAdjustOverflow = _this$props.autoAdjustOverflow;
      return builtinPlacements || placements_getPlacements({
        arrowPointAtCenter: arrowPointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow
      });
    }
  }, {
    key: "isNoTitle",
    value: function isNoTitle() {
      var _this$props2 = this.props,
          title = _this$props2.title,
          overlay = _this$props2.overlay;
      return !title && !overlay && title !== 0; // overlay for old version compatibility
    }
  }, {
    key: "getOverlay",
    value: function getOverlay() {
      var _this$props3 = this.props,
          title = _this$props3.title,
          overlay = _this$props3.overlay;

      if (title === 0) {
        return title;
      }

      return overlay || title || '';
    }
  }, {
    key: "render",
    value: function render() {
      return react["createElement"](context["a" /* ConfigConsumer */], null, this.renderTooltip);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps) {
      if ('visible' in nextProps) {
        return {
          visible: nextProps.visible
        };
      }

      return null;
    }
  }]);

  return Tooltip;
}(react["Component"]);

tooltip_Tooltip.defaultProps = {
  placement: 'top',
  transitionName: 'zoom-big-fast',
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: false,
  autoAdjustOverflow: true
};
/* harmony default export */ var tooltip = __webpack_exports__["a"] = (tooltip_Tooltip);

/***/ }),

/***/ "DbwS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("wEu9");
var global = __webpack_require__("P56o");
var ctx = __webpack_require__("9liC");
var classof = __webpack_require__("OFVL");
var $export = __webpack_require__("X6VK");
var isObject = __webpack_require__("Bsg+");
var aFunction = __webpack_require__("b8Rm");
var anInstance = __webpack_require__("EusA");
var forOf = __webpack_require__("HqX2");
var speciesConstructor = __webpack_require__("5Fu2");
var task = __webpack_require__("5BMI").set;
var microtask = __webpack_require__("XDzM")();
var newPromiseCapabilityModule = __webpack_require__("gtO+");
var perform = __webpack_require__("Yvte");
var userAgent = __webpack_require__("ROCd");
var promiseResolve = __webpack_require__("khIB");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__("9dxi")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__("+edc")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__("jPEw")($Promise, PROMISE);
__webpack_require__("E8p1")(PROMISE);
Wrapper = __webpack_require__("R5TD")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__("zlqh")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "Dhml":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("P56o");
var DESCRIPTORS = __webpack_require__("GGqZ");
var LIBRARY = __webpack_require__("wEu9");
var $typed = __webpack_require__("tW8y");
var hide = __webpack_require__("tjmq");
var redefineAll = __webpack_require__("+edc");
var fails = __webpack_require__("E7Vc");
var anInstance = __webpack_require__("EusA");
var toInteger = __webpack_require__("mvii");
var toLength = __webpack_require__("Sp5b");
var toIndex = __webpack_require__("GdbT");
var gOPN = __webpack_require__("zIds").f;
var dP = __webpack_require__("U1KF").f;
var arrayFill = __webpack_require__("Pfmf");
var setToStringTag = __webpack_require__("jPEw");
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "Dhpq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _default = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

exports["default"] = _default;
module.exports = exports["default"];

/***/ }),

/***/ "Dkg+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__("wv3L");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3["default"])(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),

/***/ "Dln1":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9p7t");

__webpack_require__("U8p0");

__webpack_require__("dtzt");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("yIlq");

__webpack_require__("it7j");

__webpack_require__("Z8gF");

__webpack_require__("GkPX");

__webpack_require__("PAbq");

__webpack_require__("V7cS");

__webpack_require__("nsbO");

__webpack_require__("asZ9");

__webpack_require__("J8hF");

__webpack_require__("e2Kn");

__webpack_require__("9ovy");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .
(function (global, factory) {
   true ? module.exports = factory() : undefined;
})(this, function () {
  'use strict'; // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var userAgent = navigator.userAgent;
  var platform = navigator.platform;
  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);
  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.

  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);
  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);

  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }

  if (presto_version && presto_version >= 15) {
    presto = false;
    webkit = true;
  } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X


  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;

  function classTest(cls) {
    return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
  }

  var rmClass = function rmClass(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);

    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }

    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);

    if (className) {
      e.className = className;
    }

    if (style) {
      e.style.cssText = style;
    }

    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i = 0; i < content.length; ++i) {
        e.appendChild(content[i]);
      }
    }

    return e;
  } // wrapper for elt, which removes the elt from the accessibility tree


  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e;
  }

  var range;

  if (document.createRange) {
    range = function range(node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function range(node, start, end) {
      var r = document.body.createTextRange();

      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }

      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      {
        child = child.parentNode;
      }

    if (parent.contains) {
      return parent.contains(child);
    }

    do {
      if (child.nodeType == 11) {
        child = child.host;
      }

      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;

    try {
      activeElement = document.activeElement;
    } catch (e) {
      activeElement = document.body || null;
    }

    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
      activeElement = activeElement.shadowRoot.activeElement;
    }

    return activeElement;
  }

  function addClass(node, cls) {
    var current = node.className;

    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }

  function joinClasses(a, b) {
    var as = a.split(" ");

    for (var i = 0; i < as.length; i++) {
      if (as[i] && !classTest(as[i]).test(b)) {
        b += " " + as[i];
      }
    }

    return b;
  }

  var selectInput = function selectInput(node) {
    node.select();
  };

  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    {
      selectInput = function selectInput(node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie) // Suppress mysterious IE10 errors
    {
      selectInput = function selectInput(node) {
        try {
          node.select();
        } catch (_e) {}
      };
    }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }

  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }

    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
        target[prop] = obj[prop];
      }
    }

    return target;
  } // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.


  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);

      if (end == -1) {
        end = string.length;
      }
    }

    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);

      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i);
      }

      n += nextTab - i;
      n += tabSize - n % tabSize;
      i = nextTab + 1;
    }
  }

  var Delayed = function Delayed() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };

  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;

    if (self.time <= +new Date()) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date());
    }
  };

  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date() + ms;

    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i) {
      if (array[i] == elt) {
        return i;
      }
    }

    return -1;
  } // Number of pixels added to scroller and sizer to hide scrollbar


  var scrollerGap = 30; // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.

  var Pass = {
    toString: function toString() {
      return "CodeMirror.Pass";
    }
  }; // Reused option objects for setSelection & friends

  var sel_dontScroll = {
    scroll: false
  },
      sel_mouse = {
    origin: "*mouse"
  },
      sel_move = {
    origin: "+move"
  }; // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.

  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);

      if (nextTab == -1) {
        nextTab = string.length;
      }

      var skipped = nextTab - pos;

      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }

      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;

      if (col >= goal) {
        return pos;
      }
    }
  }

  var spaceStrs = [""];

  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }

    return spaceStrs[n];
  }

  function lst(arr) {
    return arr[arr.length - 1];
  }

  function map(array, f) {
    var out = [];

    for (var i = 0; i < array.length; i++) {
      out[i] = f(array[i], i);
    }

    return out;
  }

  function insertSorted(array, value, score) {
    var pos = 0,
        priority = score(value);

    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }

    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;

    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }

    if (props) {
      copyObj(props, inst);
    }

    return inst;
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }

  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }

    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }

    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }

    return true;
  } // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.


  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.


  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
      pos += dir;
    }

    return pos;
  } // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.


  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;

    for (;;) {
      if (from == to) {
        return from;
      }

      var midF = (from + to) / 2,
          mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);

      if (mid == from) {
        return pred(mid) ? from : to;
      }

      if (pred(mid)) {
        to = mid;
      } else {
        from = mid + dir;
      }
    }
  } // BIDI HELPERS


  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr", 0);
    }

    var found = false;

    for (var i = 0; i < order.length; ++i) {
      var part = order[i];

      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }

    if (!found) {
      f(from, to, "ltr");
    }
  }

  var bidiOther = null;

  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;

    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];

      if (cur.from < ch && cur.to > ch) {
        return i;
      }

      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }

      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
    }

    return found != null ? found : bidiOther;
  } // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.
  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals
  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.


  var bidiOrdering = function () {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"; // Character types for codepoints 0x600 to 0x6f9

    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

    function charType(code) {
      if (code <= 0xf7) {
        return lowTypes.charAt(code);
      } else if (0x590 <= code && code <= 0x5f4) {
        return "R";
      } else if (0x600 <= code && code <= 0x6f9) {
        return arabicTypes.charAt(code - 0x600);
      } else if (0x6ee <= code && code <= 0x8ac) {
        return "r";
      } else if (0x2000 <= code && code <= 0x200b) {
        return "w";
      } else if (code == 0x200c) {
        return "b";
      } else {
        return "L";
      }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/,
        isStrong = /[LRr]/,
        countsAsLeft = /[Lb1n]/,
        countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;
      this.to = to;
    }

    return function (str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
        return false;
      }

      var len = str.length,
          types = [];

      for (var i = 0; i < len; ++i) {
        types.push(charType(str.charCodeAt(i)));
      } // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.


      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];

        if (type == "m") {
          types[i$1] = prev;
        } else {
          prev = type;
        }
      } // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.


      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];

        if (type$1 == "1" && cur == "r") {
          types[i$2] = "n";
        } else if (isStrong.test(type$1)) {
          cur = type$1;

          if (type$1 == "r") {
            types[i$2] = "R";
          }
        }
      } // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.


      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];

        if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
          types[i$3] = "1";
        } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
          types[i$3] = prev$1;
        }

        prev$1 = type$2;
      } // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.


      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];

        if (type$3 == ",") {
          types[i$4] = "N";
        } else if (type$3 == "%") {
          var end = void 0;

          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}

          var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";

          for (var j = i$4; j < end; ++j) {
            types[j] = replace;
          }

          i$4 = end - 1;
        }
      } // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.


      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];

        if (cur$1 == "L" && type$4 == "1") {
          types[i$5] = "L";
        } else if (isStrong.test(type$4)) {
          cur$1 = type$4;
        }
      } // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.


      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = void 0;

          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}

          var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? before ? "L" : "R" : outerType;

          for (var j$1 = i$6; j$1 < end$1; ++j$1) {
            types[j$1] = replace$1;
          }

          i$6 = end$1 - 1;
        }
      } // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.


      var order = [],
          m;

      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;

          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}

          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7,
              at = order.length,
              isRTL = direction == "rtl" ? 1 : 0;

          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}

          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j$2));
                at += isRTL;
              }

              var nstart = j$2;

              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}

              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else {
              ++j$2;
            }
          }

          if (pos < i$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i$7));
          }
        }
      }

      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }

        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order;
    };
  }(); // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.


  function getOrder(line, direction) {
    var order = line.order;

    if (order == null) {
      order = line.order = bidiOrdering(line.text, direction);
    }

    return order;
  } // EVENT HANDLING
  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.


  var noHandlers = [];

  var on = function on(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers;
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers,
          arr = map && map[type];

      if (arr) {
        var index = indexOf(arr, f);

        if (index > -1) {
          map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }

  function signal(emitter, type
  /*, values...*/
  ) {
    var handlers = getHandlers(emitter, type);

    if (!handlers.length) {
      return;
    }

    var args = Array.prototype.slice.call(arguments, 2);

    for (var i = 0; i < handlers.length; ++i) {
      handlers[i].apply(null, args);
    }
  } // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.


  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = {
        type: e,
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
        }
      };
    }

    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;

    if (!arr) {
      return;
    }

    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);

    for (var i = 0; i < arr.length; ++i) {
      if (indexOf(set, arr[i]) == -1) {
        set.push(arr[i]);
      }
    }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0;
  } // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.


  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };

    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  } // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.


  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }

  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }

  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }

  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }

  function e_target(e) {
    return e.target || e.srcElement;
  }

  function e_button(e) {
    var b = e.which;

    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }

    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }

    return b;
  } // Detect drag-and-drop


  var dragAndDrop = function () {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) {
      return false;
    }

    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;

  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200B");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));

      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }

    var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  } // Feature-detect IE's crummy client rect reporting for bidi text


  var badBidiRects;

  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }

    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);

    if (!r0 || r0.left == r0.right) {
      return false;
    } // Safari returns null in some cases (#2780)


    return badBidiRects = r1.right - r0.right < 3;
  } // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.


  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0,
        result = [],
        l = string.length;

    while (pos <= l) {
      var nl = string.indexOf("\n", pos);

      if (nl == -1) {
        nl = string.length;
      }

      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");

      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }

    return result;
  } : function (string) {
    return string.split(/\r\n?|\n/);
  };
  var hasSelection = window.getSelection ? function (te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function (te) {
    var range;

    try {
      range = te.ownerDocument.selection.createRange();
    } catch (e) {}

    if (!range || range.parentElement() != te) {
      return false;
    }

    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = function () {
    var e = elt("div");

    if ("oncopy" in e) {
      return true;
    }

    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();

  var badZoomedRects = null;

  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }

    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  } // Known modes, by name and by MIME


  var modes = {},
      mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)

  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }

    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  } // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.


  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];

      if (typeof found == "string") {
        found = {
          name: found
        };
      }

      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json");
    }

    if (typeof spec == "string") {
      return {
        name: spec
      };
    } else {
      return spec || {
        name: "null"
      };
    }
  } // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.


  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];

    if (!mfactory) {
      return getMode(options, "text/plain");
    }

    var modeObj = mfactory(options, spec);

    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];

      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) {
          continue;
        }

        if (modeObj.hasOwnProperty(prop)) {
          modeObj["_" + prop] = modeObj[prop];
        }

        modeObj[prop] = exts[prop];
      }
    }

    modeObj.name = spec.name;

    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }

    if (spec.modeProps) {
      for (var prop$1 in spec.modeProps) {
        modeObj[prop$1] = spec.modeProps[prop$1];
      }
    }

    return modeObj;
  } // This can be used to attach properties to mode objects from
  // outside the actual mode definition.


  var modeExtensions = {};

  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) {
      return state;
    }

    if (mode.copyState) {
      return mode.copyState(state);
    }

    var nstate = {};

    for (var n in state) {
      var val = state[n];

      if (val instanceof Array) {
        val = val.concat([]);
      }

      nstate[n] = val;
    }

    return nstate;
  } // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.


  function innerMode(mode, state) {
    var info;

    while (mode.innerMode) {
      info = mode.innerMode(state);

      if (!info || info.mode == mode) {
        break;
      }

      state = info.state;
      mode = info.mode;
    }

    return info || {
      mode: mode,
      state: state
    };
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  } // STRING STREAM
  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.


  var StringStream = function StringStream(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {
    return this.pos >= this.string.length;
  };

  StringStream.prototype.sol = function () {
    return this.pos == this.lineStart;
  };

  StringStream.prototype.peek = function () {
    return this.string.charAt(this.pos) || undefined;
  };

  StringStream.prototype.next = function () {
    if (this.pos < this.string.length) {
      return this.string.charAt(this.pos++);
    }
  };

  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;

    if (typeof match == "string") {
      ok = ch == match;
    } else {
      ok = ch && (match.test ? match.test(ch) : match(ch));
    }

    if (ok) {
      ++this.pos;
      return ch;
    }
  };

  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;

    while (this.eat(match)) {}

    return this.pos > start;
  };

  StringStream.prototype.eatSpace = function () {
    var start = this.pos;

    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
      ++this.pos;
    }

    return this.pos > start;
  };

  StringStream.prototype.skipToEnd = function () {
    this.pos = this.string.length;
  };

  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);

    if (found > -1) {
      this.pos = found;
      return true;
    }
  };

  StringStream.prototype.backUp = function (n) {
    this.pos -= n;
  };

  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }

    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };

  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };

  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function cased(str) {
        return caseInsensitive ? str.toLowerCase() : str;
      };

      var substr = this.string.substr(this.pos, pattern.length);

      if (cased(substr) == cased(pattern)) {
        if (consume !== false) {
          this.pos += pattern.length;
        }

        return true;
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);

      if (match && match.index > 0) {
        return null;
      }

      if (match && consume !== false) {
        this.pos += match[0].length;
      }

      return match;
    }
  };

  StringStream.prototype.current = function () {
    return this.string.slice(this.start, this.pos);
  };

  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;

    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  };

  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  };

  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  }; // Find the line object corresponding to the given line number.


  function getLine(doc, n) {
    n -= doc.first;

    if (n < 0 || n >= doc.size) {
      throw new Error("There is no line " + (n + doc.first) + " in the document.");
    }

    var chunk = doc;

    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i],
            sz = child.chunkSize();

        if (n < sz) {
          chunk = child;
          break;
        }

        n -= sz;
      }
    }

    return chunk.lines[n];
  } // Get the part of a document between two positions, as an array of
  // strings.


  function getBetween(doc, start, end) {
    var out = [],
        n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;

      if (n == end.line) {
        text = text.slice(0, end.ch);
      }

      if (n == start.line) {
        text = text.slice(start.ch);
      }

      out.push(text);
      ++n;
    });
    return out;
  } // Get the lines between from and to, as array of strings.


  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    }); // iter aborts when callback returns truthy value

    return out;
  } // Update the height of a line, propagating the height change
  // upwards to parent nodes.


  function updateLineHeight(line, height) {
    var diff = height - line.height;

    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  } // Given a line object, find its line number by walking up through
  // its parent links.


  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }

    var cur = line.parent,
        no = indexOf(cur.lines, line);

    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) {
          break;
        }

        no += chunk.children[i].chunkSize();
      }
    }

    return no + cur.first;
  } // Find the line at the given vertical position, using the height
  // information in the document tree.


  function _lineAtHeight(chunk, h) {
    var n = chunk.first;

    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1],
            ch = child.height;

        if (h < ch) {
          chunk = child;
          continue outer;
        }

        h -= ch;
        n += child.chunkSize();
      }

      return n;
    } while (!chunk.lines);

    var i = 0;

    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i],
          lh = line.height;

      if (h < lh) {
        break;
      }

      h -= lh;
    }

    return n + i;
  }

  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  } // A Pos instance represents a position within the text.


  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;

    if (!(this instanceof Pos)) {
      return new Pos(line, ch, sticky);
    }

    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  } // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.


  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }

  function equalCursorPos(a, b) {
    return a.sticky == b.sticky && cmp(a, b) == 0;
  }

  function copyPos(x) {
    return Pos(x.line, x.ch);
  }

  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }

  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  } // Most of the external API clips given positions to make sure they
  // actually exist within the document.


  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }

  function _clipPos(doc, pos) {
    if (pos.line < doc.first) {
      return Pos(doc.first, 0);
    }

    var last = doc.first + doc.size - 1;

    if (pos.line > last) {
      return Pos(last, getLine(doc, last).text.length);
    }

    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }

  function clipToLen(pos, linelen) {
    var ch = pos.ch;

    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }

  function clipPosArray(doc, array) {
    var out = [];

    for (var i = 0; i < array.length; i++) {
      out[i] = _clipPos(doc, array[i]);
    }

    return out;
  }

  var SavedContext = function SavedContext(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function Context(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);

    if (line != null && n > this.maxLookAhead) {
      this.maxLookAhead = n;
    }

    return line;
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) {
      return null;
    }

    while (this.baseTokens[this.baseTokenPos] <= n) {
      this.baseTokenPos += 2;
    }

    var type = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type && type.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    };
  };

  Context.prototype.nextLine = function () {
    this.line++;

    if (this.maxLookAhead > 0) {
      this.maxLookAhead--;
    }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext) {
      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
    } else {
      return new Context(doc, copyState(doc.mode, saved), line);
    }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  }; // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.


  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen],
        lineClasses = {}; // Compute the base array of styles

    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
      return st.push(end, style);
    }, lineClasses, forceToEnd);
    var state = context.state; // Run overlays, adjust style array.

    var loop = function loop(o) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o],
          i = 1,
          at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i; // Ensure there's a token end at the current position, and that i points at it

        while (at < end) {
          var i_end = st[i];

          if (i_end > end) {
            st.splice(i, 1, end, st[i + 1], i_end);
          }

          i += 2;
          at = Math.min(end, i_end);
        }

        if (!style) {
          return;
        }

        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) {
      loop(o);
    }

    return {
      styles: st,
      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
    };
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);

      if (resetState) {
        context.state = resetState;
      }

      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;

      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }

      if (updateFrontier === cm.doc.highlightFrontier) {
        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
      }
    }

    return line.styles;
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc,
        display = cm.display;

    if (!doc.mode.startState) {
      return new Context(doc, true, n);
    }

    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });

    if (precise) {
      doc.modeFrontier = context.line;
    }

    return context;
  } // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.


  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;

    if (text == "") {
      callBlankLine(mode, context.state);
    }

    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }

    if (!mode.innerMode) {
      return;
    }

    var inner = innerMode(mode, state);

    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }

      var style = mode.token(stream, state);

      if (stream.pos > stream.start) {
        return style;
      }
    }

    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  var Token = function Token(stream, type, state) {
    this.start = stream.start;
    this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  }; // Utility for getTokenAt and getLineTokens


  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc,
        mode = doc.mode,
        style;
    pos = _clipPos(doc, pos);
    var line = getLine(doc, pos.line),
        context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context),
        tokens;

    if (asArray) {
      tokens = [];
    }

    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);

      if (asArray) {
        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
      }
    }

    return asArray ? tokens : new Token(stream, style, context.state);
  }

  function extractLineClasses(type, output) {
    if (type) {
      for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);

        if (!lineClass) {
          break;
        }

        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";

        if (output[prop] == null) {
          output[prop] = lineClass[2];
        } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
          output[prop] += " " + lineClass[2];
        }
      }
    }

    return type;
  } // Run the given mode's parser over a line, calling f for each token.


  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;

    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }

    var curStart = 0,
        curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context),
        style;
    var inner = cm.options.addModeClass && [null];

    if (text == "") {
      extractLineClasses(callBlankLine(mode, context.state), lineClasses);
    }

    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;

        if (forceToEnd) {
          processLine(cm, text, context, stream.pos);
        }

        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }

      if (inner) {
        var mName = inner[0].name;

        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }

      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }

        curStyle = style;
      }

      stream.start = stream.pos;
    }

    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  } // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.


  function findStartLine(cm, n, precise) {
    var minindent,
        minline,
        doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);

    for (var search = n; search > lim; --search) {
      if (search <= doc.first) {
        return doc.first;
      }

      var line = getLine(doc, search - 1),
          after = line.stateAfter;

      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
        return search;
      }

      var indented = countColumn(line.text, null, cm.options.tabSize);

      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }

    return minline;
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);

    if (doc.highlightFrontier < n - 10) {
      return;
    }

    var start = doc.first;

    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter; // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this

      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break;
      }
    }

    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  } // Optimize some code when these features are not used.


  var sawReadOnlySpans = false,
      sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  } // TEXTMARKER SPANS


  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;
    this.to = to;
  } // Search an array of spans for a span matching the given marker.


  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];

        if (span.marker == marker) {
          return span;
        }
      }
    }
  } // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).


  function removeMarkedSpan(spans, span) {
    var r;

    for (var i = 0; i < spans.length; ++i) {
      if (spans[i] != span) {
        (r || (r = [])).push(spans[i]);
      }
    }

    return r;
  } // Add a span to a line.


  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  } // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).


  function markedSpansBefore(old, startCh, isInsert) {
    var nw;

    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);

        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }

    return nw;
  }

  function markedSpansAfter(old, endCh, isInsert) {
    var nw;

    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);

        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
        }
      }
    }

    return nw;
  } // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.


  function stretchSpansOverChange(doc, change) {
    if (change.full) {
      return null;
    }

    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;

    if (!oldFirst && !oldLast) {
      return null;
    }

    var startCh = change.from.ch,
        endCh = change.to.ch,
        isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides

    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends

    var sameLine = change.text.length == 1,
        offset = lst(change.text).length + (sameLine ? startCh : 0);

    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];

        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);

          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }

    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];

        if (span$1.to != null) {
          span$1.to += offset;
        }

        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);

          if (!found$1) {
            span$1.from = offset;

            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        } else {
          span$1.from += offset;

          if (sameLine) {
            (first || (first = [])).push(span$1);
          }
        }
      }
    } // Make sure we didn't create any zero-length spans


    if (first) {
      first = clearEmptySpans(first);
    }

    if (last && last != first) {
      last = clearEmptySpans(last);
    }

    var newMarkers = [first];

    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2,
          gapMarkers;

      if (gap > 0 && first) {
        for (var i$2 = 0; i$2 < first.length; ++i$2) {
          if (first[i$2].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
          }
        }
      }

      for (var i$3 = 0; i$3 < gap; ++i$3) {
        newMarkers.push(gapMarkers);
      }

      newMarkers.push(last);
    }

    return newMarkers;
  } // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.


  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];

      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i--, 1);
      }
    }

    if (!spans.length) {
      return null;
    }

    return spans;
  } // Used to 'clip' out readOnly ranges when making a change.


  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;

          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });

    if (!markers) {
      return null;
    }

    var parts = [{
      from: from,
      to: to
    }];

    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i],
          m = mk.find(0);

      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];

        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }

        var newParts = [j, 1],
            dfrom = cmp(p.from, m.from),
            dto = cmp(p.to, m.to);

        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({
            from: p.from,
            to: m.from
          });
        }

        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({
            from: m.to,
            to: p.to
          });
        }

        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }

    return parts;
  } // Connect or disconnect spans from a line.


  function detachMarkedSpans(line) {
    var spans = line.markedSpans;

    if (!spans) {
      return;
    }

    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.detachLine(line);
    }

    line.markedSpans = null;
  }

  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }

    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.attachLine(line);
    }

    line.markedSpans = spans;
  } // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.


  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }

  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  } // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.


  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;

    if (lenDiff != 0) {
      return lenDiff;
    }

    var aPos = a.find(),
        bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);

    if (fromCmp) {
      return -fromCmp;
    }

    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);

    if (toCmp) {
      return toCmp;
    }

    return b.id - a.id;
  } // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.


  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans,
        found;

    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];

        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }

    return found;
  }

  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }

  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans,
        found;

    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];

        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }

    return found;
  } // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.


  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;

    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];

        if (!sp.marker.collapsed) {
          continue;
        }

        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);

        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }

        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  } // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).


  function visualLine(line) {
    var merged;

    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }

    return line;
  }

  function visualLineEnd(line) {
    var merged;

    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }

    return line;
  } // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.


  function visualLineContinued(line) {
    var merged, lines;

    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }

    return lines;
  } // Get the line number of the start of the visual line that the
  // given line number is part of.


  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN),
        vis = visualLine(line);

    if (line == vis) {
      return lineN;
    }

    return lineNo(vis);
  } // Get the line number of the start of the next visual line after
  // the given line.


  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) {
      return lineN;
    }

    var line = getLine(doc, lineN),
        merged;

    if (!lineIsHidden(doc, line)) {
      return lineN;
    }

    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }

    return lineNo(line) + 1;
  } // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.


  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;

    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];

        if (!sp.marker.collapsed) {
          continue;
        }

        if (sp.from == null) {
          return true;
        }

        if (sp.marker.widgetNode) {
          continue;
        }

        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
  }

  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }

    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }

    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];

      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
        return true;
      }
    }
  } // Find the height above the given line.


  function _heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);
    var h = 0,
        chunk = lineObj.parent;

    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];

      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }

    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];

        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }

    return h;
  } // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.


  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }

    var len = line.text.length,
        merged,
        cur = line;

    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }

    cur = line;

    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }

    return len;
  } // Find the longest line in the document.


  function findMaxLine(cm) {
    var d = cm.display,
        doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);

      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  } // LINE DATA STRUCTURE
  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).


  var Line = function Line(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () {
    return lineNo(this);
  };

  eventMixin(Line); // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.

  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;

    if (line.stateAfter) {
      line.stateAfter = null;
    }

    if (line.styles) {
      line.styles = null;
    }

    if (line.order != null) {
      line.order = null;
    }

    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;

    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  } // Detach a line from the document tree and its markers.


  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  } // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.


  var styleToClassCache = {},
      styleToClassCacheWithMode = {};

  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) {
      return null;
    }

    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
  } // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.


  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {
      pre: eltP("pre", [content], "CodeMirror-line"),
      content: content,
      col: 0,
      pos: 0,
      cm: cm,
      trailingSpace: false,
      splitSpaces: cm.getOption("lineWrapping")
    };
    lineView.measure = {}; // Iterate over the logical lines that make up this visual line.

    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line,
          order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.

      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }

      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));

      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }

        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      } // Ensure at least a single node is present, for measuring.


      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      } // Store the map and a cache object for the current logical line


      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    } // See issue #2901


    if (webkit) {
      var last = builder.content.lastChild;

      if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);

    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  } // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.


  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) {
      return;
    }

    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars,
        mustWrap = false;
    var content;

    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);

      if (ie && ie_version < 9) {
        mustWrap = true;
      }

      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;

      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;

        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));

          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }

          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }

        if (!m) {
          break;
        }

        pos += skipped + 1;
        var txt$1 = void 0;

        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize,
              tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);

          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt$1]));
          } else {
            content.appendChild(txt$1);
          }

          builder.col += 1;
        }

        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }

    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;

    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";

      if (startStyle) {
        fullStyle += startStyle;
      }

      if (endStyle) {
        fullStyle += endStyle;
      }

      var token = elt("span", [content], fullStyle, css);

      if (attributes) {
        for (var attr in attributes) {
          if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
            token.setAttribute(attr, attributes[attr]);
          }
        }
      }

      return builder.content.appendChild(token);
    }

    builder.content.appendChild(content);
  } // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).


  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }

    var spaceBefore = trailingBefore,
        result = "";

    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);

      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
        ch = "\xA0";
      }

      result += ch;
      spaceBefore = ch == " ";
    }

    return result;
  } // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.


  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos,
          end = start + text.length;

      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = void 0;

        for (var i = 0; i < order.length; i++) {
          part = order[i];

          if (part.to > start && part.from <= start) {
            break;
          }
        }

        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, css, attributes);
        }

        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;

    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }

    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }

      widget.setAttribute("cm-marker", marker.id);
    }

    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }

    builder.pos += size;
    builder.trailingSpace = false;
  } // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.


  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans,
        allText = line.text,
        at = 0;

    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
      }

      return;
    }

    var len = allText.length,
        pos = 0,
        i = 1,
        text = "",
        style,
        css;
    var nextChange = 0,
        spanStyle,
        spanEndStyle,
        spanStartStyle,
        collapsed,
        attributes;

    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null;
        nextChange = Infinity;
        var foundBookmarks = [],
            endStyles = void 0;

        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j],
              m = sp.marker;

          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }

            if (m.className) {
              spanStyle += " " + m.className;
            }

            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }

            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }

            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            } // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673


            if (m.title) {
              (attributes || (attributes = {})).title = m.title;
            }

            if (m.attributes) {
              for (var attr in m.attributes) {
                (attributes || (attributes = {}))[attr] = m.attributes[attr];
              }
            }

            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }

        if (endStyles) {
          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
            if (endStyles[j$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j$1];
            }
          }
        }

        if (!collapsed || collapsed.from == pos) {
          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
          }
        }

        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);

          if (collapsed.to == null) {
            return;
          }

          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }

      if (pos >= len) {
        break;
      }

      var upto = Math.min(len, nextChange);

      while (true) {
        if (text) {
          var end = pos + text.length;

          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }

          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }

          pos = end;
          spanStartStyle = "";
        }

        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  } // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.


  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line; // Continuing lines, if any

    this.rest = visualLineContinued(line); // Number of logical lines in this visual line

    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  } // Create a range of LineView objects for the given lines.


  function buildViewArray(cm, from, to) {
    var array = [],
        nextPos;

    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }

    return array;
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks,
        i = 0;

    do {
      for (; i < callbacks.length; i++) {
        callbacks[i].call(null);
      }

      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];

        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i < callbacks.length);
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;

    if (!group) {
      return;
    }

    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.

  function signalLater(emitter, type
  /*, values...*/
  ) {
    var arr = getHandlers(emitter, type);

    if (!arr.length) {
      return;
    }

    var args = Array.prototype.slice.call(arguments, 2),
        list;

    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }

    var loop = function loop(i) {
      list.push(function () {
        return arr[i].apply(null, args);
      });
    };

    for (var i = 0; i < arr.length; ++i) {
      loop(i);
    }
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;

    for (var i = 0; i < delayed.length; ++i) {
      delayed[i]();
    }
  } // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.


  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];

      if (type == "text") {
        updateLineText(cm, lineView);
      } else if (type == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type == "class") {
        updateLineClasses(cm, lineView);
      } else if (type == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }

    lineView.changes = null;
  } // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div


  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");

      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }

      lineView.node.appendChild(lineView.text);

      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }

    return lineView.node;
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;

    if (cls) {
      cls += " CodeMirror-linebackground";
    }

    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);
        lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  } // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.


  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;

    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }

    return buildLineContent(cm, lineView);
  } // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.


  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);

    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }

    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;

    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);

    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }

    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }

    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }

    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }

    var markers = lineView.line.gutterMarkers;

    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);

      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }

      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
      }

      if (markers) {
        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
          var id = cm.display.gutterSpecs[k].className,
              found = markers.hasOwnProperty(id) && markers[id];

          if (found) {
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }

    var isWidget = classTest("CodeMirror-linewidget");

    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;

      if (isWidget.test(node.className)) {
        lineView.node.removeChild(node);
      }
    }

    insertLineWidgets(cm, lineView, dims);
  } // Build a line's DOM representation from scratch


  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;

    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }

    if (built.textClass) {
      lineView.textClass = built.textClass;
    }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  } // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.


  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);

    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) {
        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
    }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }

    var wrap = ensureLineWrapped(lineView);

    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i],
          node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));

      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }

      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);

      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }

      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";

      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }

      node.style.width = width + "px";
    }

    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";

      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }

    var cm = widget.doc.cm;

    if (!cm) {
      return 0;
    }

    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";

      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }

      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }

      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }

    return widget.height = widget.node.parentNode.offsetHeight;
  } // Return true when the given mouse event happened in a widget


  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  } // POSITION MEASUREMENT


  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }

  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }

  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }

    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {
      left: parseInt(style.paddingLeft),
      right: parseInt(style.paddingRight)
    };

    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }

    return data;
  }

  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }

  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }

  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  } // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.


  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);

    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];

      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();

        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i],
              next = rects[i + 1];

          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }

      heights.push(rect.bottom - rect.top);
    }
  } // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)


  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return {
        map: lineView.measure.map,
        cache: lineView.measure.cache
      };
    }

    for (var i = 0; i < lineView.rest.length; i++) {
      if (lineView.rest[i] == line) {
        return {
          map: lineView.measure.maps[i],
          cache: lineView.measure.caches[i]
        };
      }
    }

    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
      if (lineNo(lineView.rest[i$1]) > lineN) {
        return {
          map: lineView.measure.maps[i$1],
          cache: lineView.measure.caches[i$1],
          before: true
        };
      }
    }
  } // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.


  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  } // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.


  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  } // Find a line view that corresponds to the given line number.


  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }

    var ext = cm.display.externalMeasured;

    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  } // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.


  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);

    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }

    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line,
      view: view,
      rect: null,
      map: info.map,
      cache: info.cache,
      before: info.before,
      hasHeights: false
    };
  } // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).


  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }

    var key = ch + (bias || ""),
        found;

    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }

      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }

      found = measureCharInner(cm, prepared, ch, bias);

      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }

    return {
      left: found.left,
      right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom
    };
  }

  var nullRect = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,
    // or closest to, the target character.

    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];

      if (ch < mStart) {
        start = 0;
        end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;

        if (ch >= mEnd) {
          collapse = "right";
        }
      }

      if (start != null) {
        node = map[i + 2];

        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }

        if (bias == "left" && start == 0) {
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        }

        if (bias == "right" && start == mEnd - mStart) {
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        }

        break;
      }
    }

    return {
      node: node,
      start: start,
      end: end,
      collapse: collapse,
      coverStart: mStart,
      coverEnd: mEnd
    };
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;

    if (bias == "left") {
      for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) {
          break;
        }
      }
    }

    return rect;
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node,
        start = place.start,
        end = place.end,
        collapse = place.collapse;
    var rect;

    if (node.nodeType == 3) {
      // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) {
        // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }

        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }

        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }

        if (rect.left || rect.right || start == 0) {
          break;
        }

        end = start;
        start = start - 1;
        collapse = "right";
      }

      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      // If it is a widget, simply get the box for the whole widget.
      if (start > 0) {
        collapse = bias = "right";
      }

      var rects;

      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }

    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];

      if (rSpan) {
        rect = {
          left: rSpan.left,
          right: rSpan.left + charWidth(cm.display),
          top: rSpan.top,
          bottom: rSpan.bottom
        };
      } else {
        rect = nullRect;
      }
    }

    var rtop = rect.top - prepared.rect.top,
        rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;

    for (; i < heights.length - 1; i++) {
      if (mid < heights[i]) {
        break;
      }
    }

    var top = i ? heights[i - 1] : 0,
        bot = heights[i];
    var result = {
      left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top: top,
      bottom: bot
    };

    if (!rect.left && !rect.right) {
      result.bogus = true;
    }

    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;
      result.rbottom = rbot;
    }

    return result;
  } // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.


  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }

    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {
      left: rect.left * scaleX,
      right: rect.right * scaleX,
      top: rect.top * scaleY,
      bottom: rect.bottom * scaleY
    };
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;

      if (lineView.rest) {
        for (var i = 0; i < lineView.rest.length; i++) {
          lineView.measure.caches[i] = {};
        }
      }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);

    for (var i = 0; i < cm.display.view.length; i++) {
      clearLineMeasurementCacheFor(cm.display.view[i]);
    }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;

    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }

    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
    }

    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }

  function pageScrollY() {
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
    }

    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }

  function widgetTopHeight(lineObj) {
    var height = 0;

    if (lineObj.widgets) {
      for (var i = 0; i < lineObj.widgets.length; ++i) {
        if (lineObj.widgets[i].above) {
          height += widgetHeight(lineObj.widgets[i]);
        }
      }
    }

    return height;
  } // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".


  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height;
      rect.bottom += height;
    }

    if (context == "line") {
      return rect;
    }

    if (!context) {
      context = "local";
    }

    var yOff = _heightAtLine(lineObj);

    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }

    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff;
      rect.right += xOff;
    }

    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  } // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.


  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }

    var left = coords.left,
        top = coords.top; // First move into "page" coordinate system

    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {
      left: left - lineSpaceBox.left,
      top: top - lineSpaceBox.top
    };
  }

  function _charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }

    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  } // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.


  function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);

    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }

    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);

      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }

      return intoCoordSystem(cm, lineObj, m, context);
    }

    var order = getOrder(lineObj, cm.doc.direction),
        ch = pos.ch,
        sticky = pos.sticky;

    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }

    if (!order) {
      return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
    }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos],
          right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert);
    }

    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");

    if (other != null) {
      val.other = getBidi(ch, other, sticky != "before");
    }

    return val;
  } // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.


  function estimateCoords(cm, pos) {
    var left = 0;
    pos = _clipPos(cm.doc, pos);

    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }

    var lineObj = getLine(cm.doc, pos.line);
    var top = _heightAtLine(lineObj) + paddingTop(cm.display);
    return {
      left: left,
      right: left,
      top: top,
      bottom: top + lineObj.height
    };
  } // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.


  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;

    if (outside) {
      pos.outside = outside;
    }

    return pos;
  } // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).


  function _coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;

    if (y < 0) {
      return PosWithInfo(doc.first, 0, null, -1, -1);
    }

    var lineN = _lineAtHeight(doc, y),
        last = doc.first + doc.size - 1;

    if (lineN > last) {
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
    }

    if (x < 0) {
      x = 0;
    }

    var lineObj = getLine(doc, lineN);

    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));

      if (!collapsed) {
        return found;
      }

      var rangeEnd = collapsed.find(1);

      if (rangeEnd.line == lineN) {
        return rangeEnd;
      }

      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
    }, end, 0);
    end = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch).top > y;
    }, begin, end);
    return {
      begin: begin,
      end: end
    };
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }

    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
  } // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.


  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= _heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.

    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0,
        end = lineObj.text.length,
        ltr = true;
    var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.

    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range

      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    } // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.


    var chAround = null,
        boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight;
      box.bottom += widgetHeight;

      if (!boxIsAfter(box, x, y, false)) {
        return false;
      }

      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }

      return true;
    }, begin, end);
    var baseX,
        sticky,
        outside = false; // If a box around the coordinates was found, use that

    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x,
          atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) {
        ch++;
      } // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates


      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? "after" : "before"; // Now get accurate coordinates for this place, in order to get a
      // base X position

      var coords = _cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);

      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i],
          ltr = part.level != 1;
      return boxIsAfter(_cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
    }, 0, order.length - 1);
    var part = order[index]; // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.

    if (index > 0) {
      var ltr = part.level != 1;

      var start = _cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);

      if (boxIsAfter(start, x, y, true) && start.top > y) {
        part = order[index - 1];
      }
    }

    return part;
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;

    if (/\s/.test(lineObj.text.charAt(end - 1))) {
      end--;
    }

    var part = null,
        closestDist = null;

    for (var i = 0; i < order.length; i++) {
      var p = order[i];

      if (p.from >= end || p.to <= begin) {
        continue;
      }

      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after

      var dist = endX < x ? x - endX + 1e9 : endX - x;

      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }

    if (!part) {
      part = order[order.length - 1];
    } // Clip the part to the wrapped line.


    if (part.from < begin) {
      part = {
        from: begin,
        to: part.to,
        level: part.level
      };
    }

    if (part.to > end) {
      part = {
        from: part.from,
        to: end,
        level: part.level
      };
    }

    return part;
  }

  var measureText; // Compute the default text height.

  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }

    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like"); // Measure a bunch of lines, for browsers that compute
      // fractional heights.

      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }

      measureText.appendChild(document.createTextNode("x"));
    }

    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;

    if (height > 3) {
      display.cachedTextHeight = height;
    }

    removeChildren(display.measure);
    return height || 1;
  } // Compute the default character width.


  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }

    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(),
        width = (rect.right - rect.left) / 10;

    if (width > 2) {
      display.cachedCharWidth = width;
    }

    return width || 10;
  } // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.


  function getDimensions(cm) {
    var d = cm.display,
        left = {},
        width = {};
    var gutterLeft = d.gutters.clientLeft;

    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }

    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.


  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  } // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).


  function estimateHeight(cm) {
    var th = textHeight(cm.display),
        wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }

      var widgetsHeight = 0;

      if (line.widgets) {
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) {
            widgetsHeight += line.widgets[i].height;
          }
        }
      }

      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc,
        est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);

      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  } // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.


  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;

    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }

    var x,
        y,
        space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.

    try {
      x = e.clientX - space.left;
      y = e.clientY - space.top;
    } catch (e) {
      return null;
    }

    var coords = _coordsChar(cm, x, y),
        line;

    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }

    return coords;
  } // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.


  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }

    n -= cm.display.viewFrom;

    if (n < 0) {
      return null;
    }

    var view = cm.display.view;

    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;

      if (n < 0) {
        return i;
      }
    }
  } // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.


  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }

    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }

    if (!lendiff) {
      lendiff = 0;
    }

    var display = cm.display;

    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) {
      // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) {
      // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);

      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);

      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);

      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;

    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  } // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"


  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display,
        ext = cm.display.externalMeasured;

    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }

    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }

    var lineView = display.view[findViewIndex(cm, line)];

    if (lineView.node == null) {
      return;
    }

    var arr = lineView.changes || (lineView.changes = []);

    if (indexOf(arr, type) == -1) {
      arr.push(type);
    }
  } // Clear the view.


  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN),
        diff,
        view = cm.display.view;

    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return {
        index: index,
        lineN: newN
      };
    }

    var n = cm.display.viewFrom;

    for (var i = 0; i < index; i++) {
      n += view[i].size;
    }

    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }

        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }

      oldN += diff;
      newN += diff;
    }

    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }

      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }

    return {
      index: index,
      lineN: newN
    };
  } // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.


  function adjustView(cm, from, to) {
    var display = cm.display,
        view = display.view;

    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }

      display.viewFrom = from;

      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }

    display.viewTo = to;
  } // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).


  function countDirtyView(cm) {
    var view = cm.display.view,
        dirty = 0;

    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];

      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }

    return dirty;
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;
    var doc = cm.doc,
        result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) {
        continue;
      }

      var range = doc.sel.ranges[i];

      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {
        continue;
      }

      var collapsed = range.empty();

      if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range.head, curFragment);
      }

      if (!collapsed) {
        drawSelectionRange(cm, range, selFragment);
      }
    }

    return result;
  } // Draws a cursor for the given range


  function drawSelectionCursor(cm, head, output) {
    var pos = _cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) {
    return a.top - b.top || a.left - b.left;
  } // Draws the given range as a highlighted selection


  function drawSelectionRange(cm, range, output) {
    var display = cm.display,
        doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display),
        leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }

      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;

      function coords(ch, bias) {
        return _charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = dir == "ltr" == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop];
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");
        var openStart = fromArg == null && from == 0,
            openEnd = toArg == null && to == lineLen;
        var first = i == 0,
            last = !order || i == order.length - 1;

        if (toPos.top - fromPos.top <= 3) {
          // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else {
          // Multiple lines
          var topLeft, topRight, botLeft, botRight;

          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }

          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);

          if (fromPos.bottom < toPos.top) {
            add(leftSide, fromPos.bottom, null, toPos.top);
          }

          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) {
          start = fromPos;
        }

        if (cmpCoords(toPos, start) < 0) {
          start = toPos;
        }

        if (!end || cmpCoords(fromPos, end) < 0) {
          end = fromPos;
        }

        if (cmpCoords(toPos, end) < 0) {
          end = toPos;
        }
      });
      return {
        start: start,
        end: end
      };
    }

    var sFrom = range.from(),
        sTo = range.to();

    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line),
          toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;

      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }

      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }

    output.appendChild(fragment);
  } // Cursor-blinking


  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }

    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";

    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function () {
        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) {
      cm.display.input.focus();
      onFocus(cm);
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
    }

    if (cm.options.readOnly == "nocursor") {
      return;
    }

    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused"); // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)

      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();

        if (webkit) {
          setTimeout(function () {
            return cm.display.input.reset(true);
          }, 20);
        } // Issue #1730

      }

      cm.display.input.receivedFocus();
    }

    restartBlink(cm);
  }

  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }

    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  } // Read the actual heights of the rendered lines, and update their
  // stored heights to match.


  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;

    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i],
          wrapping = cm.options.lineWrapping;
      var height = void 0,
          width = 0;

      if (cur.hidden) {
        continue;
      }

      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top; // Check that lines don't extend past the right of the current
        // editor width

        if (!wrapping && cur.text.firstChild) {
          width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
        }
      }

      var diff = cur.line.height - height;

      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);

        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }

      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));

        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  } // Read and store the height of line widgets associated with the
  // given line.


  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i = 0; i < line.widgets.length; ++i) {
        var w = line.widgets[i],
            parent = w.node.parentNode;

        if (parent) {
          w.height = parent.offsetHeight;
        }
      }
    }
  } // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.


  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = _lineAtHeight(doc, top),
        to = _lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).


    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line,
          ensureTo = viewport.ensure.to.line;

      if (ensureFrom < from) {
        from = ensureFrom;
        to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }

    return {
      from: from,
      to: Math.max(to, from + 1)
    };
  } // SCROLLING THINGS INTO VIEW
  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.


  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }

    var display = cm.display,
        box = display.sizer.getBoundingClientRect(),
        doScroll = null;

    if (rect.top + box.top < 0) {
      doScroll = true;
    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
      doScroll = false;
    }

    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  } // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).


  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }

    var rect;

    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }

    for (var limit = 0; limit < 5; limit++) {
      var changed = false;

      var coords = _cursorCoords(cm, pos);

      var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);
      rect = {
        left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
      };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop,
          startLeft = cm.doc.scrollLeft;

      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);

        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }

      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);

        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }

      if (!changed) {
        break;
      }
    }

    return rect;
  } // Scroll a given set of coordinates into view (immediately).


  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);

    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
    }

    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  } // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.


  function calculateScrollPos(cm, rect) {
    var display = cm.display,
        snapMargin = textHeight(cm.display);

    if (rect.top < 0) {
      rect.top = 0;
    }

    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm),
        result = {};

    if (rect.bottom - rect.top > screen) {
      rect.bottom = rect.top + screen;
    }

    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin,
        atBottom = rect.bottom > docBottom - snapMargin;

    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);

      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;

    if (tooWide) {
      rect.right = rect.left + screenw;
    }

    if (rect.left < 10) {
      result.scrollLeft = 0;
    } else if (rect.left < screenleft) {
      result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));
    } else if (rect.right > screenw + screenleft - 3) {
      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
    }

    return result;
  } // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).


  function addToScrollTop(cm, top) {
    if (top == null) {
      return;
    }

    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  } // Make sure that at the end of the operation the current cursor is
  // shown.


  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {
      from: cur,
      to: cur,
      margin: cm.options.cursorScrollMargin
    };
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) {
      resolveScrollToPos(cm);
    }

    if (x != null) {
      cm.curOp.scrollLeft = x;
    }

    if (y != null) {
      cm.curOp.scrollTop = y;
    }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  } // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.


  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;

    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from),
          to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  } // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.


  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }

    if (!gecko) {
      updateDisplaySimple(cm, {
        top: val
      });
    }

    setScrollTop(cm, val, true);

    if (gecko) {
      updateDisplaySimple(cm);
    }

    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));

    if (cm.display.scroller.scrollTop == val && !forceScroll) {
      return;
    }

    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);

    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
  } // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.


  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));

    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
      return;
    }

    cm.doc.scrollLeft = val;
    alignHorizontally(cm);

    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }

    cm.display.scrollbars.setScrollLeft(val);
  } // SCROLLBARS
  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.


  function measureForScrollbars(cm) {
    var d = cm.display,
        gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth,
      clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  var NativeScrollbars = function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert);
    place(horiz);
    on(vert, "scroll", function () {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });
    this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).

    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.

      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) {
        this.zeroWidthHack();
      }

      this.checkedZeroWidth = true;
    }

    return {
      right: needsV ? sWidth : 0,
      bottom: needsH ? sWidth : 0
    };
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) {
      this.horiz.scrollLeft = pos;
    }

    if (this.disableHoriz) {
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) {
      this.vert.scrollTop = pos;
    }

    if (this.disableVert) {
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";

    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);

      if (elt != bar) {
        bar.style.pointerEvents = "none";
      } else {
        delay.set(1000, maybeDisable);
      }
    }

    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function NullScrollbars() {};

  NullScrollbars.prototype.update = function () {
    return {
      bottom: 0,
      right: 0
    };
  };

  NullScrollbars.prototype.setScrollLeft = function () {};

  NullScrollbars.prototype.setScrollTop = function () {};

  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }

    var startWidth = cm.display.barWidth,
        startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);

    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }

      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;
      startHeight = cm.display.barHeight;
    }
  } // Re-synchronize the fake scrollbars with the actual size of the
  // content.


  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);
    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }

    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }

  var scrollbarModel = {
    "native": NativeScrollbars,
    "null": NullScrollbars
  };

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();

      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus

      on(node, "mousedown", function () {
        if (cm.state.focused) {
          setTimeout(function () {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        updateScrollTop(cm, pos);
      }
    }, cm);

    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  } // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.


  var nextOpId = 0; // Start a new operation.

  function _startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,
      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height,
      // Used to detect need to update scrollbar
      forceUpdate: false,
      // Used to force a redraw
      updateInput: 0,
      // Whether to reset the input textarea
      typing: false,
      // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,
      // Accumulated changes, for firing change events
      cursorActivityHandlers: null,
      // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0,
      // Tracks which cursorActivity handlers have been called already
      selectionChanged: false,
      // Whether the selection needs to be redrawn
      updateMaxLine: false,
      // Set when the widest line needs to be determined anew
      scrollLeft: null,
      scrollTop: null,
      // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,
      // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId // Unique ID

    };
    pushOperation(cm.curOp);
  } // Finish an operation, updating the display and signalling delayed events


  function _endOperation(cm) {
    var op = cm.curOp;

    if (op) {
      finishOperation(op, function (group) {
        for (var i = 0; i < group.ops.length; i++) {
          group.ops[i].cm.curOp = null;
        }

        endOperations(group);
      });
    }
  } // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.


  function endOperations(group) {
    var ops = group.ops;

    for (var i = 0; i < ops.length; i++) // Read DOM
    {
      endOperation_R1(ops[i]);
    }

    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    {
      endOperation_W1(ops[i$1]);
    }

    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    {
      endOperation_R2(ops[i$2]);
    }

    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    {
      endOperation_W2(ops[i$3]);
    }

    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    {
      endOperation_finish(ops[i$4]);
    }
  }

  function endOperation_R1(op) {
    var cm = op.cm,
        display = cm.display;
    maybeClipScrollbars(cm);

    if (op.updateMaxLine) {
      findMaxLine(cm);
    }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
      top: op.scrollTop,
      ensure: op.scrollToPos
    }, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm,
        display = cm.display;

    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }

    op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing

    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection();
    }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";

      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }

      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();

    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }

    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }

    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }

    if (op.selectionChanged) {
      restartBlink(cm);
    }

    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }

    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }

  function endOperation_finish(op) {
    var cm = op.cm,
        display = cm.display,
        doc = cm.doc;

    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    } // Abort mouse wheel delta measurement, when scrolling explicitly


    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    } // Propagate the scroll position to the actual DOM scroller


    if (op.scrollTop != null) {
      setScrollTop(cm, op.scrollTop, op.forceScroll);
    }

    if (op.scrollLeft != null) {
      setScrollLeft(cm, op.scrollLeft, true, true);
    } // If we need to scroll a specific position into view, do so.


    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    } // Fire events for markers that are hidden/unidden by editing or
    // undoing


    var hidden = op.maybeHiddenMarkers,
        unhidden = op.maybeUnhiddenMarkers;

    if (hidden) {
      for (var i = 0; i < hidden.length; ++i) {
        if (!hidden[i].lines.length) {
          signal(hidden[i], "hide");
        }
      }
    }

    if (unhidden) {
      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
        if (unhidden[i$1].lines.length) {
          signal(unhidden[i$1], "unhide");
        }
      }
    }

    if (display.wrapper.offsetHeight) {
      doc.scrollTop = cm.display.scroller.scrollTop;
    } // Fire change events, and delayed event handlers


    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }

    if (op.update) {
      op.update.finish();
    }
  } // Run the given function in an operation


  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }

    _startOperation(cm);

    try {
      return f();
    } finally {
      _endOperation(cm);
    }
  } // Wraps a function in an operation. Returns the wrapped function.


  function operation(cm, f) {
    return function () {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }

      _startOperation(cm);

      try {
        return f.apply(cm, arguments);
      } finally {
        _endOperation(cm);
      }
    };
  } // Used to add methods to editor and doc instances, wrapping them in
  // operations.


  function methodOp(f) {
    return function () {
      if (this.curOp) {
        return f.apply(this, arguments);
      }

      _startOperation(this);

      try {
        return f.apply(this, arguments);
      } finally {
        _endOperation(this);
      }
    };
  }

  function docMethodOp(f) {
    return function () {
      var cm = this.cm;

      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }

      _startOperation(cm);

      try {
        return f.apply(this, arguments);
      } finally {
        _endOperation(cm);
      }
    };
  } // HIGHLIGHT WORKER


  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;

    if (doc.highlightFrontier >= cm.display.viewTo) {
      return;
    }

    var end = +new Date() + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];
    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) {
        // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);

        if (resetState) {
          context.state = resetState;
        }

        line.styles = highlighted.styles;
        var oldCls = line.styleClasses,
            newCls = highlighted.classes;

        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }

        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);

        for (var i = 0; !ischange && i < oldStyles.length; ++i) {
          ischange = oldStyles[i] != line.styles[i];
        }

        if (ischange) {
          changedLines.push(context.line);
        }

        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, context);
        }

        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }

      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);

    if (changedLines.length) {
      runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++) {
          regLineChange(cm, changedLines[i], "text");
        }
      });
    }
  } // DISPLAY DRAWING


  var DisplayUpdate = function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;
    this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)

    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type)) {
      this.events.push(arguments);
    }
  };

  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++) {
      signal.apply(null, this.events[i]);
    }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;

    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) {
      return null;
    }

    var active = activeElt();

    if (!active || !contains(cm.display.lineDiv, active)) {
      return null;
    }

    var result = {
      activeElt: active
    };

    if (window.getSelection) {
      var sel = window.getSelection();

      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }

    return result;
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
      return;
    }

    snapshot.activeElt.focus();

    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(),
          range = document.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  } // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.


  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display,
        doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    } // Bail out if the visible area is already rendered and nothing changed.


    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    } // Compute a suitable new viewport (from & to)


    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);

    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc.first, display.viewFrom);
    }

    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }

    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);
    display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position

    cm.display.mover.style.top = display.viewOffset + "px";
    var toUpdate = countDirtyView(cm);

    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    } // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.


    var selSnapshot = selectionSnapshot(cm);

    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }

    patchDisplay(cm, display.updateLineNumbers, update.dims);

    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }

    display.renderedView = display.view; // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.

    restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll
    // width and height.

    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;
    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null) {
          viewport = {
            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
          };
        } // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.


        update.visible = visibleLines(cm.display, cm.doc, viewport);

        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }

      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }

      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);

    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;
      cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);

    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  } // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.


  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display,
        lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv,
        cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit

      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
      } else {
        node.parentNode.removeChild(node);
      }

      return next;
    }

    var view = display.view,
        lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.

    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {
        // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        // Already drawn
        while (cur != lineView.node) {
          cur = rm(cur);
        }

        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;

        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }

          updateLineForChanges(cm, lineView, lineN, dims);
        }

        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }

        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }

    while (cur) {
      cur = rm(cur);
    }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  } // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.


  function alignHorizontally(cm) {
    var display = cm.display,
        view = display.view;

    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }

    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth,
        left = comp + "px";

    for (var i = 0; i < view.length; i++) {
      if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter) {
            view[i].gutter.style.left = left;
          }

          if (view[i].gutterBackground) {
            view[i].gutterBackground.style.left = left;
          }
        }

        var align = view[i].alignable;

        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }

    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  } // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.


  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }

    var doc = cm.doc,
        last = lineNumberFor(cm.options, doc.first + doc.size - 1),
        display = cm.display;

    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth,
          padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true;
    }

    return false;
  }

  function getGutters(gutters, lineNumbers) {
    var result = [],
        sawLineNumbers = false;

    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i],
          style = null;

      if (typeof name != "string") {
        style = name.style;
        name = name.className;
      }

      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) {
          continue;
        } else {
          sawLineNumbers = true;
        }
      }

      result.push({
        className: name,
        style: style
      });
    }

    if (lineNumbers && !sawLineNumbers) {
      result.push({
        className: "CodeMirror-linenumbers",
        style: null
      });
    }

    return result;
  } // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.


  function renderGutters(display) {
    var gutters = display.gutters,
        specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;

    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));

      if (style) {
        gElt.style.cssText = style;
      }

      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }

    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  } // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.


  function Display(place, doc, input, options) {
    var d = this;
    this.input = input; // Covers bottom-right square when both scrollbars are present.

    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true"); // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.

    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true"); // Will contain the actual code, positioned to cover the viewport.

    d.lineDiv = eltP("div", null, "CodeMirror-code"); // Elements are added to these to represent selection and cursors.

    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors"); // A visibility: hidden element used to find the size of things.

    d.measure = elt("div", null, "CodeMirror-measure"); // When lines outside of the viewport are measured, they are drawn in this.

    d.lineMeasure = elt("div", null, "CodeMirror-measure"); // Wraps everything that needs to exist inside the vertically-padded coordinate system

    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines"); // Moved around its parent to cover visible view.

    d.mover = elt("div", [lines], null, "position: relative"); // Set to the height of the document, allowing scrolling.

    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.

    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"); // Will contain the gutters, if any.

    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null; // Actual scrollable element.

    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1"); // The element in which the editor lives.

    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)

    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }

    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }

    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    } // Current rendered range (may be bigger than the view window).


    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.

    d.view = [];
    d.renderedView = null; // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.

    d.externalMeasured = null; // Empty space (in pixels) above the view

    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;
    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)

    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.

    d.alignWidgets = false;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.

    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false; // Used for measuring wheel scrolling granularity

    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.

    d.shift = false; // Used to track whether anything happened since the context menu
    // was opened.

    d.selForContextMenu = null;
    d.activeTouch = null;
    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);
    input.init(d);
  } // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.


  var wheelSamples = 0,
      wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).

  if (ie) {
    wheelPixelsPerUnit = -.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX,
        dy = e.wheelDeltaY;

    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }

    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }

    return {
      x: dx,
      y: dy
    };
  }

  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e),
        dx = delta.x,
        dy = delta.y;
    var display = cm.display,
        scroll = display.scroller; // Quit if there's nothing to scroll here

    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;

    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    } // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.


    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    } // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.


    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY) {
        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
      }

      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)

      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }

      display.wheelStartX = null; // Abort measurement, if in progress

      return;
    } // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).


    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop,
          bot = top + display.wrapper.clientHeight;

      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }

      updateDisplaySimple(cm, {
        top: top,
        bottom: bot
      });
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) {
            return;
          }

          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;

          if (!sample) {
            return;
          }

          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  } // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).


  var Selection = function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () {
    return this.ranges[this.primIndex];
  };

  Selection.prototype.equals = function (other) {
    if (other == this) {
      return true;
    }

    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
      return false;
    }

    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i],
          there = other.ranges[i];

      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
        return false;
      }
    }

    return true;
  };

  Selection.prototype.deepCopy = function () {
    var out = [];

    for (var i = 0; i < this.ranges.length; i++) {
      out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
    }

    return new Selection(out, this.primIndex);
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++) {
      if (!this.ranges[i].empty()) {
        return true;
      }
    }

    return false;
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) {
      end = pos;
    }

    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];

      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
        return i;
      }
    }

    return -1;
  };

  var Range = function Range(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };

  Range.prototype.from = function () {
    return minPos(this.anchor, this.head);
  };

  Range.prototype.to = function () {
    return maxPos(this.anchor, this.head);
  };

  Range.prototype.empty = function () {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  }; // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).


  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);

    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i],
          prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());

      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()),
            to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;

        if (i <= primIndex) {
          --primIndex;
        }

        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }

    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  } // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).


  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }

    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  } // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.


  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }

    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
        ch = pos.ch;

    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }

    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
    }

    return normalizeSelection(doc.cm, out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  } // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".


  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0),
        newPrev = oldPrev;

    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;

      if (hint == "around") {
        var range = doc.sel.ranges[i],
            inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }

    return new Selection(out, doc.sel.primIndex);
  } // Used to get the editor into a consistent state again when options change.


  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }

      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;

    if (cm.curOp) {
      regChange(cm);
    }
  } // DOCUMENT DATA STRUCTURE
  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.


  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  } // Perform a change on the document data structure.


  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }

    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    function linesFor(start, end) {
      var result = [];

      for (var i = start; i < end; ++i) {
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      }

      return result;
    }

    var from = change.from,
        to = change.to,
        text = change.text;
    var firstLine = getLine(doc, from.line),
        lastLine = getLine(doc, to.line);
    var lastText = lst(text),
        lastSpans = spansFor(text.length - 1),
        nlines = to.line - from.line; // Adjust the line structure

    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);

      if (nlines) {
        doc.remove(from.line, nlines);
      }

      if (added.length) {
        doc.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);

      if (nlines > 1) {
        doc.remove(from.line + 1, nlines - 1);
      }

      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  } // Call f for all linked documents.


  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) {
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];

          if (rel.doc == skip) {
            continue;
          }

          var shared = sharedHist && rel.sharedHist;

          if (sharedHistOnly && !shared) {
            continue;
          }

          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
    }

    propagate(doc, null, true);
  } // Attach a document to an editor.


  function attachDoc(cm, doc) {
    if (doc.cm) {
      throw new Error("This document is already in use.");
    }

    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);

    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }

    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = [];
    this.undone = [];
    this.undoDepth = Infinity; // Used to track when changes can be merged into a single undo
    // event

    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method

    this.generation = this.maxGeneration = startGen || 1;
  } // Create a history change event from an updateDoc-style change
  // object.


  function historyChangeFromChange(doc, change) {
    var histChange = {
      from: copyPos(change.from),
      to: changeEnd(change),
      text: getBetween(doc, change.from, change.to)
    };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  } // Pop all selection events off the end of a history array. Stop at
  // a change event.


  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);

      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  } // Find the top change event in the history. Pop off selection
  // events that are in the way.


  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  } // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.


  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(),
        cur;
    var last;

    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);

      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);

      if (!before || !before.ranges) {
        pushSelectionToHistory(doc.sel, hist.done);
      }

      cur = {
        changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation
      };
      hist.done.push(cur);

      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();

        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }

    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) {
      signal(doc, "historyAdded");
    }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  } // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).


  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history,
        origin = options && options.origin; // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.

    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }

    hist.lastSelTime = +new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;

    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);

    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  } // Used to store marked span information in the history.


  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id],
        n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      }

      ++n;
    });
  } // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.


  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }

    var out;

    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i);
        }
      } else if (out) {
        out.push(spans[i]);
      }
    }

    return !out ? spans : out.length ? out : null;
  } // Retrieve and filter the old marked spans stored in a change event.


  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];

    if (!found) {
      return null;
    }

    var nw = [];

    for (var i = 0; i < change.text.length; ++i) {
      nw.push(removeClearedSpans(found[i]));
    }

    return nw;
  } // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).


  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);

    if (!old) {
      return stretched;
    }

    if (!stretched) {
      return old;
    }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i],
          stretchCur = stretched[i];

      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];

          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }

          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }

    return old;
  } // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two


  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];

    for (var i = 0; i < events.length; ++i) {
      var event = events[i];

      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }

      var changes = event.changes,
          newChanges = [];
      copy.push({
        changes: newChanges
      });

      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j],
            m = void 0;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });

        if (newGroup) {
          for (var prop in change) {
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
      }
    }

    return copy;
  } // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.
  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.


  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;

      if (other) {
        var posBefore = cmp(head, anchor) < 0;

        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }

      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  } // Extend the primary selection range, discard the rest.


  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) {
      extend = doc.cm && (doc.cm.display.shift || doc.extend);
    }

    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  } // Extend all selections (pos is an array of selections with length
  // equal the number of selections)


  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
    }

    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  } // Updates a single range in the selection.


  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  } // Reset the selection to a single range.


  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  } // Give beforeSelectionChange handlers a change to influence a
  // selection update.


  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function update(ranges) {
        this.ranges = [];

        for (var i = 0; i < ranges.length; i++) {
          this.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));
        }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);

    if (doc.cm) {
      signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    }

    if (obj.ranges != sel.ranges) {
      return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done,
        last = lst(done);

    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  } // Set a new selection.


  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc, sel, options);
    }

    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm) {
      ensureCursorVisible(doc.cm);
    }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) {
      return;
    }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }

    signalLater(doc, "cursorActivity", doc);
  } // Verify that the selection does not partially select any atomic
  // marked ranges.


  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  } // Return a selection that does not partially select any atomic
  // ranges.


  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;

    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);

      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) {
          out = sel.ranges.slice(0, i);
        }

        out[i] = new Range(newAnchor, newHead);
      }
    }

    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);

    if (line.markedSpans) {
      for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i],
            m = sp.marker; // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
        // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
        // is with selectLeft/Right

        var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
        var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;

        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");

            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i;
                continue;
              }
            }
          }

          if (!m.atomic) {
            continue;
          }

          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1),
                diff = void 0;

            if (dir < 0 ? preventCursorRight : preventCursorLeft) {
              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
            }

            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc, near, pos, dir, mayClear);
            }
          }

          var far = m.find(dir < 0 ? -1 : 1);

          if (dir < 0 ? preventCursorLeft : preventCursorRight) {
            far = movePos(doc, far, dir, far.line == pos.line ? line : null);
          }

          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
        }
      }
    }

    return pos;
  } // Ensure a given position is not inside an atomic range.


  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);

    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }

    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) {
        return _clipPos(doc, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  } // UPDATING
  // Allow "beforeChange" event handlers to influence a change


  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function cancel() {
        return obj.canceled = true;
      }
    };

    if (update) {
      obj.update = function (from, to, text, origin) {
        if (from) {
          obj.from = _clipPos(doc, from);
        }

        if (to) {
          obj.to = _clipPos(doc, to);
        }

        if (text) {
          obj.text = text;
        }

        if (origin !== undefined) {
          obj.origin = origin;
        }
      };
    }

    signal(doc, "beforeChange", doc, obj);

    if (doc.cm) {
      signal(doc.cm, "beforeChange", doc.cm, obj);
    }

    if (obj.canceled) {
      if (doc.cm) {
        doc.cm.curOp.updateInput = 2;
      }

      return null;
    }

    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  } // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.


  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) {
        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      }

      if (doc.cm.state.suppressEdits) {
        return;
      }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);

      if (!change) {
        return;
      }
    } // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.


    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);

    if (split) {
      for (var i = split.length - 1; i >= 0; --i) {
        makeChangeInner(doc, {
          from: split[i].from,
          to: split[i].to,
          text: i ? [""] : change.text,
          origin: change.origin
        });
      }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }

    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }

      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  } // Revert a change stored in a document's history.


  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;

    if (suppress && !allowSelectionOnly) {
      return;
    }

    var hist = doc.history,
        event,
        selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone,
        dest = type == "undo" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)

    var i = 0;

    for (; i < source.length; i++) {
      event = source[i];

      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
        break;
      }
    }

    if (i == source.length) {
      return;
    }

    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();

      if (event.ranges) {
        pushSelectionToHistory(event, dest);

        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {
            clearRedo: false
          });
          return;
        }

        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return;
      } else {
        break;
      }
    } // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).


    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({
      changes: antiChanges,
      generation: hist.generation
    });
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function loop(i) {
      var change = event.changes[i];
      change.origin = type;

      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {};
      }

      antiChanges.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));

      if (!i && doc.cm) {
        doc.cm.scrollIntoView({
          from: change.from,
          to: changeEnd(change)
        });
      }

      var rebased = []; // Propagate to the linked documents

      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }

        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop(i$1);
      if (returned) return returned.v;
    }
  } // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.


  function shiftDoc(doc, distance) {
    if (distance == 0) {
      return;
    }

    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);

    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);

      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc.cm, l, "gutter");
      }
    }
  } // More lower-level change function, handling only a single document
  // (not linked ones).


  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }

    if (change.from.line > doc.lastLine()) {
      return;
    } // Clip the change to the size of this doc


    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }

    var last = doc.lastLine();

    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) {
      selAfter = computeSelAfterChange(doc, change);
    }

    if (doc.cm) {
      makeChangeSingleDocInEditor(doc.cm, change, spans);
    } else {
      updateDoc(doc, change, spans);
    }

    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
      doc.cantEdit = false;
    }
  } // Handle the interaction of a change to a document with the editor
  // that this document is part of.


  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc,
        display = cm.display,
        from = change.from,
        to = change.to;
    var recomputeMaxLength = false,
        checkWidthStart = from.line;

    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);

        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });

      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display

    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }

    var changesHandler = hasHandler(cm, "changes"),
        changeHandler = hasHandler(cm, "change");

    if (changeHandler || changesHandler) {
      var obj = {
        from: from,
        to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };

      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }

      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }

    cm.display.selForContextMenu = null;
  }

  function _replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) {
      to = from;
    }

    if (cmp(to, from) < 0) {
      assign = [to, from], from = assign[0], to = assign[1];
    }

    if (typeof code == "string") {
      code = doc.splitLines(code);
    }

    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    });
  } // Rebasing/resetting history to deal with externally-sourced changes


  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  } // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.


  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i],
          ok = true;

      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i] = sub.deepCopy();
          sub.copied = true;
        }

        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }

        continue;
      }

      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];

        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }

      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line,
        to = change.to.line,
        diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  } // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.


  function changeLine(doc, handle, changeType, op) {
    var no = handle,
        line = handle;

    if (typeof handle == "number") {
      line = getLine(doc, clipLine(doc, handle));
    } else {
      no = lineNo(handle);
    }

    if (no == null) {
      return null;
    }

    if (op(line, no) && doc.cm) {
      regLineChange(doc.cm, no, changeType);
    }

    return line;
  } // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html


  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;

    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }

    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.lines.length;
    },
    // Remove the n lines at offset 'at'.
    removeInner: function removeInner(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }

      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function collapse(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function insertInner(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));

      for (var i = 0; i < lines.length; ++i) {
        lines[i].parent = this;
      }
    },
    // Used to iterate over a part of the tree.
    iterN: function iterN(at, n, op) {
      for (var e = at + n; at < e; ++at) {
        if (op(this.lines[at])) {
          return true;
        }
      }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0,
        height = 0;

    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }

    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.size;
    },
    removeInner: function removeInner(at, n) {
      this.size -= n;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i],
            sz = child.chunkSize();

        if (at < sz) {
          var rm = Math.min(n, sz - at),
              oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;

          if (sz == rm) {
            this.children.splice(i--, 1);
            child.parent = null;
          }

          if ((n -= rm) == 0) {
            break;
          }

          at = 0;
        } else {
          at -= sz;
        }
      } // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.


      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function collapse(lines) {
      for (var i = 0; i < this.children.length; ++i) {
        this.children[i].collapse(lines);
      }
    },
    insertInner: function insertInner(at, lines, height) {
      this.size += lines.length;
      this.height += height;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i],
            sz = child.chunkSize();

        if (at <= sz) {
          child.insertInner(at, lines, height);

          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;

            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }

            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }

          break;
        }

        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function maybeSpill() {
      if (this.children.length <= 10) {
        return;
      }

      var me = this;

      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);

        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }

        sibling.parent = me.parent;
      } while (me.children.length > 10);

      me.parent.maybeSpill();
    },
    iterN: function iterN(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i],
            sz = child.chunkSize();

        if (at < sz) {
          var used = Math.min(n, sz - at);

          if (child.iterN(at, used, op)) {
            return true;
          }

          if ((n -= used) == 0) {
            break;
          }

          at = 0;
        } else {
          at -= sz;
        }
      }
    }
  }; // Line widgets are block elements displayed above or below a line.

  var LineWidget = function LineWidget(doc, node, options) {
    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this[opt] = options[opt];
        }
      }
    }

    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm,
        ws = this.line.widgets,
        line = this.line,
        no = lineNo(line);

    if (no == null || !ws) {
      return;
    }

    for (var i = 0; i < ws.length; ++i) {
      if (ws[i] == this) {
        ws.splice(i--, 1);
      }
    }

    if (!ws.length) {
      line.widgets = null;
    }

    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));

    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
    var this$1 = this;
    var oldH = this.height,
        cm = this.doc.cm,
        line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;

    if (!diff) {
      return;
    }

    if (!lineIsHidden(this.doc, line)) {
      updateLineHeight(line, line.height + diff);
    }

    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };

  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollTop(cm, diff);
    }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;

    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }

    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);

      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      }

      widget.line = line;

      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = _heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));

        if (aboveVisible) {
          addToScrollTop(cm, widget.height);
        }

        cm.curOp.forceUpdate = true;
      }

      return true;
    });

    if (cm) {
      signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
    }

    return widget;
  } // TEXTMARKERS
  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.
  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).


  var nextMarkerId = 0;

  var TextMarker = function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  }; // Clear the marker.


  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) {
      return;
    }

    var cm = this.doc.cm,
        withOp = cm && !cm.curOp;

    if (withOp) {
      _startOperation(cm);
    }

    if (hasHandler(this, "clear")) {
      var found = this.find();

      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }

    var min = null,
        max = null;

    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);

      if (cm && !this.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }

        if (span.from != null) {
          min = lineNo(line);
        }
      }

      line.markedSpans = removeMarkedSpan(line.markedSpans, span);

      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }

    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this.lines[i$1]),
            len = lineLength(visual);

        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }

    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }

    this.lines.length = 0;
    this.explicitlyCleared = true;

    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;

      if (cm) {
        reCheckSelection(cm.doc);
      }
    }

    if (cm) {
      signalLater(cm, "markerCleared", cm, this, min, max);
    }

    if (withOp) {
      _endOperation(cm);
    }

    if (this.parent) {
      this.parent.clear();
    }
  }; // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).


  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") {
      side = 1;
    }

    var from, to;

    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);

      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);

        if (side == -1) {
          return from;
        }
      }

      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);

        if (side == 1) {
          return to;
        }
      }
    }

    return from && {
      from: from,
      to: to
    };
  }; // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.


  TextMarker.prototype.changed = function () {
    var this$1 = this;
    var pos = this.find(-1, true),
        widget = this,
        cm = this.doc.cm;

    if (!pos || !cm) {
      return;
    }

    runInOp(cm, function () {
      var line = pos.line,
          lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);

      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }

      cm.curOp.updateMaxLine = true;

      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;

        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }

      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;

      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }

    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);

    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and

  function _markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) {
      return markTextShared(doc, from, to, options, type);
    } // Ensure we are in an operation.


    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, _markText)(doc, from, to, options, type);
    }

    var marker = new TextMarker(doc, type),
        diff = cmp(from, to);

    if (options) {
      copyObj(options, marker, false);
    } // Don't connect empty markers unless clearWhenEmpty is false


    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }

    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");

      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }

      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }

    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }

      seeCollapsedSpans();
    }

    if (marker.addToHistory) {
      addChangeToHistory(doc, {
        from: from,
        to: to,
        origin: "markText"
      }, doc.sel, NaN);
    }

    var curLine = from.line,
        cm = doc.cm,
        updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }

      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }

      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
      ++curLine;
    }); // lineIsHidden depends on the presence of the spans, so needs a second pass

    if (marker.collapsed) {
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) {
          updateLineHeight(line, 0);
        }
      });
    }

    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function () {
        return marker.clear();
      });
    }

    if (marker.readOnly) {
      seeReadOnlySpans();

      if (doc.history.done.length || doc.history.undone.length) {
        doc.clearHistory();
      }
    }

    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }

    if (cm) {
      // Sync editor state
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }

      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
        for (var i = from.line; i <= to.line; i++) {
          regLineChange(cm, i, "text");
        }
      }

      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }

      signalLater(cm, "markerAdded", cm, marker);
    }

    return marker;
  } // SHARED TEXTMARKERS
  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.


  var SharedTextMarker = function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;

    for (var i = 0; i < markers.length; ++i) {
      markers[i].parent = this;
    }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) {
      return;
    }

    this.explicitlyCleared = true;

    for (var i = 0; i < this.markers.length; ++i) {
      this.markers[i].clear();
    }

    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [_markText(doc, from, to, options, type)],
        primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }

      markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));

      for (var i = 0; i < doc.linked.length; ++i) {
        if (doc.linked[i].isParent) {
          return;
        }
      }

      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
      return m.parent;
    });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i],
          pos = marker.find();
      var mFrom = doc.clipPos(pos.from),
          mTo = doc.clipPos(pos.to);

      if (cmp(mFrom, mTo)) {
        var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);

        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function loop(i) {
      var marker = markers[i],
          linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) {
        return linked.push(d);
      });

      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];

        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) {
      loop(i);
    }
  }

  var nextDocId = 0;

  var Doc = function Doc(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep, direction);
    }

    if (firstLine == null) {
      firstLine = 0;
    }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = direction == "rtl" ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") {
      text = this.splitLines(text);
    }

    updateDoc(this, {
      from: start,
      to: start,
      text: text
    });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function iter(from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },
    // Non-public interface for adding and removing lines.
    insert: function insert(at, lines) {
      var height = 0;

      for (var i = 0; i < lines.length; ++i) {
        height += lines[i].height;
      }

      this.insertInner(at - this.first, lines, height);
    },
    remove: function remove(at, n) {
      this.removeInner(at - this.first, n);
    },
    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.
    getValue: function getValue(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);

      if (lineSep === false) {
        return lines;
      }

      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0),
          last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code),
        origin: "setValue",
        full: true
      }, true);

      if (this.cm) {
        scrollToCoords(this.cm, 0, 0);
      }

      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function replaceRange(code, from, to, origin) {
      from = _clipPos(this, from);
      to = to ? _clipPos(this, to) : from;

      _replaceRange(this, code, from, to, origin);
    },
    getRange: function getRange(from, to, lineSep) {
      var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));

      if (lineSep === false) {
        return lines;
      }

      return lines.join(lineSep || this.lineSeparator());
    },
    getLine: function getLine(line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    getLineHandle: function getLineHandle(line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function getLineNumber(line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function getLineHandleVisualStart(line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }

      return visualLine(line);
    },
    lineCount: function lineCount() {
      return this.size;
    },
    firstLine: function firstLine() {
      return this.first;
    },
    lastLine: function lastLine() {
      return this.first + this.size - 1;
    },
    clipPos: function clipPos(pos) {
      return _clipPos(this, pos);
    },
    getCursor: function getCursor(start) {
      var range = this.sel.primary(),
          pos;

      if (start == null || start == "head") {
        pos = range.head;
      } else if (start == "anchor") {
        pos = range.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range.to();
      } else {
        pos = range.from();
      }

      return pos;
    },
    listSelections: function listSelections() {
      return this.sel.ranges;
    },
    somethingSelected: function somethingSelected() {
      return this.sel.somethingSelected();
    },
    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, _clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      if (!ranges.length) {
        return;
      }

      var out = [];

      for (var i = 0; i < ranges.length; i++) {
        out[i] = new Range(_clipPos(this, ranges[i].anchor), _clipPos(this, ranges[i].head));
      }

      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }

      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),
    getSelection: function getSelection(lineSep) {
      var ranges = this.sel.ranges,
          lines;

      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }

      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function getSelections(lineSep) {
      var parts = [],
          ranges = this.sel.ranges;

      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());

        if (lineSep !== false) {
          sel = sel.join(lineSep || this.lineSeparator());
        }

        parts[i] = sel;
      }

      return parts;
    },
    replaceSelection: function replaceSelection(code, collapse, origin) {
      var dup = [];

      for (var i = 0; i < this.sel.ranges.length; i++) {
        dup[i] = code;
      }

      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var changes = [],
          sel = this.sel;

      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {
          from: range.from(),
          to: range.to(),
          text: this.splitLines(code[i]),
          origin: origin
        };
      }

      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);

      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
        makeChange(this, changes[i$1]);
      }

      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function () {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function () {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "redo", true);
    }),
    setExtending: function setExtending(val) {
      this.extend = val;
    },
    getExtending: function getExtending() {
      return this.extend;
    },
    historySize: function historySize() {
      var hist = this.history,
          done = 0,
          undone = 0;

      for (var i = 0; i < hist.done.length; i++) {
        if (!hist.done[i].ranges) {
          ++done;
        }
      }

      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
        if (!hist.undone[i$1].ranges) {
          ++undone;
        }
      }

      return {
        undo: done,
        redo: undone
      };
    },
    clearHistory: function clearHistory() {
      var this$1 = this;
      this.history = new History(this.history.maxGeneration);
      linkedDocs(this, function (doc) {
        return doc.history = this$1.history;
      }, true);
    },
    markClean: function markClean() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function changeGeneration(forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }

      return this.history.generation;
    },
    isClean: function isClean(gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function getHistory() {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function setHistory(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },
    setGutterMarker: docMethodOp(function (line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;

        if (!value && isEmpty(markers)) {
          line.gutterMarkers = null;
        }

        return true;
      });
    }),
    clearGutter: docMethodOp(function (gutterID) {
      var this$1 = this;
      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;

            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }

            return true;
          });
        }
      });
    }),
    lineInfo: function lineInfo(line) {
      var n;

      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }

        n = line;
        line = getLine(this, line);

        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);

        if (n == null) {
          return null;
        }
      }

      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    addLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";

        if (!line[prop]) {
          line[prop] = cls;
        } else if (classTest(cls).test(line[prop])) {
          return false;
        } else {
          line[prop] += " " + cls;
        }

        return true;
      });
    }),
    removeLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];

        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop] = null;
        } else {
          var found = cur.match(classTest(cls));

          if (!found) {
            return false;
          }

          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }

        return true;
      });
    }),
    addLineWidget: docMethodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function removeLineWidget(widget) {
      widget.clear();
    },
    markText: function markText(from, to, options) {
      return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function setBookmark(pos, options) {
      var realOpts = {
        replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false,
        shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents
      };
      pos = _clipPos(this, pos);
      return _markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function findMarksAt(pos) {
      pos = _clipPos(this, pos);
      var markers = [],
          spans = getLine(this, pos.line).markedSpans;

      if (spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];

          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }

      return markers;
    },
    findMarks: function findMarks(from, to, filter) {
      from = _clipPos(this, from);
      to = _clipPos(this, to);
      var found = [],
          lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;

        if (spans) {
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];

            if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }

        ++lineNo;
      });
      return found;
    },
    getAllMarks: function getAllMarks() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;

        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            if (sps[i].from != null) {
              markers.push(sps[i].marker);
            }
          }
        }
      });
      return markers;
    },
    posFromIndex: function posFromIndex(off) {
      var ch,
          lineNo = this.first,
          sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;

        if (sz > off) {
          ch = off;
          return true;
        }

        off -= sz;
        ++lineNo;
      });
      return _clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function indexFromPos(coords) {
      coords = _clipPos(this, coords);
      var index = coords.ch;

      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }

      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index;
    },
    copy: function copy(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;

      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }

      return doc;
    },
    linkedDoc: function linkedDoc(options) {
      if (!options) {
        options = {};
      }

      var from = this.first,
          to = this.first + this.size;

      if (options.from != null && options.from > from) {
        from = options.from;
      }

      if (options.to != null && options.to < to) {
        to = options.to;
      }

      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);

      if (options.sharedHist) {
        copy.history = this.history;
      }

      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
        doc: this,
        isParent: true,
        sharedHist: options.sharedHist
      }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function unlinkDoc(other) {
      if (other instanceof CodeMirror) {
        other = other.doc;
      }

      if (this.linked) {
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];

          if (link.doc != other) {
            continue;
          }

          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          detachSharedMarkers(findSharedMarkers(this));
          break;
        }
      } // If the histories were shared, split them again


      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          return splitIds.push(doc.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function iterLinkedDocs(f) {
      linkedDocs(this, f);
    },
    getMode: function getMode() {
      return this.mode;
    },
    getEditor: function getEditor() {
      return this.cm;
    },
    splitLines: function splitLines(str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }

      return splitLinesAuto(str);
    },
    lineSeparator: function lineSeparator() {
      return this.lineSep || "\n";
    },
    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") {
        dir = "ltr";
      }

      if (dir == this.direction) {
        return;
      }

      this.direction = dir;
      this.iter(function (line) {
        return line.order = null;
      });

      if (this.cm) {
        directionChanged(this.cm);
      }
    })
  }); // Public alias.

  Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)

  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);

    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }

    e_preventDefault(e);

    if (ie) {
      lastDrop = +new Date();
    }

    var pos = posFromMouse(cm, e, true),
        files = e.dataTransfer.files;

    if (!pos || cm.isReadOnly()) {
      return;
    } // Might be a file drop, in which case we simply extract the text
    // and insert it.


    if (files && files.length && window.FileReader && window.File) {
      var n = files.length,
          text = Array(n),
          read = 0;

      var markAsReadAndPasteIfAllFilesAreRead = function markAsReadAndPasteIfAllFilesAreRead() {
        if (++read == n) {
          operation(cm, function () {
            pos = _clipPos(cm.doc, pos);
            var change = {
              from: pos,
              to: pos,
              text: cm.doc.splitLines(text.filter(function (t) {
                return t != null;
              }).join(cm.doc.lineSeparator())),
              origin: "paste"
            };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(_clipPos(cm.doc, pos), _clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };

      var readTextFromFile = function readTextFromFile(file, i) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return;
        }

        var reader = new FileReader();

        reader.onerror = function () {
          return markAsReadAndPasteIfAllFilesAreRead();
        };

        reader.onload = function () {
          var content = reader.result;

          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }

          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };

        reader.readAsText(file);
      };

      for (var i = 0; i < files.length; i++) {
        readTextFromFile(files[i], i);
      }
    } else {
      // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e); // Ensure the editor is re-focused

        setTimeout(function () {
          return cm.display.input.focus();
        }, 20);
        return;
      }

      try {
        var text$1 = e.dataTransfer.getData("Text");

        if (text$1) {
          var selected;

          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }

          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));

          if (selected) {
            for (var i$1 = 0; i$1 < selected.length; ++i$1) {
              _replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
            }
          }

          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e) {}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }

    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove"; // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.

    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason

        img._top = img.offsetTop;
      }

      e.dataTransfer.setDragImage(img, 0, 0);

      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);

    if (!pos) {
      return;
    }

    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);

    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }

    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  } // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.


  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) {
      return;
    }

    var byClass = document.getElementsByClassName("CodeMirror"),
        editors = [];

    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;

      if (cm) {
        editors.push(cm);
      }
    }

    if (editors.length) {
      editors[0].operation(function () {
        for (var i = 0; i < editors.length; i++) {
          f(editors[i]);
        }
      });
    }
  }

  var globalsRegistered = false;

  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }

    registerGlobalHandlers();
    globalsRegistered = true;
  }

  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    }); // When the window loses focus, we want to show the editor as blurred

    on(window, "blur", function () {
      return forEachCodeMirror(onBlur);
    });
  } // Called when the window resizes


  function onResize(cm) {
    var d = cm.display; // Might be a text scaling operation, clear size caches.

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause",
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Ctrl",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Esc",
    32: "Space",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    44: "PrintScrn",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Mod",
    92: "Mod",
    93: "Mod",
    106: "*",
    107: "=",
    109: "-",
    110: ".",
    111: "/",
    145: "ScrollLock",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    63232: "Up",
    63233: "Down",
    63234: "Left",
    63235: "Right",
    63272: "Delete",
    63273: "Home",
    63275: "End",
    63276: "PageUp",
    63277: "PageDown",
    63302: "Insert"
  }; // Number keys

  for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  } // Alphabetic keys


  for (var i$1 = 65; i$1 <= 90; i$1++) {
    keyNames[i$1] = String.fromCharCode(i$1);
  } // Function keys


  for (var i$2 = 1; i$2 <= 12; i$2++) {
    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
  }

  var keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft",
    "Right": "goCharRight",
    "Up": "goLineUp",
    "Down": "goLineDown",
    "End": "goLineEnd",
    "Home": "goLineStartSmart",
    "PageUp": "goPageUp",
    "PageDown": "goPageDown",
    "Delete": "delCharAfter",
    "Backspace": "delCharBefore",
    "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab",
    "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent",
    "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  }; // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.

  keyMap.pcDefault = {
    "Ctrl-A": "selectAll",
    "Ctrl-D": "deleteLine",
    "Ctrl-Z": "undo",
    "Shift-Ctrl-Z": "redo",
    "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart",
    "Ctrl-End": "goDocEnd",
    "Ctrl-Up": "goLineUp",
    "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft",
    "Ctrl-Right": "goGroupRight",
    "Alt-Left": "goLineStart",
    "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore",
    "Ctrl-Delete": "delGroupAfter",
    "Ctrl-S": "save",
    "Ctrl-F": "find",
    "Ctrl-G": "findNext",
    "Shift-Ctrl-G": "findPrev",
    "Shift-Ctrl-F": "replace",
    "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess",
    "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection",
    "Shift-Ctrl-U": "redoSelection",
    "Alt-U": "redoSelection",
    "fallthrough": "basic"
  }; // Very basic readline/emacs-style bindings, which are standard on Mac.

  keyMap.emacsy = {
    "Ctrl-F": "goCharRight",
    "Ctrl-B": "goCharLeft",
    "Ctrl-P": "goLineUp",
    "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight",
    "Alt-B": "goWordLeft",
    "Ctrl-A": "goLineStart",
    "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown",
    "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter",
    "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter",
    "Alt-Backspace": "delWordBefore",
    "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll",
    "Cmd-D": "deleteLine",
    "Cmd-Z": "undo",
    "Shift-Cmd-Z": "redo",
    "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart",
    "Cmd-Up": "goDocStart",
    "Cmd-End": "goDocEnd",
    "Cmd-Down": "goDocEnd",
    "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight",
    "Cmd-Left": "goLineLeft",
    "Cmd-Right": "goLineRight",
    "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter",
    "Alt-Delete": "delGroupAfter",
    "Cmd-S": "save",
    "Cmd-F": "find",
    "Cmd-G": "findNext",
    "Shift-Cmd-G": "findPrev",
    "Cmd-Alt-F": "replace",
    "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess",
    "Cmd-]": "indentMore",
    "Cmd-Backspace": "delWrappedLineLeft",
    "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection",
    "Shift-Cmd-U": "redoSelection",
    "Ctrl-Up": "goDocStart",
    "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;

    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];

      if (/^(cmd|meta|m)$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }

    if (alt) {
      name = "Alt-" + name;
    }

    if (ctrl) {
      name = "Ctrl-" + name;
    }

    if (cmd) {
      name = "Cmd-" + name;
    }

    if (shift) {
      name = "Shift-" + name;
    }

    return name;
  } // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.


  function normalizeKeyMap(keymap) {
    var copy = {};

    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];

        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
          continue;
        }

        if (value == "...") {
          delete keymap[keyname];
          continue;
        }

        var keys = map(keyname.split(" "), normalizeKeyName);

        for (var i = 0; i < keys.length; i++) {
          var val = void 0,
              name = void 0;

          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }

          var prev = copy[name];

          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }

        delete keymap[keyname];
      }
    }

    for (var prop in copy) {
      keymap[prop] = copy[prop];
    }

    return keymap;
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];

    if (found === false) {
      return "nothing";
    }

    if (found === "...") {
      return "multi";
    }

    if (found != null && handle(found)) {
      return "handled";
    }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]") {
        return lookupKey(key, map.fallthrough, handle, context);
      }

      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);

        if (result) {
          return result;
        }
      }
    }
  } // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.


  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }

  function addModifierNames(name, event, noShift) {
    var base = name;

    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }

    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }

    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
      name = "Cmd-" + name;
    }

    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }

    return name;
  } // Look up the name of a key as indicated by an event object.


  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }

    var name = keyNames[event.keyCode];

    if (name == null || event.altGraphKey) {
      return false;
    } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)


    if (event.keyCode == 3 && event.code) {
      name = event.code;
    }

    return addModifierNames(name, event, noShift);
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  } // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.


  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges,
        kill = []; // Build up a set of ranges to kill first, merging overlapping
    // ranges.

    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);

      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();

        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }

      kill.push(toKill);
    } // Next, remove those actual ranges.


    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--) {
        _replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      }

      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target;
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") {
        dir = -dir;
      }

      var order = getOrder(lineObj, cm.doc.direction);

      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = dir < 0 == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).

        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) {
            return measureCharPrepared(cm, prep, ch).top == targetTop;
          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);

          if (sticky == "before") {
            ch = moveCharLogically(lineObj, ch, 1);
          }
        } else {
          ch = dir < 0 ? part.to : part.from;
        }

        return new Pos(lineNo, ch, sticky);
      }
    }

    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);

    if (!bidi) {
      return moveLogically(line, start, dir);
    }

    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }

    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
        part = bidi[partPos];

    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir);
    }

    var mv = function mv(pos, dir) {
      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
    };

    var prep;

    var getWrappedLineExtent = function getWrappedLineExtent(ch) {
      if (!cm.options.lineWrapping) {
        return {
          begin: 0,
          end: line.text.length
        };
      }

      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch);
    };

    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = part.level == 1 == dir < 0;
      var ch = mv(start, moveInStorageOrder ? 1 : -1);

      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky);
      }
    } // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part


    var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent) {
      var getRes = function getRes(ch, moveInStorageOrder) {
        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
      };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = dir > 0 == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);

        if (part.from <= ch && ch < part.to) {
          return getRes(ch, moveInStorageOrder);
        }

        ch = moveInStorageOrder ? part.from : mv(part.to, -1);

        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
          return getRes(ch, moveInStorageOrder);
        }
      }
    }; // Case 3a: Look for other bidi parts on the same visual line


    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);

    if (res) {
      return res;
    } // Case 3b: Look for other bidi parts on the next visual line


    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);

    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));

      if (res) {
        return res;
      }
    } // Case 4: Nowhere to move


    return null;
  } // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.


  var commands = {
    selectAll: selectAll,
    singleSelection: function singleSelection(cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function killLine(cm) {
      return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;

          if (range.head.ch == len && range.head.line < cm.lastLine()) {
            return {
              from: range.head,
              to: Pos(range.head.line + 1, 0)
            };
          } else {
            return {
              from: range.head,
              to: Pos(range.head.line, len)
            };
          }
        } else {
          return {
            from: range.from(),
            to: range.to()
          };
        }
      });
    },
    deleteLine: function deleteLine(cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function delLineLeft(cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: range.from()
        };
      });
    },
    delWrappedLineLeft: function delWrappedLineLeft(cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");
        return {
          from: leftPos,
          to: range.from()
        };
      });
    },
    delWrappedLineRight: function delWrappedLineRight(cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
        return {
          from: range.from(),
          to: rightPos
        };
      });
    },
    undo: function undo(cm) {
      return cm.undo();
    },
    redo: function redo(cm) {
      return cm.redo();
    },
    undoSelection: function undoSelection(cm) {
      return cm.undoSelection();
    },
    redoSelection: function redoSelection(cm) {
      return cm.redoSelection();
    },
    goDocStart: function goDocStart(cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function goDocEnd(cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function goLineStart(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStart(cm, range.head.line);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineStartSmart: function goLineStartSmart(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStartSmart(cm, range.head);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineEnd: function goLineEnd(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineEnd(cm, range.head.line);
      }, {
        origin: "+move",
        bias: -1
      });
    },
    goLineRight: function goLineRight(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeft: function goLineLeft(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: 0,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function goLineLeftSmart(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");

        if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
          return lineStartSmart(cm, range.head);
        }

        return pos;
      }, sel_move);
    },
    goLineUp: function goLineUp(cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function goLineDown(cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function goPageUp(cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function goPageDown(cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function goCharLeft(cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function goCharRight(cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function goColumnLeft(cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function goColumnRight(cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function goWordLeft(cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function goGroupRight(cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function goGroupLeft(cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function goWordRight(cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function delCharBefore(cm) {
      return cm.deleteH(-1, "char");
    },
    delCharAfter: function delCharAfter(cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function delWordBefore(cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function delWordAfter(cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function delGroupBefore(cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function delGroupAfter(cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function indentAuto(cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function indentMore(cm) {
      return cm.indentSelection("add");
    },
    indentLess: function indentLess(cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function insertTab(cm) {
      return cm.replaceSelection("\t");
    },
    insertSoftTab: function insertSoftTab(cm) {
      var spaces = [],
          ranges = cm.listSelections(),
          tabSize = cm.options.tabSize;

      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }

      cm.replaceSelections(spaces);
    },
    defaultTab: function defaultTab(cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function transposeChars(cm) {
      return runInOp(cm, function () {
        var ranges = cm.listSelections(),
            newSel = [];

        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) {
            continue;
          }

          var cur = ranges[i].head,
              line = getLine(cm.doc, cur.line).text;

          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }

            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;

              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }

          newSel.push(new Range(cur, cur));
        }

        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function newlineAndIndent(cm) {
      return runInOp(cm, function () {
        var sels = cm.listSelections();

        for (var i = sels.length - 1; i >= 0; i--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
        }

        sels = cm.listSelections();

        for (var i$1 = 0; i$1 < sels.length; i$1++) {
          cm.indentLine(sels[i$1].from().line, null, true);
        }

        ensureCursorVisible(cm);
      });
    },
    openLine: function openLine(cm) {
      return cm.replaceSelection("\n", "start");
    },
    toggleOverwrite: function toggleOverwrite(cm) {
      return cm.toggleOverwrite();
    }
  };

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);

    if (visual != line) {
      lineN = lineNo(visual);
    }

    return endOfLine(true, cm, visual, lineN, 1);
  }

  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);

    if (visual != line) {
      lineN = lineNo(visual);
    }

    return endOfLine(true, cm, line, lineN, -1);
  }

  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);

    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
    }

    return start;
  } // Run a handler that was bound to a key.


  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];

      if (!bound) {
        return false;
      }
    } // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document


    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift,
        done = false;

    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }

      if (dropShift) {
        cm.display.shift = false;
      }

      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }

    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);

      if (result) {
        return result;
      }
    }

    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  } // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.


  var stopSeq = new Delayed();

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;

    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }

      if (/\'$/.test(name)) {
        cm.state.keySeq = null;
      } else {
        stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }

      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
        return true;
      }
    }

    return dispatchKeyInner(cm, name, e, handle);
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi") {
      cm.state.keySeq = name;
    }

    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result;
  } // Handle a key from the keydown event.


  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);

    if (!name) {
      return false;
    }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function (b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function (b) {
        return doHandleBinding(cm, b);
      });
    }
  } // Handle a key from the keypress event


  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) {
      return doHandleBinding(cm, b, true);
    });
  }

  var lastStoppedKey = null;

  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();

    if (signalDOMEvent(cm, e)) {
      return;
    } // IE does strange things with escape.


    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }

    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);

    if (presto) {
      lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo

      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    }

    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
      document.execCommand("cut");
    } // Turn mouse into crosshair when Alt is held on Mac.


    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }

    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }

    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;

    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }

    var keyCode = e.keyCode,
        charCode = e.charCode;

    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }

    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }

    var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace

    if (ch == "\x08") {
      return;
    }

    if (handleCharBinding(cm, e, ch)) {
      return;
    }

    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function PastClick(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  };

  var lastClick, lastDoubleClick;

  function clickRepeat(pos, button) {
    var now = +new Date();

    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple";
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double";
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single";
    }
  } // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.


  function onMouseDown(e) {
    var cm = this,
        display = cm.display;

    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }

    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () {
          return display.scroller.draggable = true;
        }, 100);
      }

      return;
    }

    if (clickInGutter(cm, e)) {
      return;
    }

    var pos = posFromMouse(cm, e),
        button = e_button(e),
        repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus(); // #3261: make sure, that we're not starting a second selection

    if (button == 1 && cm.state.selectingText) {
      cm.state.selectingText(e);
    }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
      return;
    }

    if (button == 1) {
      if (pos) {
        leftButtonDown(cm, pos, repeat, e);
      } else if (e_target(e) == display.scroller) {
        e_preventDefault(e);
      }
    } else if (button == 2) {
      if (pos) {
        extendSelection(cm.doc, pos);
      }

      setTimeout(function () {
        return display.input.focus();
      }, 20);
    } else if (button == 3) {
      if (captureRightClick) {
        cm.display.input.onContextMenu(e);
      } else {
        delayBlurEvent(cm);
      }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";

    if (repeat == "double") {
      name = "Double" + name;
    } else if (repeat == "triple") {
      name = "Triple" + name;
    }

    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") {
        bound = commands[bound];
      }

      if (!bound) {
        return false;
      }

      var done = false;

      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }

        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }

      return done;
    });
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};

    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }

    if (value.extend == null || cm.doc.extend) {
      value.extend = cm.doc.extend || event.shiftKey;
    }

    if (value.addNew == null) {
      value.addNew = mac ? event.metaKey : event.ctrlKey;
    }

    if (value.moveOnDrag == null) {
      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
    }

    return value;
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt();
    }

    var behavior = configureMouse(cm, repeat, event);
    var sel = cm.doc.sel,
        contained;

    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
      leftButtonStartDrag(cm, event, pos, behavior);
    } else {
      leftButtonSelect(cm, event, pos, behavior);
    }
  } // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.


  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display,
        moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) {
        display.scroller.draggable = false;
      }

      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);

      if (!moved) {
        e_preventDefault(e);

        if (!behavior.addNew) {
          extendSelection(cm.doc, pos, null, null, behavior.extend);
        } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)


        if (webkit || ie && ie_version == 9) {
          setTimeout(function () {
            display.wrapper.ownerDocument.body.focus();
            display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });

    var mouseMove = function mouseMove(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };

    var dragStart = function dragStart() {
      return moved = true;
    }; // Let the drag handler handle this.


    if (webkit) {
      display.scroller.draggable = true;
    }

    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag; // IE's approach to draggable

    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }

    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);
    delayBlurEvent(cm);
    setTimeout(function () {
      return display.input.focus();
    }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") {
      return new Range(pos, pos);
    }

    if (unit == "word") {
      return cm.findWordAt(pos);
    }

    if (unit == "line") {
      return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
    }

    var result = unit(cm, pos);
    return new Range(result.from, result.to);
  } // Normal selection, as opposed to text dragging.


  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display,
        doc = cm.doc;
    e_preventDefault(event);
    var ourRange,
        ourIndex,
        startSel = doc.sel,
        ranges = startSel.ranges;

    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);

      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) {
        ourRange = new Range(start, start);
      }

      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);

      if (behavior.extend) {
        ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);
      } else {
        ourRange = range;
      }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {
        scroll: false,
        origin: "*mouse"
      });
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
        scroll: false,
        origin: "*mouse"
      });
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;

    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }

      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [],
            tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol),
            right = Math.max(startCol, posCol);

        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc, line).text,
              leftPos = findColumn(text, left, tabSize);

          if (left == right) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }

        if (!ranges.length) {
          ranges.push(new Range(start, start));
        }

        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
          origin: "*mouse",
          scroll: false
        });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor,
            head;

        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }

        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).

    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");

      if (!cur) {
        return;
      }

      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);

        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function () {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;

        if (outside) {
          setTimeout(operation(cm, function () {
            if (counter != curCount) {
              return;
            }

            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity; // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.

      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }

      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  } // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.


  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);

    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
      return range;
    }

    var order = getOrder(anchorLine);

    if (!order) {
      return range;
    }

    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
        part = order[index];

    if (part.from != anchor.ch && part.to != anchor.ch) {
      return range;
    }

    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);

    if (boundary == 0 || boundary == order.length) {
      return range;
    } // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)


    var leftSide;

    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);

      if (headIndex == boundary - 1 || headIndex == boundary) {
        leftSide = dir < 0;
      } else {
        leftSide = dir > 0;
      }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to,
        sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);
  } // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.


  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;

    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try {
        mX = e.clientX;
        mY = e.clientY;
      } catch (e) {
        return false;
      }
    }

    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }

    if (prevent) {
      e_preventDefault(e);
    }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) {
      return e_defaultPrevented(e);
    }

    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];

      if (g && g.getBoundingClientRect().right >= mX) {
        var line = _lineAtHeight(cm.doc, mY);

        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  } // CONTEXT MENU HANDLING
  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.


  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }

    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }

    if (!captureRightClick) {
      cm.display.input.onContextMenu(e);
    }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }

    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {
    toString: function toString() {
      return "CodeMirror.Init";
    }
  };
  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;

      if (handle) {
        optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }

    CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.

    CodeMirror.Init = Init; // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.

    option("value", "", function (cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);
    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;

      if (!val) {
        return;
      }

      var newBreaks = [],
          lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);

          if (found == -1) {
            break;
          }

          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }

        lineNo++;
      });

      for (var i = newBreaks.length - 1; i >= 0; i--) {
        _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");

      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("autocorrect", false, function (cm, val) {
      return cm.getInputField().autocorrect = val;
    }, true);
    option("autocapitalize", false, function (cm, val) {
      return cm.getInputField().autocapitalize = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);
    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);

      if (prev && prev.detach) {
        prev.detach(cm, next);
      }

      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);
    option("configureMouse", null);
    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) {
      return integer;
    }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);
    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);
    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }

      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);
    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });
    option("tabindex", null, function (cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) {
      return cm.doc.setDirection(val);
    }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;

    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }

    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      return updateScrollbars(cm);
    }, 100);
  } // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.


  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) {
      return new CodeMirror(place, options);
    }

    this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.

    copyObj(defaults, options, false);
    var doc = options.value;

    if (typeof doc == "string") {
      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
    } else if (options.mode) {
      doc.modeOption = options.mode;
    }

    this.doc = doc;
    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);

    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }

    initScrollbars(this);
    this.state = {
      keyMaps: [],
      // stores maps added by addKeyMap
      overlays: [],
      // highlighting overlays, as added by addOverlay
      modeGen: 0,
      // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false,
      // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1,
      cutIncoming: -1,
      // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(),
      // stores highlight worker timeout
      keySeq: null,
      // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) {
      display.input.focus();
    } // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload


    if (ie && ie_version < 11) {
      setTimeout(function () {
        return this$1.display.input.reset(true);
      }, 20);
    }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    _startOperation(this);

    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(bind(onFocus, this), 20);
    } else {
      onBlur(this);
    }

    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this, options[opt], Init);
      }
    }

    maybeUpdateLineNumberWidth(this);

    if (options.finishInit) {
      options.finishInit(this);
    }

    for (var i = 0; i < initHooks.length; ++i) {
      initHooks[i](this);
    }

    _endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.


    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  } // The default configuration options.


  CodeMirror.defaults = defaults; // Functions to run when options are changed.

  CodeMirror.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor

  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click

    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }

        var pos = posFromMouse(cm, e);

        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }

        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function (e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    } // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.


    on(d.scroller, "contextmenu", function (e) {
      return onContextMenu(cm, e);
    });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) {
        onContextMenu(cm, e);
      }
    }); // Used to suppress mouse event handling when a touch happens

    var touchFinished,
        prevTouch = {
      end: 0
    };

    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () {
          return d.activeTouch = null;
        }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date();
      }
    }

    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }

      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }

    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }

      var dx = other.left - touch.left,
          dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }

    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date();
        d.activeTouch = {
          start: now,
          moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null
        };

        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;

      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"),
            range;

        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          {
            range = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          {
            range = cm.findWordAt(pos);
          } else // Triple tap
          {
            range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }

        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }

      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch); // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.

    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    }); // Listen to wheel events in order to try and update the viewport on time.

    on(d.scroller, "mousewheel", function (e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function (e) {
      return onScrollWheel(cm, e);
    }); // Prevent wrapper from ever scrolling

    on(d.wrapper, "scroll", function () {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    d.dragFunctions = {
      enter: function enter(e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function over(e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);
          e_stop(e);
        }
      },
      start: function start(e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function leave(e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };
    var inp = d.input.getField();
    on(inp, "keyup", function (e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function (e) {
      return onBlur(cm, e);
    });
  }

  var initHooks = [];

  CodeMirror.defineInitHook = function (f) {
    return initHooks.push(f);
  }; // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.


  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc,
        state;

    if (how == null) {
      how = "add";
    }

    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) {
        how = "prev";
      } else {
        state = getContextBefore(cm, n).state;
      }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n),
        curSpace = countColumn(line.text, null, tabSize);

    if (line.stateAfter) {
      line.stateAfter = null;
    }

    var curSpaceString = line.text.match(/^\s*/)[0],
        indentation;

    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);

      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }

        how = "prev";
      }
    }

    if (how == "prev") {
      if (n > doc.first) {
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }

    indentation = Math.max(0, indentation);
    var indentString = "",
        pos = 0;

    if (cm.options.indentWithTabs) {
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += "\t";
      }
    }

    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }

    if (indentString != curSpaceString) {
      _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");

      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];

        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break;
        }
      }
    }
  } // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.


  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;

    if (!sel) {
      sel = doc.sel;
    }

    var recent = +new Date() - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted),
        multiPaste = null; // When pasting N lines into N selections, insert one line per selection

    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];

          for (var i = 0; i < lastCopied.text.length; i++) {
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
          }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) {
          return [l];
        });
      }
    }

    var updateInput = cm.curOp.updateInput; // Normal behavior is to insert the new text into every selection

    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(),
          to = range.to();

      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) // Handle overwrite
          {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
          from = to = Pos(from.line, 0);
        }
      }

      var changeEvent = {
        from: from,
        to: to,
        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
      };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }

    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }

    ensureCursorVisible(cm);

    if (cm.curOp.updateInput < 2) {
      cm.curOp.updateInput = updateInput;
    }

    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");

    if (pasted) {
      e.preventDefault();

      if (!cm.isReadOnly() && !cm.options.disableInput) {
        runInOp(cm, function () {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }

      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }

    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];

      if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {
        continue;
      }

      var mode = cm.getModeAt(range.head);
      var indented = false;

      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {
          indented = indentLine(cm, range.head.line, "smart");
        }
      }

      if (indented) {
        signalLater(cm, "electricInput", cm, range.head.line);
      }
    }
  }

  function copyableRanges(cm) {
    var text = [],
        ranges = [];

    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {
        anchor: Pos(line, 0),
        head: Pos(line + 1, 0)
      };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }

    return {
      text: text,
      ranges: ranges
    };
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.

    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    } // If border: 0; -- iOS fails to open keyboard (issue #1287)


    if (ios) {
      te.style.border = "1px solid black";
    }

    disableBrowserMagic(te);
    return div;
  } // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.
  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.


  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;
    var helpers = CodeMirror.helpers = {};
    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function focus() {
        window.focus();
        this.display.input.focus();
      },
      setOption: function setOption(option, value) {
        var options = this.options,
            old = options[option];

        if (options[option] == value && option != "mode") {
          return;
        }

        options[option] = value;

        if (optionHandlers.hasOwnProperty(option)) {
          operation(this, optionHandlers[option])(this, value, old);
        }

        signal(this, "optionChange", this, option);
      },
      getOption: function getOption(option) {
        return this.options[option];
      },
      getDoc: function getDoc() {
        return this.doc;
      },
      addKeyMap: function addKeyMap(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function removeKeyMap(map) {
        var maps = this.state.keyMaps;

        for (var i = 0; i < maps.length; ++i) {
          if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true;
          }
        }
      },
      addOverlay: methodOp(function (spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);

        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }

        insertSorted(this.state.overlays, {
          mode: mode,
          modeSpec: spec,
          opaque: options && options.opaque,
          priority: options && options.priority || 0
        }, function (overlay) {
          return overlay.priority;
        });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function (spec) {
        var overlays = this.state.overlays;

        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;

          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return;
          }
        }
      }),
      indentLine: methodOp(function (n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }

        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function (how) {
        var ranges = this.doc.sel.ranges,
            end = -1;

        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];

          if (!range.empty()) {
            var from = range.from(),
                to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;

            for (var j = start; j < end; ++j) {
              indentLine(this, j, how);
            }

            var newRanges = this.doc.sel.ranges;

            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
              replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;

            if (i == this.doc.sel.primIndex) {
              ensureCursorVisible(this);
            }
          }
        }
      }),
      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function getTokenAt(pos, precise) {
        return takeToken(this, pos, precise);
      },
      getLineTokens: function getLineTokens(line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },
      getTokenTypeAt: function getTokenTypeAt(pos) {
        pos = _clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0,
            after = (styles.length - 1) / 2,
            ch = pos.ch;
        var type;

        if (ch == 0) {
          type = styles[2];
        } else {
          for (;;) {
            var mid = before + after >> 1;

            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type = styles[mid * 2 + 2];
              break;
            }
          }
        }

        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
      },
      getModeAt: function getModeAt(pos) {
        var mode = this.doc.mode;

        if (!mode.innerMode) {
          return mode;
        }

        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
      },
      getHelper: function getHelper(pos, type) {
        return this.getHelpers(pos, type)[0];
      },
      getHelpers: function getHelpers(pos, type) {
        var found = [];

        if (!helpers.hasOwnProperty(type)) {
          return found;
        }

        var help = helpers[type],
            mode = this.getModeAt(pos);

        if (typeof mode[type] == "string") {
          if (help[mode[type]]) {
            found.push(help[mode[type]]);
          }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];

            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }

        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];

          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }

        return found;
      },
      getStateAfter: function getStateAfter(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state;
      },
      cursorCoords: function cursorCoords(start, mode) {
        var pos,
            range = this.doc.sel.primary();

        if (start == null) {
          pos = range.head;
        } else if (typeof start == "object") {
          pos = _clipPos(this.doc, start);
        } else {
          pos = start ? range.from() : range.to();
        }

        return _cursorCoords(this, pos, mode || "page");
      },
      charCoords: function charCoords(pos, mode) {
        return _charCoords(this, _clipPos(this.doc, pos), mode || "page");
      },
      coordsChar: function coordsChar(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return _coordsChar(this, coords.left, coords.top);
      },
      lineAtHeight: function lineAtHeight(height, mode) {
        height = fromCoordSystem(this, {
          top: height,
          left: 0
        }, mode || "page").top;
        return _lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function heightAtLine(line, mode, includeWidgets) {
        var end = false,
            lineObj;

        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;

          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;
            end = true;
          }

          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }

        return intoCoordSystem(this, lineObj, {
          top: 0,
          left: 0
        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);
      },
      defaultTextHeight: function defaultTextHeight() {
        return textHeight(this.display);
      },
      defaultCharWidth: function defaultCharWidth() {
        return charWidth(this.display);
      },
      getViewport: function getViewport() {
        return {
          from: this.display.viewFrom,
          to: this.display.viewTo
        };
      },
      addWidget: function addWidget(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = _cursorCoords(this, _clipPos(this.doc, pos));
        var top = pos.bottom,
            left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);

        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below

          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }

          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }

        node.style.top = top + "px";
        node.style.left = node.style.right = "";

        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }

          node.style.left = left + "px";
        }

        if (scroll) {
          scrollIntoView(this, {
            left: left,
            top: top,
            right: left + node.offsetWidth,
            bottom: top + node.offsetHeight
          });
        }
      },
      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),
      execCommand: function execCommand(cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },
      triggerElectric: methodOp(function (text) {
        triggerElectric(this, text);
      }),
      findPosH: function findPosH(from, amount, unit, visually) {
        var dir = 1;

        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }

        var cur = _clipPos(this.doc, from);

        for (var i = 0; i < amount; ++i) {
          cur = _findPosH(this.doc, cur, dir, unit, visually);

          if (cur.hitSide) {
            break;
          }
        }

        return cur;
      },
      moveH: methodOp(function (dir, unit) {
        var this$1 = this;
        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty()) {
            return _findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range.from() : range.to();
          }
        }, sel_move);
      }),
      deleteH: methodOp(function (dir, unit) {
        var sel = this.doc.sel,
            doc = this.doc;

        if (sel.somethingSelected()) {
          doc.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function (range) {
            var other = _findPosH(doc, range.head, dir, unit, false);

            return dir < 0 ? {
              from: other,
              to: range.head
            } : {
              from: range.head,
              to: other
            };
          });
        }
      }),
      findPosV: function findPosV(from, amount, unit, goalColumn) {
        var dir = 1,
            x = goalColumn;

        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }

        var cur = _clipPos(this.doc, from);

        for (var i = 0; i < amount; ++i) {
          var coords = _cursorCoords(this, cur, "div");

          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }

          cur = _findPosV(this, coords, dir, unit);

          if (cur.hitSide) {
            break;
          }
        }

        return cur;
      },
      moveV: methodOp(function (dir, unit) {
        var this$1 = this;
        var doc = this.doc,
            goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse) {
            return dir < 0 ? range.from() : range.to();
          }

          var headPos = _cursorCoords(this$1, range.head, "div");

          if (range.goalColumn != null) {
            headPos.left = range.goalColumn;
          }

          goals.push(headPos.left);

          var pos = _findPosV(this$1, headPos, dir, unit);

          if (unit == "page" && range == doc.sel.primary()) {
            addToScrollTop(this$1, _charCoords(this$1, pos, "div").top - headPos.top);
          }

          return pos;
        }, sel_move);

        if (goals.length) {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            doc.sel.ranges[i].goalColumn = goals[i];
          }
        }
      }),
      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function findWordAt(pos) {
        var doc = this.doc,
            line = getLine(doc, pos.line).text;
        var start = pos.ch,
            end = pos.ch;

        if (line) {
          var helper = this.getHelper(pos, "wordChars");

          if ((pos.sticky == "before" || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }

          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function (ch) {
            return isWordChar(ch, helper);
          } : /\s/.test(startChar) ? function (ch) {
            return /\s/.test(ch);
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };

          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }

          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }

        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },
      toggleOverwrite: function toggleOverwrite(value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }

        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function hasFocus() {
        return this.display.input.getField() == activeElt();
      },
      isReadOnly: function isReadOnly() {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },
      scrollTo: methodOp(function (x, y) {
        scrollToCoords(this, x, y);
      }),
      getScrollInfo: function getScrollInfo() {
        var scroller = this.display.scroller;
        return {
          left: scroller.scrollLeft,
          top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this),
          clientWidth: displayWidth(this)
        };
      },
      scrollIntoView: methodOp(function (range, margin) {
        if (range == null) {
          range = {
            from: this.doc.sel.primary().head,
            to: null
          };

          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range == "number") {
          range = {
            from: Pos(range, 0),
            to: null
          };
        } else if (range.from == null) {
          range = {
            from: range,
            to: null
          };
        }

        if (!range.to) {
          range.to = range.from;
        }

        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),
      setSize: methodOp(function (width, height) {
        var this$1 = this;

        var interpret = function interpret(val) {
          return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
        };

        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }

        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }

        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }

        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].noHScroll) {
                regLineChange(this$1, lineNo, "widget");
                break;
              }
            }
          }

          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),
      operation: function operation(f) {
        return runInOp(this, f);
      },
      startOperation: function startOperation() {
        return _startOperation(this);
      },
      endOperation: function endOperation() {
        return _endOperation(this);
      },
      refresh: methodOp(function () {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);

        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
          estimateLineHeights(this);
        }

        signal(this, "refresh", this);
      }),
      swapDoc: methodOp(function (doc) {
        var old = this.doc;
        old.cm = null; // Cancel the current text selection if any (#5821)

        if (this.state.selectingText) {
          this.state.selectingText();
        }

        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),
      phrase: function phrase(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
      },
      getInputField: function getInputField() {
        return this.display.input.getField();
      },
      getWrapperElement: function getWrapperElement() {
        return this.display.wrapper;
      },
      getScrollerElement: function getScrollerElement() {
        return this.display.scroller;
      },
      getGutterElement: function getGutterElement() {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function (type, name, value) {
      if (!helpers.hasOwnProperty(type)) {
        helpers[type] = CodeMirror[type] = {
          _global: []
        };
      }

      helpers[type][name] = value;
    };

    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);

      helpers[type]._global.push({
        pred: predicate,
        val: value
      });
    };
  } // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.


  function _findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;

    function findNextLine() {
      var l = pos.line + lineDir;

      if (l < doc.first || l >= doc.first + doc.size) {
        return false;
      }

      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l);
    }

    function moveOnce(boundToLine) {
      var next;

      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }

      if (next == null) {
        if (!boundToLine && findNextLine()) {
          pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
        } else {
          return false;
        }
      } else {
        pos = next;
      }

      return true;
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null,
          group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");

      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }

        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";

        if (group && !first && !type) {
          type = "s";
        }

        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
            pos.sticky = "after";
          }

          break;
        }

        if (type) {
          sawType = type;
        }

        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }

    var result = skipAtomic(doc, pos, oldPos, origDir, true);

    if (equalCursorPos(oldPos, result)) {
      result.hitSide = true;
    }

    return result;
  } // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.


  function _findPosV(cm, pos, dir, unit) {
    var doc = cm.doc,
        x = pos.left,
        y;

    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }

    var target;

    for (;;) {
      target = _coordsChar(cm, x, y);

      if (!target.outside) {
        break;
      }

      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }

      y += dir * 5;
    }

    return target;
  } // CONTENTEDITABLE INPUT STYLE


  var ContentEditableInput = function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
        cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      } // IE doesn't fire input events, so we schedule a read for the pasted content in this way


      if (ie_version <= 11) {
        setTimeout(operation(cm, function () {
          return this$1.updateFromDOM();
        }), 20);
      }
    });
    on(div, "compositionstart", function (e) {
      this$1.composing = {
        data: e.data,
        done: false
      };
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) {
        this$1.composing = {
          data: e.data,
          done: false
        };
      }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) {
          this$1.readFromDOMSoon();
        }

        this$1.composing.done = true;
      }
    });
    on(div, "touchstart", function () {
      return input.forceCompositionEnd();
    });
    on(div, "input", function () {
      if (!this$1.composing) {
        this$1.readFromDOMSoon();
      }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }

      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });

        if (e.type == "cut") {
          cm.replaceSelection("", null, "cut");
        }
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });

        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }

      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n"); // iOS exposes the clipboard API, but seems to discard content inserted into it

        e.clipboardData.setData("Text", content);

        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      } // Old-fashioned briefly-focus-a-textarea hack


      var kludge = hiddenTextarea(),
          te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();

        if (hadFocus == div) {
          input.showPrimarySelection();
        }
      }, 50);
    }

    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = document.activeElement == this.div;
    return result;
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) {
      return;
    }

    if (info.focus || takeFocus) {
      this.showPrimarySelection();
    }

    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(),
        cm = this.cm,
        prim = cm.doc.sel.primary();
    var from = prim.from(),
        to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);

    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
      return;
    }

    var view = cm.display.view;
    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
      node: view[0].measure.map[2],
      offset: 0
    };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);

    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {
        node: map[map.length - 1],
        offset: map[map.length - 2] - map[map.length - 3]
      };
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return;
    }

    var old = sel.rangeCount && sel.getRangeAt(0),
        rng;

    try {
      rng = range(start.node, start.offset, end.offset, end.node);
    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible


    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);

        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }

      if (old && sel.anchorNode == null) {
        sel.addRange(old);
      } else if (gecko) {
        this.startGracePeriod();
      }
    }

    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;
    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;

      if (this$1.selectionChanged()) {
        this$1.cm.operation(function () {
          return this$1.cm.curOp.selectionChanged = true;
        });
      }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode;
    this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;
    this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();

    if (!sel.rangeCount) {
      return false;
    }

    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node);
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || document.activeElement != this.div) {
        this.showSelection(this.prepareSelection(), true);
      }

      this.div.focus();
    }
  };

  ContentEditableInput.prototype.blur = function () {
    this.div.blur();
  };

  ContentEditableInput.prototype.getField = function () {
    return this.div;
  };

  ContentEditableInput.prototype.supportsTouch = function () {
    return true;
  };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;

    if (this.selectionInEditor()) {
      this.pollSelection();
    } else {
      runInOp(this.cm, function () {
        return input.cm.curOp.selectionChanged = true;
      });
    }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }

    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
      return;
    }

    var sel = this.getSelection(),
        cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.

    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({
        type: "keydown",
        keyCode: 8,
        preventDefault: Math.abs
      });
      this.blur();
      this.focus();
      return;
    }

    if (this.composing) {
      return;
    }

    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);

    if (anchor && head) {
      runInOp(cm, function () {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);

        if (anchor.bad || head.bad) {
          cm.curOp.selectionChanged = true;
        }
      });
    }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm,
        display = cm.display,
        sel = cm.doc.sel.primary();
    var from = sel.from(),
        to = sel.to();

    if (from.ch == 0 && from.line > cm.firstLine()) {
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    }

    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
      to = Pos(to.line + 1, 0);
    }

    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
      return false;
    }

    var fromIndex, fromLine, fromNode;

    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }

    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;

    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) {
      return false;
    }

    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));

    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();
        oldText.pop();
        toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();
        oldText.shift();
        fromLine++;
      } else {
        break;
      }
    }

    var cutFront = 0,
        cutEnd = 0;
    var newTop = newText[0],
        oldTop = oldText[0],
        maxCutFront = Math.min(newTop.length, oldTop.length);

    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
      ++cutFront;
    }

    var newBot = lst(newText),
        oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));

    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      ++cutEnd;
    } // Try to move start of change to start of selection if ambiguous


    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);

    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      _replaceRange(cm.doc, newText, chFrom, chTo, "+input");

      return true;
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };

  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };

  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) {
      return;
    }

    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };

  ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;

    if (this.readDOMTimeout != null) {
      return;
    }

    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;

      if (this$1.composing) {
        if (this$1.composing.done) {
          this$1.composing = null;
        } else {
          return;
        }
      }

      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent()) {
      runInOp(this.cm, function () {
        return regChange(this$1.cm);
      });
    }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) {
      return;
    }

    e.preventDefault();

    if (!this.cm.isReadOnly()) {
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};

  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);

    if (!view || view.hidden) {
      return null;
    }

    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);
    var order = getOrder(line, cm.doc.direction),
        side = "left";

    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }

    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) {
      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
        return true;
      }
    }

    return false;
  }

  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }

    return pos;
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "",
        closing = false,
        lineSep = cm.doc.lineSeparator(),
        extraLinebreak = false;

    function recognizeMarker(id) {
      return function (marker) {
        return marker.id == id;
      };
    }

    function close() {
      if (closing) {
        text += lineSep;

        if (extraLinebreak) {
          text += lineSep;
        }

        closing = extraLinebreak = false;
      }
    }

    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }

    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");

        if (cmText) {
          addText(cmText);
          return;
        }

        var markerID = node.getAttribute("cm-marker"),
            range;

        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));

          if (found.length && (range = found[0].find(0))) {
            addText(getBetween(cm.doc, range.from, range.to).join(lineSep));
          }

          return;
        }

        if (node.getAttribute("contenteditable") == "false") {
          return;
        }

        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);

        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
          return;
        }

        if (isBlock) {
          close();
        }

        for (var i = 0; i < node.childNodes.length; i++) {
          walk(node.childNodes[i]);
        }

        if (/^(pre|p)$/i.test(node.nodeName)) {
          extraLinebreak = true;
        }

        if (isBlock) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }

    for (;;) {
      walk(from);

      if (from == to) {
        break;
      }

      from = from.nextSibling;
      extraLinebreak = false;
    }

    return text;
  }

  function domToPos(cm, node, offset) {
    var lineNode;

    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];

      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }

      node = null;
      offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }

        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }

    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];

      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild,
        bad = false;

    if (!node || !contains(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }

    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;

      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null,
        topNode = node;

    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;

      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }

    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }

    var measure = lineView.measure,
        maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];

        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];

          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;

            if (offset < 0 || curNode != textNode) {
              ch = map[j + (offset ? 1 : 0)];
            }

            return Pos(line, ch);
          }
        }
      }
    }

    var found = find(textNode, topNode, offset);

    if (found) {
      return badPos(found, bad);
    } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems


    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);

      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }

    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);

      if (found) {
        return badPos(Pos(found.line, found.ch + dist$1), bad);
      } else {
        dist$1 += before.textContent.length;
      }
    }
  } // TEXTAREA INPUT STYLE


  var TextareaInput = function TextareaInput(cm) {
    this.cm = cm; // See input.poll and input.reset

    this.prevInput = ""; // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.

    this.pollingFast = false; // Self-resetting timeout for the poller

    this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea

    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
        cm = this.cm;
    this.createField(display);
    var te = this.textarea;
    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)

    if (ios) {
      te.style.width = "0px";
    }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) {
        this$1.hasSelection = null;
      }

      input.poll();
    });
    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }

      cm.state.pasteIncoming = +new Date();
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }

      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });

        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }

      if (e.type == "cut") {
        cm.state.cutIncoming = +new Date();
      }
    }

    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);
    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
        return;
      }

      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date();
        input.focus();
        return;
      } // Pass the `paste` event to the textarea so it's handled by its event listener.


      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    }); // Prevent normal selection in the editor (we handle our own)

    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) {
        e_preventDefault(e);
      }
    });
    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");

      if (input.composing) {
        input.composing.range.clear();
      }

      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        })
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is
    // focused, and receives input.

    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm,
        display = cm.display,
        doc = cm.doc;
    var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts

    if (cm.options.moveInputWithCursor) {
      var headPos = _cursorCoords(cm, doc.sel.primary().head, "div");

      var wrapOff = display.wrapper.getBoundingClientRect(),
          lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
    }

    return result;
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm,
        display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);

    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  }; // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)


  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) {
      return;
    }

    var cm = this.cm;

    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;

      if (cm.state.focused) {
        selectInput(this.textarea);
      }

      if (ie && ie_version >= 9) {
        this.hasSelection = content;
      }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";

      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
    }
  };

  TextareaInput.prototype.getField = function () {
    return this.textarea;
  };

  TextareaInput.prototype.supportsTouch = function () {
    return false;
  };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM

    }
  };

  TextareaInput.prototype.blur = function () {
    this.textarea.blur();
  };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () {
    this.slowPoll();
  }; // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.


  TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;

    if (this.pollingFast) {
      return;
    }

    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();

      if (this$1.cm.state.focused) {
        this$1.slowPoll();
      }
    });
  }; // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.


  TextareaInput.prototype.fastPoll = function () {
    var missed = false,
        input = this;
    input.pollingFast = true;

    function p() {
      var changed = input.poll();

      if (!changed && !missed) {
        missed = true;
        input.polling.set(60, p);
      } else {
        input.pollingFast = false;
        input.slowPoll();
      }
    }

    input.polling.set(20, p);
  }; // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).


  TextareaInput.prototype.poll = function () {
    var this$1 = this;
    var cm = this.cm,
        input = this.textarea,
        prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.

    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
      return false;
    }

    var text = input.value; // If nothing changed, bail.

    if (text == prevInput && !cm.somethingSelected()) {
      return false;
    } // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).


    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);

      if (first == 0x200b && !prevInput) {
        prevInput = "\u200B";
      }

      if (first == 0x21da) {
        this.reset();
        return this.cm.execCommand("undo");
      }
    } // Find the part of the input that is actually new


    var same = 0,
        l = Math.min(prevInput.length, text.length);

    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
      ++same;
    }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null); // Don't leave long text in the textarea, since it makes further polling slow

      if (text.length > 1000 || text.indexOf("\n") > -1) {
        input.value = this$1.prevInput = "";
      } else {
        this$1.prevInput = text;
      }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        });
      }
    });
    return true;
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) {
      this.pollingFast = false;
    }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) {
      this.hasSelection = null;
    }

    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this,
        cm = input.cm,
        display = cm.display,
        te = input.textarea;

    if (input.contextMenuPending) {
      input.contextMenuPending();
    }

    var pos = posFromMouse(cm, e),
        scrollPos = display.scroller.scrollTop;

    if (!pos || presto) {
      return;
    } // Opera is difficult.
    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.


    var reset = cm.options.resetSelectionOnContextMenu;

    if (reset && cm.doc.sel.contains(pos) == -1) {
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    }

    var oldCSS = te.style.cssText,
        oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;

    if (webkit) {
      oldScrollY = window.scrollY;
    } // Work around Chrome issue (#2712)


    display.input.focus();

    if (webkit) {
      window.scrollTo(null, oldScrollY);
    }

    display.input.reset(); // Adds "Select all" to context menu in FF

    if (!cm.somethingSelected()) {
      te.value = input.prevInput = " ";
    }

    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.

    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200B" + (selected ? te.value : "");
        te.value = "\u21DA"; // Used to catch context-menu undo

        te.value = extval;
        input.prevInput = selected ? "" : "\u200B";
        te.selectionStart = 1;
        te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the
        // selection in the meantime.

        display.selForContextMenu = cm.doc.sel;
      }
    }

    function rehide() {
      if (input.contextMenuPending != rehide) {
        return;
      }

      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;

      if (ie && ie_version < 9) {
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      } // Try to detect the user choosing select-all


      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9) {
          prepareSelectAllHack();
        }

        var i = 0,
            poll = function poll() {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };

        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) {
      prepareSelectAllHack();
    }

    if (captureRightClick) {
      e_stop(e);

      var mouseup = function mouseup() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };

      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) {
      this.reset();
    }

    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;

    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }

    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    } // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.


    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {
      textarea.value = cm.getValue();
    }

    var realSubmit;

    if (textarea.form) {
      on(textarea.form, "submit", save); // Deplorable hack to make the submit method do the right thing.

      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;

        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;

      cm.getTextArea = function () {
        return textarea;
      };

      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice

        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";

        if (textarea.form) {
          off(textarea.form, "submit", save);

          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) {
      return textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  } // EDITOR CONSTRUCTOR


  defineOptions(CodeMirror);
  addEditorMethods(CodeMirror); // Set up methods on CodeMirror's prototype to redirect to the editor's document.

  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");

  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }

  eventMixin(Doc);
  CodeMirror.inputStyles = {
    "textarea": TextareaInput,
    "contenteditable": ContentEditableInput
  }; // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)

  CodeMirror.defineMode = function (name
  /*, mode, …*/
  ) {
    if (!CodeMirror.defaults.mode && name != "null") {
      CodeMirror.defaults.mode = name;
    }

    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME; // Minimal default mode.

  CodeMirror.defineMode("null", function () {
    return {
      token: function token(stream) {
        return stream.skipToEnd();
      }
    };
  });
  CodeMirror.defineMIME("text/plain", "null"); // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };

  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;
  addLegacyProps(CodeMirror);
  CodeMirror.version = "5.52.2";
  return CodeMirror;
});

/***/ }),

/***/ "E02R":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;

/***/ }),

/***/ "E6Ca":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__("/6KZ");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__("WbNG").set });


/***/ }),

/***/ "E6WT":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("5hJT");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

var mm = Symbol["for"]('@@meta:magical');

var copyDocumentation = function copyDocumentation(source, target) {
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if ({}.FOLKTALE_DOCS !== 'false') {
    target[mm] = Object.assign({}, source[mm] || {}, extensions);
  }
};

module.exports = copyDocumentation;

/***/ }),

/***/ "E7Vc":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "E8p1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("P56o");
var dP = __webpack_require__("U1KF");
var DESCRIPTORS = __webpack_require__("GGqZ");
var SPECIES = __webpack_require__("9dxi")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "EDUi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports["default"] = void 0;

var _inDOM = _interopRequireDefault(__webpack_require__("Dhpq"));

var off = function off() {};

if (_inDOM["default"]) {
  off = function () {
    if (document.addEventListener) return function (node, eventName, handler, capture) {
      return node.removeEventListener(eventName, handler, capture || false);
    };else if (document.attachEvent) return function (node, eventName, handler) {
      return node.detachEvent('on' + eventName, handler);
    };
  }();
}

var _default = off;
exports["default"] = _default;
module.exports = exports["default"];

/***/ }),

/***/ "ELdr":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalHistory", function() { return globalHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "navigate", function() { return navigate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHistory", function() { return createHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMemorySource", function() { return createMemorySource; });
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("asZ9");
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("V7cS");
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("7lGJ");
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_promise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("DbwS");
/* harmony import */ var core_js_modules_es6_promise__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_promise__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_date_now__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("7t+O");
/* harmony import */ var core_js_modules_es6_date_now__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_date_now__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("Z8gF");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("9p7t");
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es6_regexp_search__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("nsbO");
/* harmony import */ var core_js_modules_es6_regexp_search__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_search__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("5hJT");
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_9__);











var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var getLocation = function getLocation(source) {
  var _source$location = source.location,
      search = _source$location.search,
      hash = _source$location.hash,
      href = _source$location.href,
      origin = _source$location.origin,
      protocol = _source$location.protocol,
      host = _source$location.host,
      hostname = _source$location.hostname,
      port = _source$location.port;
  var pathname = source.location.pathname;

  if (!pathname && href && canUseDOM) {
    var url = new URL(href);
    pathname = url.pathname;
  }

  return {
    pathname: encodeURI(decodeURI(pathname)),
    search: search,
    hash: hash,
    href: href,
    origin: origin,
    protocol: protocol,
    host: host,
    hostname: hostname,
    port: port,
    state: source.history.state,
    key: source.history.state && source.history.state.key || "initial"
  };
};

var createHistory = function createHistory(source, options) {
  var listeners = [];
  var location = getLocation(source);
  var transitioning = false;

  var resolveTransition = function resolveTransition() {};

  return {
    get location() {
      return location;
    },

    get transitioning() {
      return transitioning;
    },

    _onTransitionComplete: function _onTransitionComplete() {
      transitioning = false;
      resolveTransition();
    },
    listen: function listen(listener) {
      listeners.push(listener);

      var popstateListener = function popstateListener() {
        location = getLocation(source);
        listener({
          location: location,
          action: "POP"
        });
      };

      source.addEventListener("popstate", popstateListener);
      return function () {
        source.removeEventListener("popstate", popstateListener);
        listeners = listeners.filter(function (fn) {
          return fn !== listener;
        });
      };
    },
    navigate: function navigate(to) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          state = _ref.state,
          _ref$replace = _ref.replace,
          replace = _ref$replace === undefined ? false : _ref$replace;

      if (typeof to === "number") {
        source.history.go(to);
      } else {
        state = _extends({}, state, {
          key: Date.now() + ""
        }); // try...catch iOS Safari limits to 100 pushState calls

        try {
          if (transitioning || replace) {
            source.history.replaceState(state, null, to);
          } else {
            source.history.pushState(state, null, to);
          }
        } catch (e) {
          source.location[replace ? "replace" : "assign"](to);
        }
      }

      location = getLocation(source);
      transitioning = true;
      var transition = new Promise(function (res) {
        return resolveTransition = res;
      });
      listeners.forEach(function (listener) {
        return listener({
          location: location,
          action: "PUSH"
        });
      });
      return transition;
    }
  };
}; ////////////////////////////////////////////////////////////////////////////////
// Stores history entries in memory for testing or other platforms like Native


var createMemorySource = function createMemorySource() {
  var initialPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";
  var searchIndex = initialPath.indexOf("?");
  var initialLocation = {
    pathname: searchIndex > -1 ? initialPath.substr(0, searchIndex) : initialPath,
    search: searchIndex > -1 ? initialPath.substr(searchIndex) : ""
  };
  var index = 0;
  var stack = [initialLocation];
  var states = [null];
  return {
    get location() {
      return stack[index];
    },

    addEventListener: function addEventListener(name, fn) {},
    removeEventListener: function removeEventListener(name, fn) {},
    history: {
      get entries() {
        return stack;
      },

      get index() {
        return index;
      },

      get state() {
        return states[index];
      },

      pushState: function pushState(state, _, uri) {
        var _uri$split = uri.split("?"),
            pathname = _uri$split[0],
            _uri$split$ = _uri$split[1],
            search = _uri$split$ === undefined ? "" : _uri$split$;

        index++;
        stack.push({
          pathname: pathname,
          search: search.length ? "?" + search : search
        });
        states.push(state);
      },
      replaceState: function replaceState(state, _, uri) {
        var _uri$split2 = uri.split("?"),
            pathname = _uri$split2[0],
            _uri$split2$ = _uri$split2[1],
            search = _uri$split2$ === undefined ? "" : _uri$split2$;

        stack[index] = {
          pathname: pathname,
          search: search
        };
        states[index] = state;
      },
      go: function go(to) {
        var newIndex = index + to;

        if (newIndex < 0 || newIndex > states.length - 1) {
          return;
        }

        index = newIndex;
      }
    }
  };
}; ////////////////////////////////////////////////////////////////////////////////
// global history - uses window.history as the source if available, otherwise a
// memory history


var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);

var getSource = function getSource() {
  return canUseDOM ? window : createMemorySource();
};

var globalHistory = createHistory(getSource());
var navigate = globalHistory.navigate; ////////////////////////////////////////////////////////////////////////////////



/***/ }),

/***/ "EWXb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _CloseOutlined = _interopRequireDefault(__webpack_require__("vbmX"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _CloseOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "EgEt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _ExclamationCircleOutlined = _interopRequireDefault(__webpack_require__("o/3r"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var ExclamationCircleOutlined = function ExclamationCircleOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _ExclamationCircleOutlined["default"]
  }));
};

ExclamationCircleOutlined.displayName = 'ExclamationCircleOutlined';

var _default = _react["default"].forwardRef(ExclamationCircleOutlined);

exports["default"] = _default;

/***/ }),

/***/ "EusA":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "F56x":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("o7PZ");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

//
module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB); // Test for A's keys different from B.

  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];
    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }

  return true;
};

/***/ }),

/***/ "FEHE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__("X6VK");
var toLength = __webpack_require__("Sp5b");
var context = __webpack_require__("Alw5");
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__("Fl7L")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "FUg+":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"), __webpack_require__("Un63"));else {}
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineOption("matchTags", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchTags);
      cm.off("viewportChange", maybeUpdateMatch);
      clear(cm);
    }

    if (val) {
      cm.state.matchBothTags = typeof val == "object" && val.bothTags;
      cm.on("cursorActivity", doMatchTags);
      cm.on("viewportChange", maybeUpdateMatch);
      doMatchTags(cm);
    }
  });

  function clear(cm) {
    if (cm.state.tagHit) cm.state.tagHit.clear();
    if (cm.state.tagOther) cm.state.tagOther.clear();
    cm.state.tagHit = cm.state.tagOther = null;
  }

  function doMatchTags(cm) {
    cm.state.failedTagMatch = false;
    cm.operation(function () {
      clear(cm);
      if (cm.somethingSelected()) return;
      var cur = cm.getCursor(),
          range = cm.getViewport();
      range.from = Math.min(range.from, cur.line);
      range.to = Math.max(cur.line + 1, range.to);
      var match = CodeMirror.findMatchingTag(cm, cur, range);
      if (!match) return;

      if (cm.state.matchBothTags) {
        var hit = match.at == "open" ? match.open : match.close;
        if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, {
          className: "CodeMirror-matchingtag"
        });
      }

      var other = match.at == "close" ? match.open : match.close;
      if (other) cm.state.tagOther = cm.markText(other.from, other.to, {
        className: "CodeMirror-matchingtag"
      });else cm.state.failedTagMatch = true;
    });
  }

  function maybeUpdateMatch(cm) {
    if (cm.state.failedTagMatch) doMatchTags(cm);
  }

  CodeMirror.commands.toMatchingTag = function (cm) {
    var found = CodeMirror.findMatchingTag(cm, cm.getCursor());

    if (found) {
      var other = found.at == "close" ? found.open : found.close;
      if (other) cm.extendSelection(other.to, other.from);
    }
  };
});

/***/ }),

/***/ "FWEc":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _reduced = __webpack_require__("Xx9V");

var _xfBase = __webpack_require__("K8HH");

module.exports = function () {
  function XTake(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }

  XTake.prototype['@@transducer/init'] = _xfBase.init;
  XTake.prototype['@@transducer/result'] = _xfBase.result;

  XTake.prototype['@@transducer/step'] = function (result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
    return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
  };

  return _curry2(function _xtake(n, xf) {
    return new XTake(n, xf);
  });
}();

/***/ }),

/***/ "Fl7L":
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__("9dxi")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "Fu0I":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__("OFVL");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "G+Zn":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("ADe/");
var dPs = __webpack_require__("n6P+");
var enumBugKeys = __webpack_require__("miGZ");
var IE_PROTO = __webpack_require__("Q5TA")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("m/Uw")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("5gKE").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "G8Im":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7lGJ");
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_0__);

var START_EVENT_NAME_MAP = {
  transitionstart: {
    transition: 'transitionstart',
    WebkitTransition: 'webkitTransitionStart',
    MozTransition: 'mozTransitionStart',
    OTransition: 'oTransitionStart',
    msTransition: 'MSTransitionStart'
  },
  animationstart: {
    animation: 'animationstart',
    WebkitAnimation: 'webkitAnimationStart',
    MozAnimation: 'mozAnimationStart',
    OAnimation: 'oAnimationStart',
    msAnimation: 'MSAnimationStart'
  }
};
var END_EVENT_NAME_MAP = {
  transitionend: {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'mozTransitionEnd',
    OTransition: 'oTransitionEnd',
    msTransition: 'MSTransitionEnd'
  },
  animationend: {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'mozAnimationEnd',
    OAnimation: 'oAnimationEnd',
    msAnimation: 'MSAnimationEnd'
  }
};
var startEvents = [];
var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  if (!('AnimationEvent' in window)) {
    delete START_EVENT_NAME_MAP.animationstart.animation;
    delete END_EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete START_EVENT_NAME_MAP.transitionstart.transition;
    delete END_EVENT_NAME_MAP.transitionend.transition;
  }

  function process(EVENT_NAME_MAP, events) {
    for (var baseEventName in EVENT_NAME_MAP) {
      if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];

        for (var styleName in baseEvents) {
          if (styleName in style) {
            events.push(baseEvents[styleName]);
            break;
          }
        }
      }
    }
  }

  process(START_EVENT_NAME_MAP, startEvents);
  process(END_EVENT_NAME_MAP, endEvents);
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  detectEvents();
}

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
  // Start events
  startEvents: startEvents,
  addStartEventListener: function addStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }

    startEvents.forEach(function (startEvent) {
      addEventListener(node, startEvent, eventListener);
    });
  },
  removeStartEventListener: function removeStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      return;
    }

    startEvents.forEach(function (startEvent) {
      removeEventListener(node, startEvent, eventListener);
    });
  },
  // End events
  endEvents: endEvents,
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }

    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },
  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }

    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};
/* harmony default export */ __webpack_exports__["a"] = (TransitionEvents);

/***/ }),

/***/ "GCLZ":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("qA3Z");
var toObject = __webpack_require__("dCrc");
var IE_PROTO = __webpack_require__("Q5TA")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "GCOZ":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "GFZo":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("m8zh");

__webpack_require__("asZ9");

var BLAME_FUNCTION_INDEX = 3; // [current, parent, *error*, caller to blame, …]

function warnDeprecation(reason) {
  // eslint-disable-line max-statements
  if ({}.FOLKTALE_ASSERTIONS !== 'none') {
    var stack = new Error('').stack;
    var offender = void 0;

    if (stack) {
      var lines = stack.split('\n');
      offender = lines[BLAME_FUNCTION_INDEX];
    }

    if (offender) {
      console.warn(reason + '\n    Blame: ' + offender.trim());
    } else {
      console.warn(reason);
    }
  }
}

module.exports = warnDeprecation;

/***/ }),

/***/ "GGqZ":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("E7Vc")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "GTEP":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__("s14n");
var validate = __webpack_require__("SsG5");
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__("AkS8")(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),

/***/ "GYOe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var RightOutlined = {
  "name": "right",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"
      }
    }]
  }
};
exports["default"] = RightOutlined;

/***/ }),

/***/ "GdbT":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__("mvii");
var toLength = __webpack_require__("Sp5b");
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ "GddB":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("asZ9");__webpack_require__("oMRA");__webpack_require__("6d4m");window.g2=__webpack_require__("/7QA").default;// gatsby-browser.js
exports.shouldUpdateScroll=function(_ref){var routerProps=_ref.routerProps,prevRouterProps=_ref.prevRouterProps;if(routerProps.location.hash){return false;}var prevPathname=prevRouterProps.location.pathname;var currentPathname=routerProps.location.pathname;// 演示里的 Tabs 切换，不进行页面滚动
if(prevPathname.includes('/examples/')&&currentPathname.includes('/examples/')){var prevPathes=prevPathname.split('/');var currentPathes=currentPathname.split('/');if(prevPathes.length===currentPathes.length){return prevPathes.slice(0,-1).join('/')!==currentPathes.slice(0,-1).join('/');}var compareLength=Math.min(prevPathes.length,currentPathes.length);return prevPathes.slice(0,compareLength).join('/')!==currentPathes.slice(0,compareLength).join('/');}return true;};

/***/ }),

/***/ "Gjrs":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__("rIjD");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__("7oj+");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__("wv3L");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3["default"])(superClass)));
  }

  subClass.prototype = (0, _create2["default"])(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2["default"] ? (0, _setPrototypeOf2["default"])(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),

/***/ "GkPX":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("U1KF").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__("GGqZ") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "Grb3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("nsbO");exports.__esModule=true;exports.onRouteUpdate=void 0;var onRouteUpdate=function onRouteUpdate(_ref,pluginOptions){var location=_ref.location;if(pluginOptions===void 0){pluginOptions={};}if( false||typeof ga!=="function"){return null;}var pathIsExcluded=location&&typeof window.excludeGAPaths!=="undefined"&&window.excludeGAPaths.some(function(rx){return rx.test(location.pathname);});if(pathIsExcluded)return null;// wrap inside a timeout to make sure react-helmet is done with it's changes (https://github.com/gatsbyjs/gatsby/issues/9139)
// reactHelmet is using requestAnimationFrame: https://github.com/nfl/react-helmet/blob/5.2.0/src/HelmetUtils.js#L296-L299
var sendPageView=function sendPageView(){var pagePath=location?location.pathname+location.search+location.hash:undefined;window.ga("set","page",pagePath);window.ga("send","pageview");};// Minimum delay for reactHelmet's requestAnimationFrame
var delay=Math.max(32,pluginOptions.pageTransitionDelay||0);setTimeout(sendPageView,delay);return null;};exports.onRouteUpdate=onRouteUpdate;

/***/ }),

/***/ "Gv0X":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__("X6VK");

$export($export.S, 'Number', { isInteger: __webpack_require__("xI3J") });


/***/ }),

/***/ "Gv4w":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("V7cS");

var equals = __webpack_require__("LGMZ");

module.exports = function _indexOf(list, a, idx) {
  var inf, item; // Array.prototype.indexOf doesn't exist below IE9

  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;

          while (idx < list.length) {
            item = list[idx];

            if (item === 0 && 1 / item === inf) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];

            if (typeof item === 'number' && item !== item) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } // non-zero numbers can utilise Set


        return list.indexOf(a, idx);
      // all these types can utilise Set

      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }

    }
  } // anything else not covered above, defer to R.equals


  while (idx < list.length) {
    if (equals(list[idx], a)) {
      return idx;
    }

    idx += 1;
  }

  return -1;
};

/***/ }),

/***/ "GwS+":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("+3V6");

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

/***/ }),

/***/ "GyeN":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("XmXP");
var $Object = __webpack_require__("TaGV").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "H4M2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__("asZ9");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.bind.js
var es6_function_bind = __webpack_require__("o7PZ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/LoadingOutlined.js
var LoadingOutlined = __webpack_require__("yRvC");
var LoadingOutlined_default = /*#__PURE__*/__webpack_require__.n(LoadingOutlined);

// EXTERNAL MODULE: ../node_modules/omit.js/es/index.js
var es = __webpack_require__("x9u5");

// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/context.js + 4 modules
var context = __webpack_require__("Bfez");

// EXTERNAL MODULE: ../node_modules/antd/es/_util/wave.js
var wave = __webpack_require__("wWt5");

// EXTERNAL MODULE: ../node_modules/antd/es/_util/type.js
var _util_type = __webpack_require__("UyNX");

// EXTERNAL MODULE: ../node_modules/antd/es/_util/warning.js
var warning = __webpack_require__("papw");

// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/SizeContext.js
var SizeContext = __webpack_require__("hxuA");

// CONCATENATED MODULE: ../node_modules/antd/es/button/button.js












function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable react/button-has-type */











var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);

function isString(str) {
  return typeof str === 'string';
} // Insert one space between two chinese characters automatically.


function insertSpace(child, needInserted) {
  // Check the child if is undefined or null.
  if (child == null) {
    return;
  }

  var SPACE = needInserted ? ' ' : ''; // strictNullChecks oops.

  if (typeof child !== 'string' && typeof child !== 'number' && isString(child.type) && isTwoCNChar(child.props.children)) {
    return react["cloneElement"](child, {}, child.props.children.split('').join(SPACE));
  }

  if (typeof child === 'string') {
    if (isTwoCNChar(child)) {
      child = child.split('').join(SPACE);
    }

    return react["createElement"]("span", null, child);
  }

  return child;
}

function spaceChildren(children, needInserted) {
  var isPrevChildPure = false;
  var childList = [];
  react["Children"].forEach(children, function (child) {
    var type = _typeof(child);

    var isCurrentChildPure = type === 'string' || type === 'number';

    if (isPrevChildPure && isCurrentChildPure) {
      var lastIndex = childList.length - 1;
      var lastChild = childList[lastIndex];
      childList[lastIndex] = "".concat(lastChild).concat(child);
    } else {
      childList.push(child);
    }

    isPrevChildPure = isCurrentChildPure;
  }); // Pass to React.Children.map to auto fill key

  return react["Children"].map(childList, function (child) {
    return insertSpace(child, needInserted);
  });
}

var ButtonTypes = Object(_util_type["a" /* tuple */])('default', 'primary', 'ghost', 'dashed', 'danger', 'link');
var ButtonShapes = Object(_util_type["a" /* tuple */])('circle', 'circle-outline', 'round');
var ButtonHTMLTypes = Object(_util_type["a" /* tuple */])('submit', 'button', 'reset');

var button_Button = /*#__PURE__*/function (_React$Component) {
  _inherits(Button, _React$Component);

  function Button(props) {
    var _this;

    _classCallCheck(this, Button);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Button).call(this, props));

    _this.saveButtonRef = function (node) {
      _this.buttonNode = node;
    };

    _this.handleClick = function (e) {
      var loading = _this.state.loading;
      var onClick = _this.props.onClick;

      if (loading) {
        return;
      }

      if (onClick) {
        onClick(e);
      }
    };

    _this.state = {
      loading: props.loading,
      hasTwoCNChar: false
    };
    return _this;
  }

  _createClass(Button, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.fixTwoCNChar();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this2 = this;

      this.fixTwoCNChar();

      if (prevProps.loading && typeof prevProps.loading !== 'boolean') {
        clearTimeout(this.delayTimeout);
      }

      var loading = this.props.loading;

      if (loading && typeof loading !== 'boolean' && loading.delay) {
        this.delayTimeout = window.setTimeout(function () {
          _this2.setState({
            loading: loading
          });
        }, loading.delay);
      } else if (prevProps.loading !== loading) {
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          loading: loading
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.delayTimeout) {
        clearTimeout(this.delayTimeout);
      }
    }
  }, {
    key: "fixTwoCNChar",
    value: function fixTwoCNChar() {
      var autoInsertSpaceInButton = this.context.autoInsertSpaceInButton; // Fix for HOC usage like <FormatMessage />

      if (!this.buttonNode || autoInsertSpaceInButton === false) {
        return;
      }

      var buttonText = this.buttonNode.textContent;

      if (this.isNeedInserted() && isTwoCNChar(buttonText)) {
        if (!this.state.hasTwoCNChar) {
          this.setState({
            hasTwoCNChar: true
          });
        }
      } else if (this.state.hasTwoCNChar) {
        this.setState({
          hasTwoCNChar: false
        });
      }
    }
  }, {
    key: "isNeedInserted",
    value: function isNeedInserted() {
      var _this$props = this.props,
          icon = _this$props.icon,
          children = _this$props.children,
          type = _this$props.type;
      return react["Children"].count(children) === 1 && !icon && type !== 'link';
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$context = this.context,
          getPrefixCls = _this$context.getPrefixCls,
          autoInsertSpaceInButton = _this$context.autoInsertSpaceInButton,
          direction = _this$context.direction;
      return react["createElement"](SizeContext["b" /* default */].Consumer, null, function (size) {
        var _classNames;

        var _a = _this3.props,
            customizePrefixCls = _a.prefixCls,
            type = _a.type,
            danger = _a.danger,
            shape = _a.shape,
            customizeSize = _a.size,
            className = _a.className,
            children = _a.children,
            icon = _a.icon,
            ghost = _a.ghost,
            block = _a.block,
            rest = __rest(_a, ["prefixCls", "type", "danger", "shape", "size", "className", "children", "icon", "ghost", "block"]);

        var _this3$state = _this3.state,
            loading = _this3$state.loading,
            hasTwoCNChar = _this3$state.hasTwoCNChar;
        Object(warning["a" /* default */])(!(typeof icon === 'string' && icon.length > 2), 'Button', "`icon` is using ReactNode instead of string naming in v4. Please check `".concat(icon, "` at https://ant.design/components/icon"));
        var prefixCls = getPrefixCls('btn', customizePrefixCls);
        var autoInsertSpace = autoInsertSpaceInButton !== false; // large => lg
        // small => sm

        var sizeCls = '';

        switch (customizeSize || size) {
          case 'large':
            sizeCls = 'lg';
            break;

          case 'small':
            sizeCls = 'sm';
            break;

          default:
            break;
        }

        var iconType = loading ? 'loading' : icon;
        var classes = classnames_default()(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-").concat(type), type), _defineProperty(_classNames, "".concat(prefixCls, "-").concat(shape), shape), _defineProperty(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty(_classNames, "".concat(prefixCls, "-icon-only"), !children && children !== 0 && iconType), _defineProperty(_classNames, "".concat(prefixCls, "-loading"), !!loading), _defineProperty(_classNames, "".concat(prefixCls, "-background-ghost"), ghost), _defineProperty(_classNames, "".concat(prefixCls, "-two-chinese-chars"), hasTwoCNChar && autoInsertSpace), _defineProperty(_classNames, "".concat(prefixCls, "-block"), block), _defineProperty(_classNames, "".concat(prefixCls, "-dangerous"), !!danger), _defineProperty(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames));
        var iconNode = loading ? react["createElement"](LoadingOutlined_default.a, null) : icon || null;
        var kids = children || children === 0 ? spaceChildren(children, _this3.isNeedInserted() && autoInsertSpace) : null;
        var linkButtonRestProps = Object(es["a" /* default */])(rest, ['htmlType', 'loading']);

        if (linkButtonRestProps.href !== undefined) {
          return react["createElement"]("a", _extends({}, linkButtonRestProps, {
            className: classes,
            onClick: _this3.handleClick,
            ref: _this3.saveButtonRef
          }), iconNode, kids);
        } // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.


        var _b = rest,
            htmlType = _b.htmlType,
            otherProps = __rest(_b, ["htmlType"]);

        var buttonNode = react["createElement"]("button", _extends({}, Object(es["a" /* default */])(otherProps, ['loading']), {
          type: htmlType,
          className: classes,
          onClick: _this3.handleClick,
          ref: _this3.saveButtonRef
        }), iconNode, kids);

        if (type === 'link') {
          return buttonNode;
        }

        return react["createElement"](wave["a" /* default */], null, buttonNode);
      });
    }
  }]);

  return Button;
}(react["Component"]);

button_Button.__ANT_BUTTON = true;
button_Button.contextType = context["b" /* ConfigContext */];
button_Button.defaultProps = {
  loading: false,
  ghost: false,
  block: false,
  htmlType: 'button'
};
/* harmony default export */ var button_button = (button_Button);
// CONCATENATED MODULE: ../node_modules/antd/es/button/button-group.js





function button_group_extends() {
  button_group_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return button_group_extends.apply(this, arguments);
}

function button_group_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var button_group_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





var button_group_ButtonGroup = function ButtonGroup(props) {
  return react["createElement"](context["a" /* ConfigConsumer */], null, function (_ref) {
    var _classNames;

    var getPrefixCls = _ref.getPrefixCls,
        direction = _ref.direction;

    var customizePrefixCls = props.prefixCls,
        size = props.size,
        className = props.className,
        others = button_group_rest(props, ["prefixCls", "size", "className"]);

    var prefixCls = getPrefixCls('btn-group', customizePrefixCls); // large => lg
    // small => sm

    var sizeCls = '';

    switch (size) {
      case 'large':
        sizeCls = 'lg';
        break;

      case 'small':
        sizeCls = 'sm';
        break;

      default:
        break;
    }

    var classes = classnames_default()(prefixCls, (_classNames = {}, button_group_defineProperty(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), button_group_defineProperty(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames), className);
    return react["createElement"]("div", button_group_extends({}, others, {
      className: classes
    }));
  });
};

/* harmony default export */ var button_group = (button_group_ButtonGroup);
// CONCATENATED MODULE: ../node_modules/antd/es/button/index.js


button_button.Group = button_group;
/* harmony default export */ var es_button = __webpack_exports__["a"] = (button_button);

/***/ }),

/***/ "H8M3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("9p7t");

__webpack_require__("Z8gF");

__webpack_require__("asZ9");

__webpack_require__("yIlq");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _not = __webpack_require__("kFsC");

var _not2 = _interopRequireDefault(_not);

var _head = __webpack_require__("4SiD");

var _head2 = _interopRequireDefault(_head);

var _isNil = __webpack_require__("CL0D");

var _isNil2 = _interopRequireDefault(_isNil);

var _curry = __webpack_require__("NU6T");

var _curry2 = _interopRequireDefault(_curry);

var _compose = __webpack_require__("+yb+");

var _compose2 = _interopRequireDefault(_compose);

var _endsWith = __webpack_require__("hV/m");

var _endsWith2 = _interopRequireDefault(_endsWith);

var _startsWith = __webpack_require__("cpHF");

var _startsWith2 = _interopRequireDefault(_startsWith);

var _index = __webpack_require__("wc+d");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var defaultPagesPaths = ['/src/pages/'];

var getPagesPaths = function getPagesPaths(options) {
  return options && options.pagesPaths || defaultPagesPaths;
};

var getLangKeyDefault = function getLangKeyDefault(options) {
  return options && options.langKeyDefault || options;
};

var addSlashStart = function addSlashStart(fileName) {
  return (0, _startsWith2["default"])('/', fileName) ? fileName : '/' + fileName;
};

var addSlashEnd = function addSlashEnd(fileName) {
  return (0, _endsWith2["default"])('/', fileName) ? fileName : fileName + '/';
};

var addSlash = (0, _compose2["default"])(addSlashStart, addSlashEnd);
/**
 * Get slug (path) and langKey for a given file path.
 *
 * Used by gatsby-plugin-i18n and gatsby-plugin-i18n-tags
 *
 * @param {{langKeyDefault: string, pagesPaths: string[], prefixDefault: boolean }} options plugin options
 * @param {String} fileAbsolutePath local file absolute path
 * @return {{slug: string, langKey: string, redirectTo: string}} slug and langKey
 */

var getSlugAndLang = (0, _curry2["default"])(function (options, fileAbsolutePath) {
  var slugsAndLangs = getPagesPaths(options).map(function (pagesPath) {
    var filePath = ('safeStartToSplit-' + fileAbsolutePath).split(pagesPath)[1];

    if ((0, _isNil2["default"])(filePath)) {
      return null;
    }

    var langKeyDefault = getLangKeyDefault(options);
    var fileName = filePath.split('.');
    var langKey = fileName.length === 3 ? fileName[1] : langKeyDefault;
    var title = addSlash(fileName[0].replace('index', ''));
    var slug = fileName.length === 3 ? (0, _index.addLangKeyToSlug)(title, langKey, options) : title;
    return {
      slug: slug,
      langKey: langKey,
      redirectTo: slug === '/' ? addSlash(langKeyDefault) : null
    };
  });
  return (0, _head2["default"])(slugsAndLangs.filter((0, _compose2["default"])(_not2["default"], _isNil2["default"])));
});
exports["default"] = getSlugAndLang;

/***/ }),

/***/ "HAof":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"), __webpack_require__("rpsq"), __webpack_require__("2y5g"));else {}
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("htmlembedded", function (config, parserConfig) {
    var closeComment = parserConfig.closeComment || "--%>";
    return CodeMirror.multiplexingMode(CodeMirror.getMode(config, "htmlmixed"), {
      open: parserConfig.openComment || "<%--",
      close: closeComment,
      delimStyle: "comment",
      mode: {
        token: function token(stream) {
          stream.skipTo(closeComment) || stream.skipToEnd();
          return "comment";
        }
      }
    }, {
      open: parserConfig.open || parserConfig.scriptStartRegex || "<%",
      close: parserConfig.close || parserConfig.scriptEndRegex || "%>",
      mode: CodeMirror.getMode(config, parserConfig.scriptingModeSpec)
    });
  }, "htmlmixed");
  CodeMirror.defineMIME("application/x-ejs", {
    name: "htmlembedded",
    scriptingModeSpec: "javascript"
  });
  CodeMirror.defineMIME("application/x-aspx", {
    name: "htmlembedded",
    scriptingModeSpec: "text/x-csharp"
  });
  CodeMirror.defineMIME("application/x-jsp", {
    name: "htmlembedded",
    scriptingModeSpec: "text/x-java"
  });
  CodeMirror.defineMIME("application/x-erb", {
    name: "htmlembedded",
    scriptingModeSpec: "ruby"
  });
});

/***/ }),

/***/ "HApA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warning = warning;
exports.note = note;
exports.resetWarned = resetWarned;
exports.call = call;
exports.warningOnce = warningOnce;
exports.noteOnce = noteOnce;
exports["default"] = void 0;
/* eslint-disable no-console */

var warned = {};

function warning(valid, message) {
  // Support uglify
  if (false) {}
}

function note(valid, message) {
  // Support uglify
  if (false) {}
}

function resetWarned() {
  warned = {};
}

function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}

function warningOnce(valid, message) {
  call(warning, valid, message);
}

function noteOnce(valid, message) {
  call(note, valid, message);
}

var _default = warningOnce;
/* eslint-enable */

exports["default"] = _default;

/***/ }),

/***/ "HCJm":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _isString = __webpack_require__("74ju");
/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      var list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */


module.exports = _curry2(function nth(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString(list) ? list.charAt(idx) : list[idx];
});

/***/ }),

/***/ "HD3J":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "HWsP":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("GGqZ") && !__webpack_require__("E7Vc")(function () {
  return Object.defineProperty(__webpack_require__("mggL")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "Hb9A":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CloseOutlined = {
  "name": "close",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"
      }
    }]
  }
};
exports["default"] = CloseOutlined;

/***/ }),

/***/ "HbTz":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("fGh/");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "HqX2":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("9liC");
var call = __webpack_require__("iJnn");
var isArrayIter = __webpack_require__("2LOZ");
var anObject = __webpack_require__("PAFS");
var toLength = __webpack_require__("Sp5b");
var getIterFn = __webpack_require__("pB2m");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "I2ZI":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9ovy");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("css", function (config, parserConfig) {
    var inline = parserConfig.inline;
    if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");
    var indentUnit = config.indentUnit,
        tokenHooks = parserConfig.tokenHooks,
        documentTypes = parserConfig.documentTypes || {},
        mediaTypes = parserConfig.mediaTypes || {},
        mediaFeatures = parserConfig.mediaFeatures || {},
        mediaValueKeywords = parserConfig.mediaValueKeywords || {},
        propertyKeywords = parserConfig.propertyKeywords || {},
        nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
        fontProperties = parserConfig.fontProperties || {},
        counterDescriptors = parserConfig.counterDescriptors || {},
        colorKeywords = parserConfig.colorKeywords || {},
        valueKeywords = parserConfig.valueKeywords || {},
        allowNested = parserConfig.allowNested,
        lineComment = parserConfig.lineComment,
        supportsAtComponent = parserConfig.supportsAtComponent === true;
    var type, override;

    function ret(style, tp) {
      type = tp;
      return style;
    } // Tokenizers


    function tokenBase(stream, state) {
      var ch = stream.next();

      if (tokenHooks[ch]) {
        var result = tokenHooks[ch](stream, state);
        if (result !== false) return result;
      }

      if (ch == "@") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("def", stream.current());
      } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
        return ret(null, "compare");
      } else if (ch == "\"" || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "#") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("atom", "hash");
      } else if (ch == "!") {
        stream.match(/^\s*\w*/);
        return ret("keyword", "important");
      } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (ch === "-") {
        if (/[\d.]/.test(stream.peek())) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (stream.match(/^-[\w\\\-]*/)) {
          stream.eatWhile(/[\w\\\-]/);
          if (stream.match(/^\s*:/, false)) return ret("variable-2", "variable-definition");
          return ret("variable-2", "variable");
        } else if (stream.match(/^\w+-/)) {
          return ret("meta", "meta");
        }
      } else if (/[,+>*\/]/.test(ch)) {
        return ret(null, "select-op");
      } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
        return ret("qualifier", "qualifier");
      } else if (/[:;{}\[\]\(\)]/.test(ch)) {
        return ret(null, ch);
      } else if (stream.match(/[\w-.]+(?=\()/)) {
        if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {
          state.tokenize = tokenParenthesized;
        }

        return ret("variable callee", "variable");
      } else if (/[\w\\\-]/.test(ch)) {
        stream.eatWhile(/[\w\\\-]/);
        return ret("property", "word");
      } else {
        return ret(null, null);
      }
    }

    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false,
            ch;

        while ((ch = stream.next()) != null) {
          if (ch == quote && !escaped) {
            if (quote == ")") stream.backUp(1);
            break;
          }

          escaped = !escaped && ch == "\\";
        }

        if (ch == quote || !escaped && quote != ")") state.tokenize = null;
        return ret("string", "string");
      };
    }

    function tokenParenthesized(stream, state) {
      stream.next(); // Must be '('

      if (!stream.match(/\s*[\"\')]/, false)) state.tokenize = tokenString(")");else state.tokenize = null;
      return ret(null, "(");
    } // Context management


    function Context(type, indent, prev) {
      this.type = type;
      this.indent = indent;
      this.prev = prev;
    }

    function pushContext(state, stream, type, indent) {
      state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
      return type;
    }

    function popContext(state) {
      if (state.context.prev) state.context = state.context.prev;
      return state.context.type;
    }

    function pass(type, stream, state) {
      return states[state.context.type](type, stream, state);
    }

    function popAndPass(type, stream, state, n) {
      for (var i = n || 1; i > 0; i--) {
        state.context = state.context.prev;
      }

      return pass(type, stream, state);
    } // Parser


    function wordAsValue(stream) {
      var word = stream.current().toLowerCase();
      if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "variable";
    }

    var states = {};

    states.top = function (type, stream, state) {
      if (type == "{") {
        return pushContext(state, stream, "block");
      } else if (type == "}" && state.context.prev) {
        return popContext(state);
      } else if (supportsAtComponent && /@component/i.test(type)) {
        return pushContext(state, stream, "atComponentBlock");
      } else if (/^@(-moz-)?document$/i.test(type)) {
        return pushContext(state, stream, "documentTypes");
      } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
        return pushContext(state, stream, "atBlock");
      } else if (/^@(font-face|counter-style)/i.test(type)) {
        state.stateArg = type;
        return "restricted_atBlock_before";
      } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
        return "keyframes";
      } else if (type && type.charAt(0) == "@") {
        return pushContext(state, stream, "at");
      } else if (type == "hash") {
        override = "builtin";
      } else if (type == "word") {
        override = "tag";
      } else if (type == "variable-definition") {
        return "maybeprop";
      } else if (type == "interpolation") {
        return pushContext(state, stream, "interpolation");
      } else if (type == ":") {
        return "pseudo";
      } else if (allowNested && type == "(") {
        return pushContext(state, stream, "parens");
      }

      return state.context.type;
    };

    states.block = function (type, stream, state) {
      if (type == "word") {
        var word = stream.current().toLowerCase();

        if (propertyKeywords.hasOwnProperty(word)) {
          override = "property";
          return "maybeprop";
        } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
          override = "string-2";
          return "maybeprop";
        } else if (allowNested) {
          override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
          return "block";
        } else {
          override += " error";
          return "maybeprop";
        }
      } else if (type == "meta") {
        return "block";
      } else if (!allowNested && (type == "hash" || type == "qualifier")) {
        override = "error";
        return "block";
      } else {
        return states.top(type, stream, state);
      }
    };

    states.maybeprop = function (type, stream, state) {
      if (type == ":") return pushContext(state, stream, "prop");
      return pass(type, stream, state);
    };

    states.prop = function (type, stream, state) {
      if (type == ";") return popContext(state);
      if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
      if (type == "}" || type == "{") return popAndPass(type, stream, state);
      if (type == "(") return pushContext(state, stream, "parens");

      if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
        override += " error";
      } else if (type == "word") {
        wordAsValue(stream);
      } else if (type == "interpolation") {
        return pushContext(state, stream, "interpolation");
      }

      return "prop";
    };

    states.propBlock = function (type, _stream, state) {
      if (type == "}") return popContext(state);

      if (type == "word") {
        override = "property";
        return "maybeprop";
      }

      return state.context.type;
    };

    states.parens = function (type, stream, state) {
      if (type == "{" || type == "}") return popAndPass(type, stream, state);
      if (type == ")") return popContext(state);
      if (type == "(") return pushContext(state, stream, "parens");
      if (type == "interpolation") return pushContext(state, stream, "interpolation");
      if (type == "word") wordAsValue(stream);
      return "parens";
    };

    states.pseudo = function (type, stream, state) {
      if (type == "meta") return "pseudo";

      if (type == "word") {
        override = "variable-3";
        return state.context.type;
      }

      return pass(type, stream, state);
    };

    states.documentTypes = function (type, stream, state) {
      if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
        override = "tag";
        return state.context.type;
      } else {
        return states.atBlock(type, stream, state);
      }
    };

    states.atBlock = function (type, stream, state) {
      if (type == "(") return pushContext(state, stream, "atBlock_parens");
      if (type == "}" || type == ";") return popAndPass(type, stream, state);
      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
      if (type == "interpolation") return pushContext(state, stream, "interpolation");

      if (type == "word") {
        var word = stream.current().toLowerCase();
        if (word == "only" || word == "not" || word == "and" || word == "or") override = "keyword";else if (mediaTypes.hasOwnProperty(word)) override = "attribute";else if (mediaFeatures.hasOwnProperty(word)) override = "property";else if (mediaValueKeywords.hasOwnProperty(word)) override = "keyword";else if (propertyKeywords.hasOwnProperty(word)) override = "property";else if (nonStandardPropertyKeywords.hasOwnProperty(word)) override = "string-2";else if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "error";
      }

      return state.context.type;
    };

    states.atComponentBlock = function (type, stream, state) {
      if (type == "}") return popAndPass(type, stream, state);
      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
      if (type == "word") override = "error";
      return state.context.type;
    };

    states.atBlock_parens = function (type, stream, state) {
      if (type == ")") return popContext(state);
      if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
      return states.atBlock(type, stream, state);
    };

    states.restricted_atBlock_before = function (type, stream, state) {
      if (type == "{") return pushContext(state, stream, "restricted_atBlock");

      if (type == "word" && state.stateArg == "@counter-style") {
        override = "variable";
        return "restricted_atBlock_before";
      }

      return pass(type, stream, state);
    };

    states.restricted_atBlock = function (type, stream, state) {
      if (type == "}") {
        state.stateArg = null;
        return popContext(state);
      }

      if (type == "word") {
        if (state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())) override = "error";else override = "property";
        return "maybeprop";
      }

      return "restricted_atBlock";
    };

    states.keyframes = function (type, stream, state) {
      if (type == "word") {
        override = "variable";
        return "keyframes";
      }

      if (type == "{") return pushContext(state, stream, "top");
      return pass(type, stream, state);
    };

    states.at = function (type, stream, state) {
      if (type == ";") return popContext(state);
      if (type == "{" || type == "}") return popAndPass(type, stream, state);
      if (type == "word") override = "tag";else if (type == "hash") override = "builtin";
      return "at";
    };

    states.interpolation = function (type, stream, state) {
      if (type == "}") return popContext(state);
      if (type == "{" || type == ";") return popAndPass(type, stream, state);
      if (type == "word") override = "variable";else if (type != "variable" && type != "(" && type != ")") override = "error";
      return "interpolation";
    };

    return {
      startState: function startState(base) {
        return {
          tokenize: null,
          state: inline ? "block" : "top",
          stateArg: null,
          context: new Context(inline ? "block" : "top", base || 0, null)
        };
      },
      token: function token(stream, state) {
        if (!state.tokenize && stream.eatSpace()) return null;
        var style = (state.tokenize || tokenBase)(stream, state);

        if (style && typeof style == "object") {
          type = style[1];
          style = style[0];
        }

        override = style;
        if (type != "comment") state.state = states[state.state](type, stream, state);
        return override;
      },
      indent: function indent(state, textAfter) {
        var cx = state.context,
            ch = textAfter && textAfter.charAt(0);
        var indent = cx.indent;
        if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;

        if (cx.prev) {
          if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
            // Resume indentation from parent context.
            cx = cx.prev;
            indent = cx.indent;
          } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
            // Dedent relative to current context.
            indent = Math.max(0, cx.indent - indentUnit);
          }
        }

        return indent;
      },
      electricChars: "}",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      blockCommentContinue: " * ",
      lineComment: lineComment,
      fold: "brace"
    };
  });

  function keySet(array) {
    var keys = {};

    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }

    return keys;
  }

  var documentTypes_ = ["domain", "regexp", "url", "url-prefix"],
      documentTypes = keySet(documentTypes_);
  var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"],
      mediaTypes = keySet(mediaTypes_);
  var mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover"],
      mediaFeatures = keySet(mediaFeatures_);
  var mediaValueKeywords_ = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive"],
      mediaValueKeywords = keySet(mediaValueKeywords_);
  var propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backdrop-filter", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-position-x", "background-position-y", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "block-size", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-optical-sizing", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "isolation", "justify-content", "justify-items", "justify-self", "left", "letter-spacing", "line-break", "line-height", "line-height-step", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotate", "rotation", "rotation-point", "row-gap", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-type", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-skip-ink", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-orientation", "text-outline", "text-overflow", "text-rendering", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "translate", "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index", // SVG-specific
  "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"],
      propertyKeywords = keySet(propertyKeywords_);
  var nonStandardPropertyKeywords_ = ["border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "margin-block", "margin-block-end", "margin-block-start", "margin-inline", "margin-inline-end", "margin-inline-start", "padding-block", "padding-block-end", "padding-block-start", "padding-inline", "padding-inline-end", "padding-inline-start", "scroll-snap-stop", "scrollbar-3d-light-color", "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-track-color", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "shape-inside", "zoom"],
      nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
  var fontProperties_ = ["font-display", "font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"],
      fontProperties = keySet(fontProperties_);
  var counterDescriptors_ = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"],
      counterDescriptors = keySet(counterDescriptors_);
  var colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"],
      colorKeywords = keySet(colorKeywords_);
  var valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"],
      valueKeywords = keySet(valueKeywords_);
  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false,
        ch;

    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }

      maybeEnd = ch == "*";
    }

    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function _(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });
  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function _(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function _(stream) {
        if (stream.match(/\s*\{/, false)) return [null, null];
        return false;
      },
      "$": function $(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function _(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });
  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function _(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function _(stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function _() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });
  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function _(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });
});

/***/ }),

/***/ "IEjY":
/***/ (function(module, exports) {

module.exports = function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
};

/***/ }),

/***/ "IFhY":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export warning */
/* unused harmony export note */
/* unused harmony export resetWarned */
/* unused harmony export call */
/* unused harmony export warningOnce */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return noteOnce; });
/* eslint-disable no-console */
var warned = {};
function warning(valid, message) {
  // Support uglify
  if (false) {}
}
function note(valid, message) {
  // Support uglify
  if (false) {}
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}
/* harmony default export */ __webpack_exports__["a"] = (warningOnce);
/* eslint-enable */

/***/ }),

/***/ "IH2s":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("/6KZ");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__("lBnu"), 'Object', { defineProperty: __webpack_require__("eOWL").f });


/***/ }),

/***/ "IKQL":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__("X6VK");

$export($export.P, 'Array', { fill: __webpack_require__("Pfmf") });

__webpack_require__("OfmW")('fill');


/***/ }),

/***/ "IL7q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("asZ9");

__webpack_require__("7lGJ");

__webpack_require__("yIlq");

__webpack_require__("5hJT");

__webpack_require__("ABKx");

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ "IOVJ":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("4aJ6");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_reflect_construct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("LXYL");
/* harmony import */ var core_js_modules_es6_reflect_construct__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_reflect_construct__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("5hJT");
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("emEt");
/* harmony import */ var _api_runner_browser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("xtsi");
/* harmony import */ var _api_runner_browser__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_api_runner_browser__WEBPACK_IMPORTED_MODULE_6__);
function _createSuper(Derived){return function(){var Super=_getPrototypeOf(Derived),result;if(_isNativeReflectConstruct()){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(typeof call==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}// Renders page
var PageRenderer=/*#__PURE__*/function(_React$Component){_inheritsLoose(PageRenderer,_React$Component);var _super=_createSuper(PageRenderer);function PageRenderer(){return _React$Component.apply(this,arguments)||this;}var _proto=PageRenderer.prototype;_proto.render=function render(){var props=Object.assign({},this.props,{pathContext:this.props.pageContext});var _apiRunner=Object(_api_runner_browser__WEBPACK_IMPORTED_MODULE_6__["apiRunner"])("replaceComponentRenderer",{props:this.props,loader:_loader__WEBPACK_IMPORTED_MODULE_5__["publicLoader"]}),replacementElement=_apiRunner[0];var pageElement=replacementElement||Object(react__WEBPACK_IMPORTED_MODULE_4__["createElement"])(this.props.pageResources.component,Object.assign({},props,{key:this.props.path||this.props.pageResources.page.path}));var wrappedPage=Object(_api_runner_browser__WEBPACK_IMPORTED_MODULE_6__["apiRunner"])("wrapPageElement",{element:pageElement,props:props},pageElement,function(_ref){var result=_ref.result;return{element:result,props:props};}).pop();return wrappedPage;};return PageRenderer;}(react__WEBPACK_IMPORTED_MODULE_4___default.a.Component);/* harmony default export */ __webpack_exports__["a"] = (PageRenderer);

/***/ }),

/***/ "Ibj2":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "IdFN":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "IqHs":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ExclamationCircleFilled = {
  "name": "exclamation-circle",
  "theme": "filled",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
      }
    }]
  }
};
exports["default"] = ExclamationCircleFilled;

/***/ }),

/***/ "IsBi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("VNvs");

var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports["default"] = void 0;

var _inDOM = _interopRequireDefault(__webpack_require__("Dhpq"));

var vendors = ['', 'webkit', 'moz', 'o', 'ms'];
var cancel = 'clearTimeout';
var raf = fallback;
var compatRaf;

var getKey = function getKey(vendor, k) {
  return vendor + (!vendor ? k : k[0].toUpperCase() + k.substr(1)) + 'AnimationFrame';
};

if (_inDOM["default"]) {
  vendors.some(function (vendor) {
    var rafKey = getKey(vendor, 'request');

    if (rafKey in window) {
      cancel = getKey(vendor, 'cancel');
      return raf = function raf(cb) {
        return window[rafKey](cb);
      };
    }
  });
}
/* https://github.com/component/raf */


var prev = new Date().getTime();

function fallback(fn) {
  var curr = new Date().getTime(),
      ms = Math.max(0, 16 - (curr - prev)),
      req = setTimeout(fn, ms);
  prev = curr;
  return req;
}

compatRaf = function compatRaf(cb) {
  return raf(cb);
};

compatRaf.cancel = function (id) {
  window[cancel] && typeof window[cancel] === 'function' && window[cancel](id);
};

var _default = compatRaf;
exports["default"] = _default;
module.exports = exports["default"];

/***/ }),

/***/ "IyKV":
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = __webpack_require__("vXgj");

var _curry1 = __webpack_require__("AN6r");

var slice = __webpack_require__("w4Md");
/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */


module.exports = _curry1(_checkForMethod('tail', slice(1, Infinity)));

/***/ }),

/***/ "IycE":
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__("r/sL");

var _pipe = __webpack_require__("IEjY");

var reduce = __webpack_require__("wV56");

var tail = __webpack_require__("IyKV");
/**
 * Performs left-to-right function composition. The leftmost function may have
 * any arity; the remaining functions must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      var f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */


module.exports = function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }

  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
};

/***/ }),

/***/ "J1LG":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _typeof; });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "J8hF":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("P56o");
var inheritIfRequired = __webpack_require__("jEou");
var dP = __webpack_require__("U1KF").f;
var gOPN = __webpack_require__("zIds").f;
var isRegExp = __webpack_require__("NVL/");
var $flags = __webpack_require__("MBcE");
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__("GGqZ") && (!CORRECT_NEW || __webpack_require__("E7Vc")(function () {
  re2[__webpack_require__("9dxi")('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__("sU/p")(global, 'RegExp', $RegExp);
}

__webpack_require__("E8p1")('RegExp');


/***/ }),

/***/ "JF+v":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Link", function() { return /* binding */ Link; });
__webpack_require__.d(__webpack_exports__, "Location", function() { return /* binding */ es_Location; });
__webpack_require__.d(__webpack_exports__, "LocationProvider", function() { return /* binding */ es_LocationProvider; });
__webpack_require__.d(__webpack_exports__, "Match", function() { return /* binding */ es_Match; });
__webpack_require__.d(__webpack_exports__, "Redirect", function() { return /* binding */ es_Redirect; });
__webpack_require__.d(__webpack_exports__, "Router", function() { return /* binding */ es_Router; });
__webpack_require__.d(__webpack_exports__, "ServerLocation", function() { return /* binding */ es_ServerLocation; });
__webpack_require__.d(__webpack_exports__, "createHistory", function() { return /* reexport */ lib_history["createHistory"]; });
__webpack_require__.d(__webpack_exports__, "createMemorySource", function() { return /* reexport */ lib_history["createMemorySource"]; });
__webpack_require__.d(__webpack_exports__, "isRedirect", function() { return /* binding */ isRedirect; });
__webpack_require__.d(__webpack_exports__, "navigate", function() { return /* reexport */ lib_history["navigate"]; });
__webpack_require__.d(__webpack_exports__, "redirectTo", function() { return /* binding */ redirectTo; });
__webpack_require__.d(__webpack_exports__, "globalHistory", function() { return /* reexport */ lib_history["globalHistory"]; });
__webpack_require__.d(__webpack_exports__, "matchPath", function() { return /* reexport */ utils["b" /* match */]; });
__webpack_require__.d(__webpack_exports__, "useLocation", function() { return /* binding */ es_useLocation; });
__webpack_require__.d(__webpack_exports__, "useNavigate", function() { return /* binding */ es_useNavigate; });
__webpack_require__.d(__webpack_exports__, "useParams", function() { return /* binding */ es_useParams; });
__webpack_require__.d(__webpack_exports__, "useMatch", function() { return /* binding */ es_useMatch; });
__webpack_require__.d(__webpack_exports__, "BaseContext", function() { return /* binding */ BaseContext; });

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.replace.js
var es6_regexp_replace = __webpack_require__("Z8gF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.reduce.js
var es6_array_reduce = __webpack_require__("3y5y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__("DbwS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");

// EXTERNAL MODULE: ../node_modules/invariant/browser.js
var browser = __webpack_require__("+Ltg");
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);

// CONCATENATED MODULE: ./.cache/create-react-context.js
/* harmony default export */ var create_react_context = (react_default.a.createContext);
// EXTERNAL MODULE: ./.cache/react-lifecycles-compat.js
var react_lifecycles_compat = __webpack_require__("94VI");

// EXTERNAL MODULE: ../node_modules/@reach/router/es/lib/utils.js
var utils = __webpack_require__("ZkUl");

// EXTERNAL MODULE: ../node_modules/@reach/router/es/lib/history.js
var lib_history = __webpack_require__("ELdr");

// CONCATENATED MODULE: ../node_modules/@reach/router/es/index.js










var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
/* eslint-disable jsx-a11y/anchor-has-content */








 ////////////////////////////////////////////////////////////////////////////////

var es_createNamedContext = function createNamedContext(name, defaultValue) {
  var Ctx = create_react_context(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}; ////////////////////////////////////////////////////////////////////////////////
// Location Context/Provider


var LocationContext = es_createNamedContext("Location"); // sets up a listener if there isn't one already so apps don't need to be
// wrapped in some top level provider

var es_Location = function Location(_ref) {
  var children = _ref.children;
  return react_default.a.createElement(LocationContext.Consumer, null, function (context) {
    return context ? children(context) : react_default.a.createElement(es_LocationProvider, null, children);
  });
};

var es_LocationProvider = function (_React$Component) {
  _inherits(LocationProvider, _React$Component);

  function LocationProvider() {
    var _temp, _this, _ret;

    _classCallCheck(this, LocationProvider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      context: _this.getContext(),
      refs: {
        unlisten: null
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  LocationProvider.prototype.getContext = function getContext() {
    var _props$history = this.props.history,
        navigate = _props$history.navigate,
        location = _props$history.location;
    return {
      navigate: navigate,
      location: location
    };
  };

  LocationProvider.prototype.componentDidCatch = function componentDidCatch(error, info) {
    if (isRedirect(error)) {
      var _navigate = this.props.history.navigate;

      _navigate(error.uri, {
        replace: true
      });
    } else {
      throw error;
    }
  };

  LocationProvider.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevState.context.location !== this.state.context.location) {
      this.props.history._onTransitionComplete();
    }
  };

  LocationProvider.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var refs = this.state.refs,
        history = this.props.history;

    history._onTransitionComplete();

    refs.unlisten = history.listen(function () {
      Promise.resolve().then(function () {
        // TODO: replace rAF with react deferred update API when it's ready https://github.com/facebook/react/issues/13306
        requestAnimationFrame(function () {
          if (!_this2.unmounted) {
            _this2.setState(function () {
              return {
                context: _this2.getContext()
              };
            });
          }
        });
      });
    });
  };

  LocationProvider.prototype.componentWillUnmount = function componentWillUnmount() {
    var refs = this.state.refs;
    this.unmounted = true;
    refs.unlisten();
  };

  LocationProvider.prototype.render = function render() {
    var context = this.state.context,
        children = this.props.children;
    return react_default.a.createElement(LocationContext.Provider, {
      value: context
    }, typeof children === "function" ? children(context) : children || null);
  };

  return LocationProvider;
}(react_default.a.Component); ////////////////////////////////////////////////////////////////////////////////


es_LocationProvider.defaultProps = {
  history: lib_history["globalHistory"]
};
 false ? undefined : void 0;

var es_ServerLocation = function ServerLocation(_ref2) {
  var url = _ref2.url,
      children = _ref2.children;
  var searchIndex = url.indexOf("?");
  var searchExists = searchIndex > -1;
  var pathname = void 0;
  var search = "";
  var hash = "";

  if (searchExists) {
    pathname = url.substring(0, searchIndex);
    search = url.substring(searchIndex);
  } else {
    pathname = url;
  }

  return react_default.a.createElement(LocationContext.Provider, {
    value: {
      location: {
        pathname: pathname,
        search: search,
        hash: hash
      },
      navigate: function navigate() {
        throw new Error("You can't call navigate on the server.");
      }
    }
  }, children);
}; ////////////////////////////////////////////////////////////////////////////////
// Sets baseuri and basepath for nested routers and links


var BaseContext = es_createNamedContext("Base", {
  baseuri: "/",
  basepath: "/"
}); ////////////////////////////////////////////////////////////////////////////////
// The main event, welcome to the show everybody.

var es_Router = function Router(props) {
  return react_default.a.createElement(BaseContext.Consumer, null, function (baseContext) {
    return react_default.a.createElement(es_Location, null, function (locationContext) {
      return react_default.a.createElement(es_RouterImpl, _extends({}, baseContext, locationContext, props));
    });
  });
};

var es_RouterImpl = function (_React$PureComponent) {
  _inherits(RouterImpl, _React$PureComponent);

  function RouterImpl() {
    _classCallCheck(this, RouterImpl);

    return _possibleConstructorReturn(this, _React$PureComponent.apply(this, arguments));
  }

  RouterImpl.prototype.render = function render() {
    var _props = this.props,
        location = _props.location,
        _navigate2 = _props.navigate,
        basepath = _props.basepath,
        primary = _props.primary,
        children = _props.children,
        baseuri = _props.baseuri,
        _props$component = _props.component,
        component = _props$component === undefined ? "div" : _props$component,
        domProps = _objectWithoutProperties(_props, ["location", "navigate", "basepath", "primary", "children", "baseuri", "component"]);

    var routes = react_default.a.Children.toArray(children).reduce(function (array, child) {
      var routes = es_createRoute(basepath)(child);
      return array.concat(routes);
    }, []);
    var pathname = location.pathname;
    var match = Object(utils["c" /* pick */])(routes, pathname);

    if (match) {
      var params = match.params,
          uri = match.uri,
          route = match.route,
          element = match.route.value; // remove the /* from the end for child routes relative paths

      basepath = route["default"] ? basepath : route.path.replace(/\*$/, "");

      var props = _extends({}, params, {
        uri: uri,
        location: location,
        navigate: function navigate(to, options) {
          return _navigate2(Object(utils["d" /* resolve */])(to, uri), options);
        }
      });

      var clone = react_default.a.cloneElement(element, props, element.props.children ? react_default.a.createElement(es_Router, {
        location: location,
        primary: primary
      }, element.props.children) : undefined); // using 'div' for < 16.3 support

      var FocusWrapper = primary ? es_FocusHandler : component; // don't pass any props to 'div'

      var wrapperProps = primary ? _extends({
        uri: uri,
        location: location,
        component: component
      }, domProps) : domProps;
      return react_default.a.createElement(BaseContext.Provider, {
        value: {
          baseuri: uri,
          basepath: basepath
        }
      }, react_default.a.createElement(FocusWrapper, wrapperProps, clone));
    } else {
      // Not sure if we want this, would require index routes at every level
      // warning(
      //   false,
      //   `<Router basepath="${basepath}">\n\nNothing matched:\n\t${
      //     location.pathname
      //   }\n\nPaths checked: \n\t${routes
      //     .map(route => route.path)
      //     .join(
      //       "\n\t"
      //     )}\n\nTo get rid of this warning, add a default NotFound component as child of Router:
      //   \n\tlet NotFound = () => <div>Not Found!</div>
      //   \n\t<Router>\n\t  <NotFound default/>\n\t  {/* ... */}\n\t</Router>`
      // );
      return null;
    }
  };

  return RouterImpl;
}(react_default.a.PureComponent);

es_RouterImpl.defaultProps = {
  primary: true
};
var FocusContext = es_createNamedContext("Focus");

var es_FocusHandler = function FocusHandler(_ref3) {
  var uri = _ref3.uri,
      location = _ref3.location,
      component = _ref3.component,
      domProps = _objectWithoutProperties(_ref3, ["uri", "location", "component"]);

  return react_default.a.createElement(FocusContext.Consumer, null, function (requestFocus) {
    return react_default.a.createElement(es_FocusHandlerImpl, _extends({}, domProps, {
      component: component,
      requestFocus: requestFocus,
      uri: uri,
      location: location
    }));
  });
}; // don't focus on initial render


var initialRender = true;
var focusHandlerCount = 0;

var es_FocusHandlerImpl = function (_React$Component2) {
  _inherits(FocusHandlerImpl, _React$Component2);

  function FocusHandlerImpl() {
    var _temp2, _this4, _ret2;

    _classCallCheck(this, FocusHandlerImpl);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _ret2 = (_temp2 = (_this4 = _possibleConstructorReturn(this, _React$Component2.call.apply(_React$Component2, [this].concat(args))), _this4), _this4.state = {}, _this4.requestFocus = function (node) {
      if (!_this4.state.shouldFocus && node) {
        node.focus();
      }
    }, _temp2), _possibleConstructorReturn(_this4, _ret2);
  }

  FocusHandlerImpl.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    var initial = prevState.uri == null;

    if (initial) {
      return _extends({
        shouldFocus: true
      }, nextProps);
    } else {
      var myURIChanged = nextProps.uri !== prevState.uri;
      var navigatedUpToMe = prevState.location.pathname !== nextProps.location.pathname && nextProps.location.pathname === nextProps.uri;
      return _extends({
        shouldFocus: myURIChanged || navigatedUpToMe
      }, nextProps);
    }
  };

  FocusHandlerImpl.prototype.componentDidMount = function componentDidMount() {
    focusHandlerCount++;
    this.focus();
  };

  FocusHandlerImpl.prototype.componentWillUnmount = function componentWillUnmount() {
    focusHandlerCount--;

    if (focusHandlerCount === 0) {
      initialRender = true;
    }
  };

  FocusHandlerImpl.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.location !== this.props.location && this.state.shouldFocus) {
      this.focus();
    }
  };

  FocusHandlerImpl.prototype.focus = function focus() {
    if (false) {}

    var requestFocus = this.props.requestFocus;

    if (requestFocus) {
      requestFocus(this.node);
    } else {
      if (initialRender) {
        initialRender = false;
      } else if (this.node) {
        // React polyfills [autofocus] and it fires earlier than cDM,
        // so we were stealing focus away, this line prevents that.
        if (!this.node.contains(document.activeElement)) {
          this.node.focus();
        }
      }
    }
  };

  FocusHandlerImpl.prototype.render = function render() {
    var _this5 = this;

    var _props2 = this.props,
        children = _props2.children,
        style = _props2.style,
        requestFocus = _props2.requestFocus,
        _props2$component = _props2.component,
        Comp = _props2$component === undefined ? "div" : _props2$component,
        uri = _props2.uri,
        location = _props2.location,
        domProps = _objectWithoutProperties(_props2, ["children", "style", "requestFocus", "component", "uri", "location"]);

    return react_default.a.createElement(Comp, _extends({
      style: _extends({
        outline: "none"
      }, style),
      tabIndex: "-1",
      ref: function ref(n) {
        return _this5.node = n;
      }
    }, domProps), react_default.a.createElement(FocusContext.Provider, {
      value: this.requestFocus
    }, this.props.children));
  };

  return FocusHandlerImpl;
}(react_default.a.Component);

Object(react_lifecycles_compat["polyfill"])(es_FocusHandlerImpl);

var k = function k() {}; ////////////////////////////////////////////////////////////////////////////////


var forwardRef = react_default.a.forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = function forwardRef(C) {
    return C;
  };
}

var Link = forwardRef(function (_ref4, ref) {
  var innerRef = _ref4.innerRef,
      props = _objectWithoutProperties(_ref4, ["innerRef"]);

  return react_default.a.createElement(BaseContext.Consumer, null, function (_ref5) {
    var basepath = _ref5.basepath,
        baseuri = _ref5.baseuri;
    return react_default.a.createElement(es_Location, null, function (_ref6) {
      var location = _ref6.location,
          navigate = _ref6.navigate;

      var to = props.to,
          state = props.state,
          replace = props.replace,
          _props$getProps = props.getProps,
          getProps = _props$getProps === undefined ? k : _props$getProps,
          anchorProps = _objectWithoutProperties(props, ["to", "state", "replace", "getProps"]);

      var href = Object(utils["d" /* resolve */])(to, baseuri);
      var encodedHref = encodeURI(href);
      var isCurrent = location.pathname === encodedHref;
      var isPartiallyCurrent = Object(utils["f" /* startsWith */])(location.pathname, encodedHref);
      return react_default.a.createElement("a", _extends({
        ref: ref || innerRef,
        "aria-current": isCurrent ? "page" : undefined
      }, anchorProps, getProps({
        isCurrent: isCurrent,
        isPartiallyCurrent: isPartiallyCurrent,
        href: href,
        location: location
      }), {
        href: href,
        onClick: function onClick(event) {
          if (anchorProps.onClick) anchorProps.onClick(event);

          if (shouldNavigate(event)) {
            event.preventDefault();
            var shouldReplace = replace;

            if (typeof replace !== "boolean" && isCurrent) {
              var _location$state = _extends({}, location.state),
                  key = _location$state.key,
                  restState = _objectWithoutProperties(_location$state, ["key"]);

              shouldReplace = Object(utils["e" /* shallowCompare */])(_extends({}, state), restState);
            }

            navigate(href, {
              state: state,
              replace: shouldReplace
            });
          }
        }
      }));
    });
  });
});
Link.displayName = "Link";
 false ? undefined : void 0; ////////////////////////////////////////////////////////////////////////////////

function RedirectRequest(uri) {
  this.uri = uri;
}

var isRedirect = function isRedirect(o) {
  return o instanceof RedirectRequest;
};

var redirectTo = function redirectTo(to) {
  throw new RedirectRequest(to);
};

var es_RedirectImpl = function (_React$Component3) {
  _inherits(RedirectImpl, _React$Component3);

  function RedirectImpl() {
    _classCallCheck(this, RedirectImpl);

    return _possibleConstructorReturn(this, _React$Component3.apply(this, arguments));
  } // Support React < 16 with this hook


  RedirectImpl.prototype.componentDidMount = function componentDidMount() {
    var _props3 = this.props,
        navigate = _props3.navigate,
        to = _props3.to,
        from = _props3.from,
        _props3$replace = _props3.replace,
        replace = _props3$replace === undefined ? true : _props3$replace,
        state = _props3.state,
        noThrow = _props3.noThrow,
        baseuri = _props3.baseuri,
        props = _objectWithoutProperties(_props3, ["navigate", "to", "from", "replace", "state", "noThrow", "baseuri"]);

    Promise.resolve().then(function () {
      var resolvedTo = Object(utils["d" /* resolve */])(to, baseuri);
      navigate(Object(utils["a" /* insertParams */])(resolvedTo, props), {
        replace: replace,
        state: state
      });
    });
  };

  RedirectImpl.prototype.render = function render() {
    var _props4 = this.props,
        navigate = _props4.navigate,
        to = _props4.to,
        from = _props4.from,
        replace = _props4.replace,
        state = _props4.state,
        noThrow = _props4.noThrow,
        baseuri = _props4.baseuri,
        props = _objectWithoutProperties(_props4, ["navigate", "to", "from", "replace", "state", "noThrow", "baseuri"]);

    var resolvedTo = Object(utils["d" /* resolve */])(to, baseuri);
    if (!noThrow) redirectTo(Object(utils["a" /* insertParams */])(resolvedTo, props));
    return null;
  };

  return RedirectImpl;
}(react_default.a.Component);

var es_Redirect = function Redirect(props) {
  return react_default.a.createElement(BaseContext.Consumer, null, function (_ref7) {
    var baseuri = _ref7.baseuri;
    return react_default.a.createElement(es_Location, null, function (locationContext) {
      return react_default.a.createElement(es_RedirectImpl, _extends({}, locationContext, {
        baseuri: baseuri
      }, props));
    });
  });
};

 false ? undefined : void 0; ////////////////////////////////////////////////////////////////////////////////

var es_Match = function Match(_ref8) {
  var path = _ref8.path,
      children = _ref8.children;
  return react_default.a.createElement(BaseContext.Consumer, null, function (_ref9) {
    var baseuri = _ref9.baseuri;
    return react_default.a.createElement(es_Location, null, function (_ref10) {
      var navigate = _ref10.navigate,
          location = _ref10.location;
      var resolvedPath = Object(utils["d" /* resolve */])(path, baseuri);
      var result = Object(utils["b" /* match */])(resolvedPath, location.pathname);
      return children({
        navigate: navigate,
        location: location,
        match: result ? _extends({}, result.params, {
          uri: result.uri,
          path: path
        }) : null
      });
    });
  });
}; ////////////////////////////////////////////////////////////////////////////////
// Hooks


var es_useLocation = function useLocation() {
  var context = Object(react["useContext"])(LocationContext);

  if (!context) {
    throw new Error("useLocation hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }

  return context.location;
};

var es_useNavigate = function useNavigate() {
  var context = Object(react["useContext"])(LocationContext);

  if (!context) {
    throw new Error("useNavigate hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }

  return context.navigate;
};

var es_useParams = function useParams() {
  var context = Object(react["useContext"])(BaseContext);

  if (!context) {
    throw new Error("useParams hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }

  var location = es_useLocation();
  var results = Object(utils["b" /* match */])(context.basepath, location.pathname);
  return results ? results.params : null;
};

var es_useMatch = function useMatch(path) {
  if (!path) {
    throw new Error("useMatch(path: string) requires an argument of a string to match against");
  }

  var context = Object(react["useContext"])(BaseContext);

  if (!context) {
    throw new Error("useMatch hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }

  var location = es_useLocation();
  var resolvedPath = Object(utils["d" /* resolve */])(path, context.baseuri);
  var result = Object(utils["b" /* match */])(resolvedPath, location.pathname);
  return result ? _extends({}, result.params, {
    uri: result.uri,
    path: path
  }) : null;
}; ////////////////////////////////////////////////////////////////////////////////
// Junk


var stripSlashes = function stripSlashes(str) {
  return str.replace(/(^\/+|\/+$)/g, "");
};

var es_createRoute = function createRoute(basepath) {
  return function (element) {
    if (!element) {
      return null;
    }

    if (element.type === react_default.a.Fragment && element.props.children) {
      return react_default.a.Children.map(element.props.children, createRoute(basepath));
    }

    !(element.props.path || element.props["default"] || element.type === es_Redirect) ?  false ? undefined : browser_default()(false) : void 0;
    !!(element.type === es_Redirect && (!element.props.from || !element.props.to)) ?  false ? undefined : browser_default()(false) : void 0;
    !!(element.type === es_Redirect && !Object(utils["g" /* validateRedirect */])(element.props.from, element.props.to)) ?  false ? undefined : browser_default()(false) : void 0;

    if (element.props["default"]) {
      return {
        value: element,
        "default": true
      };
    }

    var elementPath = element.type === es_Redirect ? element.props.from : element.props.path;
    var path = elementPath === "/" ? basepath : stripSlashes(basepath) + "/" + stripSlashes(elementPath);
    return {
      value: element,
      "default": element.props["default"],
      path: element.props.children ? stripSlashes(path) + "/*" : path
    };
  };
};

var shouldNavigate = function shouldNavigate(event) {
  return !event.defaultPrevented && event.button === 0 && !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}; ////////////////////////////////////////////////////////////////////////




/***/ }),

/***/ "JGfN":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("ZVIm")('native-function-to-string', Function.toString);


/***/ }),

/***/ "JKk3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__("UnHL");
var toAbsoluteIndex = __webpack_require__("BUlT");
var toLength = __webpack_require__("Sp5b");

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "Jh4J":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("g2rQ");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "JiyH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("7lGJ");

__webpack_require__("3y5y");

__webpack_require__("yIlq");

var aliases = {
  equals: {
    /*~
     * module: null
     * type: |
     *   ('S 'a).('S 'a) => Boolean
     *   where 'S is Setoid
     */
    'fantasy-land/equals': function fantasyLandEquals(that) {
      return this.equals(that);
    }
  },
  concat: {
    /*~
     * module: null
     * type: |
     *   ('S 'a).('S 'a) => 'S 'a
     *   where 'S is Semigroup
     */
    'fantasy-land/concat': function fantasyLandConcat(that) {
      return this.concat(that);
    }
  },
  empty: {
    /*~
     * module: null
     * type: |
     *   ('M).() => 'M a
     *   where 'M is Monoid
     */
    'fantasy-land/empty': function fantasyLandEmpty() {
      return this.empty();
    }
  },
  map: {
    /*~
     * module: null
     * type: |
     *   ('F 'a).(('a) => 'b) => 'F 'b
     *   where 'F is Functor
     */
    'fantasy-land/map': function fantasyLandMap(transformation) {
      return this.map(transformation);
    }
  },
  apply: {
    /*~
     * module: null
     * type: |
     *   ('F ('a) => b).('F 'a) => 'F 'b
     *   where 'F is Apply
     */
    ap: function ap(that) {
      return this.apply(that);
    },

    /*~
     * module: null
     * type: |
     *   ('F 'a).('F ('a) => 'b) => 'F 'b
     *   where 'F is Apply
     */
    'fantasy-land/ap': function fantasyLandAp(that) {
      return that.apply(this);
    }
  },
  of: {
    /*~
     * module: null
     * type: |
     *   forall F, a:
     *     (F).(a) => F a
     *   where F is Applicative
     */
    'fantasy-land/of': function fantasyLandOf(value) {
      return this.of(value);
    }
  },
  or: {
    /*~
     * module: null
     * type: |
     *   forall F, a:
     *     (F a).(F a) => F a
     *   where F is Functor, Alt
     */
    'fantasy-land/alt': function fantasyLandAlt(value) {
      return this.or(value);
    },

    /*~
     * module: null
     * type: |
     *   forall F, a:
     *     (F a).(F a) => F a
     *   where F is Functor, Alt
     */
    alt: function alt(value) {
      return this.or(value);
    }
  },
  reduce: {
    /*~
     * module: null
     * type: |
     *   forall F, a, b:
     *     (F a).((b, a) => b, b) => b
     *   where F is Foldable
     */
    'fantasy-land/reduce': function fantasyLandReduce(combinator, initial) {
      return this.reduce(combinator, initial);
    }
  },
  traverse: {
    /*~
     * module: null
     * type: |
     *   forall F, T, a, b:
     *     (T a).((a) => F b, (c) => F c) => F (T b)
     *   where F is Apply, T is Traversable
     */
    'fantasy-land/traverse': function fantasyLandTraverse(transformation, lift) {
      return this.traverse(transformation, lift);
    }
  },
  chain: {
    /*~
     * module: null
     * type: |
     *   forall M, a, b:
     *     (M a).((a) => M b) => M b
     *   where M is Chain
     */
    'fantasy-land/chain': function fantasyLandChain(transformation) {
      return this.chain(transformation);
    }
  },
  chainRecursively: {
    /*~
     * module: null
     * type: |
     *   forall M, a, b, c:
     *     (M).(
     *       Step:    ((a) => c, (b) => c, a) => M c,
     *       Initial: a
     *     ) => M b
     *   where M is ChainRec
     */
    chainRec: function chainRec(step, initial) {
      return this.chainRecursively(step, initial);
    },

    /*~
     * module: null
     * type: |
     *   forall M, a, b, c:
     *     (M).(
     *       Step:    ((a) => c, (b) => c, a) => M c,
     *       Initial: a
     *     ) => M b
     *   where M is ChainRec
     */
    'fantasy-land/chainRec': function fantasyLandChainRec(step, initial) {
      return this.chainRecursively(step, initial);
    }
  },
  extend: {
    /*~
     * module: null
     * type: |
     *   forall W, a, b:
     *     (W a).((W a) => b) => W b
     *   where W is Extend
     */
    'fantasy-land/extend': function fantasyLandExtend(transformation) {
      return this.extend(transformation);
    }
  },
  extract: {
    /*~
     * module: null
     * type: |
     *   forall W, a, b:
     *     (W a).() => a
     *   where W is Comonad
     */
    'fantasy-land/extract': function fantasyLandExtract() {
      return this.extract();
    }
  },
  bimap: {
    /*~
     * module: null
     * type: |
     *   forall F, a, b, c, d:
     *     (F a b).((a) => c, (b) => d) => F c d
     *   where F is Bifunctor
     */
    'fantasy-land/bimap': function fantasyLandBimap(f, g) {
      return this.bimap(f, g);
    }
  },
  promap: {
    /*~
     * module: null
     * type: |
     *   forall P, a, b, c, d:
     *     (P a b).((c) => a, (b) => d) => P c d
     */
    'fantasy-land/promap': function fantasyLandPromap(f, g) {
      return this.promap(f, g);
    }
  }
};

var provideAliases = function provideAliases(structure) {
  Object.keys(aliases).forEach(function (method) {
    if (typeof structure[method] === 'function') {
      Object.keys(aliases[method]).forEach(function (alias) {
        structure[alias] = aliases[method][alias];
      });
    }
  });
};

module.exports = provideAliases;

/***/ }),

/***/ "Jjw7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("Z8gF");

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }

  return str.replace(matchOperatorsRe, '\\$&');
};

/***/ }),

/***/ "Jww/":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("wEu9");
var $export = __webpack_require__("X6VK");
var redefine = __webpack_require__("sU/p");
var hide = __webpack_require__("tjmq");
var Iterators = __webpack_require__("Ibj2");
var $iterCreate = __webpack_require__("puZ4");
var setToStringTag = __webpack_require__("jPEw");
var getPrototypeOf = __webpack_require__("A1KM");
var ITERATOR = __webpack_require__("9dxi")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "K+P+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _EllipsisOutlined = _interopRequireDefault(__webpack_require__("M5rE"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var EllipsisOutlined = function EllipsisOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _EllipsisOutlined["default"]
  }));
};

EllipsisOutlined.displayName = 'EllipsisOutlined';

var _default = _react["default"].forwardRef(EllipsisOutlined);

exports["default"] = _default;

/***/ }),

/***/ "K/PF":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("OfmW");
var step = __webpack_require__("VVFi");
var Iterators = __webpack_require__("Ibj2");
var toIObject = __webpack_require__("ml72");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("Jww/")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "K4Ra":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");

// CONCATENATED MODULE: ../node_modules/react-use/esm/util.js
var isClient = typeof window === 'object';
var on = function on(obj) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  return obj.addEventListener.apply(obj, args);
};
var off = function off(obj) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  return obj.removeEventListener.apply(obj, args);
};
var isDeepEqual = __webpack_require__("uLh5");
// CONCATENATED MODULE: ../node_modules/react-use/esm/useMedia.js



var useMedia_useMedia = function useMedia(query, defaultState) {
  if (defaultState === void 0) {
    defaultState = false;
  }

  var _a = Object(react["useState"])(isClient ? function () {
    return window.matchMedia(query).matches;
  } : defaultState),
      state = _a[0],
      setState = _a[1];

  Object(react["useEffect"])(function () {
    var mounted = true;
    var mql = window.matchMedia(query);

    var onChange = function onChange() {
      if (!mounted) {
        return;
      }

      setState(!!mql.matches);
    };

    mql.addListener(onChange);
    setState(mql.matches);
    return function () {
      mounted = false;
      mql.removeListener(onChange);
    };
  }, [query]);
  return state;
};

/* harmony default export */ var esm_useMedia = __webpack_exports__["a"] = (useMedia_useMedia);

/***/ }),

/***/ "K8HH":
/***/ (function(module, exports) {

module.exports = {
  init: function init() {
    return this.xf['@@transducer/init']();
  },
  result: function result(_result) {
    return this.xf['@@transducer/result'](_result);
  }
};

/***/ }),

/***/ "KELd":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("MRte");
__webpack_require__("iKhv");
__webpack_require__("4Xtu");
__webpack_require__("UvcN");
module.exports = __webpack_require__("TaGV").Symbol;


/***/ }),

/***/ "KFSm":
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "Kdq7":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("zWQs");
var defined = __webpack_require__("Xj5l");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "Kn+0":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("V7cS");

/*!
 * domready (c) Dustin Diaz 2014 - License MIT
 * ie10 fix - Mikael Kristiansson 2019
 */
!function (name, definition) {
  if (true) module.exports = definition();else {}
}("domready", function () {
  var ie10 = false;

  if (navigator.appVersion.indexOf("MSIE 10") !== -1) {
    ie10 = true;
  }

  var fns = [],
      _listener,
      doc = typeof document === "object" && document,
      hack = ie10 ? doc.documentElement.doScroll("left") : doc.documentElement.doScroll,
      domContentLoaded = "DOMContentLoaded",
      loaded = doc && (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState);

  if (!loaded && doc) doc.addEventListener(domContentLoaded, _listener = function listener() {
    doc.removeEventListener(domContentLoaded, _listener);
    loaded = 1;

    while (_listener = fns.shift()) {
      _listener();
    }
  });
  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn);
  };
});

/***/ }),

/***/ "KvMB":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9ovy");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  "use strict";

  var htmlConfig = {
    autoSelfClosers: {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'command': true,
      'embed': true,
      'frame': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true,
      'menuitem': true
    },
    implicitlyClosed: {
      'dd': true,
      'li': true,
      'optgroup': true,
      'option': true,
      'p': true,
      'rp': true,
      'rt': true,
      'tbody': true,
      'td': true,
      'tfoot': true,
      'th': true,
      'tr': true
    },
    contextGrabbers: {
      'dd': {
        'dd': true,
        'dt': true
      },
      'dt': {
        'dd': true,
        'dt': true
      },
      'li': {
        'li': true
      },
      'option': {
        'option': true,
        'optgroup': true
      },
      'optgroup': {
        'optgroup': true
      },
      'p': {
        'address': true,
        'article': true,
        'aside': true,
        'blockquote': true,
        'dir': true,
        'div': true,
        'dl': true,
        'fieldset': true,
        'footer': true,
        'form': true,
        'h1': true,
        'h2': true,
        'h3': true,
        'h4': true,
        'h5': true,
        'h6': true,
        'header': true,
        'hgroup': true,
        'hr': true,
        'menu': true,
        'nav': true,
        'ol': true,
        'p': true,
        'pre': true,
        'section': true,
        'table': true,
        'ul': true
      },
      'rp': {
        'rp': true,
        'rt': true
      },
      'rt': {
        'rp': true,
        'rt': true
      },
      'tbody': {
        'tbody': true,
        'tfoot': true
      },
      'td': {
        'td': true,
        'th': true
      },
      'tfoot': {
        'tbody': true
      },
      'th': {
        'td': true,
        'th': true
      },
      'thead': {
        'tbody': true,
        'tfoot': true
      },
      'tr': {
        'tr': true
      }
    },
    doNotIndent: {
      "pre": true
    },
    allowUnquoted: true,
    allowMissing: true,
    caseFold: true
  };
  var xmlConfig = {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false,
    allowMissingTagName: false,
    caseFold: false
  };
  CodeMirror.defineMode("xml", function (editorConf, config_) {
    var indentUnit = editorConf.indentUnit;
    var config = {};
    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;

    for (var prop in defaults) {
      config[prop] = defaults[prop];
    }

    for (var prop in config_) {
      config[prop] = config_[prop];
    } // Return variables for tokenizers


    var type, setStyle;

    function inText(stream, state) {
      function chain(parser) {
        state.tokenize = parser;
        return parser(stream, state);
      }

      var ch = stream.next();

      if (ch == "<") {
        if (stream.eat("!")) {
          if (stream.eat("[")) {
            if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));else return null;
          } else if (stream.match("--")) {
            return chain(inBlock("comment", "-->"));
          } else if (stream.match("DOCTYPE", true, true)) {
            stream.eatWhile(/[\w\._\-]/);
            return chain(doctype(1));
          } else {
            return null;
          }
        } else if (stream.eat("?")) {
          stream.eatWhile(/[\w\._\-]/);
          state.tokenize = inBlock("meta", "?>");
          return "meta";
        } else {
          type = stream.eat("/") ? "closeTag" : "openTag";
          state.tokenize = inTag;
          return "tag bracket";
        }
      } else if (ch == "&") {
        var ok;

        if (stream.eat("#")) {
          if (stream.eat("x")) {
            ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
          } else {
            ok = stream.eatWhile(/[\d]/) && stream.eat(";");
          }
        } else {
          ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
        }

        return ok ? "atom" : "error";
      } else {
        stream.eatWhile(/[^&<]/);
        return null;
      }
    }

    inText.isInText = true;

    function inTag(stream, state) {
      var ch = stream.next();

      if (ch == ">" || ch == "/" && stream.eat(">")) {
        state.tokenize = inText;
        type = ch == ">" ? "endTag" : "selfcloseTag";
        return "tag bracket";
      } else if (ch == "=") {
        type = "equals";
        return null;
      } else if (ch == "<") {
        state.tokenize = inText;
        state.state = baseState;
        state.tagName = state.tagStart = null;
        var next = state.tokenize(stream, state);
        return next ? next + " tag error" : "tag error";
      } else if (/[\'\"]/.test(ch)) {
        state.tokenize = inAttribute(ch);
        state.stringStartCol = stream.column();
        return state.tokenize(stream, state);
      } else {
        stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
        return "word";
      }
    }

    function inAttribute(quote) {
      var closure = function closure(stream, state) {
        while (!stream.eol()) {
          if (stream.next() == quote) {
            state.tokenize = inTag;
            break;
          }
        }

        return "string";
      };

      closure.isInAttribute = true;
      return closure;
    }

    function inBlock(style, terminator) {
      return function (stream, state) {
        while (!stream.eol()) {
          if (stream.match(terminator)) {
            state.tokenize = inText;
            break;
          }

          stream.next();
        }

        return style;
      };
    }

    function doctype(depth) {
      return function (stream, state) {
        var ch;

        while ((ch = stream.next()) != null) {
          if (ch == "<") {
            state.tokenize = doctype(depth + 1);
            return state.tokenize(stream, state);
          } else if (ch == ">") {
            if (depth == 1) {
              state.tokenize = inText;
              break;
            } else {
              state.tokenize = doctype(depth - 1);
              return state.tokenize(stream, state);
            }
          }
        }

        return "meta";
      };
    }

    function Context(state, tagName, startOfLine) {
      this.prev = state.context;
      this.tagName = tagName;
      this.indent = state.indented;
      this.startOfLine = startOfLine;
      if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;
    }

    function popContext(state) {
      if (state.context) state.context = state.context.prev;
    }

    function maybePopContext(state, nextTagName) {
      var parentTagName;

      while (true) {
        if (!state.context) {
          return;
        }

        parentTagName = state.context.tagName;

        if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
          return;
        }

        popContext(state);
      }
    }

    function baseState(type, stream, state) {
      if (type == "openTag") {
        state.tagStart = stream.column();
        return tagNameState;
      } else if (type == "closeTag") {
        return closeTagNameState;
      } else {
        return baseState;
      }
    }

    function tagNameState(type, stream, state) {
      if (type == "word") {
        state.tagName = stream.current();
        setStyle = "tag";
        return attrState;
      } else if (config.allowMissingTagName && type == "endTag") {
        setStyle = "tag bracket";
        return attrState(type, stream, state);
      } else {
        setStyle = "error";
        return tagNameState;
      }
    }

    function closeTagNameState(type, stream, state) {
      if (type == "word") {
        var tagName = stream.current();
        if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);

        if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
          setStyle = "tag";
          return closeState;
        } else {
          setStyle = "tag error";
          return closeStateErr;
        }
      } else if (config.allowMissingTagName && type == "endTag") {
        setStyle = "tag bracket";
        return closeState(type, stream, state);
      } else {
        setStyle = "error";
        return closeStateErr;
      }
    }

    function closeState(type, _stream, state) {
      if (type != "endTag") {
        setStyle = "error";
        return closeState;
      }

      popContext(state);
      return baseState;
    }

    function closeStateErr(type, stream, state) {
      setStyle = "error";
      return closeState(type, stream, state);
    }

    function attrState(type, _stream, state) {
      if (type == "word") {
        setStyle = "attribute";
        return attrEqState;
      } else if (type == "endTag" || type == "selfcloseTag") {
        var tagName = state.tagName,
            tagStart = state.tagStart;
        state.tagName = state.tagStart = null;

        if (type == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(tagName)) {
          maybePopContext(state, tagName);
        } else {
          maybePopContext(state, tagName);
          state.context = new Context(state, tagName, tagStart == state.indented);
        }

        return baseState;
      }

      setStyle = "error";
      return attrState;
    }

    function attrEqState(type, stream, state) {
      if (type == "equals") return attrValueState;
      if (!config.allowMissing) setStyle = "error";
      return attrState(type, stream, state);
    }

    function attrValueState(type, stream, state) {
      if (type == "string") return attrContinuedState;

      if (type == "word" && config.allowUnquoted) {
        setStyle = "string";
        return attrState;
      }

      setStyle = "error";
      return attrState(type, stream, state);
    }

    function attrContinuedState(type, stream, state) {
      if (type == "string") return attrContinuedState;
      return attrState(type, stream, state);
    }

    return {
      startState: function startState(baseIndent) {
        var state = {
          tokenize: inText,
          state: baseState,
          indented: baseIndent || 0,
          tagName: null,
          tagStart: null,
          context: null
        };
        if (baseIndent != null) state.baseIndent = baseIndent;
        return state;
      },
      token: function token(stream, state) {
        if (!state.tagName && stream.sol()) state.indented = stream.indentation();
        if (stream.eatSpace()) return null;
        type = null;
        var style = state.tokenize(stream, state);

        if ((style || type) && style != "comment") {
          setStyle = null;
          state.state = state.state(type || style, stream, state);
          if (setStyle) style = setStyle == "error" ? style + " error" : setStyle;
        }

        return style;
      },
      indent: function indent(state, textAfter, fullLine) {
        var context = state.context; // Indent multi-line strings (e.g. css).

        if (state.tokenize.isInAttribute) {
          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;
        }

        if (context && context.noIndent) return CodeMirror.Pass;
        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0; // Indent the starts of attribute names.

        if (state.tagName) {
          if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
        }

        if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
        var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);

        if (tagAfter && tagAfter[1]) {
          // Closing tag spotted
          while (context) {
            if (context.tagName == tagAfter[2]) {
              context = context.prev;
              break;
            } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
              context = context.prev;
            } else {
              break;
            }
          }
        } else if (tagAfter) {
          // Opening tag spotted
          while (context) {
            var grabbers = config.contextGrabbers[context.tagName];
            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;
          }
        }

        while (context && context.prev && !context.startOfLine) {
          context = context.prev;
        }

        if (context) return context.indent + indentUnit;else return state.baseIndent || 0;
      },
      electricInput: /<\/[\s\w:]+>$/,
      blockCommentStart: "<!--",
      blockCommentEnd: "-->",
      configuration: config.htmlMode ? "html" : "xml",
      helperType: config.htmlMode ? "html" : "xml",
      skipAttribute: function skipAttribute(state) {
        if (state.state == attrValueState) state.state = attrState;
      },
      xmlCurrentTag: function xmlCurrentTag(state) {
        return state.tagName ? {
          name: state.tagName,
          close: state.type == "closeTag"
        } : null;
      },
      xmlCurrentContext: function xmlCurrentContext(state) {
        var context = [];

        for (var cx = state.context; cx; cx = cx.prev) {
          if (cx.tagName) context.push(cx.tagName);
        }

        return context.reverse();
      }
    };
  });
  CodeMirror.defineMIME("text/xml", "xml");
  CodeMirror.defineMIME("application/xml", "xml");
  if (!CodeMirror.mimeModes.hasOwnProperty("text/html")) CodeMirror.defineMIME("text/html", {
    name: "xml",
    htmlMode: true
  });
});

/***/ }),

/***/ "KyLU":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("KELd"), __esModule: true };

/***/ }),

/***/ "Kz1y":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__("PSh9");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = _assign2["default"] || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "LAIM":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__("X6VK");
$export($export.S, 'Object', { is: __webpack_require__("Nu7b") });


/***/ }),

/***/ "LEAW":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");
var fails = __webpack_require__("E7Vc");
var defined = __webpack_require__("GCOZ");
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),

/***/ "LGMZ":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _equals = __webpack_require__("XQie");
/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */


module.exports = _curry2(function equals(a, b) {
  return _equals(a, b, [], []);
});

/***/ }),

/***/ "LKC9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Portal; });
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("PAbq");
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("1qKx");
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("d3/y");
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("+jjx");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("ABKx");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("xARA");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("W0B4");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_7__);






function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}





var Portal = /*#__PURE__*/function (_React$Component) {
  _inherits(Portal, _React$Component);

  function Portal() {
    _classCallCheck(this, Portal);

    return _possibleConstructorReturn(this, _getPrototypeOf(Portal).apply(this, arguments));
  }

  _createClass(Portal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.createContainer();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var didUpdate = this.props.didUpdate;

      if (didUpdate) {
        didUpdate(prevProps);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeContainer();
    }
  }, {
    key: "createContainer",
    value: function createContainer() {
      this._container = this.props.getContainer();
      this.forceUpdate();
    }
  }, {
    key: "removeContainer",
    value: function removeContainer() {
      if (this._container) {
        this._container.parentNode.removeChild(this._container);
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (this._container) {
        return react_dom__WEBPACK_IMPORTED_MODULE_6___default.a.createPortal(this.props.children, this._container);
      }

      return null;
    }
  }]);

  return Portal;
}(react__WEBPACK_IMPORTED_MODULE_5___default.a.Component);

Portal.propTypes = {
  getContainer: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func.isRequired,
  children: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.node.isRequired,
  didUpdate: prop_types__WEBPACK_IMPORTED_MODULE_7___default.a.func
};


/***/ }),

/***/ "LOD0":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _dispatchable = __webpack_require__("ex0g");

var _filter = __webpack_require__("+H3U");

var _isObject = __webpack_require__("Ln+j");

var _reduce = __webpack_require__("o2D/");

var _xfilter = __webpack_require__("jCf+");

var keys = __webpack_require__("bmJ9");
/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array} Filterable
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */


module.exports = _curry2(_dispatchable(['filter'], _xfilter, function (pred, filterable) {
  return _isObject(filterable) ? _reduce(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }

    return acc;
  }, {}, keys(filterable)) : // else
  _filter(pred, filterable);
}));

/***/ }),

/***/ "LPDj":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("E6Ca");
module.exports = __webpack_require__("TaGV").Object.setPrototypeOf;


/***/ }),

/***/ "LTuF":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("7lGJ");

__webpack_require__("d3/y");

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var generate_1 = __importDefault(__webpack_require__("TEyA"));

exports.generate = generate_1["default"];
var presetPrimaryColors = {
  red: '#F5222D',
  volcano: '#FA541C',
  orange: '#FA8C16',
  gold: '#FAAD14',
  yellow: '#FADB14',
  lime: '#A0D911',
  green: '#52C41A',
  cyan: '#13C2C2',
  blue: '#1890FF',
  geekblue: '#2F54EB',
  purple: '#722ED1',
  magenta: '#EB2F96',
  grey: '#666666'
};
exports.presetPrimaryColors = presetPrimaryColors;
var presetPalettes = {};
exports.presetPalettes = presetPalettes;
Object.keys(presetPrimaryColors).forEach(function (key) {
  presetPalettes[key] = generate_1["default"](presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5];
});
var red = presetPalettes.red;
exports.red = red;
var volcano = presetPalettes.volcano;
exports.volcano = volcano;
var gold = presetPalettes.gold;
exports.gold = gold;
var orange = presetPalettes.orange;
exports.orange = orange;
var yellow = presetPalettes.yellow;
exports.yellow = yellow;
var lime = presetPalettes.lime;
exports.lime = lime;
var green = presetPalettes.green;
exports.green = green;
var cyan = presetPalettes.cyan;
exports.cyan = cyan;
var blue = presetPalettes.blue;
exports.blue = blue;
var geekblue = presetPalettes.geekblue;
exports.geekblue = geekblue;
var purple = presetPalettes.purple;
exports.purple = purple;
var magenta = presetPalettes.magenta;
exports.magenta = magenta;
var grey = presetPalettes.grey;
exports.grey = grey;

/***/ }),

/***/ "LXYL":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__("X6VK");
var create = __webpack_require__("Vx+c");
var aFunction = __webpack_require__("b8Rm");
var anObject = __webpack_require__("PAFS");
var isObject = __webpack_require__("Bsg+");
var fails = __webpack_require__("E7Vc");
var bind = __webpack_require__("oAuq");
var rConstruct = (__webpack_require__("P56o").Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "LeKB":
/***/ (function(module, exports, __webpack_require__) {

module.exports=[{plugin:__webpack_require__("zuwH"),options:{"plugins":[]}},{plugin:__webpack_require__("CnhP"),options:{"plugins":[]}},{plugin:__webpack_require__("6vZ6"),options:{"plugins":[],"name":"ucan","short_name":"ucan","start_url":"/","background_color":"#db4241","theme_color":"#db4241","display":"minimal-ui","icon":"/home/ejleone/Desktop/Ucanlanding/gatsby-theme-antv/@antv/gatsby-theme-antv/site/images/favicon.png"}},{plugin:__webpack_require__("6K2M"),options:{"plugins":[]}},{plugin:__webpack_require__("TOXe"),options:{"plugins":[]}},{plugin:__webpack_require__("dXJ/"),options:{"plugins":[],"component":"/home/ejleone/Desktop/Ucanlanding/gatsby-theme-antv/@antv/gatsby-theme-antv/site/layouts/layout.tsx"}},{plugin:__webpack_require__("TOXe"),options:{"plugins":[],"color":"#db4241"}},{plugin:__webpack_require__("Grb3"),options:{"plugins":[],"trackingId":"UA-XXXXXXXXX-X"}},{plugin:__webpack_require__("+Yd0"),options:{"plugins":[],"GATrackingId":"UA-XXXXXXXXX-X","pathPrefix":"/ucanlanding","theme":{"primary-color":"#db4241"},"pwa":true,"cname":true,"codeSplit":true}},{plugin:__webpack_require__("GddB"),options:{"plugins":[]}}];

/***/ }),

/***/ "Ln+j":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

module.exports = function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
};

/***/ }),

/***/ "LuBU":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("at5L");
var enumBugKeys = __webpack_require__("fQty");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "M/4x":
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__("sU/p")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "M5rE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var EllipsisOutlined = {
  "name": "ellipsis",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z"
      }
    }]
  }
};
exports["default"] = EllipsisOutlined;

/***/ }),

/***/ "MBcE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__("PAFS");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "MMYs":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _CheckOutlined = _interopRequireDefault(__webpack_require__("XgqJ"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _CheckOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "MNOf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("+3V6");

__webpack_require__("V7cS");

__webpack_require__("Z8gF");

__webpack_require__("asZ9");

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ "MRte":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__("41F1");
var has = __webpack_require__("qA3Z");
var DESCRIPTORS = __webpack_require__("lBnu");
var $export = __webpack_require__("/6KZ");
var redefine = __webpack_require__("5BpW");
var META = __webpack_require__("hYpR").KEY;
var $fails = __webpack_require__("/Vl9");
var shared = __webpack_require__("67sl");
var setToStringTag = __webpack_require__("sWB5");
var uid = __webpack_require__("ct/D");
var wks = __webpack_require__("0Sp3");
var wksExt = __webpack_require__("eTWF");
var wksDefine = __webpack_require__("YlUf");
var enumKeys = __webpack_require__("T4P6");
var isArray = __webpack_require__("Jh4J");
var anObject = __webpack_require__("ADe/");
var isObject = __webpack_require__("fGh/");
var toObject = __webpack_require__("dCrc");
var toIObject = __webpack_require__("T/1i");
var toPrimitive = __webpack_require__("HbTz");
var createDesc = __webpack_require__("zJT+");
var _create = __webpack_require__("G+Zn");
var gOPNExt = __webpack_require__("dn9X");
var $GOPD = __webpack_require__("0HwX");
var $GOPS = __webpack_require__("phsM");
var $DP = __webpack_require__("eOWL");
var $keys = __webpack_require__("/Lgp");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("sqS1").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("kBaS").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("gtwY")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("PPkd")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "MYxt":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__("X6VK");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),

/***/ "MlAH":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _ucan_public_static_d_3978990474_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7S3h");
var _ucan_public_static_d_3978990474_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t("7S3h", 1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_helmet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("tj/o");
/* harmony import */ var react_helmet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_helmet__WEBPACK_IMPORTED_MODULE_2__);


/**
 * SEO component that queries for data with
 *  Gatsby's useStaticQuery React hook
 *
 * See: https://www.gatsbyjs.org/docs/use-static-query/
 */



var SEO = function SEO(_ref) {
  var description = _ref.description,
      _ref$lang = _ref.lang,
      lang = _ref$lang === void 0 ? '' : _ref$lang,
      _ref$meta = _ref.meta,
      meta = _ref$meta === void 0 ? [] : _ref$meta,
      title = _ref.title,
      titleSuffix = _ref.titleSuffix;
  var site = _ucan_public_static_d_3978990474_json__WEBPACK_IMPORTED_MODULE_0__.data.site;
  var metaDescription = description || site.siteMetadata.description;
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_helmet__WEBPACK_IMPORTED_MODULE_2__["Helmet"], {
    htmlAttributes: {
      lang: lang
    },
    title: title,
    titleTemplate: "%s | " + (titleSuffix || site.siteMetadata.title),
    meta: [{
      name: "description",
      content: metaDescription
    }, {
      property: "og:title",
      content: title
    }, {
      property: "og:description",
      content: metaDescription
    }, {
      property: "og:image",
      content: 'https://gw.alipayobjects.com/zos/antfincdn/FLrTNDvlna/antv.png'
    }, {
      property: "og:type",
      content: "website"
    }, {
      name: "twitter:card",
      content: "summary"
    }, {
      name: "twitter:title",
      content: title
    }, {
      name: "twitter:description",
      content: metaDescription
    }, {
      property: "twitter:image",
      content: 'https://gw.alipayobjects.com/zos/antfincdn/FLrTNDvlna/antv.png'
    }].concat(meta)
  });
};

SEO.defaultProps = {
  lang: "en",
  meta: [],
  description: ""
};
/* harmony default export */ __webpack_exports__["a"] = (SEO);

/***/ }),

/***/ "N6/Q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__("lAKj");
__webpack_require__("X6VK")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "N9zW":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "NR3o":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__("GGqZ");
var getKeys = __webpack_require__("LuBU");
var gOPS = __webpack_require__("0oPD");
var pIE = __webpack_require__("IdFN");
var toObject = __webpack_require__("UnHL");
var IObject = __webpack_require__("Cmsx");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("E7Vc")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "NS33":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


__webpack_require__("GkPX");

var ReactPropTypesSecret = __webpack_require__("E02R");

function emptyFunction() {}

function emptyFunctionWithReset() {}

emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }

    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  }

  ;
  shim.isRequired = shim;

  function getShim() {
    return shim;
  }

  ; // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/***/ }),

/***/ "NSX3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _api_runner_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("xtsi");
/* harmony import */ var _api_runner_browser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_api_runner_browser__WEBPACK_IMPORTED_MODULE_0__);
if(window.location.protocol!=="https:"&&window.location.hostname!=="localhost"){console.error("Service workers can only be used over HTTPS, or on localhost for development");}else if("serviceWorker"in navigator){navigator.serviceWorker.register("/ucanlanding"+"/sw.js").then(function(reg){reg.addEventListener("updatefound",function(){Object(_api_runner_browser__WEBPACK_IMPORTED_MODULE_0__["apiRunner"])("onServiceWorkerUpdateFound",{serviceWorker:reg});// The updatefound event implies that reg.installing is set; see
// https://w3c.github.io/ServiceWorker/#service-worker-registration-updatefound-event
var installingWorker=reg.installing;console.log("installingWorker",installingWorker);installingWorker.addEventListener("statechange",function(){switch(installingWorker.state){case"installed":if(navigator.serviceWorker.controller){// At this point, the old content will have been purged and the fresh content will
// have been added to the cache.
// We set a flag so Gatsby Link knows to refresh the page on next navigation attempt
window.___swUpdated=true;// We call the onServiceWorkerUpdateReady API so users can show update prompts.
Object(_api_runner_browser__WEBPACK_IMPORTED_MODULE_0__["apiRunner"])("onServiceWorkerUpdateReady",{serviceWorker:reg});// If resources failed for the current page, reload.
if(window.___failedResources){console.log("resources failed, SW updated - reloading");window.location.reload();}}else{// At this point, everything has been precached.
// It's the perfect time to display a "Content is cached for offline use." message.
console.log("Content is now available offline!");// Post to service worker that install is complete.
// Delay to allow time for the event listener to be added --
// otherwise fetch is called too soon and resources aren't cached.
Object(_api_runner_browser__WEBPACK_IMPORTED_MODULE_0__["apiRunner"])("onServiceWorkerInstalled",{serviceWorker:reg});}break;case"redundant":console.error("The installing service worker became redundant.");Object(_api_runner_browser__WEBPACK_IMPORTED_MODULE_0__["apiRunner"])("onServiceWorkerRedundant",{serviceWorker:reg});break;case"activated":Object(_api_runner_browser__WEBPACK_IMPORTED_MODULE_0__["apiRunner"])("onServiceWorkerActive",{serviceWorker:reg});break;}});});}).catch(function(e){console.error("Error during service worker registration:",e);});}

/***/ }),

/***/ "NToG":
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "NU6T":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");

var curryN = __webpack_require__("3D/W");
/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN
 * @example
 *
 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */


module.exports = _curry1(function curry(fn) {
  return curryN(fn.length, fn);
});

/***/ }),

/***/ "NUlt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _CheckCircleOutlined = _interopRequireDefault(__webpack_require__("OMNp"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var CheckCircleOutlined = function CheckCircleOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _CheckCircleOutlined["default"]
  }));
};

CheckCircleOutlined.displayName = 'CheckCircleOutlined';

var _default = _react["default"].forwardRef(CheckCircleOutlined);

exports["default"] = _default;

/***/ }),

/***/ "NVL/":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__("Bsg+");
var cof = __webpack_require__("n+VH");
var MATCH = __webpack_require__("9dxi")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "NYms":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// CONCATENATED MODULE: ../node_modules/@ant-design/icons-svg/es/asn/LoadingOutlined.js
// This icon file is generated automatically.
// tslint:disable
var LoadingOutlined_LoadingOutlined = {
  "name": "loading",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"
      }
    }]
  }
};
/* harmony default export */ var asn_LoadingOutlined = (LoadingOutlined_LoadingOutlined);
// EXTERNAL MODULE: ../node_modules/@ant-design/icons/es/components/AntdIcon.js + 2 modules
var AntdIcon = __webpack_require__("uoK5");

// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/icons/LoadingOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var icons_LoadingOutlined_LoadingOutlined = function LoadingOutlined(props, ref) {
  return react_default.a.createElement(AntdIcon["a" /* default */], Object.assign({}, props, {
    ref: ref,
    icon: asn_LoadingOutlined
  }));
};

icons_LoadingOutlined_LoadingOutlined.displayName = 'LoadingOutlined';
/* harmony default export */ var icons_LoadingOutlined = (react_default.a.forwardRef(icons_LoadingOutlined_LoadingOutlined));
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/components/PageLoading.module.less
var PageLoading_module = __webpack_require__("L+cS");
var PageLoading_module_default = /*#__PURE__*/__webpack_require__.n(PageLoading_module);

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/PageLoading.tsx




var PageLoading_PageLoading = function PageLoading() {
  return react_default.a.createElement("div", {
    className: PageLoading_module_default.a.container
  }, react_default.a.createElement(icons_LoadingOutlined, {
    className: PageLoading_module_default.a.loading
  }));
};

/* harmony default export */ var components_PageLoading = __webpack_exports__["a"] = (PageLoading_PageLoading);

/***/ }),

/***/ "Ndiv":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__("LEAW")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),

/***/ "NhxO":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__("p1Jl")
});


/***/ }),

/***/ "Nu7b":
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "NyDw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _SearchOutlined = _interopRequireDefault(__webpack_require__("RaTo"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var SearchOutlined = function SearchOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _SearchOutlined["default"]
  }));
};

SearchOutlined.displayName = 'SearchOutlined';

var _default = _react["default"].forwardRef(SearchOutlined);

exports["default"] = _default;

/***/ }),

/***/ "O6Bp":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports["default"] = void 0;

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _inheritsLoose2 = _interopRequireDefault(__webpack_require__("QKC2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _reactDom = _interopRequireDefault(__webpack_require__("xARA"));

var _warning = _interopRequireDefault(__webpack_require__("5CuE"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var propTypes = {
  scrollKey: _propTypes["default"].string.isRequired,
  shouldUpdateScroll: _propTypes["default"].func,
  children: _propTypes["default"].element.isRequired
};
var contextTypes = {
  // This is necessary when rendering on the client. However, when rendering on
  // the server, this container will do nothing, and thus does not require the
  // scroll behavior context.
  scrollBehavior: _propTypes["default"].object
};

var ScrollContainer = /*#__PURE__*/function (_React$Component) {
  (0, _inheritsLoose2["default"])(ScrollContainer, _React$Component);

  function ScrollContainer(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this; // We don't re-register if the scroll key changes, so make sure we
    // unregister with the initial scroll key just in case the user changes it.

    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "shouldUpdateScroll", function (prevRouterProps, routerProps) {
      var shouldUpdateScroll = _this.props.shouldUpdateScroll;

      if (!shouldUpdateScroll) {
        return true;
      } // Hack to allow accessing scrollBehavior._stateStorage.


      return shouldUpdateScroll.call(_this.context.scrollBehavior.scrollBehavior, prevRouterProps, routerProps);
    });
    _this.scrollKey = props.scrollKey;
    return _this;
  }

  var _proto = ScrollContainer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.context.scrollBehavior.registerElement(this.props.scrollKey, _reactDom["default"].findDOMNode(this), // eslint-disable-line react/no-find-dom-node
    this.shouldUpdateScroll); // Only keep around the current DOM node in development, as this is only
    // for emitting the appropriate warning.

    if (false) {}
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    (0, _warning["default"])(prevProps.scrollKey === this.props.scrollKey, "<ScrollContainer> does not support changing scrollKey.");

    if (false) { var prevDomNode; }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.context.scrollBehavior.unregisterElement(this.scrollKey);
  };

  _proto.render = function render() {
    return this.props.children;
  };

  return ScrollContainer;
}(_react["default"].Component);

ScrollContainer.propTypes = propTypes;
ScrollContainer.contextTypes = contextTypes;
var _default = ScrollContainer;
exports["default"] = _default;

/***/ }),

/***/ "OFPg":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");

var _isPlaceholder = __webpack_require__("SaPD");
/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


module.exports = function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;

      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
};

/***/ }),

/***/ "OFVL":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("n+VH");
var TAG = __webpack_require__("9dxi")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "OMNp":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CheckCircleOutlined = {
  "name": "check-circle",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }]
  }
};
exports["default"] = CheckCircleOutlined;

/***/ }),

/***/ "OdHn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("4aJ6");__webpack_require__("t91x");var React=__webpack_require__("mXGw");var preferDefault=function preferDefault(m){return m&&m.default||m;};var Layout;try{Layout=preferDefault(__webpack_require__("vTVJ"));}catch(e){if(e.toString().indexOf("Error: Cannot find module")!==-1){throw new Error("Couldn't find layout component at \""+"/home/ejleone/Desktop/Ucanlanding/gatsby-theme-antv/@antv/gatsby-theme-antv/site/layouts/layout.tsx"+".\n\n"+"Please create layout component in that location or specify path to layout component in gatsby-config.js");}else{// Logging the error for debugging older browsers as there is no way
// to wrap the thrown error in a try/catch.
console.error(e);throw e;}}// eslint-disable-next-line react/prop-types,react/display-name
module.exports=function(_ref){var element=_ref.element,props=_ref.props;return React.createElement(Layout,props,element);};

/***/ }),

/***/ "OeCt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CloseCircleFilled = {
  "name": "close-circle",
  "theme": "filled",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z"
      }
    }]
  }
};
exports["default"] = CloseCircleFilled;

/***/ }),

/***/ "OfmW":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__("9dxi")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("tjmq")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "OgXt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("+3V6");

__webpack_require__("yIlq");

__webpack_require__("3y5y");

__webpack_require__("GkPX");

__webpack_require__("+jjx");

__webpack_require__("6/FK");

__webpack_require__("2Tod");

__webpack_require__("7lGJ");

__webpack_require__("9p7t");

__webpack_require__("ABKx");

__webpack_require__("75LO");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("lQyR");

__webpack_require__("orKN");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warning = warning;
exports.isIconDefinition = isIconDefinition;
exports.normalizeAttrs = normalizeAttrs;
exports.generate = generate;
exports.getSecondaryColor = getSecondaryColor;
exports.normalizeTwoToneColors = normalizeTwoToneColors;
exports.useInsertStyles = exports.iconStyles = exports.svgBaseProps = void 0;

var _colors = __webpack_require__("LTuF");

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _warning = _interopRequireDefault(__webpack_require__("HApA"));

var _insertCss = __webpack_require__("3Q0B");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function warning(valid, message) {
  (0, _warning["default"])(valid, "[@ant-design/icons] ".concat(message));
}

function isIconDefinition(target) {
  return _typeof(target) === 'object' && typeof target.name === 'string' && typeof target.theme === 'string' && (_typeof(target.icon) === 'object' || typeof target.icon === 'function');
}

function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(attrs).reduce(function (acc, key) {
    var val = attrs[key];

    switch (key) {
      case 'class':
        acc.className = val;
        delete acc["class"];
        break;

      default:
        acc[key] = val;
    }

    return acc;
  }, {});
}

function generate(node, key, rootProps) {
  if (!rootProps) {
    return _react["default"].createElement(node.tag, _objectSpread({
      key: key
    }, normalizeAttrs(node.attrs)), (node.children || []).map(function (child, index) {
      return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
    }));
  }

  return _react["default"].createElement(node.tag, _objectSpread({
    key: key
  }, normalizeAttrs(node.attrs), {}, rootProps), (node.children || []).map(function (child, index) {
    return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
  }));
}

function getSecondaryColor(primaryColor) {
  // choose the second color
  return (0, _colors.generate)(primaryColor)[0];
}

function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }

  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
} // These props make sure that the SVG behaviours like general text.
// Reference: https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4


var svgBaseProps = {
  width: '1em',
  height: '1em',
  fill: 'currentColor',
  'aria-hidden': 'true',
  focusable: 'false'
};
exports.svgBaseProps = svgBaseProps;
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
exports.iconStyles = iconStyles;
var cssInjectedFlag = false;

var useInsertStyles = function useInsertStyles() {
  var styleStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iconStyles;
  (0, _react.useEffect)(function () {
    if (!cssInjectedFlag) {
      (0, _insertCss.insertCss)(styleStr, {
        prepend: true
      });
      cssInjectedFlag = true;
    }
  }, []);
};

exports.useInsertStyles = useInsertStyles;

/***/ }),

/***/ "OvAC":
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "P+uj":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _getPrototypeOf; });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "P/oo":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var toIObject = __webpack_require__("ml72");
var toInteger = __webpack_require__("mvii");
var toLength = __webpack_require__("Sp5b");
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__("/6rt")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),

/***/ "P3BQ":
/***/ (function(module, exports) {

module.exports = function _arrayFromIterator(iter) {
  var list = [];
  var next;

  while (!(next = iter.next()).done) {
    list.push(next.value);
  }

  return list;
};

/***/ }),

/***/ "P56o":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "PAFS":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("Bsg+");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "PAbq":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__("Vx+c") });


/***/ }),

/***/ "PE9J":
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),

/***/ "PPkd":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("eOWL");
var createDesc = __webpack_require__("zJT+");
module.exports = __webpack_require__("lBnu") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "PSh9":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("AFnJ"), __esModule: true };

/***/ }),

/***/ "Pfmf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__("UnHL");
var toAbsoluteIndex = __webpack_require__("BUlT");
var toLength = __webpack_require__("Sp5b");
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "PgXy":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Dependencies

__webpack_require__("Z8gF");

__webpack_require__("nsbO");

__webpack_require__("9p7t");

__webpack_require__("e2Kn");

__webpack_require__("asZ9");

__webpack_require__("FEHE");

__webpack_require__("V7cS");

__webpack_require__("PAbq");

__webpack_require__("m8zh");

var protocols = __webpack_require__("30gj"),
    isSsh = __webpack_require__("2agF"),
    qs = __webpack_require__("UKnr");
/**
 * parsePath
 * Parses the input url.
 *
 * @name parsePath
 * @function
 * @param {String} url The input url.
 * @return {Object} An object containing the following fields:
 *
 *  - `protocols` (Array): An array with the url protocols (usually it has one element).
 *  - `protocol` (String): The first protocol, `"ssh"` (if the url is a ssh url) or `"file"`.
 *  - `port` (null|Number): The domain port.
 *  - `resource` (String): The url domain (including subdomains).
 *  - `user` (String): The authentication user (usually for ssh urls).
 *  - `pathname` (String): The url pathname.
 *  - `hash` (String): The url hash.
 *  - `search` (String): The url querystring value.
 *  - `href` (String): The input url.
 *  - `query` (Object): The url querystring, parsed as object.
 */


function parsePath(url) {
  url = (url || "").trim();
  var output = {
    protocols: protocols(url),
    protocol: null,
    port: null,
    resource: "",
    user: "",
    pathname: "",
    hash: "",
    search: "",
    href: url,
    query: Object.create(null)
  },
      protocolIndex = url.indexOf("://"),
      resourceIndex = -1,
      splits = null,
      parts = null;

  if (url.startsWith(".")) {
    if (url.startsWith("./")) {
      url = url.substring(2);
    }

    output.pathname = url;
    output.protocol = "file";
  }

  var firstChar = url.charAt(1);

  if (!output.protocol) {
    output.protocol = output.protocols[0];

    if (!output.protocol) {
      if (isSsh(url)) {
        output.protocol = "ssh";
      } else if (firstChar === "/" || firstChar === "~") {
        url = url.substring(2);
        output.protocol = "file";
      } else {
        output.protocol = "file";
      }
    }
  }

  if (protocolIndex !== -1) {
    url = url.substring(protocolIndex + 3);
  }

  parts = url.split("/");

  if (output.protocol !== "file") {
    output.resource = parts.shift();
  } else {
    output.resource = "";
  } // user@domain


  splits = output.resource.split("@");

  if (splits.length === 2) {
    output.user = splits[0];
    output.resource = splits[1];
  } // domain.com:port


  splits = output.resource.split(":");

  if (splits.length === 2) {
    output.resource = splits[0];

    if (splits[1]) {
      output.port = Number(splits[1]);

      if (isNaN(output.port)) {
        output.port = null;
        parts.unshift(splits[1]);
      }
    } else {
      output.port = null;
    }
  } // Remove empty elements


  parts = parts.filter(Boolean); // Stringify the pathname

  if (output.protocol === "file") {
    output.pathname = output.href;
  } else {
    output.pathname = output.pathname || (output.protocol !== "file" || output.href[0] === "/" ? "/" : "") + parts.join("/");
  } // #some-hash


  splits = output.pathname.split("#");

  if (splits.length === 2) {
    output.pathname = splits[0];
    output.hash = splits[1];
  } // ?foo=bar


  splits = output.pathname.split("?");

  if (splits.length === 2) {
    output.pathname = splits[0];
    output.search = splits[1];
  }

  output.query = qs.parse(output.search);
  output.href = output.href.replace(/\/$/, "");
  output.pathname = output.pathname.replace(/\/$/, "");
  return output;
}

module.exports = parsePath;

/***/ }),

/***/ "Prd0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("FEHE");__webpack_require__("it7j");exports.__esModule=true;exports.default=void 0;/**
 * Get a manifest filename depending on localized pathname
 *
 * @param {string} pathname
 * @param {Array<{start_url: string, lang: string}>} localizedManifests
 * @return string
 */var _default=function _default(pathname,localizedManifests){var defaultFilename="manifest.webmanifest";if(!Array.isArray(localizedManifests)){return defaultFilename;}var localizedManifest=localizedManifests.find(function(app){return pathname.startsWith(app.start_url);});if(!localizedManifest){return defaultFilename;}return"manifest_"+localizedManifest.lang+".webmanifest";};exports.default=_default;

/***/ }),

/***/ "Q5TA":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("67sl")('keys');
var uid = __webpack_require__("ct/D");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "QHSJ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("asZ9");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _curry = __webpack_require__("NU6T");

var _curry2 = _interopRequireDefault(_curry);

var _getValidLangKey = __webpack_require__("l5BI");

var _getValidLangKey2 = _interopRequireDefault(_getValidLangKey);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Get current language key from url.
 * @func
 * @param {[String]} langs allowed lang keys ['en', 'fr', 'pt']
 * @param {String} defaultLangKey default browser language key
 * @param {String} url browser url
 * @returns {String} current langKey
 */


var getCurrentLangKey = (0, _curry2["default"])(function (langs, defaultLangKey, url) {
  var langKey = url.split('/')[1];
  return (0, _getValidLangKey2["default"])(langs, defaultLangKey, langKey);
});
exports["default"] = getCurrentLangKey;

/***/ }),

/***/ "QKC2":
/***/ (function(module, exports) {

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

module.exports = _inheritsLoose;

/***/ }),

/***/ "QVtb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("sfhO"),
    Error = _require.Error,
    Ok = _require.Ok;

var deprecated = __webpack_require__("GFZo");
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   forall a, b:
 *     (a or None, b) => Result b a
 *   & (a or None) => Result None a
 */


var nullableToResult = function nullableToResult(a, givenFallback) {
  var oldBehaviour = arguments.length < 2; // eslint-disable-line prefer-rest-params

  if (oldBehaviour) {
    deprecated('nullableToResult(value) is being deprecated in favour of providing an explicit fallback value.\nnullableToResult(value, fallback) is the new preferred form of this function.\n');
  }

  var fallback = oldBehaviour ? a : givenFallback;
  return a != null ? Ok(a) :
  /* else */
  Error(fallback);
};

module.exports = nullableToResult;

/***/ }),

/***/ "QW2R":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _InfoCircleFilled = _interopRequireDefault(__webpack_require__("B3VA"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var InfoCircleFilled = function InfoCircleFilled(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _InfoCircleFilled["default"]
  }));
};

InfoCircleFilled.displayName = 'InfoCircleFilled';

var _default = _react["default"].forwardRef(InfoCircleFilled);

exports["default"] = _default;

/***/ }),

/***/ "Qatm":
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "Qno1":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("Bsg+");
var isArray = __webpack_require__("Xfku");
var SPECIES = __webpack_require__("9dxi")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "Qqke":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("qA3Z");
var toIObject = __webpack_require__("T/1i");
var arrayIndexOf = __webpack_require__("zeFm")(false);
var IE_PROTO = __webpack_require__("Q5TA")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "R5TD":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "ROCd":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("P56o");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "RQUx":
/***/ (function(module, exports) {

module.exports = function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

/***/ }),

/***/ "RaTo":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SearchOutlined = {
  "name": "search",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"
      }
    }]
  }
};
exports["default"] = SearchOutlined;

/***/ }),

/***/ "RiSW":
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__("PE9J");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;

/***/ }),

/***/ "RoC8":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("d3/y");

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "S411":
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "SDHo":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("o7PZ");

__webpack_require__("9p7t");

__webpack_require__("7lGJ");

__webpack_require__("Z8gF");

var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports.withPrefix = withPrefix;
exports.withAssetPrefix = withAssetPrefix;
exports.navigateTo = exports.replace = exports.push = exports.navigate = exports["default"] = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__("PE9J"));

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _inheritsLoose2 = _interopRequireDefault(__webpack_require__("QKC2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _router = __webpack_require__("JF+v");

var _parsePath = __webpack_require__("vhWV");

exports.parsePath = _parsePath.parsePath;

function withPrefix(path) {
  return normalizePath([ true ? "/ucanlanding" : undefined, path].join("/"));
}

function withAssetPrefix(path) {
  return ["/ucanlanding"].concat([path.replace(/^\//, "")]).join("/");
}

function normalizePath(path) {
  return path.replace(/\/+/g, "/");
}

var NavLinkPropTypes = {
  activeClassName: _propTypes["default"].string,
  activeStyle: _propTypes["default"].object,
  partiallyActive: _propTypes["default"].bool
}; // Set up IntersectionObserver

var createIntersectionObserver = function createIntersectionObserver(el, cb) {
  var io = new window.IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (el === entry.target) {
        // Check if element is within viewport, remove listener, destroy observer, and run link callback.
        // MSEdge doesn't currently support isIntersecting, so also test for  an intersectionRatio > 0
        if (entry.isIntersecting || entry.intersectionRatio > 0) {
          io.unobserve(el);
          io.disconnect();
          cb();
        }
      }
    });
  }); // Add element to the observer

  io.observe(el);
  return {
    instance: io,
    el: el
  };
};

var GatsbyLink = /*#__PURE__*/function (_React$Component) {
  (0, _inheritsLoose2["default"])(GatsbyLink, _React$Component);

  function GatsbyLink(props) {
    var _this;

    _this = _React$Component.call(this, props) || this; // Default to no support for IntersectionObserver

    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "defaultGetProps", function (_ref) {
      var isPartiallyCurrent = _ref.isPartiallyCurrent,
          isCurrent = _ref.isCurrent;

      if (_this.props.partiallyActive ? isPartiallyCurrent : isCurrent) {
        return {
          className: [_this.props.className, _this.props.activeClassName].filter(Boolean).join(" "),
          style: (0, _extends2["default"])({}, _this.props.style, {}, _this.props.activeStyle)
        };
      }

      return null;
    });
    var IOSupported = false;

    if (typeof window !== "undefined" && window.IntersectionObserver) {
      IOSupported = true;
    }

    _this.state = {
      IOSupported: IOSupported
    };
    _this.handleRef = _this.handleRef.bind((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  var _proto = GatsbyLink.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // Preserve non IO functionality if no support
    if (this.props.to !== prevProps.to && !this.state.IOSupported) {
      ___loader.enqueue((0, _parsePath.parsePath)(this.props.to).pathname);
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    // Preserve non IO functionality if no support
    if (!this.state.IOSupported) {
      ___loader.enqueue((0, _parsePath.parsePath)(this.props.to).pathname);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (!this.io) {
      return;
    }

    var _this$io = this.io,
        instance = _this$io.instance,
        el = _this$io.el;
    instance.unobserve(el);
    instance.disconnect();
  };

  _proto.handleRef = function handleRef(ref) {
    var _this2 = this;

    if (this.props.innerRef && this.props.innerRef.hasOwnProperty("current")) {
      this.props.innerRef.current = ref;
    } else if (this.props.innerRef) {
      this.props.innerRef(ref);
    }

    if (this.state.IOSupported && ref) {
      // If IO supported and element reference found, setup Observer functionality
      this.io = createIntersectionObserver(ref, function () {
        ___loader.enqueue((0, _parsePath.parsePath)(_this2.props.to).pathname);
      });
    }
  };

  _proto.render = function render() {
    var _this3 = this;

    var _this$props = this.props,
        to = _this$props.to,
        _this$props$getProps = _this$props.getProps,
        getProps = _this$props$getProps === void 0 ? this.defaultGetProps : _this$props$getProps,
        _onClick = _this$props.onClick,
        _onMouseEnter = _this$props.onMouseEnter,
        $activeClassName = _this$props.activeClassName,
        $activeStyle = _this$props.activeStyle,
        $innerRef = _this$props.innerRef,
        partiallyActive = _this$props.partiallyActive,
        state = _this$props.state,
        replace = _this$props.replace,
        rest = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, ["to", "getProps", "onClick", "onMouseEnter", "activeClassName", "activeStyle", "innerRef", "partiallyActive", "state", "replace"]);
    var LOCAL_URL = /^\/(?!\/)/;

    if (false) {}

    var prefixedTo = withPrefix(to);
    return _react["default"].createElement(_router.Link, (0, _extends2["default"])({
      to: prefixedTo,
      state: state,
      getProps: getProps,
      innerRef: this.handleRef,
      onMouseEnter: function onMouseEnter(e) {
        if (_onMouseEnter) {
          _onMouseEnter(e);
        }

        ___loader.hovering((0, _parsePath.parsePath)(to).pathname);
      },
      onClick: function onClick(e) {
        if (_onClick) {
          _onClick(e);
        }

        if (e.button === 0 && // ignore right clicks
        !_this3.props.target && // let browser handle "target=_blank"
        !e.defaultPrevented && // onClick prevented default
        !e.metaKey && // ignore clicks with modifier keys...
        !e.altKey && !e.ctrlKey && !e.shiftKey) {
          e.preventDefault(); // Make sure the necessary scripts and data are
          // loaded before continuing.

          navigate(to, {
            state: state,
            replace: replace
          });
        }

        return true;
      }
    }, rest));
  };

  return GatsbyLink;
}(_react["default"].Component);

GatsbyLink.propTypes = (0, _extends2["default"])({}, NavLinkPropTypes, {
  onClick: _propTypes["default"].func,
  to: _propTypes["default"].string.isRequired,
  replace: _propTypes["default"].bool,
  state: _propTypes["default"].object
});

var showDeprecationWarning = function showDeprecationWarning(functionName, altFunctionName, version) {
  return console.warn("The \"" + functionName + "\" method is now deprecated and will be removed in Gatsby v" + version + ". Please use \"" + altFunctionName + "\" instead.");
};

var _default = _react["default"].forwardRef(function (props, ref) {
  return _react["default"].createElement(GatsbyLink, (0, _extends2["default"])({
    innerRef: ref
  }, props));
});

exports["default"] = _default;

var navigate = function navigate(to, options) {
  window.___navigate(withPrefix(to), options);
};

exports.navigate = navigate;

var push = function push(to) {
  showDeprecationWarning("push", "navigate", 3);

  window.___push(withPrefix(to));
};

exports.push = push;

var replace = function replace(to) {
  showDeprecationWarning("replace", "navigate", 3);

  window.___replace(withPrefix(to));
}; // TODO: Remove navigateTo for Gatsby v3


exports.replace = replace;

var navigateTo = function navigateTo(to) {
  showDeprecationWarning("navigateTo", "navigate", 3);
  return push(to);
};

exports.navigateTo = navigateTo;

/***/ }),

/***/ "SDJZ":
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "SaPD":
/***/ (function(module, exports) {

module.exports = function _isPlaceholder(a) {
  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
};

/***/ }),

/***/ "ScpY":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__("LEAW")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),

/***/ "SeNM":
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__("P56o").parseInt;
var $trim = __webpack_require__("hGr/").trim;
var ws = __webpack_require__("SvMv");
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "SfRV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("GkPX");

__webpack_require__("6/FK");

__webpack_require__("2Tod");

__webpack_require__("7lGJ");

__webpack_require__("9p7t");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("V7cS");

__webpack_require__("ABKx");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _utils = __webpack_require__("OgXt");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var twoToneColorPalette = {
  primaryColor: '#333',
  secondaryColor: '#E6E6E6',
  calculated: false
};

function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor,
      secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || (0, _utils.getSecondaryColor)(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}

function getTwoToneColors() {
  return _objectSpread({}, twoToneColorPalette);
}

var IconBase = function IconBase(props) {
  var icon = props.icon,
      className = props.className,
      onClick = props.onClick,
      style = props.style,
      primaryColor = props.primaryColor,
      secondaryColor = props.secondaryColor,
      restProps = _objectWithoutProperties(props, ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"]);

  var colors = twoToneColorPalette;

  if (primaryColor) {
    colors = {
      primaryColor: primaryColor,
      secondaryColor: secondaryColor || (0, _utils.getSecondaryColor)(primaryColor)
    };
  }

  (0, _utils.useInsertStyles)();
  (0, _utils.warning)((0, _utils.isIconDefinition)(icon), "icon should be icon definiton, but got ".concat(icon));

  if (!(0, _utils.isIconDefinition)(icon)) {
    return null;
  }

  var target = icon;

  if (target && typeof target.icon === 'function') {
    target = _objectSpread({}, target, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }

  return (0, _utils.generate)(target.icon, "svg-".concat(target.name), _objectSpread({
    className: className,
    onClick: onClick,
    style: style,
    'data-icon': target.name,
    width: '1em',
    height: '1em',
    fill: 'currentColor',
    'aria-hidden': 'true'
  }, restProps));
};

IconBase.displayName = 'IconReact';
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
var _default = IconBase;
exports["default"] = _default;

/***/ }),

/***/ "Sp5b":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("mvii");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "SsG5":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("Bsg+");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "SvMv":
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "T/1i":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("6wgB");
var defined = __webpack_require__("Xj5l");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "T/r7":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");

var _isArguments = __webpack_require__("d075");

var _isArray = __webpack_require__("GwS+");

var _isObject = __webpack_require__("Ln+j");

var _isString = __webpack_require__("74ju");
/**
 * Returns the empty value of its argument's type. Ramda defines the empty
 * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
 * types are supported if they define `<Type>.empty` and/or
 * `<Type>.prototype.empty`.
 *
 * Dispatches to the `empty` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> a
 * @param {*} x
 * @return {*}
 * @example
 *
 *      R.empty(Just(42));      //=> Nothing()
 *      R.empty([1, 2, 3]);     //=> []
 *      R.empty('unicorns');    //=> ''
 *      R.empty({x: 1, y: 2});  //=> {}
 */


module.exports = _curry1(function empty(x) {
  return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
    return arguments;
  }() : // else
  void 0;
});

/***/ }),

/***/ "T1e2":
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "T4P6":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("/Lgp");
var gOPS = __webpack_require__("phsM");
var pIE = __webpack_require__("kBaS");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "T9om":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;
var STATE_KEY_PREFIX = "@@scroll|";
var GATSBY_ROUTER_SCROLL_STATE = "___GATSBY_REACT_ROUTER_SCROLL";

var SessionStorage = /*#__PURE__*/function () {
  function SessionStorage() {}

  var _proto = SessionStorage.prototype;

  _proto.read = function read(location, key) {
    var stateKey = this.getStateKey(location, key);

    try {
      var value = window.sessionStorage.getItem(stateKey);
      return JSON.parse(value);
    } catch (e) {
      if (false) {}

      if (window && window[GATSBY_ROUTER_SCROLL_STATE] && window[GATSBY_ROUTER_SCROLL_STATE][stateKey]) {
        return window[GATSBY_ROUTER_SCROLL_STATE][stateKey];
      }

      return {};
    }
  };

  _proto.save = function save(location, key, value) {
    var stateKey = this.getStateKey(location, key);
    var storedValue = JSON.stringify(value);

    try {
      window.sessionStorage.setItem(stateKey, storedValue);
    } catch (e) {
      if (window && window[GATSBY_ROUTER_SCROLL_STATE]) {
        window[GATSBY_ROUTER_SCROLL_STATE][stateKey] = JSON.parse(storedValue);
      } else {
        window[GATSBY_ROUTER_SCROLL_STATE] = {};
        window[GATSBY_ROUTER_SCROLL_STATE][stateKey] = JSON.parse(storedValue);
      }

      if (false) {}
    }
  };

  _proto.getStateKey = function getStateKey(location, key) {
    var locationKey = location.key || location.pathname;
    var stateKeyBase = "" + STATE_KEY_PREFIX + locationKey;
    return key === null || typeof key === "undefined" ? stateKeyBase : stateKeyBase + "|" + key;
  };

  return SessionStorage;
}();

exports["default"] = SessionStorage;

/***/ }),

/***/ "TCCx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("Z8gF");__webpack_require__("J8hF");__webpack_require__("nsbO");__webpack_require__("oMRA");__webpack_require__("6d4m");var _interopRequireDefault=__webpack_require__("63Ad");exports.__esModule=true;exports.default=_default;exports.routeThroughBrowserOrApp=exports.hashShouldBeFollowed=exports.pathIsNotHandledByApp=exports.urlsAreOnSameOrigin=exports.authorIsForcingNavigation=exports.anchorsTargetIsEquivalentToSelf=exports.findClosestAnchor=exports.navigationWasHandledElsewhere=exports.slashedPathname=exports.userIsForcingNavigation=void 0;var _escapeStringRegexp=_interopRequireDefault(__webpack_require__("Jjw7"));var _gatsby=__webpack_require__("Wbzz");var userIsForcingNavigation=function userIsForcingNavigation(event){return event.button!==0||event.altKey||event.ctrlKey||event.metaKey||event.shiftKey;};// IE does not include leading slash in anchor.pathname
exports.userIsForcingNavigation=userIsForcingNavigation;var slashedPathname=function slashedPathname(pathname){return pathname[0]==="/"?pathname:"/"+pathname;};exports.slashedPathname=slashedPathname;var navigationWasHandledElsewhere=function navigationWasHandledElsewhere(event){return event.defaultPrevented;};exports.navigationWasHandledElsewhere=navigationWasHandledElsewhere;var findClosestAnchor=function findClosestAnchor(node){for(;node.parentNode;node=node.parentNode){if(node.nodeName.toLowerCase()==="a"){return node;}}return null;};exports.findClosestAnchor=findClosestAnchor;var anchorsTargetIsEquivalentToSelf=function anchorsTargetIsEquivalentToSelf(anchor){return(/* If target attribute is not present it's treated as _self */anchor.hasAttribute("target")===false||/**
     * The browser defaults to _self, but, not all browsers set
     * a.target to the string value `_self` by default
     */ /**
     * Assumption: some browsers use null/undefined for default
     * attribute values
     */anchor.target==null||/**
     * Some browsers use the empty string to mean _self, check
     * for actual `_self`
     */["_self",""].includes(anchor.target)||/**
     * As per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target
     */anchor.target==="_parent"&&(!anchor.ownerDocument.defaultView.parent||// Assumption: This can be falsey
anchor.ownerDocument.defaultView.parent===anchor.ownerDocument.defaultView)||anchor.target==="_top"&&(!anchor.ownerDocument.defaultView.top||// Assumption: This can be falsey
anchor.ownerDocument.defaultView.top===anchor.ownerDocument.defaultView));};exports.anchorsTargetIsEquivalentToSelf=anchorsTargetIsEquivalentToSelf;var authorIsForcingNavigation=function authorIsForcingNavigation(anchor){return(/**
     * HTML5 attribute that informs the browser to handle the
     * href as a downloadable file; let the browser handle it
     */anchor.hasAttribute("download")===true||/**
     * Let the browser handle anything that doesn't look like a
     * target="_self" anchor
     */anchorsTargetIsEquivalentToSelf(anchor)===false);};// https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
exports.authorIsForcingNavigation=authorIsForcingNavigation;var urlsAreOnSameOrigin=function urlsAreOnSameOrigin(origin,destination){return origin.protocol===destination.protocol&&/* a.host includes both hostname and port in the expected format host:port */origin.host===destination.host;};exports.urlsAreOnSameOrigin=urlsAreOnSameOrigin;var pathIsNotHandledByApp=function pathIsNotHandledByApp(destination,pathStartRegEx){var pathFileExtensionRegEx=/^.*\.((?!htm)[a-z0-9]{1,5})$/i;return(/**
     * For when pathPrefix is used in an app and there happens to be a link
     * pointing to the same domain but outside of the app's pathPrefix. For
     * example, a Gatsby app lives at https://example.com/myapp/, with the
     * pathPrefix set to `/myapp`. When adding an absolute link to the same
     * domain but outside of the /myapp path, for example, `<a
     * href="https://example.com/not-my-app">` the plugin won't catch it and
     * will navigate to an external link instead of doing a pushState resulting
     * in `https://example.com/myapp/https://example.com/not-my-app`
     */pathStartRegEx.test(slashedPathname(destination.pathname))===false||/**
     * Don't catch links pointed at what look like file extensions (other than
     * .htm/html extensions).
     */destination.pathname.search(pathFileExtensionRegEx)!==-1);};exports.pathIsNotHandledByApp=pathIsNotHandledByApp;var hashShouldBeFollowed=function hashShouldBeFollowed(origin,destination){return destination.hash!==""&&(/**
   * Dynamically created anchor links (href="#my-anchor") do not always
   * have pathname on IE
   */destination.pathname===""||/* Don't catch links pointed to the same page but with a hash. */destination.pathname===origin.pathname);};exports.hashShouldBeFollowed=hashShouldBeFollowed;var routeThroughBrowserOrApp=function routeThroughBrowserOrApp(hrefHandler,pluginOptions){return function(event){if(window.___failedResources)return true;if(userIsForcingNavigation(event))return true;if(navigationWasHandledElsewhere(event))return true;var clickedAnchor=findClosestAnchor(event.target);if(clickedAnchor==null)return true;if(authorIsForcingNavigation(clickedAnchor))return true;// IE clears the host value if the anchor href changed after creation, e.g.
// in React. Creating a new anchor element to ensure host value is present
var destination=document.createElement("a");destination.href=clickedAnchor.href;if(clickedAnchor.href instanceof SVGAnimatedString){destination.href=clickedAnchor.href.animVal;}// In IE, the default port is included in the anchor host but excluded from
// the location host.  This affects the ability to directly compare
// location host to anchor host.  For example: http://example.com would
// have a location.host of 'example.com' and an destination.host of
// 'example.com:80' Creating anchor from the location.href to normalize the
// host value.
var origin=document.createElement("a");origin.href=window.location.href;if(urlsAreOnSameOrigin(origin,destination)===false)return true;// Regex to test pathname against pathPrefix
var pathStartRegEx=new RegExp("^"+(0,_escapeStringRegexp.default)((0,_gatsby.withPrefix)("/")));if(pathIsNotHandledByApp(destination,pathStartRegEx))return true;if(hashShouldBeFollowed(origin,destination))return true;if(pluginOptions.excludePattern){var excludeRegex=new RegExp(pluginOptions.excludePattern);if(excludeRegex.test(destination.pathname)){return true;}}event.preventDefault();// See issue #8907: destination.pathname already includes pathPrefix added
// by gatsby-transformer-remark but gatsby-link.navigate needs href without
var destinationPathname=slashedPathname(destination.pathname).replace(pathStartRegEx,"/");hrefHandler(""+destinationPathname+destination.search+destination.hash);return false;};};exports.routeThroughBrowserOrApp=routeThroughBrowserOrApp;function _default(root,pluginOptions,cb){var clickHandler=routeThroughBrowserOrApp(cb,pluginOptions);root.addEventListener("click",clickHandler);return function(){return root.removeEventListener("click",clickHandler);};}

/***/ }),

/***/ "TEyA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tinycolor2_1 = __importDefault(__webpack_require__("5xfP"));

var hueStep = 2; // 色相阶梯

var saturationStep = 16; // 饱和度阶梯，浅色部分

var saturationStep2 = 5; // 饱和度阶梯，深色部分

var brightnessStep1 = 5; // 亮度阶梯，浅色部分

var brightnessStep2 = 15; // 亮度阶梯，深色部分

var lightColorCount = 5; // 浅色数量，主色上

var darkColorCount = 4; // 深色数量，主色下

function getHue(hsv, i, light) {
  var hue; // 根据色相不同，色相转向不同

  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
  }

  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }

  return hue;
}

function getSaturation(hsv, i, light) {
  // grey color don't change saturation
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }

  var saturation;

  if (light) {
    saturation = Math.round(hsv.s * 100) - saturationStep * i;
  } else if (i === darkColorCount) {
    saturation = Math.round(hsv.s * 100) + saturationStep;
  } else {
    saturation = Math.round(hsv.s * 100) + saturationStep2 * i;
  } // 边界值修正


  if (saturation > 100) {
    saturation = 100;
  } // 第一格的 s 限制在 6-10 之间


  if (light && i === lightColorCount && saturation > 10) {
    saturation = 10;
  }

  if (saturation < 6) {
    saturation = 6;
  }

  return saturation;
}

function getValue(hsv, i, light) {
  if (light) {
    return Math.round(hsv.v * 100) + brightnessStep1 * i;
  }

  return Math.round(hsv.v * 100) - brightnessStep2 * i;
}

function generate(color) {
  var patterns = [];
  var pColor = tinycolor2_1["default"](color);

  for (var i = lightColorCount; i > 0; i -= 1) {
    var hsv = pColor.toHsv();
    var colorString = tinycolor2_1["default"]({
      h: getHue(hsv, i, true),
      s: getSaturation(hsv, i, true),
      v: getValue(hsv, i, true)
    }).toHexString();
    patterns.push(colorString);
  }

  patterns.push(pColor.toHexString());

  for (var i = 1; i <= darkColorCount; i += 1) {
    var hsv = pColor.toHsv();
    var colorString = tinycolor2_1["default"]({
      h: getHue(hsv, i),
      s: getSaturation(hsv, i),
      v: getValue(hsv, i)
    }).toHexString();
    patterns.push(colorString);
  }

  return patterns;
}

exports["default"] = generate;

/***/ }),

/***/ "TGEZ":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {__webpack_require__("7t+O");

// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    module.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    module.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };

    hrtime = process.hrtime;

    getNanoSeconds = function getNanoSeconds() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };

    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function () {
      return Date.now() - loadTime;
    };

    loadTime = Date.now();
  } else {
    module.exports = function () {
      return new Date().getTime() - loadTime;
    };

    loadTime = new Date().getTime();
  }
}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("5IsQ")))

/***/ }),

/***/ "THQi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("75LO");

__webpack_require__("yIlq");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("+3V6");

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

/***/ }),

/***/ "TJjZ":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _unsupportedIterableToArray; });
/* harmony import */ var _arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("YZeP");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(o, minLen);
}

/***/ }),

/***/ "TOXe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var _interopRequireDefault=__webpack_require__("63Ad");exports.__esModule=true;exports.onRouteUpdate=exports.onRouteUpdateDelayed=exports.onClientEntry=void 0;var _extends2=_interopRequireDefault(__webpack_require__("8VmE"));var _nprogress=_interopRequireDefault(__webpack_require__("ZLCB"));var defaultOptions={color:"#29d"};var onClientEntry=function onClientEntry(a,pluginOptions){if(pluginOptions===void 0){pluginOptions={};}// Merge default options with user defined options in `gatsby-config.js`
var options=(0,_extends2.default)({},defaultOptions,{},pluginOptions);// Inject styles.
var styles="\n    #nprogress {\n     pointer-events: none;\n    }\n    #nprogress .bar {\n      background: "+options.color+";\n      position: fixed;\n      z-index: 1031;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 2px;\n    }\n    #nprogress .peg {\n      display: block;\n      position: absolute;\n      right: 0px;\n      width: 100px;\n      height: 100%;\n      box-shadow: 0 0 10px "+options.color+", 0 0 5px "+options.color+";\n      opacity: 1.0;\n      -webkit-transform: rotate(3deg) translate(0px, -4px);\n      -ms-transform: rotate(3deg) translate(0px, -4px);\n      transform: rotate(3deg) translate(0px, -4px);\n    }\n    #nprogress .spinner {\n      display: block;\n      position: fixed;\n      z-index: 1031;\n      top: 15px;\n      right: 15px;\n    }\n    #nprogress .spinner-icon {\n      width: 18px;\n      height: 18px;\n      box-sizing: border-box;\n      border: solid 2px transparent;\n      border-top-color: "+options.color+";\n      border-left-color: "+options.color+";\n      border-radius: 50%;\n      -webkit-animation: nprogress-spinner 400ms linear infinite;\n      animation: nprogress-spinner 400ms linear infinite;\n    }\n    .nprogress-custom-parent {\n      overflow: hidden;\n      position: relative;\n    }\n    .nprogress-custom-parent #nprogress .spinner,\n    .nprogress-custom-parent #nprogress .bar {\n      position: absolute;\n    }\n    @-webkit-keyframes nprogress-spinner {\n      0% {\n        -webkit-transform: rotate(0deg);\n      }\n      100% {\n        -webkit-transform: rotate(360deg);\n      }\n    }\n    @keyframes nprogress-spinner {\n      0% {\n        transform: rotate(0deg);\n      }\n      100% {\n        transform: rotate(360deg);\n      }\n    }\n  ";var node=document.createElement("style");node.id="nprogress-styles";node.innerHTML=styles;document.head.appendChild(node);_nprogress.default.configure(options);};exports.onClientEntry=onClientEntry;var onRouteUpdateDelayed=function onRouteUpdateDelayed(){_nprogress.default.start();};exports.onRouteUpdateDelayed=onRouteUpdateDelayed;var onRouteUpdate=function onRouteUpdate(){_nprogress.default.done();};exports.onRouteUpdate=onRouteUpdate;

/***/ }),

/***/ "TTxG":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "TaGV":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "TcPG":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__("yO+b");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2["default"])(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),

/***/ "Tl5h":
/***/ (function(module) {

module.exports = JSON.parse("{\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Ucan\",\"githubUrl\":\"https://github.com/Sesleone/gatsby-theme-antv.git\",\"siteUrl\":\"https://ucanshuttle.co.za\",\"logoUrl\":null,\"showSearch\":null,\"showChinaMirror\":null,\"showLanguageSwitcher\":null,\"showAntVProductsCard\":null,\"showGithubCorner\":null,\"navs\":[],\"redirects\":[],\"docsearchOptions\":null,\"versions\":{\"1.0.0\":\"https://ucanshuttle.co.za\"}}},\"locales\":{\"internal\":{\"content\":\"{\\\"en\\\":{\\\"translation\\\":{\\\"蚂蚁数据可视化\\\":\\\"Liven Data Lively\\\",\\\"项目里的国际化\\\":\\\"English locale in project\\\",\\\"让数据栩栩如生\\\":\\\"Make the Data Vivid\\\",\\\"AntV 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。\\\":\\\"AntV is a new generation of data visualization technique from Ant Financial. We provide best practices of data visualization with simplicity, convenience, profession, reliability, and infinite possibilities.\\\",\\\"继续了解\\\":\\\"More\\\",\\\"更新\\\":\\\"Update\\\",\\\"L7 发布新版本，让地图动起来！\\\":\\\"L7 has published the new viewsion!\\\",\\\"推荐\\\":\\\"Recommand\\\",\\\"Kitchen 3.75，效率大幅提升！\\\":\\\"Kitchen 3.75, lift your efficient!\\\",\\\"我们的优势\\\":\\\"Our Advantages\\\",\\\"简单方便\\\":\\\"Simple and Convenient\\\",\\\"从数据出发，仅需几行代码可以轻松获得想要的图表展示效果。\\\":\\\"Starting from the data, you will get the visualization results with only a few lines of codes.\\\",\\\"方便可靠\\\":\\\"Reliable\\\",\\\"大量产品实践之上，提供绘图引擎、完备图形语法，专业设计规范。\\\":\\\"We provide rendering engines, complete grammar of graphics, and professional design standards for plenty of practice products.\\\",\\\"无限可能\\\":\\\"Infinite\\\",\\\"任何图表，都可以基于图形语法灵活绘制，满足你无限的创意。\\\":\\\"Based on the grammar of graphics, any charts or diagrams can be flexibly created, which will satisfy your infinite ideas.\\\",\\\"2000+ 公司正在使用\\\":\\\"2000+ Companies are Using AntV\\\",\\\"测试\\\":\\\"Test\\\",\\\"G6 3.2 全新上线！\\\":\\\"G6 3.2 has already updated!\\\",\\\"合作公司\\\":\\\"Companies\\\",\\\"查看详情\\\":\\\"More\\\",\\\"所有产品\\\":\\\"Products\\\",\\\"周边生态\\\":\\\"Ecosystem\\\",\\\"搜索…\\\":\\\"Search...\\\",\\\"在 GitHub 上编辑\\\":\\\"Edit on GitHub\\\",\\\"演示\\\":\\\"Examples\\\",\\\"代码演示\\\":\\\"Examples\\\",\\\"设计指引\\\":\\\"Design Guide\\\",\\\"进入全屏\\\":\\\"Enter Fullscreen\\\",\\\"离开全屏\\\":\\\"Exit Fullscreen\\\",\\\"产品首页\\\":\\\"Home Page\\\",\\\"图表示例\\\":\\\"Examples\\\",\\\"使用文档\\\":\\\"Manual\\\",\\\"API 文档\\\":\\\"API\\\",\\\"更新日志\\\":\\\"Changelog\\\",\\\"GitHub 仓库\\\":\\\"GitHub Repository\\\",\\\"国内镜像\\\":\\\"China Mirror\\\",\\\"可视化引擎\\\":\\\"Visualization Engine\\\",\\\"图可视化引擎\\\":\\\"Graph Visualization\\\",\\\"移动可视化方案\\\":\\\"Mobile Charts\\\",\\\"地理空间数据可视化\\\":\\\"Geospatial Visualization\\\",\\\"开箱即用的图表库\\\":\\\"A Charting Library\\\",\\\"开箱即用、易于配置、极致体验的通用图表库。\\\":\\\"Pretty interactive charts out of box\\\",\\\"图表魔方\\\":\\\"Charts Maker\\\",\\\"生成图表\\\":\\\"Create charts\\\",\\\"AntV 在线图表制作利器。\\\":\\\"Create pretty charts without code\\\",\\\"数据驱动，高度易用，可扩展的可视化图形语法。\\\":\\\"Data-driven visual language with a high level of usability and scalability\\\",\\\"便捷的关系数据可视化引擎与图分析工具。\\\":\\\"A Graph Visualization Framework in JavaScript\\\",\\\"高性能/高渲染质量的地理空间数据可视化框架。\\\":\\\"Large-scale WebGL-powered Geospatial Data Visualization\\\",\\\"专注于移动端的可视化解决方案，兼容 H5/小程序/Weex 等多端环境\\\":\\\"An elegant, interactive and flexible charting library for mobile\\\",\\\"基于 G6 封装的图分析应用组件。\\\":\\\"A react toolkit for graph analysis based on g6\\\",\\\"墨者学院\\\":\\\"Mohist Academy\\\",\\\"学院首页\\\":\\\"Home Page\\\",\\\"数据可视化社团\\\":\\\"Visualization Community\\\",\\\"语雀社区\\\":\\\"Yuque\\\",\\\"钉钉服务群\\\":\\\"DingTalk Group\\\",\\\"扫码进 ChartCube 服务群\\\":\\\"Scan QRCode\\\",\\\"欢迎进入 2020 可视化智能研发时代\\\":\\\"New era of intelligent VIS\\\",\\\"AntV 11-22 品牌日：知源·致远\\\":\\\"11-22, AntV brand day!\\\",\\\"G2Plot 图表库发布\\\":\\\"G2Plot is released\\\",\\\"执行代码\\\":\\\"Run code\\\",\\\"在 CodeSandbox 中打开\\\":\\\"Open in CodeSandbox\\\",\\\"在 Riddle 中打开\\\":\\\"Open in Riddle\\\",\\\"在 StackBlitz 中打开\\\":\\\"Open in StackBlitz\\\",\\\"HTML 代码\\\":\\\"Html Source Code\\\",\\\"取消\\\":\\\"Cancel\\\",\\\"关于我们\\\":\\\"About us\\\",\\\"返回旧版\\\":\\\"Old site\\\"}}}\"}}}}");

/***/ }),

/***/ "U1KF":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("PAFS");
var IE8_DOM_DEFINE = __webpack_require__("HWsP");
var toPrimitive = __webpack_require__("5MU4");
var dP = Object.defineProperty;

exports.f = __webpack_require__("GGqZ") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "U8p0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var aFunction = __webpack_require__("b8Rm");
var toObject = __webpack_require__("UnHL");
var fails = __webpack_require__("E7Vc");
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__("/6rt")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "UKnr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__("MNOf");
exports.encode = exports.stringify = __webpack_require__("THQi");

/***/ }),

/***/ "UNIm":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports["default"] = scrollTop;

var _isWindow = _interopRequireDefault(__webpack_require__("wiq9"));

function scrollTop(node, val) {
  var win = (0, _isWindow["default"])(node);
  if (val === undefined) return win ? 'pageXOffset' in win ? win.pageXOffset : win.document.documentElement.scrollLeft : node.scrollLeft;
  if (win) win.scrollTo(val, 'pageYOffset' in win ? win.pageYOffset : win.document.documentElement.scrollTop);else node.scrollLeft = val;
}

module.exports = exports["default"];

/***/ }),

/***/ "USUc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var InfoCircleOutlined = {
  "name": "info-circle",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z"
      }
    }]
  }
};
exports["default"] = InfoCircleOutlined;

/***/ }),

/***/ "UTwT":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("lBnu") && !__webpack_require__("/Vl9")(function () {
  return Object.defineProperty(__webpack_require__("m/Uw")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "UYXy":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("ml72");
var gOPN = __webpack_require__("zIds").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "Un63":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("P/oo");

__webpack_require__("V7cS");

__webpack_require__("J8hF");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;

  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }

  var nameStartChar = "A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "-:.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var xmlTagStart = new RegExp("<(/?)([" + nameStartChar + "][" + nameChar + "]*)", "g");

  function Iter(cm, line, ch, range) {
    this.line = line;
    this.ch = ch;
    this.cm = cm;
    this.text = cm.getLine(line);
    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();
    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();
  }

  function tagAt(iter, ch) {
    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));
    return type && /\btag\b/.test(type);
  }

  function nextLine(iter) {
    if (iter.line >= iter.max) return;
    iter.ch = 0;
    iter.text = iter.cm.getLine(++iter.line);
    return true;
  }

  function prevLine(iter) {
    if (iter.line <= iter.min) return;
    iter.text = iter.cm.getLine(--iter.line);
    iter.ch = iter.text.length;
    return true;
  }

  function toTagEnd(iter) {
    for (;;) {
      var gt = iter.text.indexOf(">", iter.ch);

      if (gt == -1) {
        if (nextLine(iter)) continue;else return;
      }

      if (!tagAt(iter, gt + 1)) {
        iter.ch = gt + 1;
        continue;
      }

      var lastSlash = iter.text.lastIndexOf("/", gt);
      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
      iter.ch = gt + 1;
      return selfClose ? "selfClose" : "regular";
    }
  }

  function toTagStart(iter) {
    for (;;) {
      var lt = iter.ch ? iter.text.lastIndexOf("<", iter.ch - 1) : -1;

      if (lt == -1) {
        if (prevLine(iter)) continue;else return;
      }

      if (!tagAt(iter, lt + 1)) {
        iter.ch = lt;
        continue;
      }

      xmlTagStart.lastIndex = lt;
      iter.ch = lt;
      var match = xmlTagStart.exec(iter.text);
      if (match && match.index == lt) return match;
    }
  }

  function toNextTag(iter) {
    for (;;) {
      xmlTagStart.lastIndex = iter.ch;
      var found = xmlTagStart.exec(iter.text);

      if (!found) {
        if (nextLine(iter)) continue;else return;
      }

      if (!tagAt(iter, found.index + 1)) {
        iter.ch = found.index + 1;
        continue;
      }

      iter.ch = found.index + found[0].length;
      return found;
    }
  }

  function toPrevTag(iter) {
    for (;;) {
      var gt = iter.ch ? iter.text.lastIndexOf(">", iter.ch - 1) : -1;

      if (gt == -1) {
        if (prevLine(iter)) continue;else return;
      }

      if (!tagAt(iter, gt + 1)) {
        iter.ch = gt;
        continue;
      }

      var lastSlash = iter.text.lastIndexOf("/", gt);
      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
      iter.ch = gt + 1;
      return selfClose ? "selfClose" : "regular";
    }
  }

  function findMatchingClose(iter, tag) {
    var stack = [];

    for (;;) {
      var next = toNextTag(iter),
          end,
          startLine = iter.line,
          startCh = iter.ch - (next ? next[0].length : 0);
      if (!next || !(end = toTagEnd(iter))) return;
      if (end == "selfClose") continue;

      if (next[1]) {
        // closing tag
        for (var i = stack.length - 1; i >= 0; --i) {
          if (stack[i] == next[2]) {
            stack.length = i;
            break;
          }
        }

        if (i < 0 && (!tag || tag == next[2])) return {
          tag: next[2],
          from: Pos(startLine, startCh),
          to: Pos(iter.line, iter.ch)
        };
      } else {
        // opening tag
        stack.push(next[2]);
      }
    }
  }

  function findMatchingOpen(iter, tag) {
    var stack = [];

    for (;;) {
      var prev = toPrevTag(iter);
      if (!prev) return;

      if (prev == "selfClose") {
        toTagStart(iter);
        continue;
      }

      var endLine = iter.line,
          endCh = iter.ch;
      var start = toTagStart(iter);
      if (!start) return;

      if (start[1]) {
        // closing tag
        stack.push(start[2]);
      } else {
        // opening tag
        for (var i = stack.length - 1; i >= 0; --i) {
          if (stack[i] == start[2]) {
            stack.length = i;
            break;
          }
        }

        if (i < 0 && (!tag || tag == start[2])) return {
          tag: start[2],
          from: Pos(iter.line, iter.ch),
          to: Pos(endLine, endCh)
        };
      }
    }
  }

  CodeMirror.registerHelper("fold", "xml", function (cm, start) {
    var iter = new Iter(cm, start.line, 0);

    for (;;) {
      var openTag = toNextTag(iter);
      if (!openTag || iter.line != start.line) return;
      var end = toTagEnd(iter);
      if (!end) return;

      if (!openTag[1] && end != "selfClose") {
        var startPos = Pos(iter.line, iter.ch);
        var endPos = findMatchingClose(iter, openTag[2]);
        return endPos && cmp(endPos.from, startPos) > 0 ? {
          from: startPos,
          to: endPos.from
        } : null;
      }
    }
  });

  CodeMirror.findMatchingTag = function (cm, pos, range) {
    var iter = new Iter(cm, pos.line, pos.ch, range);
    if (iter.text.indexOf(">") == -1 && iter.text.indexOf("<") == -1) return;
    var end = toTagEnd(iter),
        to = end && Pos(iter.line, iter.ch);
    var start = end && toTagStart(iter);
    if (!end || !start || cmp(iter, pos) > 0) return;
    var here = {
      from: Pos(iter.line, iter.ch),
      to: to,
      tag: start[2]
    };
    if (end == "selfClose") return {
      open: here,
      close: null,
      at: "open"
    };

    if (start[1]) {
      // closing tag
      return {
        open: findMatchingOpen(iter, start[2]),
        close: here,
        at: "close"
      };
    } else {
      // opening tag
      iter = new Iter(cm, to.line, to.ch, range);
      return {
        open: here,
        close: findMatchingClose(iter, start[2]),
        at: "open"
      };
    }
  };

  CodeMirror.findEnclosingTag = function (cm, pos, range, tag) {
    var iter = new Iter(cm, pos.line, pos.ch, range);

    for (;;) {
      var open = findMatchingOpen(iter, tag);
      if (!open) break;
      var forward = new Iter(cm, pos.line, pos.ch, range);
      var close = findMatchingClose(forward, open.tag);
      if (close) return {
        open: open,
        close: close
      };
    }
  }; // Used by addon/edit/closetag.js


  CodeMirror.scanForClosingTag = function (cm, pos, name, end) {
    var iter = new Iter(cm, pos.line, pos.ch, end ? {
      from: 0,
      to: end
    } : null);
    return findMatchingClose(iter, name);
  };
});

/***/ }),

/***/ "UnHL":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("GCOZ");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "UvcN":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("YlUf")('observable');


/***/ }),

/***/ "UxWs":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.reflect.construct.js
var es6_reflect_construct = __webpack_require__("LXYL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.search.js
var es6_regexp_search = __webpack_require__("nsbO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.match.js
var es6_regexp_match = __webpack_require__("9ovy");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ./.cache/api-runner-browser.js
var api_runner_browser = __webpack_require__("xtsi");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ../node_modules/@reach/router/es/index.js + 1 modules
var es = __webpack_require__("JF+v");

// EXTERNAL MODULE: ../node_modules/gatsby-react-router-scroll/index.js
var gatsby_react_router_scroll = __webpack_require__("5LHb");

// EXTERNAL MODULE: ../node_modules/@mikaelkristiansson/domready/ready.js
var ready = __webpack_require__("Kn+0");
var ready_default = /*#__PURE__*/__webpack_require__.n(ready);

// EXTERNAL MODULE: ./.cache/loader.js + 3 modules
var loader = __webpack_require__("emEt");

// EXTERNAL MODULE: ./.cache/redirects.json
var redirects = __webpack_require__("YLt+");

// EXTERNAL MODULE: ./.cache/emitter.js + 1 modules
var emitter = __webpack_require__("5yr3");

// CONCATENATED MODULE: ./.cache/route-announcer-props.js
// This is extracted to separate module because it's shared
// between browser and SSR code
var RouteAnnouncerProps={id:"gatsby-announcer",style:{position:"absolute",top:0,width:1,height:1,padding:0,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",border:0},"aria-live":"assertive","aria-atomic":"true"};
// EXTERNAL MODULE: ../node_modules/@reach/router/es/lib/history.js
var lib_history = __webpack_require__("ELdr");

// EXTERNAL MODULE: ../node_modules/gatsby-link/index.js
var gatsby_link = __webpack_require__("SDHo");

// CONCATENATED MODULE: ./.cache/navigation.js
function _createSuper(Derived){return function(){var Super=_getPrototypeOf(Derived),result;if(_isNativeReflectConstruct()){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(typeof call==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}// Convert to a map for faster lookup in maybeRedirect()
var redirectMap=redirects.reduce(function(map,redirect){map[redirect.fromPath]=redirect;return map;},{});function maybeRedirect(pathname){var redirect=redirectMap[pathname];if(redirect!=null){if(false){ var pageResources; }window.___replace(redirect.toPath);return true;}else{return false;}}var navigation_onPreRouteUpdate=function onPreRouteUpdate(location,prevLocation){if(!maybeRedirect(location.pathname)){Object(api_runner_browser["apiRunner"])("onPreRouteUpdate",{location:location,prevLocation:prevLocation});}};var navigation_onRouteUpdate=function onRouteUpdate(location,prevLocation){if(!maybeRedirect(location.pathname)){Object(api_runner_browser["apiRunner"])("onRouteUpdate",{location:location,prevLocation:prevLocation});}};var navigation_navigate=function navigate(to,options){if(options===void 0){options={};}var _parsePath=Object(gatsby_link["parsePath"])(to),pathname=_parsePath.pathname;var redirect=redirectMap[pathname];// If we're redirecting, just replace the passed in pathname
// to the one we want to redirect to.
if(redirect){to=redirect.toPath;pathname=Object(gatsby_link["parsePath"])(to).pathname;}// If we had a service worker update, no matter the path, reload window and
// reset the pathname whitelist
if(window.___swUpdated){window.location=pathname;return;}// Start a timer to wait for a second before transitioning and showing a
// loader in case resources aren't around yet.
var timeoutId=setTimeout(function(){emitter["a" /* default */].emit("onDelayedLoadPageResources",{pathname:pathname});Object(api_runner_browser["apiRunner"])("onRouteUpdateDelayed",{location:window.location});},1000);loader["default"].loadPage(pathname).then(function(pageResources){// If no page resources, then refresh the page
// Do this, rather than simply `window.location.reload()`, so that
// pressing the back/forward buttons work - otherwise when pressing
// back, the browser will just change the URL and expect JS to handle
// the change, which won't always work since it might not be a Gatsby
// page.
if(!pageResources||pageResources.status===loader["PageResourceStatus"].Error){window.history.replaceState({},"",location.href);window.location=pathname;clearTimeout(timeoutId);return;}// If the loaded page has a different compilation hash to the
// window, then a rebuild has occurred on the server. Reload.
if( true&&pageResources){if(pageResources.page.webpackCompilationHash!==window.___webpackCompilationHash){// Purge plugin-offline cache
if("serviceWorker"in navigator&&navigator.serviceWorker.controller!==null&&navigator.serviceWorker.controller.state==="activated"){navigator.serviceWorker.controller.postMessage({gatsbyApi:"clearPathResources"});}console.log("Site has changed on server. Reloading browser");window.location=pathname;}}Object(es["navigate"])(to,options);clearTimeout(timeoutId);});};function shouldUpdateScroll(prevRouterProps,_ref){var _this=this;var location=_ref.location;var pathname=location.pathname,hash=location.hash;var results=Object(api_runner_browser["apiRunner"])("shouldUpdateScroll",{prevRouterProps:prevRouterProps,// `pathname` for backwards compatibility
pathname:pathname,routerProps:{location:location},getSavedScrollPosition:function getSavedScrollPosition(args){return _this._stateStorage.read(args);}});if(results.length>0){// Use the latest registered shouldUpdateScroll result, this allows users to override plugin's configuration
// @see https://github.com/gatsbyjs/gatsby/issues/12038
return results[results.length-1];}if(prevRouterProps){var oldPathname=prevRouterProps.location.pathname;if(oldPathname===pathname){// Scroll to element if it exists, if it doesn't, or no hash is provided,
// scroll to top.
return hash?decodeURI(hash.slice(1)):[0,0];}}return true;}function init(){// The "scroll-behavior" package expects the "action" to be on the location
// object so let's copy it over.
lib_history["globalHistory"].listen(function(args){args.location.action=args.action;});window.___push=function(to){return navigation_navigate(to,{replace:false});};window.___replace=function(to){return navigation_navigate(to,{replace:true});};window.___navigate=function(to,options){return navigation_navigate(to,options);};// Check for initial page-load redirect
maybeRedirect(window.location.pathname);}var navigation_RouteAnnouncer=/*#__PURE__*/function(_React$Component){_inheritsLoose(RouteAnnouncer,_React$Component);var _super=_createSuper(RouteAnnouncer);function RouteAnnouncer(props){var _this2;_this2=_React$Component.call(this,props)||this;_this2.announcementRef=react_default.a.createRef();return _this2;}var _proto=RouteAnnouncer.prototype;_proto.componentDidUpdate=function componentDidUpdate(prevProps,nextProps){var _this3=this;requestAnimationFrame(function(){var pageName="new page at "+_this3.props.location.pathname;if(document.title){pageName=document.title;}var pageHeadings=document.getElementById("gatsby-focus-wrapper").getElementsByTagName("h1");if(pageHeadings&&pageHeadings.length){pageName=pageHeadings[0].textContent;}var newAnnouncement="Navigated to "+pageName;var oldAnnouncement=_this3.announcementRef.current.innerText;if(oldAnnouncement!==newAnnouncement){_this3.announcementRef.current.innerText=newAnnouncement;}});};_proto.render=function render(){return react_default.a.createElement("div",Object.assign({},RouteAnnouncerProps,{ref:this.announcementRef}));};return RouteAnnouncer;}(react_default.a.Component);// Fire on(Pre)RouteUpdate APIs
var navigation_RouteUpdates=/*#__PURE__*/function(_React$Component2){_inheritsLoose(RouteUpdates,_React$Component2);var _super2=_createSuper(RouteUpdates);function RouteUpdates(props){var _this4;_this4=_React$Component2.call(this,props)||this;navigation_onPreRouteUpdate(props.location,null);return _this4;}var _proto2=RouteUpdates.prototype;_proto2.componentDidMount=function componentDidMount(){navigation_onRouteUpdate(this.props.location,null);};_proto2.componentDidUpdate=function componentDidUpdate(prevProps,prevState,shouldFireRouteUpdate){if(shouldFireRouteUpdate){navigation_onRouteUpdate(this.props.location,prevProps.location);}};_proto2.getSnapshotBeforeUpdate=function getSnapshotBeforeUpdate(prevProps){if(this.props.location.pathname!==prevProps.location.pathname){navigation_onPreRouteUpdate(this.props.location,prevProps.location);return true;}return false;};_proto2.render=function render(){return react_default.a.createElement(react_default.a.Fragment,null,this.props.children,react_default.a.createElement(navigation_RouteAnnouncer,{location:location}));};return RouteUpdates;}(react_default.a.Component);
// EXTERNAL MODULE: ./.cache/page-renderer.js
var page_renderer = __webpack_require__("IOVJ");

// EXTERNAL MODULE: ./.cache/async-requires.js
var async_requires = __webpack_require__("pCP8");
var async_requires_default = /*#__PURE__*/__webpack_require__.n(async_requires);

// CONCATENATED MODULE: ../node_modules/shallow-compare/es/index.js
// Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349
function shallowDiffers(a, b) {
  for (var i in a) {
    if (!(i in b)) return true;
  }

  for (var _i in b) {
    if (a[_i] !== b[_i]) return true;
  }

  return false;
}

/* harmony default export */ var shallow_compare_es = (function (instance, nextProps, nextState) {
  return shallowDiffers(instance.props, nextProps) || shallowDiffers(instance.state, nextState);
});
// CONCATENATED MODULE: ./.cache/ensure-resources.js
function ensure_resources_createSuper(Derived){return function(){var Super=ensure_resources_getPrototypeOf(Derived),result;if(ensure_resources_isNativeReflectConstruct()){var NewTarget=ensure_resources_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return ensure_resources_possibleConstructorReturn(this,result);};}function ensure_resources_possibleConstructorReturn(self,call){if(call&&(typeof call==="object"||typeof call==="function")){return call;}return ensure_resources_assertThisInitialized(self);}function ensure_resources_assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function ensure_resources_isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function ensure_resources_getPrototypeOf(o){ensure_resources_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return ensure_resources_getPrototypeOf(o);}function ensure_resources_inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}var ensure_resources_EnsureResources=/*#__PURE__*/function(_React$Component){ensure_resources_inheritsLoose(EnsureResources,_React$Component);var _super=ensure_resources_createSuper(EnsureResources);function EnsureResources(props){var _this;_this=_React$Component.call(this)||this;var location=props.location,pageResources=props.pageResources;_this.state={location:Object.assign({},location),pageResources:pageResources||loader["default"].loadPageSync(location.pathname)};return _this;}EnsureResources.getDerivedStateFromProps=function getDerivedStateFromProps(_ref,prevState){var location=_ref.location;if(prevState.location.href!==location.href){var pageResources=loader["default"].loadPageSync(location.pathname);return{pageResources:pageResources,location:Object.assign({},location)};}return{location:Object.assign({},location)};};var _proto=EnsureResources.prototype;_proto.loadResources=function loadResources(rawPath){var _this2=this;loader["default"].loadPage(rawPath).then(function(pageResources){if(pageResources&&pageResources.status!==loader["PageResourceStatus"].Error){_this2.setState({location:Object.assign({},window.location),pageResources:pageResources});}else{window.history.replaceState({},"",location.href);window.location=rawPath;}});};_proto.shouldComponentUpdate=function shouldComponentUpdate(nextProps,nextState){// Always return false if we're missing resources.
if(!nextState.pageResources){this.loadResources(nextProps.location.pathname);return false;}// Check if the component or json have changed.
if(this.state.pageResources!==nextState.pageResources){return true;}if(this.state.pageResources.component!==nextState.pageResources.component){return true;}if(this.state.pageResources.json!==nextState.pageResources.json){return true;}// Check if location has changed on a page using internal routing
// via matchPath configuration.
if(this.state.location.key!==nextState.location.key&&nextState.pageResources.page&&(nextState.pageResources.page.matchPath||nextState.pageResources.page.path)){return true;}return shallow_compare_es(this,nextProps,nextState);};_proto.render=function render(){if(false){}return this.props.children(this.state);};return EnsureResources;}(react_default.a.Component);/* harmony default export */ var ensure_resources = (ensure_resources_EnsureResources);
// EXTERNAL MODULE: ./.cache/strip-prefix.js
var strip_prefix = __webpack_require__("cSJ8");

// EXTERNAL MODULE: ./.cache/match-paths.json
var match_paths = __webpack_require__("vf9c");

// CONCATENATED MODULE: ./.cache/production-app.js
function production_app_createSuper(Derived){return function(){var Super=production_app_getPrototypeOf(Derived),result;if(production_app_isNativeReflectConstruct()){var NewTarget=production_app_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return production_app_possibleConstructorReturn(this,result);};}function production_app_possibleConstructorReturn(self,call){if(call&&(typeof call==="object"||typeof call==="function")){return call;}return production_app_assertThisInitialized(self);}function production_app_assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function production_app_isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function production_app_getPrototypeOf(o){production_app_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return production_app_getPrototypeOf(o);}function production_app_inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}// Generated during bootstrap
var production_app_loader=new loader["ProdLoader"](async_requires_default.a,match_paths);Object(loader["setLoader"])(production_app_loader);production_app_loader.setApiRunner(api_runner_browser["apiRunner"]);window.asyncRequires=async_requires_default.a;window.___emitter=emitter["a" /* default */];window.___loader=loader["publicLoader"];init();Object(api_runner_browser["apiRunnerAsync"])("onClientEntry").then(function(){// Let plugins register a service worker. The plugin just needs
// to return true.
if(Object(api_runner_browser["apiRunner"])("registerServiceWorker").length>0){__webpack_require__("NSX3");}// In gatsby v2 if Router is used in page using matchPaths
// paths need to contain full path.
// For example:
//   - page have `/app/*` matchPath
//   - inside template user needs to use `/app/xyz` as path
// Resetting `basepath`/`baseuri` keeps current behaviour
// to not introduce breaking change.
// Remove this in v3
var RouteHandler=function RouteHandler(props){return react_default.a.createElement(es["BaseContext"].Provider,{value:{baseuri:"/",basepath:"/"}},react_default.a.createElement(page_renderer["a" /* default */],props));};var LocationHandler=/*#__PURE__*/function(_React$Component){production_app_inheritsLoose(LocationHandler,_React$Component);var _super=production_app_createSuper(LocationHandler);function LocationHandler(){return _React$Component.apply(this,arguments)||this;}var _proto=LocationHandler.prototype;_proto.render=function render(){var _this=this;var location=this.props.location;return react_default.a.createElement(ensure_resources,{location:location},function(_ref){var pageResources=_ref.pageResources,location=_ref.location;return react_default.a.createElement(navigation_RouteUpdates,{location:location},react_default.a.createElement(gatsby_react_router_scroll["ScrollContext"],{location:location,shouldUpdateScroll:shouldUpdateScroll},react_default.a.createElement(es["Router"],{basepath:"/ucanlanding",location:location,id:"gatsby-focus-wrapper"},react_default.a.createElement(RouteHandler,Object.assign({path:pageResources.page.path==="/404.html"?Object(strip_prefix["a" /* default */])(location.pathname,"/ucanlanding"):encodeURI(pageResources.page.matchPath||pageResources.page.path)},_this.props,{location:location,pageResources:pageResources},pageResources.json)))));});};return LocationHandler;}(react_default.a.Component);var _window=window,pagePath=_window.pagePath,browserLoc=_window.location;// Explicitly call navigate if the canonical path (window.pagePath)
// is different to the browser path (window.location.pathname). But
// only if NONE of the following conditions hold:
//
// - The url matches a client side route (page.matchPath)
// - it's a 404 page
// - it's the offline plugin shell (/offline-plugin-app-shell-fallback/)
if(pagePath&&"/ucanlanding"+pagePath!==browserLoc.pathname&&!(production_app_loader.findMatchPath(Object(strip_prefix["a" /* default */])(browserLoc.pathname,"/ucanlanding"))||pagePath==="/404.html"||pagePath.match(/^\/404\/?$/)||pagePath.match(/^\/offline-plugin-app-shell-fallback\/?$/))){Object(es["navigate"])("/ucanlanding"+pagePath+browserLoc.search+browserLoc.hash,{replace:true});}loader["publicLoader"].loadPage(browserLoc.pathname).then(function(page){if(!page||page.status===loader["PageResourceStatus"].Error){throw new Error("page resources for "+browserLoc.pathname+" not found. Not rendering React");}window.___webpackCompilationHash=page.page.webpackCompilationHash;var Root=function Root(){return react_default.a.createElement(es["Location"],null,function(locationContext){return react_default.a.createElement(LocationHandler,locationContext);});};var WrappedRoot=Object(api_runner_browser["apiRunner"])("wrapRootElement",{element:react_default.a.createElement(Root,null)},react_default.a.createElement(Root,null),function(_ref2){var result=_ref2.result;return{element:result};}).pop();var NewRoot=function NewRoot(){return WrappedRoot;};var renderer=Object(api_runner_browser["apiRunner"])("replaceHydrateFunction",undefined,react_dom_default.a.hydrate)[0];ready_default()(function(){renderer(react_default.a.createElement(NewRoot,null),typeof window!=="undefined"?document.getElementById("___gatsby"):void 0,function(){Object(api_runner_browser["apiRunner"])("onInitialClientRender");});});});});

/***/ }),

/***/ "Uy6E":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("nl0c"),
    flEquals = _require.equals;

var curry = __webpack_require__("iPMX");

var warn = __webpack_require__("4dnM")('equals');

var unsupported = __webpack_require__("zUWx")('equals');

var isNew = function isNew(a) {
  return typeof a[flEquals] === 'function';
};

var isOld = function isOld(a) {
  return typeof a.equals === 'function';
};
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 *   - Quildreen Motta
 * 
 * type: |
 *   forall S, a:
 *     (S a, S a) => Boolean
 *   where S is Setoid
 */


var equals = function equals(setoidLeft, setoidRight) {
  return isNew(setoidLeft) ? setoidLeft[flEquals](setoidRight) : isOld(setoidLeft) ? warn(setoidLeft.equals(setoidRight)) :
  /*otherwise*/
  unsupported(setoidLeft);
};
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 *   - Quildreen Motta
 * 
 * type: |
 *   forall S, a:
 *     (S a) => (S a) => Boolean
 *   where S is Setoid
 */


equals.curried = curry(2, function (setoidRight, setoidLeft) {
  return (// eslint-disable-line no-magic-numbers
    equals(setoidLeft, setoidRight)
  );
});
/*~
 * stability: experimental
 * authors:
 *   - Quildreen Motta
 * 
 * type: |
 *   forall S, a:
 *     (S a).(S a) => Boolean
 *   where S is Setoid
 */

equals.infix = function (aSetoid) {
  return equals(this, aSetoid);
};

module.exports = equals;

/***/ }),

/***/ "UyNX":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tuple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return tupleNum; });
// https://stackoverflow.com/questions/46176165/ways-to-get-string-literal-type-of-array-values-without-enum-overhead
var tuple = function tuple() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args;
};
var tupleNum = function tupleNum() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args;
};

/***/ }),

/***/ "V7cS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var $indexOf = __webpack_require__("sdkr")(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__("/6rt")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "VNvs":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var $some = __webpack_require__("1wfo")(3);

$export($export.P + $export.F * !__webpack_require__("/6rt")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "VVFi":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "VW18":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _EllipsisOutlined = _interopRequireDefault(__webpack_require__("K+P+"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _EllipsisOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "Vx+c":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("PAFS");
var dPs = __webpack_require__("pU1/");
var enumBugKeys = __webpack_require__("fQty");
var IE_PROTO = __webpack_require__("8kJd")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("mggL")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("CLuC").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "W0B4":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("NS33")();
}

/***/ }),

/***/ "W1QL":
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__("K/PF");
var getKeys = __webpack_require__("LuBU");
var redefine = __webpack_require__("sU/p");
var global = __webpack_require__("P56o");
var hide = __webpack_require__("tjmq");
var Iterators = __webpack_require__("Ibj2");
var wks = __webpack_require__("9dxi");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "W2ws":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("m8zh");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var parsePath = __webpack_require__("PgXy"),
    normalizeUrl = __webpack_require__("iBmR");
/**
 * parseUrl
 * Parses the input url.
 *
 * **Note**: This *throws* if invalid urls are provided.
 *
 * @name parseUrl
 * @function
 * @param {String} url The input url.
 * @param {Boolean|Object} normalize Wheter to normalize the url or not.
 *                         Default is `false`. If `true`, the url will
 *                         be normalized. If an object, it will be the
 *                         options object sent to [`normalize-url`](https://github.com/sindresorhus/normalize-url).
 *
 *                         For SSH urls, normalize won't work.
 *
 * @return {Object} An object containing the following fields:
 *
 *  - `protocols` (Array): An array with the url protocols (usually it has one element).
 *  - `protocol` (String): The first protocol, `"ssh"` (if the url is a ssh url) or `"file"`.
 *  - `port` (null|Number): The domain port.
 *  - `resource` (String): The url domain (including subdomains).
 *  - `user` (String): The authentication user (usually for ssh urls).
 *  - `pathname` (String): The url pathname.
 *  - `hash` (String): The url hash.
 *  - `search` (String): The url querystring value.
 *  - `href` (String): The input url.
 *  - `query` (Object): The url querystring, parsed as object.
 */


function parseUrl(url) {
  var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof url !== "string" || !url.trim()) {
    throw new Error("Invalid url.");
  }

  if (normalize) {
    if ((typeof normalize === "undefined" ? "undefined" : _typeof(normalize)) !== "object") {
      normalize = {
        stripFragment: false
      };
    }

    url = normalizeUrl(url, normalize);
  }

  var parsed = parsePath(url);
  return parsed;
}

module.exports = parseUrl;

/***/ }),

/***/ "WSfz":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("SwVN");
/* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_index_less__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("k81u");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);



/***/ }),

/***/ "WWmS":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "WbNG":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__("fGh/");
var anObject = __webpack_require__("ADe/");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__("8Xl/")(Function.call, __webpack_require__("0HwX").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "Wbzz":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graphql", function() { return graphql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticQueryContext", function() { return StaticQueryContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticQuery", function() { return StaticQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useStaticQuery", function() { return useStaticQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefetchPathname", function() { return prefetchPathname; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gatsby_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("SDHo");
/* harmony import */ var gatsby_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gatsby_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1___default.a; });
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withAssetPrefix", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1__["withAssetPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withPrefix", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1__["withPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parsePath", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1__["parsePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "navigate", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1__["navigate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "push", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1__["push"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "replace", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1__["replace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "navigateTo", function() { return gatsby_link__WEBPACK_IMPORTED_MODULE_1__["navigateTo"]; });

/* harmony import */ var _public_page_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("lw3w");
/* harmony import */ var _public_page_renderer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_public_page_renderer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "PageRenderer", function() { return _public_page_renderer__WEBPACK_IMPORTED_MODULE_2___default.a; });
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("emEt");
var prefetchPathname=_loader__WEBPACK_IMPORTED_MODULE_3__["default"].enqueue;var StaticQueryContext=react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({});function StaticQueryDataRenderer(_ref){var staticQueryData=_ref.staticQueryData,data=_ref.data,query=_ref.query,render=_ref.render;var finalData=data?data.data:staticQueryData[query]&&staticQueryData[query].data;return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment,null,finalData&&render(finalData),!finalData&&react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div",null,"Loading (StaticQuery)"));}var StaticQuery=function StaticQuery(props){var data=props.data,query=props.query,render=props.render,children=props.children;return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(StaticQueryContext.Consumer,null,function(staticQueryData){return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(StaticQueryDataRenderer,{data:data,query:query,render:render||children,staticQueryData:staticQueryData});});};var useStaticQuery=function useStaticQuery(query){if(typeof react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext!=="function"&&"production"==="development"){throw new Error("You're likely using a version of React that doesn't support Hooks\n"+"Please update React and ReactDOM to 16.8.0 or later to use the useStaticQuery hook.");}var context=react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(StaticQueryContext);if(context[query]&&context[query].data){return context[query].data;}else{throw new Error("The result of this StaticQuery could not be fetched.\n\n"+"This is likely a bug in Gatsby and if refreshing the page does not fix it, "+"please open an issue in https://github.com/gatsbyjs/gatsby/issues");}};function graphql(){throw new Error("It appears like Gatsby is misconfigured. Gatsby related `graphql` calls "+"are supposed to only be evaluated at compile time, and then compiled away. "+"Unfortunately, something went wrong and the query was left in the compiled code.\n\n"+"Unless your site has a complex or custom babel/Gatsby configuration this is likely a bug in Gatsby.");}

/***/ }),

/***/ "WiT8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("V7cS");

__webpack_require__("yIlq");

__webpack_require__("GkPX");

__webpack_require__("PAbq");

__webpack_require__("d3/y");

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var React = __webpack_require__("mXGw");

var React__default = _interopDefault(React);

var shallowEqual = _interopDefault(__webpack_require__("F56x"));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

function withSideEffect(reducePropsToState, handleStateChangeOnClient, mapStateOnServer) {
  if (typeof reducePropsToState !== 'function') {
    throw new Error('Expected reducePropsToState to be a function.');
  }

  if (typeof handleStateChangeOnClient !== 'function') {
    throw new Error('Expected handleStateChangeOnClient to be a function.');
  }

  if (typeof mapStateOnServer !== 'undefined' && typeof mapStateOnServer !== 'function') {
    throw new Error('Expected mapStateOnServer to either be undefined or a function.');
  }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }

  return function wrap(WrappedComponent) {
    if (typeof WrappedComponent !== 'function') {
      throw new Error('Expected WrappedComponent to be a React component.');
    }

    var mountedInstances = [];
    var state;

    function emitChange() {
      state = reducePropsToState(mountedInstances.map(function (instance) {
        return instance.props;
      }));

      if (SideEffect.canUseDOM) {
        handleStateChangeOnClient(state);
      } else if (mapStateOnServer) {
        state = mapStateOnServer(state);
      }
    }

    var SideEffect = /*#__PURE__*/function (_Component) {
      _inheritsLoose(SideEffect, _Component);

      function SideEffect() {
        return _Component.apply(this, arguments) || this;
      } // Try to use displayName of wrapped component
      // Expose canUseDOM so tests can monkeypatch it


      SideEffect.peek = function peek() {
        return state;
      };

      SideEffect.rewind = function rewind() {
        if (SideEffect.canUseDOM) {
          throw new Error('You may only call rewind() on the server. Call peek() to read the current state.');
        }

        var recordedState = state;
        state = undefined;
        mountedInstances = [];
        return recordedState;
      };

      var _proto = SideEffect.prototype;

      _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        return !shallowEqual(nextProps, this.props);
      };

      _proto.componentWillMount = function componentWillMount() {
        mountedInstances.push(this);
        emitChange();
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        var index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      };

      _proto.render = function render() {
        return React__default.createElement(WrappedComponent, this.props);
      };

      return SideEffect;
    }(React.Component);

    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");

    _defineProperty(SideEffect, "canUseDOM", canUseDOM);

    return SideEffect;
  };
}

module.exports = withSideEffect;

/***/ }),

/***/ "Wifh":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__("N6/Q");
var redefine = __webpack_require__("sU/p");
var hide = __webpack_require__("tjmq");
var fails = __webpack_require__("E7Vc");
var defined = __webpack_require__("GCOZ");
var wks = __webpack_require__("9dxi");
var regexpExec = __webpack_require__("lAKj");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "Wpb7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("yIlq");

__webpack_require__("5hJT");

__webpack_require__("V7cS");

__webpack_require__("d3/y");

__webpack_require__("6/FK");

__webpack_require__("2Tod");

__webpack_require__("7lGJ");

__webpack_require__("9p7t");

__webpack_require__("ABKx");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var react_1 = __importDefault(__webpack_require__("mXGw"));

var classnames_1 = __importDefault(__webpack_require__("8Jek"));

var column_1 = __importDefault(__webpack_require__("zGEu"));

var Footer = function Footer(_ref) {
  var _ref$prefixCls = _ref.prefixCls,
      prefixCls = _ref$prefixCls === void 0 ? 'rc-footer' : _ref$prefixCls,
      className = _ref.className,
      style = _ref.style,
      bottom = _ref.bottom,
      columns = _ref.columns,
      maxColumnsPerRow = _ref.maxColumnsPerRow,
      backgroundColor = _ref.backgroundColor,
      columnLayout = _ref.columnLayout,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? 'dark' : _ref$theme,
      restProps = _objectWithoutProperties(_ref, ["prefixCls", "className", "style", "bottom", "columns", "maxColumnsPerRow", "backgroundColor", "columnLayout", "theme"]);

  var footerClassName = classnames_1["default"]("".concat(prefixCls), className, _defineProperty({}, "".concat(prefixCls, "-").concat(theme), !!theme));
  var shouldWrap = typeof maxColumnsPerRow === 'number' && maxColumnsPerRow > 0;
  return react_1["default"].createElement("footer", Object.assign({}, restProps, {
    className: footerClassName,
    style: _objectSpread({}, style, {
      backgroundColor: backgroundColor
    })
  }), react_1["default"].createElement("section", {
    className: "".concat(prefixCls, "-container")
  }, columns && columns.length > 0 && react_1["default"].createElement("section", {
    className: "".concat(prefixCls, "-columns"),
    style: {
      justifyContent: columnLayout,
      flexWrap: shouldWrap ? 'wrap' : undefined
    }
  }, columns.map(function (_ref2, i) {
    var title = _ref2.title,
        icon = _ref2.icon,
        columnStyle = _ref2.style,
        columnClassName = _ref2.className,
        _ref2$items = _ref2.items,
        items = _ref2$items === void 0 ? [] : _ref2$items;

    var styleObject = _objectSpread({}, columnStyle);

    if (shouldWrap) {
      styleObject.flex = "0 0 ".concat(100 / (maxColumnsPerRow + 1) + 0.1, "%");
    }

    return react_1["default"].createElement(column_1["default"], {
      key: i,
      prefixCls: prefixCls,
      title: title,
      icon: icon,
      items: items,
      style: styleObject,
      className: columnClassName
    });
  }))), bottom && react_1["default"].createElement("section", {
    className: "".concat(prefixCls, "-bottom")
  }, react_1["default"].createElement("div", {
    className: "".concat(prefixCls, "-bottom-container")
  }, bottom)));
};

exports["default"] = Footer;

/***/ }),

/***/ "WwSA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("Kdq7")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("gMWQ")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "X6VK":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("P56o");
var core = __webpack_require__("R5TD");
var hide = __webpack_require__("tjmq");
var redefine = __webpack_require__("sU/p");
var ctx = __webpack_require__("9liC");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "XDlq":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _dispatchable = __webpack_require__("ex0g");

var _xtake = __webpack_require__("FWEc");

var slice = __webpack_require__("w4Md");
/**
 * Returns the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `take` method).
 *
 * Dispatches to the `take` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*}
 * @see R.drop
 * @example
 *
 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(3, 'ramda');               //=> 'ram'
 *
 *      var personnel = [
 *        'Dave Brubeck',
 *        'Paul Desmond',
 *        'Eugene Wright',
 *        'Joe Morello',
 *        'Gerry Mulligan',
 *        'Bob Bates',
 *        'Joe Dodge',
 *        'Ron Crotty'
 *      ];
 *
 *      var takeFive = R.take(5);
 *      takeFive(personnel);
 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
 * @symb R.take(-1, [a, b]) = [a, b]
 * @symb R.take(0, [a, b]) = []
 * @symb R.take(1, [a, b]) = [a]
 * @symb R.take(2, [a, b]) = [a, b]
 */


module.exports = _curry2(_dispatchable(['take'], _xtake, function take(n, xs) {
  return slice(0, n < 0 ? Infinity : n, xs);
}));

/***/ }),

/***/ "XDzM":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("P56o");
var macrotask = __webpack_require__("5BMI").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__("n+VH")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "XMvD":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("GkPX");

__webpack_require__("1qKx");

__webpack_require__("PAbq");

__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports["default"] = connect;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _shallowequal = __webpack_require__("F56x");

var _shallowequal2 = _interopRequireDefault(_shallowequal);

var _hoistNonReactStatics = __webpack_require__("y/En");

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _reactLifecyclesCompat = __webpack_require__("94VI");

var _PropTypes = __webpack_require__("uSgx");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

function isStateless(Component) {
  return !Component.prototype.render;
}

var defaultMapStateToProps = function defaultMapStateToProps() {
  return {};
};

function connect(mapStateToProps) {
  var shouldSubscribe = !!mapStateToProps;
  var finnalMapStateToProps = mapStateToProps || defaultMapStateToProps;
  return function wrapWithConnect(WrappedComponent) {
    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      _createClass(Connect, null, [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(props, prevState) {
          // using ownProps
          if (mapStateToProps && mapStateToProps.length === 2 && props !== prevState.props) {
            return {
              subscribed: finnalMapStateToProps(prevState.store.getState(), props),
              props: props
            };
          }

          return {
            props: props
          };
        }
      }]);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, (Connect.__proto__ || Object.getPrototypeOf(Connect)).call(this, props, context));

        _this.handleChange = function () {
          if (!_this.unsubscribe) {
            return;
          }

          var nextState = finnalMapStateToProps(_this.store.getState(), _this.props);

          _this.setState({
            subscribed: nextState
          });
        };

        _this.store = context.miniStore;
        _this.state = {
          subscribed: finnalMapStateToProps(_this.store.getState(), props),
          store: _this.store,
          props: props
        };
        return _this;
      }

      _createClass(Connect, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
          this.trySubscribe();
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          this.tryUnsubscribe();
        }
      }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps, nextState) {
          return !(0, _shallowequal2["default"])(this.props, nextProps) || !(0, _shallowequal2["default"])(this.state.subscribed, nextState.subscribed);
        }
      }, {
        key: 'trySubscribe',
        value: function trySubscribe() {
          if (shouldSubscribe) {
            this.unsubscribe = this.store.subscribe(this.handleChange);
            this.handleChange();
          }
        }
      }, {
        key: 'tryUnsubscribe',
        value: function tryUnsubscribe() {
          if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
          }
        }
      }, {
        key: 'getWrappedInstance',
        value: function getWrappedInstance() {
          return this.wrappedInstance;
        }
      }, {
        key: 'render',
        value: function render() {
          var _this2 = this;

          var props = _extends({}, this.props, this.state.subscribed, {
            store: this.store
          });

          if (!isStateless(WrappedComponent)) {
            props = _extends({}, props, {
              ref: function ref(c) {
                return _this2.wrappedInstance = c;
              }
            });
          }

          return _react2["default"].createElement(WrappedComponent, props);
        }
      }]);

      return Connect;
    }(_react.Component);

    Connect.displayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
    Connect.contextTypes = {
      miniStore: _PropTypes.storeShape.isRequired
    };
    (0, _reactLifecyclesCompat.polyfill)(Connect);
    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
  };
}

/***/ }),

/***/ "XQie":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("GkPX");

var _arrayFromIterator = __webpack_require__("P3BQ");

var _functionName = __webpack_require__("6z9p");

var _has = __webpack_require__("bprV");

var identical = __webpack_require__("1rpk");

var keys = __webpack_require__("bmJ9");

var type = __webpack_require__("CXzI");

module.exports = function _equals(a, b, stackA, stackB) {
  if (identical(a, b)) {
    return true;
  }

  if (type(a) !== type(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (type(a)) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
        return a === b;
      }

      break;

    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
        return false;
      }

      break;

    case 'Date':
      if (!identical(a.valueOf(), b.valueOf())) {
        return false;
      }

      break;

    case 'Error':
      return a.name === b.name && a.message === b.message;

    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }

      break;

    case 'Map':
    case 'Set':
      if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
        return false;
      }

      break;

    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
      break;

    case 'ArrayBuffer':
      break;

    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = keys(a);

  if (keysA.length !== keys(b).length) {
    return false;
  }

  var idx = stackA.length - 1;

  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }

    idx -= 1;
  }

  stackA.push(a);
  stackB.push(b);
  idx = keysA.length - 1;

  while (idx >= 0) {
    var key = keysA[idx];

    if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
      return false;
    }

    idx -= 1;
  }

  stackA.pop();
  stackB.pop();
  return true;
};

/***/ }),

/***/ "XQta":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__("U1KF").f;
var create = __webpack_require__("Vx+c");
var redefineAll = __webpack_require__("+edc");
var ctx = __webpack_require__("9liC");
var anInstance = __webpack_require__("EusA");
var forOf = __webpack_require__("HqX2");
var $iterDefine = __webpack_require__("Jww/");
var step = __webpack_require__("VVFi");
var setSpecies = __webpack_require__("E8p1");
var DESCRIPTORS = __webpack_require__("GGqZ");
var fastKey = __webpack_require__("zIP/").fastKey;
var validate = __webpack_require__("SsG5");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "XUZz":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("V7cS");

__webpack_require__("9ovy");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"), __webpack_require__("KvMB"), __webpack_require__("Bi0q"));else {}
})(function (CodeMirror) {
  "use strict"; // Depth means the amount of open braces in JS context, in XML
  // context 0 means not in tag, 1 means in tag, and 2 means in tag
  // and js block comment.

  function Context(state, mode, depth, prev) {
    this.state = state;
    this.mode = mode;
    this.depth = depth;
    this.prev = prev;
  }

  function copyContext(context) {
    return new Context(CodeMirror.copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev));
  }

  CodeMirror.defineMode("jsx", function (config, modeConfig) {
    var xmlMode = CodeMirror.getMode(config, {
      name: "xml",
      allowMissing: true,
      multilineTagIndentPastTag: false,
      allowMissingTagName: true
    });
    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript");

    function flatXMLIndent(state) {
      var tagName = state.tagName;
      state.tagName = null;
      var result = xmlMode.indent(state, "", "");
      state.tagName = tagName;
      return result;
    }

    function token(stream, state) {
      if (state.context.mode == xmlMode) return xmlToken(stream, state, state.context);else return jsToken(stream, state, state.context);
    }

    function xmlToken(stream, state, cx) {
      if (cx.depth == 2) {
        // Inside a JS /* */ comment
        if (stream.match(/^.*?\*\//)) cx.depth = 1;else stream.skipToEnd();
        return "comment";
      }

      if (stream.peek() == "{") {
        xmlMode.skipAttribute(cx.state);
        var indent = flatXMLIndent(cx.state),
            xmlContext = cx.state.context; // If JS starts on same line as tag

        if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
          while (xmlContext.prev && !xmlContext.startOfLine) {
            xmlContext = xmlContext.prev;
          } // If tag starts the line, use XML indentation level


          if (xmlContext.startOfLine) indent -= config.indentUnit; // Else use JS indentation level
          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented; // Else if inside of tag
        } else if (cx.depth == 1) {
          indent += config.indentUnit;
        }

        state.context = new Context(CodeMirror.startState(jsMode, indent), jsMode, 0, state.context);
        return null;
      }

      if (cx.depth == 1) {
        // Inside of tag
        if (stream.peek() == "<") {
          // Tag inside of tag
          xmlMode.skipAttribute(cx.state);
          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context);
          return null;
        } else if (stream.match("//")) {
          stream.skipToEnd();
          return "comment";
        } else if (stream.match("/*")) {
          cx.depth = 2;
          return token(stream, state);
        }
      }

      var style = xmlMode.token(stream, cx.state),
          cur = stream.current(),
          stop;

      if (/\btag\b/.test(style)) {
        if (/>$/.test(cur)) {
          if (cx.state.context) cx.depth = 0;else state.context = state.context.prev;
        } else if (/^</.test(cur)) {
          cx.depth = 1;
        }
      } else if (!style && (stop = cur.indexOf("{")) > -1) {
        stream.backUp(cur.length - stop);
      }

      return style;
    }

    function jsToken(stream, state, cx) {
      if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
        jsMode.skipExpression(cx.state);
        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "", "")), xmlMode, 0, state.context);
        return null;
      }

      var style = jsMode.token(stream, cx.state);

      if (!style && cx.depth != null) {
        var cur = stream.current();

        if (cur == "{") {
          cx.depth++;
        } else if (cur == "}") {
          if (--cx.depth == 0) state.context = state.context.prev;
        }
      }

      return style;
    }

    return {
      startState: function startState() {
        return {
          context: new Context(CodeMirror.startState(jsMode), jsMode)
        };
      },
      copyState: function copyState(state) {
        return {
          context: copyContext(state.context)
        };
      },
      token: token,
      indent: function indent(state, textAfter, fullLine) {
        return state.context.mode.indent(state.context.state, textAfter, fullLine);
      },
      innerMode: function innerMode(state) {
        return state.context;
      }
    };
  }, "xml", "javascript");
  CodeMirror.defineMIME("text/jsx", "jsx");
  CodeMirror.defineMIME("text/typescript-jsx", {
    name: "jsx",
    base: {
      name: "javascript",
      typescript: true
    }
  });
});

/***/ }),

/***/ "XVYZ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("oMRA");

__webpack_require__("6d4m");

__webpack_require__("V7cS");

__webpack_require__("Z8gF");

__webpack_require__("GkPX");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("asZ9");

var gitUp = __webpack_require__("CyNN");
/**
 * gitUrlParse
 * Parses a Git url.
 *
 * @name gitUrlParse
 * @function
 * @param {String} url The Git url to parse.
 * @return {GitUrl} The `GitUrl` object containing:
 *
 *  - `protocols` (Array): An array with the url protocols (usually it has one element).
 *  - `port` (null|Number): The domain port.
 *  - `resource` (String): The url domain (including subdomains).
 *  - `user` (String): The authentication user (usually for ssh urls).
 *  - `pathname` (String): The url pathname.
 *  - `hash` (String): The url hash.
 *  - `search` (String): The url querystring value.
 *  - `href` (String): The input url.
 *  - `protocol` (String): The git url protocol.
 *  - `token` (String): The oauth token (could appear in the https urls).
 *  - `source` (String): The Git provider (e.g. `"github.com"`).
 *  - `owner` (String): The repository owner.
 *  - `name` (String): The repository name.
 *  - `ref` (String): The repository ref (e.g., "master" or "dev").
 *  - `filepath` (String): A filepath relative to the repository root.
 *  - `filepathtype` (String): The type of filepath in the url ("blob" or "tree").
 *  - `full_name` (String): The owner and name values in the `owner/name` format.
 *  - `toString` (Function): A function to stringify the parsed url into another url type.
 *  - `organization` (String): The organization the owner belongs to. This is CloudForge specific.
 *  - `git_suffix` (Boolean): Whether to add the `.git` suffix or not.
 *
 */


function gitUrlParse(url) {
  if (typeof url !== "string") {
    throw new Error("The url must be a string.");
  }

  var urlInfo = gitUp(url),
      sourceParts = urlInfo.resource.split("."),
      splits = null;

  urlInfo.toString = function (type) {
    return gitUrlParse.stringify(this, type);
  };

  urlInfo.source = sourceParts.length > 2 ? sourceParts.slice(1 - sourceParts.length).join(".") : urlInfo.source = urlInfo.resource; // Note: Some hosting services (e.g. Visual Studio Team Services) allow whitespace characters
  // in the repository and owner names so we decode the URL pieces to get the correct result

  urlInfo.git_suffix = /\.git$/.test(urlInfo.pathname);
  urlInfo.name = decodeURIComponent(urlInfo.pathname.replace(/^\//, '').replace(/\.git$/, ""));
  urlInfo.owner = decodeURIComponent(urlInfo.user);

  switch (urlInfo.source) {
    case "git.cloudforge.com":
      urlInfo.owner = urlInfo.user;
      urlInfo.organization = sourceParts[0];
      urlInfo.source = "cloudforge.com";
      break;

    case "visualstudio.com":
      // Handle VSTS SSH URLs
      if (urlInfo.resource === 'vs-ssh.visualstudio.com') {
        splits = urlInfo.name.split("/");

        if (splits.length === 4) {
          urlInfo.organization = splits[1];
          urlInfo.owner = splits[2];
          urlInfo.name = splits[3];
          urlInfo.full_name = splits[2] + '/' + splits[3];
        }

        break;
      } else {
        splits = urlInfo.name.split("/");

        if (splits.length === 2) {
          urlInfo.owner = splits[1];
          urlInfo.name = splits[1];
          urlInfo.full_name = '_git/' + urlInfo.name;
        } else if (splits.length === 3) {
          urlInfo.name = splits[2];

          if (splits[0] === 'DefaultCollection') {
            urlInfo.owner = splits[2];
            urlInfo.organization = splits[0];
            urlInfo.full_name = urlInfo.organization + '/_git/' + urlInfo.name;
          } else {
            urlInfo.owner = splits[0];
            urlInfo.full_name = urlInfo.owner + '/_git/' + urlInfo.name;
          }
        } else if (splits.length === 4) {
          urlInfo.organization = splits[0];
          urlInfo.owner = splits[1];
          urlInfo.name = splits[3];
          urlInfo.full_name = urlInfo.organization + '/' + urlInfo.owner + '/_git/' + urlInfo.name;
        }

        break;
      }

    // Azure DevOps (formerly Visual Studio Team Services)

    case "dev.azure.com":
    case "azure.com":
      if (urlInfo.resource === 'ssh.dev.azure.com') {
        splits = urlInfo.name.split("/");

        if (splits.length === 4) {
          urlInfo.organization = splits[1];
          urlInfo.owner = splits[2];
          urlInfo.name = splits[3];
        }

        break;
      } else {
        splits = urlInfo.name.split("/");

        if (splits.length === 5) {
          urlInfo.organization = splits[0];
          urlInfo.owner = splits[1];
          urlInfo.name = splits[4];
          urlInfo.full_name = '_git/' + urlInfo.name;
        } else if (splits.length === 3) {
          urlInfo.name = splits[2];

          if (splits[0] === 'DefaultCollection') {
            urlInfo.owner = splits[2];
            urlInfo.organization = splits[0];
            urlInfo.full_name = urlInfo.organization + '/_git/' + urlInfo.name;
          } else {
            urlInfo.owner = splits[0];
            urlInfo.full_name = urlInfo.owner + '/_git/' + urlInfo.name;
          }
        } else if (splits.length === 4) {
          urlInfo.organization = splits[0];
          urlInfo.owner = splits[1];
          urlInfo.name = splits[3];
          urlInfo.full_name = urlInfo.organization + '/' + urlInfo.owner + '/_git/' + urlInfo.name;
        }

        break;
      }

    default:
      splits = urlInfo.name.split("/");
      var nameIndex = splits.length - 1;

      if (splits.length >= 2) {
        var blobIndex = splits.indexOf("blob", 2);
        var treeIndex = splits.indexOf("tree", 2);
        var commitIndex = splits.indexOf("commit", 2);
        nameIndex = blobIndex > 0 ? blobIndex - 1 : treeIndex > 0 ? treeIndex - 1 : commitIndex > 0 ? commitIndex - 1 : nameIndex;
        urlInfo.owner = splits.slice(0, nameIndex).join('/');
        urlInfo.name = splits[nameIndex];

        if (commitIndex) {
          urlInfo.commit = splits[nameIndex + 2];
        }
      }

      urlInfo.ref = "";
      urlInfo.filepathtype = "";
      urlInfo.filepath = "";

      if (splits.length > nameIndex + 2 && ["blob", "tree"].indexOf(splits[nameIndex + 1]) >= 0) {
        urlInfo.filepathtype = splits[nameIndex + 1];
        urlInfo.ref = splits[nameIndex + 2];

        if (splits.length > nameIndex + 3) {
          urlInfo.filepath = splits.slice(nameIndex + 3).join('/');
        }
      }

      urlInfo.organization = urlInfo.owner;
      break;
  }

  if (!urlInfo.full_name) {
    urlInfo.full_name = urlInfo.owner;

    if (urlInfo.name) {
      urlInfo.full_name && (urlInfo.full_name += "/");
      urlInfo.full_name += urlInfo.name;
    }
  }

  return urlInfo;
}
/**
 * stringify
 * Stringifies a `GitUrl` object.
 *
 * @name stringify
 * @function
 * @param {GitUrl} obj The parsed Git url object.
 * @param {String} type The type of the stringified url (default `obj.protocol`).
 * @return {String} The stringified url.
 */


gitUrlParse.stringify = function (obj, type) {
  type = type || (obj.protocols && obj.protocols.length ? obj.protocols.join('+') : obj.protocol);
  var port = obj.port ? ":" + obj.port : '';
  var user = obj.user || 'git';
  var maybeGitSuffix = obj.git_suffix ? ".git" : "";

  switch (type) {
    case "ssh":
      if (port) return "ssh://" + user + "@" + obj.resource + port + "/" + obj.full_name + maybeGitSuffix;else return user + "@" + obj.resource + ":" + obj.full_name + maybeGitSuffix;

    case "git+ssh":
    case "ssh+git":
    case "ftp":
    case "ftps":
      return type + "://" + user + "@" + obj.resource + port + "/" + obj.full_name + maybeGitSuffix;

    case "http":
    case "https":
      var auth = obj.token ? buildToken(obj) : obj.user && (obj.protocols.includes('http') || obj.protocols.includes('https')) ? obj.user + "@" : "";
      return type + "://" + auth + obj.resource + port + "/" + obj.full_name + maybeGitSuffix;

    default:
      return obj.href;
  }
};
/*!
 * buildToken
 * Builds OAuth token prefix (helper function)
 *
 * @name buildToken
 * @function
 * @param {GitUrl} obj The parsed Git url object.
 * @return {String} token prefix
 */


function buildToken(obj) {
  switch (obj.source) {
    case "bitbucket.org":
      return "x-token-auth:" + obj.token + "@";

    default:
      return obj.token + "@";
  }
}

module.exports = gitUrlParse;

/***/ }),

/***/ "XfXe":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("SwVN");
/* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_index_less__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DzUA");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _tooltip_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("WSfz");

 // style dependencies
// deps-lint-skip: layout



/***/ }),

/***/ "Xfku":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("n+VH");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "XgqJ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _CheckOutlined = _interopRequireDefault(__webpack_require__("h3fB"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var CheckOutlined = function CheckOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _CheckOutlined["default"]
  }));
};

CheckOutlined.displayName = 'CheckOutlined';

var _default = _react["default"].forwardRef(CheckOutlined);

exports["default"] = _default;

/***/ }),

/***/ "Xj5l":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "XmXP":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("/6KZ");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__("G+Zn") });


/***/ }),

/***/ "Xx9V":
/***/ (function(module, exports) {

module.exports = function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
};

/***/ }),

/***/ "Y8EE":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return warning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isIconDefinition; });
/* unused harmony export normalizeAttrs */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getSecondaryColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return normalizeTwoToneColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return svgBaseProps; });
/* unused harmony export iconStyles */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return useInsertStyles; });
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("+3V6");
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("yIlq");
/* harmony import */ var core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("3y5y");
/* harmony import */ var core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("GkPX");
/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("+jjx");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("d3/y");
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_object_define_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("6/FK");
/* harmony import */ var core_js_modules_es6_object_define_properties__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_define_properties__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("2Tod");
/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("7lGJ");
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("9p7t");
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("ABKx");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("W1QL");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("K/PF");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("75LO");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _ant_design_colors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("LTuF");
/* harmony import */ var _ant_design_colors__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_ant_design_colors__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var rc_util_es_warning__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("IFhY");
/* harmony import */ var insert_css__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("3Q0B");
/* harmony import */ var insert_css__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(insert_css__WEBPACK_IMPORTED_MODULE_18__);
















function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}





function warning(valid, message) {
  Object(rc_util_es_warning__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"])(valid, "[@ant-design/icons] ".concat(message));
}
function isIconDefinition(target) {
  return _typeof(target) === 'object' && typeof target.name === 'string' && typeof target.theme === 'string' && (_typeof(target.icon) === 'object' || typeof target.icon === 'function');
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(attrs).reduce(function (acc, key) {
    var val = attrs[key];

    switch (key) {
      case 'class':
        acc.className = val;
        delete acc["class"];
        break;

      default:
        acc[key] = val;
    }

    return acc;
  }, {});
}
function generate(node, key, rootProps) {
  if (!rootProps) {
    return react__WEBPACK_IMPORTED_MODULE_16___default.a.createElement(node.tag, _objectSpread({
      key: key
    }, normalizeAttrs(node.attrs)), (node.children || []).map(function (child, index) {
      return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
    }));
  }

  return react__WEBPACK_IMPORTED_MODULE_16___default.a.createElement(node.tag, _objectSpread({
    key: key
  }, normalizeAttrs(node.attrs), {}, rootProps), (node.children || []).map(function (child, index) {
    return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
  }));
}
function getSecondaryColor(primaryColor) {
  // choose the second color
  return Object(_ant_design_colors__WEBPACK_IMPORTED_MODULE_15__["generate"])(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }

  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
} // These props make sure that the SVG behaviours like general text.
// Reference: https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4

var svgBaseProps = {
  width: '1em',
  height: '1em',
  fill: 'currentColor',
  'aria-hidden': 'true',
  focusable: 'false'
};
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var cssInjectedFlag = false;
var useInsertStyles = function useInsertStyles() {
  var styleStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iconStyles;
  Object(react__WEBPACK_IMPORTED_MODULE_16__["useEffect"])(function () {
    if (!cssInjectedFlag) {
      Object(insert_css__WEBPACK_IMPORTED_MODULE_18__["insertCss"])(styleStr, {
        prepend: true
      });
      cssInjectedFlag = true;
    }
  }, []);
};

/***/ }),

/***/ "YLt+":
/***/ (function(module) {

module.exports = JSON.parse("[{\"fromPath\":\"/ucanlanding/zh/docs/other\",\"isPermanent\":true,\"redirectInBrowser\":true,\"toPath\":\"/ucanlanding/zh/docs/other/getting-started\"},{\"fromPath\":\"/ucanlanding/zh/docs/specification\",\"isPermanent\":true,\"redirectInBrowser\":true,\"toPath\":\"/ucanlanding/zh/docs/specification/getting-started\"},{\"fromPath\":\"/ucanlanding/en/docs/other\",\"isPermanent\":true,\"redirectInBrowser\":true,\"toPath\":\"/ucanlanding/en/docs/other/getting-started\"},{\"fromPath\":\"/ucanlanding/en/docs/specification\",\"isPermanent\":true,\"redirectInBrowser\":true,\"toPath\":\"/ucanlanding/en/docs/specification/getting-started\"},{\"fromPath\":\"/ucanlanding/en/examples\",\"isPermanent\":true,\"redirectInBrowser\":true,\"toPath\":\"/ucanlanding/en/examples/gallery\"},{\"fromPath\":\"/ucanlanding/zh/examples\",\"isPermanent\":true,\"redirectInBrowser\":true,\"toPath\":\"/ucanlanding/zh/examples/gallery\"}]");

/***/ }),

/***/ "YOo+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("1qKx");

__webpack_require__("PAbq");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _PropTypes = __webpack_require__("uSgx");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Provider = function (_Component) {
  _inherits(Provider, _Component);

  function Provider() {
    _classCallCheck(this, Provider);

    return _possibleConstructorReturn(this, (Provider.__proto__ || Object.getPrototypeOf(Provider)).apply(this, arguments));
  }

  _createClass(Provider, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        miniStore: this.props.store
      };
    }
  }, {
    key: 'render',
    value: function render() {
      return _react.Children.only(this.props.children);
    }
  }]);

  return Provider;
}(_react.Component);

Provider.propTypes = {
  store: _PropTypes.storeShape.isRequired
};
Provider.childContextTypes = {
  miniStore: _PropTypes.storeShape.isRequired
};
exports["default"] = Provider;

/***/ }),

/***/ "YSJY":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.bind.js
var es6_function_bind = __webpack_require__("o7PZ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.now.js
var es6_date_now = __webpack_require__("7t+O");

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/extends.js
var helpers_extends = __webpack_require__("Kz1y");
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__("TcPG");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__("Zv/C");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/createClass.js
var createClass = __webpack_require__("2lBV");
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__("Dkg+");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/inherits.js
var inherits = __webpack_require__("Gjrs");
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// CONCATENATED MODULE: ../node_modules/rc-util/es/unsafeLifecyclesPolyfill.js


var unsafeLifecyclesPolyfill_unsafeLifecyclesPolyfill = function unsafeLifecyclesPolyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  } // only handle componentWillReceiveProps


  if (typeof prototype.componentWillReceiveProps !== 'function') {
    return Component;
  } // In React 16.9, React.Profiler was introduced together with UNSAFE_componentWillReceiveProps
  // https://reactjs.org/blog/2019/08/08/react-v16.9.0.html#performance-measurements-with-reactprofiler


  if (!react_default.a.Profiler) {
    return Component;
  } // Here polyfill get started


  prototype.UNSAFE_componentWillReceiveProps = prototype.componentWillReceiveProps;
  delete prototype.componentWillReceiveProps;
  return Component;
};

/* harmony default export */ var es_unsafeLifecyclesPolyfill = (unsafeLifecyclesPolyfill_unsafeLifecyclesPolyfill);
// CONCATENATED MODULE: ../node_modules/rc-animate/es/ChildrenUtils.js


function toArrayChildren(children) {
  var ret = [];
  react_default.a.Children.forEach(children, function (child) {
    ret.push(child);
  });
  return ret;
}
function findChildInChildrenByKey(children, key) {
  var ret = null;

  if (children) {
    children.forEach(function (child) {
      if (ret) {
        return;
      }

      if (child && child.key === key) {
        ret = child;
      }
    });
  }

  return ret;
}
function findShownChildInChildrenByKey(children, key, showProp) {
  var ret = null;

  if (children) {
    children.forEach(function (child) {
      if (child && child.key === key && child.props[showProp]) {
        if (ret) {
          throw new Error('two child with same key for <rc-animate> children');
        }

        ret = child;
      }
    });
  }

  return ret;
}
function findHiddenChildInChildrenByKey(children, key, showProp) {
  var found = 0;

  if (children) {
    children.forEach(function (child) {
      if (found) {
        return;
      }

      found = child && child.key === key && !child.props[showProp];
    });
  }

  return found;
}
function isSameChildren(c1, c2, showProp) {
  var same = c1.length === c2.length;

  if (same) {
    c1.forEach(function (child, index) {
      var child2 = c2[index];

      if (child && child2) {
        if (child && !child2 || !child && child2) {
          same = false;
        } else if (child.key !== child2.key) {
          same = false;
        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
          same = false;
        }
      }
    });
  }

  return same;
}
function mergeChildren(prev, next) {
  var ret = []; // For each key of `next`, the list of keys to insert before that key in
  // the combined list

  var nextChildrenPending = {};
  var pendingChildren = [];
  prev.forEach(function (child) {
    if (child && findChildInChildrenByKey(next, child.key)) {
      if (pendingChildren.length) {
        nextChildrenPending[child.key] = pendingChildren;
        pendingChildren = [];
      }
    } else {
      pendingChildren.push(child);
    }
  });
  next.forEach(function (child) {
    if (child && Object.prototype.hasOwnProperty.call(nextChildrenPending, child.key)) {
      ret = ret.concat(nextChildrenPending[child.key]);
    }

    ret.push(child);
  });
  ret = ret.concat(pendingChildren);
  return ret;
}
// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.to-string.js
var es6_date_to_string = __webpack_require__("M/4x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__("GkPX");

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__("wv3L");
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ../node_modules/css-animation/es/Event.js
var Event = __webpack_require__("G8Im");

// EXTERNAL MODULE: ../node_modules/component-classes/index.js
var component_classes = __webpack_require__("7UOo");
var component_classes_default = /*#__PURE__*/__webpack_require__.n(component_classes);

// CONCATENATED MODULE: ../node_modules/css-animation/es/index.js








var isCssAnimationSupported = Event["a" /* default */].endEvents.length !== 0;
var capitalPrefixes = ['Webkit', 'Moz', 'O', // ms is special .... !
'ms'];
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getStyleProperty(node, name) {
  // old ff need null, https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
  var style = window.getComputedStyle(node, null);
  var ret = '';

  for (var i = 0; i < prefixes.length; i++) {
    ret = style.getPropertyValue(prefixes[i] + name);

    if (ret) {
      break;
    }
  }

  return ret;
}

function fixBrowserByTimeout(node) {
  if (isCssAnimationSupported) {
    var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
    var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
    var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
    var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
    var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay); // sometimes, browser bug

    node.rcEndAnimTimeout = setTimeout(function () {
      node.rcEndAnimTimeout = null;

      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }, time * 1000 + 200);
  }
}

function clearBrowserBugTimeout(node) {
  if (node.rcEndAnimTimeout) {
    clearTimeout(node.rcEndAnimTimeout);
    node.rcEndAnimTimeout = null;
  }
}

var es_cssAnimation = function cssAnimation(node, transitionName, endCallback) {
  var nameIsObj = (typeof transitionName === 'undefined' ? 'undefined' : typeof_default()(transitionName)) === 'object';
  var className = nameIsObj ? transitionName.name : transitionName;
  var activeClassName = nameIsObj ? transitionName.active : transitionName + '-active';
  var end = endCallback;
  var start = void 0;
  var active = void 0;
  var nodeClasses = component_classes_default()(node);

  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
    end = endCallback.end;
    start = endCallback.start;
    active = endCallback.active;
  }

  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);
    nodeClasses.remove(className);
    nodeClasses.remove(activeClassName);
    Event["a" /* default */].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null; // Usually this optional end is used for informing an owner of
    // a leave animation and telling it to remove the child.

    if (end) {
      end();
    }
  };

  Event["a" /* default */].addEndEventListener(node, node.rcEndListener);

  if (start) {
    start();
  }

  nodeClasses.add(className);
  node.rcAnimTimeout = setTimeout(function () {
    node.rcAnimTimeout = null;
    nodeClasses.add(activeClassName);

    if (active) {
      setTimeout(active, 0);
    }

    fixBrowserByTimeout(node); // 30ms for firefox
  }, 30);
  return {
    stop: function stop() {
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }
  };
};

es_cssAnimation.style = function (node, style, callback) {
  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);
    Event["a" /* default */].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null; // Usually this optional callback is used for informing an owner of
    // a leave animation and telling it to remove the child.

    if (callback) {
      callback();
    }
  };

  Event["a" /* default */].addEndEventListener(node, node.rcEndListener);
  node.rcAnimTimeout = setTimeout(function () {
    for (var s in style) {
      if (style.hasOwnProperty(s)) {
        node.style[s] = style[s];
      }
    }

    node.rcAnimTimeout = null;
    fixBrowserByTimeout(node);
  }, 0);
};

es_cssAnimation.setTransition = function (node, p, value) {
  var property = p;
  var v = value;

  if (value === undefined) {
    v = property;
    property = '';
  }

  property = property || '';
  capitalPrefixes.forEach(function (prefix) {
    node.style[prefix + 'Transition' + property] = v;
  });
};

es_cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

/* harmony default export */ var es = (es_cssAnimation);
// CONCATENATED MODULE: ../node_modules/rc-animate/es/util/animate.js
var util = {
  isAppearSupported: function isAppearSupported(props) {
    return props.transitionName && props.transitionAppear || props.animation.appear;
  },
  isEnterSupported: function isEnterSupported(props) {
    return props.transitionName && props.transitionEnter || props.animation.enter;
  },
  isLeaveSupported: function isLeaveSupported(props) {
    return props.transitionName && props.transitionLeave || props.animation.leave;
  },
  allowAppearCallback: function allowAppearCallback(props) {
    return props.transitionAppear || props.animation.appear;
  },
  allowEnterCallback: function allowEnterCallback(props) {
    return props.transitionEnter || props.animation.enter;
  },
  allowLeaveCallback: function allowLeaveCallback(props) {
    return props.transitionLeave || props.animation.leave;
  }
};
/* harmony default export */ var animate = (util);
// CONCATENATED MODULE: ../node_modules/rc-animate/es/AnimateChild.js









var transitionMap = {
  enter: 'transitionEnter',
  appear: 'transitionAppear',
  leave: 'transitionLeave'
};

var AnimateChild_AnimateChild = function (_React$Component) {
  inherits_default()(AnimateChild, _React$Component);

  function AnimateChild() {
    classCallCheck_default()(this, AnimateChild);

    return possibleConstructorReturn_default()(this, (AnimateChild.__proto__ || Object.getPrototypeOf(AnimateChild)).apply(this, arguments));
  }

  createClass_default()(AnimateChild, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.stop();
    }
  }, {
    key: 'componentWillEnter',
    value: function componentWillEnter(done) {
      if (animate.isEnterSupported(this.props)) {
        this.transition('enter', done);
      } else {
        done();
      }
    }
  }, {
    key: 'componentWillAppear',
    value: function componentWillAppear(done) {
      if (animate.isAppearSupported(this.props)) {
        this.transition('appear', done);
      } else {
        done();
      }
    }
  }, {
    key: 'componentWillLeave',
    value: function componentWillLeave(done) {
      if (animate.isLeaveSupported(this.props)) {
        this.transition('leave', done);
      } else {
        // always sync, do not interupt with react component life cycle
        // update hidden -> animate hidden ->
        // didUpdate -> animate leave -> unmount (if animate is none)
        done();
      }
    }
  }, {
    key: 'transition',
    value: function transition(animationType, finishCallback) {
      var _this2 = this;

      var node = react_dom_default.a.findDOMNode(this);
      var props = this.props;
      var transitionName = props.transitionName;
      var nameIsObj = typeof transitionName === 'object';
      this.stop();

      var end = function end() {
        _this2.stopper = null;
        finishCallback();
      };

      if ((isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
        var name = nameIsObj ? transitionName[animationType] : transitionName + '-' + animationType;
        var activeName = name + '-active';

        if (nameIsObj && transitionName[animationType + 'Active']) {
          activeName = transitionName[animationType + 'Active'];
        }

        this.stopper = es(node, {
          name: name,
          active: activeName
        }, end);
      } else {
        this.stopper = props.animation[animationType](node, end);
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var stopper = this.stopper;

      if (stopper) {
        this.stopper = null;
        stopper.stop();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);

  return AnimateChild;
}(react_default.a.Component);

AnimateChild_AnimateChild.propTypes = {
  children: prop_types_default.a.any,
  animation: prop_types_default.a.any,
  transitionName: prop_types_default.a.any
};
/* harmony default export */ var es_AnimateChild = (AnimateChild_AnimateChild);
// CONCATENATED MODULE: ../node_modules/rc-animate/es/Animate.js





















var defaultKey = 'rc_animate_' + Date.now();

function getChildrenFromProps(props) {
  var children = props.children;

  if (react_default.a.isValidElement(children)) {
    if (!children.key) {
      return react_default.a.cloneElement(children, {
        key: defaultKey
      });
    }
  }

  return children;
}

function noop() {}

var Animate_Animate = function (_React$Component) {
  inherits_default()(Animate, _React$Component); // eslint-disable-line


  function Animate(props) {
    classCallCheck_default()(this, Animate);

    var _this = possibleConstructorReturn_default()(this, (Animate.__proto__ || Object.getPrototypeOf(Animate)).call(this, props));

    Animate_initialiseProps.call(_this);

    _this.currentlyAnimatingKeys = {};
    _this.keysToEnter = [];
    _this.keysToLeave = [];
    _this.state = {
      children: toArrayChildren(getChildrenFromProps(props))
    };
    _this.childrenRefs = {};
    return _this;
  }

  createClass_default()(Animate, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var showProp = this.props.showProp;
      var children = this.state.children;

      if (showProp) {
        children = children.filter(function (child) {
          return !!child.props[showProp];
        });
      }

      children.forEach(function (child) {
        if (child) {
          _this2.performAppear(child.key);
        }
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;

      this.nextProps = nextProps;
      var nextChildren = toArrayChildren(getChildrenFromProps(nextProps));
      var props = this.props; // exclusive needs immediate response

      if (props.exclusive) {
        Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
          _this3.stop(key);
        });
      }

      var showProp = props.showProp;
      var currentlyAnimatingKeys = this.currentlyAnimatingKeys; // last props children if exclusive

      var currentChildren = props.exclusive ? toArrayChildren(getChildrenFromProps(props)) : this.state.children; // in case destroy in showProp mode

      var newChildren = [];

      if (showProp) {
        currentChildren.forEach(function (currentChild) {
          var nextChild = currentChild && findChildInChildrenByKey(nextChildren, currentChild.key);
          var newChild = void 0;

          if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
            newChild = react_default.a.cloneElement(nextChild || currentChild, defineProperty_default()({}, showProp, true));
          } else {
            newChild = nextChild;
          }

          if (newChild) {
            newChildren.push(newChild);
          }
        });
        nextChildren.forEach(function (nextChild) {
          if (!nextChild || !findChildInChildrenByKey(currentChildren, nextChild.key)) {
            newChildren.push(nextChild);
          }
        });
      } else {
        newChildren = mergeChildren(currentChildren, nextChildren);
      } // need render to avoid update


      this.setState({
        children: newChildren
      });
      nextChildren.forEach(function (child) {
        var key = child && child.key;

        if (child && currentlyAnimatingKeys[key]) {
          return;
        }

        var hasPrev = child && findChildInChildrenByKey(currentChildren, key);

        if (showProp) {
          var showInNext = child.props[showProp];

          if (hasPrev) {
            var showInNow = findShownChildInChildrenByKey(currentChildren, key, showProp);

            if (!showInNow && showInNext) {
              _this3.keysToEnter.push(key);
            }
          } else if (showInNext) {
            _this3.keysToEnter.push(key);
          }
        } else if (!hasPrev) {
          _this3.keysToEnter.push(key);
        }
      });
      currentChildren.forEach(function (child) {
        var key = child && child.key;

        if (child && currentlyAnimatingKeys[key]) {
          return;
        }

        var hasNext = child && findChildInChildrenByKey(nextChildren, key);

        if (showProp) {
          var showInNow = child.props[showProp];

          if (hasNext) {
            var showInNext = findShownChildInChildrenByKey(nextChildren, key, showProp);

            if (!showInNext && showInNow) {
              _this3.keysToLeave.push(key);
            }
          } else if (showInNow) {
            _this3.keysToLeave.push(key);
          }
        } else if (!hasNext) {
          _this3.keysToLeave.push(key);
        }
      });
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var keysToEnter = this.keysToEnter;
      this.keysToEnter = [];
      keysToEnter.forEach(this.performEnter);
      var keysToLeave = this.keysToLeave;
      this.keysToLeave = [];
      keysToLeave.forEach(this.performLeave);
    }
  }, {
    key: 'isValidChildByKey',
    value: function isValidChildByKey(currentChildren, key) {
      var showProp = this.props.showProp;

      if (showProp) {
        return findShownChildInChildrenByKey(currentChildren, key, showProp);
      }

      return findChildInChildrenByKey(currentChildren, key);
    }
  }, {
    key: 'stop',
    value: function stop(key) {
      delete this.currentlyAnimatingKeys[key];
      var component = this.childrenRefs[key];

      if (component) {
        component.stop();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var props = this.props;
      this.nextProps = props;
      var stateChildren = this.state.children;
      var children = null;

      if (stateChildren) {
        children = stateChildren.map(function (child) {
          if (child === null || child === undefined) {
            return child;
          }

          if (!child.key) {
            throw new Error('must set key for <rc-animate> children');
          }

          return react_default.a.createElement(es_AnimateChild, {
            key: child.key,
            ref: function ref(node) {
              _this4.childrenRefs[child.key] = node;
            },
            animation: props.animation,
            transitionName: props.transitionName,
            transitionEnter: props.transitionEnter,
            transitionAppear: props.transitionAppear,
            transitionLeave: props.transitionLeave
          }, child);
        });
      }

      var Component = props.component;

      if (Component) {
        var passedProps = props;

        if (typeof Component === 'string') {
          passedProps = extends_default()({
            className: props.className,
            style: props.style
          }, props.componentProps);
        }

        return react_default.a.createElement(Component, passedProps, children);
      }

      return children[0] || null;
    }
  }]);

  return Animate;
}(react_default.a.Component);

Animate_Animate.isAnimate = true;
Animate_Animate.propTypes = {
  className: prop_types_default.a.string,
  style: prop_types_default.a.object,
  component: prop_types_default.a.any,
  componentProps: prop_types_default.a.object,
  animation: prop_types_default.a.object,
  transitionName: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]),
  transitionEnter: prop_types_default.a.bool,
  transitionAppear: prop_types_default.a.bool,
  exclusive: prop_types_default.a.bool,
  transitionLeave: prop_types_default.a.bool,
  onEnd: prop_types_default.a.func,
  onEnter: prop_types_default.a.func,
  onLeave: prop_types_default.a.func,
  onAppear: prop_types_default.a.func,
  showProp: prop_types_default.a.string,
  children: prop_types_default.a.node
};
Animate_Animate.defaultProps = {
  animation: {},
  component: 'span',
  componentProps: {},
  transitionEnter: true,
  transitionLeave: true,
  transitionAppear: false,
  onEnd: noop,
  onEnter: noop,
  onLeave: noop,
  onAppear: noop
};

var Animate_initialiseProps = function _initialiseProps() {
  var _this5 = this;

  this.performEnter = function (key) {
    // may already remove by exclusive
    if (_this5.childrenRefs[key]) {
      _this5.currentlyAnimatingKeys[key] = true;

      _this5.childrenRefs[key].componentWillEnter(_this5.handleDoneAdding.bind(_this5, key, 'enter'));
    }
  };

  this.performAppear = function (key) {
    if (_this5.childrenRefs[key]) {
      _this5.currentlyAnimatingKeys[key] = true;

      _this5.childrenRefs[key].componentWillAppear(_this5.handleDoneAdding.bind(_this5, key, 'appear'));
    }
  };

  this.handleDoneAdding = function (key, type) {
    var props = _this5.props;
    delete _this5.currentlyAnimatingKeys[key]; // if update on exclusive mode, skip check

    if (props.exclusive && props !== _this5.nextProps) {
      return;
    }

    var currentChildren = toArrayChildren(getChildrenFromProps(props));

    if (!_this5.isValidChildByKey(currentChildren, key)) {
      // exclusive will not need this
      _this5.performLeave(key);
    } else if (type === 'appear') {
      if (animate.allowAppearCallback(props)) {
        props.onAppear(key);
        props.onEnd(key, true);
      }
    } else if (animate.allowEnterCallback(props)) {
      props.onEnter(key);
      props.onEnd(key, true);
    }
  };

  this.performLeave = function (key) {
    // may already remove by exclusive
    if (_this5.childrenRefs[key]) {
      _this5.currentlyAnimatingKeys[key] = true;

      _this5.childrenRefs[key].componentWillLeave(_this5.handleDoneLeaving.bind(_this5, key));
    }
  };

  this.handleDoneLeaving = function (key) {
    var props = _this5.props;
    delete _this5.currentlyAnimatingKeys[key]; // if update on exclusive mode, skip check

    if (props.exclusive && props !== _this5.nextProps) {
      return;
    }

    var currentChildren = toArrayChildren(getChildrenFromProps(props)); // in case state change is too fast

    if (_this5.isValidChildByKey(currentChildren, key)) {
      _this5.performEnter(key);
    } else {
      var end = function end() {
        if (animate.allowLeaveCallback(props)) {
          props.onLeave(key);
          props.onEnd(key, false);
        }
      };

      if (!isSameChildren(_this5.state.children, currentChildren, props.showProp)) {
        _this5.setState({
          children: currentChildren
        }, end);
      } else {
        end();
      }
    }
  };
};

/* harmony default export */ var es_Animate = __webpack_exports__["a"] = (es_unsafeLifecyclesPolyfill(Animate_Animate));

/***/ }),

/***/ "YZeP":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "YhIr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__("9liC");
var $export = __webpack_require__("X6VK");
var toObject = __webpack_require__("UnHL");
var call = __webpack_require__("iJnn");
var isArrayIter = __webpack_require__("2LOZ");
var toLength = __webpack_require__("Sp5b");
var createProperty = __webpack_require__("CIiV");
var getIterFn = __webpack_require__("pB2m");

$export($export.S + $export.F * !__webpack_require__("zlqh")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "YlUf":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("41F1");
var core = __webpack_require__("TaGV");
var LIBRARY = __webpack_require__("gtwY");
var wksExt = __webpack_require__("eTWF");
var defineProperty = __webpack_require__("eOWL").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "Yvte":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "Z8gF":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__("PAFS");
var toObject = __webpack_require__("UnHL");
var toLength = __webpack_require__("Sp5b");
var toInteger = __webpack_require__("mvii");
var advanceStringIndex = __webpack_require__("dVhv");
var regExpExec = __webpack_require__("Fu0I");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__("Wifh")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "ZGup":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _CheckCircleFilled = _interopRequireDefault(__webpack_require__("4NbO"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var CheckCircleFilled = function CheckCircleFilled(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _CheckCircleFilled["default"]
  }));
};

CheckCircleFilled.displayName = 'CheckCircleFilled';

var _default = _react["default"].forwardRef(CheckCircleFilled);

exports["default"] = _default;

/***/ }),

/***/ "ZLCB":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__("V7cS");

__webpack_require__("Z8gF");

/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
;

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  var NProgress = {};
  NProgress.version = '0.2.0';
  var Settings = NProgress.settings = {
    minimum: 0.08,
    easing: 'ease',
    positionUsing: '',
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    showSpinner: true,
    barSelector: '[role="bar"]',
    spinnerSelector: '[role="spinner"]',
    parent: 'body',
    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
  };
  /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */

  NProgress.configure = function (options) {
    var key, value;

    for (key in options) {
      value = options[key];
      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
    }

    return this;
  };
  /**
   * Last number.
   */


  NProgress.status = null;
  /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */

  NProgress.set = function (n) {
    var started = NProgress.isStarted();
    n = clamp(n, Settings.minimum, 1);
    NProgress.status = n === 1 ? null : n;
    var progress = NProgress.render(!started),
        bar = progress.querySelector(Settings.barSelector),
        speed = Settings.speed,
        ease = Settings.easing;
    progress.offsetWidth;
    /* Repaint */

    queue(function (next) {
      // Set positionUsing if it hasn't already been set
      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS(); // Add transition

      css(bar, barPositionCSS(n, speed, ease));

      if (n === 1) {
        // Fade out
        css(progress, {
          transition: 'none',
          opacity: 1
        });
        progress.offsetWidth;
        /* Repaint */

        setTimeout(function () {
          css(progress, {
            transition: 'all ' + speed + 'ms linear',
            opacity: 0
          });
          setTimeout(function () {
            NProgress.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(next, speed);
      }
    });
    return this;
  };

  NProgress.isStarted = function () {
    return typeof NProgress.status === 'number';
  };
  /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */


  NProgress.start = function () {
    if (!NProgress.status) NProgress.set(0);

    var work = function work() {
      setTimeout(function () {
        if (!NProgress.status) return;
        NProgress.trickle();
        work();
      }, Settings.trickleSpeed);
    };

    if (Settings.trickle) work();
    return this;
  };
  /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */


  NProgress.done = function (force) {
    if (!force && !NProgress.status) return this;
    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
  };
  /**
   * Increments by a random amount.
   */


  NProgress.inc = function (amount) {
    var n = NProgress.status;

    if (!n) {
      return NProgress.start();
    } else {
      if (typeof amount !== 'number') {
        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
      }

      n = clamp(n + amount, 0, 0.994);
      return NProgress.set(n);
    }
  };

  NProgress.trickle = function () {
    return NProgress.inc(Math.random() * Settings.trickleRate);
  };
  /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   *
   * @param $promise jQUery Promise
   */


  (function () {
    var initial = 0,
        current = 0;

    NProgress.promise = function ($promise) {
      if (!$promise || $promise.state() === "resolved") {
        return this;
      }

      if (current === 0) {
        NProgress.start();
      }

      initial++;
      current++;
      $promise.always(function () {
        current--;

        if (current === 0) {
          initial = 0;
          NProgress.done();
        } else {
          NProgress.set((initial - current) / initial);
        }
      });
      return this;
    };
  })();
  /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */


  NProgress.render = function (fromStart) {
    if (NProgress.isRendered()) return document.getElementById('nprogress');
    addClass(document.documentElement, 'nprogress-busy');
    var progress = document.createElement('div');
    progress.id = 'nprogress';
    progress.innerHTML = Settings.template;
    var bar = progress.querySelector(Settings.barSelector),
        perc = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
        parent = document.querySelector(Settings.parent),
        spinner;
    css(bar, {
      transition: 'all 0 linear',
      transform: 'translate3d(' + perc + '%,0,0)'
    });

    if (!Settings.showSpinner) {
      spinner = progress.querySelector(Settings.spinnerSelector);
      spinner && removeElement(spinner);
    }

    if (parent != document.body) {
      addClass(parent, 'nprogress-custom-parent');
    }

    parent.appendChild(progress);
    return progress;
  };
  /**
   * Removes the element. Opposite of render().
   */


  NProgress.remove = function () {
    removeClass(document.documentElement, 'nprogress-busy');
    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
    var progress = document.getElementById('nprogress');
    progress && removeElement(progress);
  };
  /**
   * Checks if the progress bar is rendered.
   */


  NProgress.isRendered = function () {
    return !!document.getElementById('nprogress');
  };
  /**
   * Determine which positioning CSS rule to use.
   */


  NProgress.getPositioningCSS = function () {
    // Sniff on document.body.style
    var bodyStyle = document.body.style; // Sniff prefixes

    var vendorPrefix = 'WebkitTransform' in bodyStyle ? 'Webkit' : 'MozTransform' in bodyStyle ? 'Moz' : 'msTransform' in bodyStyle ? 'ms' : 'OTransform' in bodyStyle ? 'O' : '';

    if (vendorPrefix + 'Perspective' in bodyStyle) {
      // Modern browsers with 3D support, e.g. Webkit, IE10
      return 'translate3d';
    } else if (vendorPrefix + 'Transform' in bodyStyle) {
      // Browsers without 3D support, e.g. IE9
      return 'translate';
    } else {
      // Browsers without translate() support, e.g. IE7-8
      return 'margin';
    }
  };
  /**
   * Helpers
   */


  function clamp(n, min, max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
  }
  /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */


  function toBarPerc(n) {
    return (-1 + n) * 100;
  }
  /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */


  function barPositionCSS(n, speed, ease) {
    var barCSS;

    if (Settings.positionUsing === 'translate3d') {
      barCSS = {
        transform: 'translate3d(' + toBarPerc(n) + '%,0,0)'
      };
    } else if (Settings.positionUsing === 'translate') {
      barCSS = {
        transform: 'translate(' + toBarPerc(n) + '%,0)'
      };
    } else {
      barCSS = {
        'margin-left': toBarPerc(n) + '%'
      };
    }

    barCSS.transition = 'all ' + speed + 'ms ' + ease;
    return barCSS;
  }
  /**
   * (Internal) Queues a function to be executed.
   */


  var queue = function () {
    var pending = [];

    function next() {
      var fn = pending.shift();

      if (fn) {
        fn(next);
      }
    }

    return function (fn) {
      pending.push(fn);
      if (pending.length == 1) next();
    };
  }();
  /**
   * (Internal) Applies css properties to an element, similar to the jQuery 
   * css method.
   *
   * While this helper does assist with vendor prefixed property names, it 
   * does not perform any manipulation of values prior to setting styles.
   */


  var css = function () {
    var cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'],
        cssProps = {};

    function camelCase(string) {
      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function (match, letter) {
        return letter.toUpperCase();
      });
    }

    function getVendorProp(name) {
      var style = document.body.style;
      if (name in style) return name;
      var i = cssPrefixes.length,
          capName = name.charAt(0).toUpperCase() + name.slice(1),
          vendorName;

      while (i--) {
        vendorName = cssPrefixes[i] + capName;
        if (vendorName in style) return vendorName;
      }

      return name;
    }

    function getStyleProp(name) {
      name = camelCase(name);
      return cssProps[name] || (cssProps[name] = getVendorProp(name));
    }

    function applyCss(element, prop, value) {
      prop = getStyleProp(prop);
      element.style[prop] = value;
    }

    return function (element, properties) {
      var args = arguments,
          prop,
          value;

      if (args.length == 2) {
        for (prop in properties) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
        }
      } else {
        applyCss(element, args[1], args[2]);
      }
    };
  }();
  /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */


  function hasClass(element, name) {
    var list = typeof element == 'string' ? element : classList(element);
    return list.indexOf(' ' + name + ' ') >= 0;
  }
  /**
   * (Internal) Adds a class to an element.
   */


  function addClass(element, name) {
    var oldList = classList(element),
        newList = oldList + name;
    if (hasClass(oldList, name)) return; // Trim the opening space.

    element.className = newList.substring(1);
  }
  /**
   * (Internal) Removes a class from an element.
   */


  function removeClass(element, name) {
    var oldList = classList(element),
        newList;
    if (!hasClass(element, name)) return; // Replace the class name.

    newList = oldList.replace(' ' + name + ' ', ' '); // Trim the opening and closing spaces.

    element.className = newList.substring(1, newList.length - 1);
  }
  /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */


  function classList(element) {
    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
  }
  /**
   * (Internal) Removes an element from the DOM.
   */


  function removeElement(element) {
    element && element.parentNode && element.parentNode.removeChild(element);
  }

  return NProgress;
});

/***/ }),

/***/ "ZVIm":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("R5TD");
var global = __webpack_require__("P56o");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("wEu9") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "ZWs+":
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__("r/sL");

var _isPlaceholder = __webpack_require__("SaPD");
/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


module.exports = function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;

    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;

      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }

      combined[combinedIdx] = result;

      if (!_isPlaceholder(result)) {
        left -= 1;
      }

      combinedIdx += 1;
    }

    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
};

/***/ }),

/***/ "Zhxd":
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__("+Sw5");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "ZkUl":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return startsWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return pick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return resolve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return insertParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return validateRedirect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return shallowCompare; });
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("+3V6");
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("W1QL");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("K/PF");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("75LO");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("Z8gF");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("3y5y");
/* harmony import */ var core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("9p7t");
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("U8p0");
/* harmony import */ var core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("V7cS");
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("yIlq");
/* harmony import */ var core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("asZ9");
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("+Ltg");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_12__);












 ////////////////////////////////////////////////////////////////////////////////
// startsWith(string, search) - Check if `string` starts with `search`

var startsWith = function startsWith(string, search) {
  return string.substr(0, search.length) === search;
}; ////////////////////////////////////////////////////////////////////////////////
// pick(routes, uri)
//
// Ranks and picks the best route to match. Each segment gets the highest
// amount of points, then the type of segment gets an additional amount of
// points where
//
//     static > dynamic > splat > root
//
// This way we don't have to worry about the order of our routes, let the
// computers do it.
//
// A route looks like this
//
//     { path, default, value }
//
// And a returned match looks like:
//
//     { route, params, uri }
//
// I know, I should use TypeScript not comments for these types.


var pick = function pick(routes, uri) {
  var match = void 0;
  var default_ = void 0;

  var _uri$split = uri.split("?"),
      uriPathname = _uri$split[0];

  var uriSegments = segmentize(uriPathname);
  var isRootUri = uriSegments[0] === "";
  var ranked = rankRoutes(routes);

  for (var i = 0, l = ranked.length; i < l; i++) {
    var missed = false;
    var route = ranked[i].route;

    if (route["default"]) {
      default_ = {
        route: route,
        params: {},
        uri: uri
      };
      continue;
    }

    var routeSegments = segmentize(route.path);
    var params = {};
    var max = Math.max(uriSegments.length, routeSegments.length);
    var index = 0;

    for (; index < max; index++) {
      var routeSegment = routeSegments[index];
      var uriSegment = uriSegments[index];

      if (isSplat(routeSegment)) {
        // Hit a splat, just grab the rest, and return a match
        // uri:   /files/documents/work
        // route: /files/*
        var param = routeSegment.slice(1) || "*";
        params[param] = uriSegments.slice(index).map(decodeURIComponent).join("/");
        break;
      }

      if (uriSegment === undefined) {
        // URI is shorter than the route, no match
        // uri:   /users
        // route: /users/:userId
        missed = true;
        break;
      }

      var dynamicMatch = paramRe.exec(routeSegment);

      if (dynamicMatch && !isRootUri) {
        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;
        !matchIsNotReserved ?  false ? undefined : invariant__WEBPACK_IMPORTED_MODULE_12___default()(false) : void 0;
        var value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        // Current segments don't match, not dynamic, not splat, so no match
        // uri:   /users/123/settings
        // route: /users/:id/profile
        missed = true;
        break;
      }
    }

    if (!missed) {
      match = {
        route: route,
        params: params,
        uri: "/" + uriSegments.slice(0, index).join("/")
      };
      break;
    }
  }

  return match || default_ || null;
}; ////////////////////////////////////////////////////////////////////////////////
// match(path, uri) - Matches just one path to a uri, also lol


var match = function match(path, uri) {
  return pick([{
    path: path
  }], uri);
}; ////////////////////////////////////////////////////////////////////////////////
// resolve(to, basepath)
//
// Resolves URIs as though every path is a directory, no files.  Relative URIs
// in the browser can feel awkward because not only can you be "in a directory"
// you can be "at a file", too. For example
//
//     browserSpecResolve('foo', '/bar/') => /bar/foo
//     browserSpecResolve('foo', '/bar') => /foo
//
// But on the command line of a file system, it's not as complicated, you can't
// `cd` from a file, only directories.  This way, links have to know less about
// their current path. To go deeper you can do this:
//
//     <Link to="deeper"/>
//     // instead of
//     <Link to=`{${props.uri}/deeper}`/>
//
// Just like `cd`, if you want to go deeper from the command line, you do this:
//
//     cd deeper
//     # not
//     cd $(pwd)/deeper
//
// By treating every path as a directory, linking to relative paths should
// require less contextual information and (fingers crossed) be more intuitive.


var resolve = function resolve(to, base) {
  // /foo/bar, /baz/qux => /foo/bar
  if (startsWith(to, "/")) {
    return to;
  }

  var _to$split = to.split("?"),
      toPathname = _to$split[0],
      toQuery = _to$split[1];

  var _base$split = base.split("?"),
      basePathname = _base$split[0];

  var toSegments = segmentize(toPathname);
  var baseSegments = segmentize(basePathname); // ?a=b, /users?b=c => /users?a=b

  if (toSegments[0] === "") {
    return addQuery(basePathname, toQuery);
  } // profile, /users/789 => /users/789/profile


  if (!startsWith(toSegments[0], ".")) {
    var pathname = baseSegments.concat(toSegments).join("/");
    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  } // ./         /users/123  =>  /users/123
  // ../        /users/123  =>  /users
  // ../..      /users/123  =>  /
  // ../../one  /a/b/c/d    =>  /a/b/one
  // .././one   /a/b/c/d    =>  /a/b/c/one


  var allSegments = baseSegments.concat(toSegments);
  var segments = [];

  for (var i = 0, l = allSegments.length; i < l; i++) {
    var segment = allSegments[i];
    if (segment === "..") segments.pop();else if (segment !== ".") segments.push(segment);
  }

  return addQuery("/" + segments.join("/"), toQuery);
}; ////////////////////////////////////////////////////////////////////////////////
// insertParams(path, params)


var insertParams = function insertParams(path, params) {
  var segments = segmentize(path);
  return "/" + segments.map(function (segment) {
    var match = paramRe.exec(segment);
    return match ? params[match[1]] : segment;
  }).join("/");
};

var validateRedirect = function validateRedirect(from, to) {
  var filter = function filter(segment) {
    return isDynamic(segment);
  };

  var fromString = segmentize(from).filter(filter).sort().join("/");
  var toString = segmentize(to).filter(filter).sort().join("/");
  return fromString === toString;
}; ////////////////////////////////////////////////////////////////////////////////
// Junk


var paramRe = /^:(.+)/;
var SEGMENT_POINTS = 4;
var STATIC_POINTS = 3;
var DYNAMIC_POINTS = 2;
var SPLAT_PENALTY = 1;
var ROOT_POINTS = 1;

var isRootSegment = function isRootSegment(segment) {
  return segment === "";
};

var isDynamic = function isDynamic(segment) {
  return paramRe.test(segment);
};

var isSplat = function isSplat(segment) {
  return segment && segment[0] === "*";
};

var rankRoute = function rankRoute(route, index) {
  var score = route["default"] ? 0 : segmentize(route.path).reduce(function (score, segment) {
    score += SEGMENT_POINTS;
    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;
    return score;
  }, 0);
  return {
    route: route,
    score: score,
    index: index
  };
};

var rankRoutes = function rankRoutes(routes) {
  return routes.map(rankRoute).sort(function (a, b) {
    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;
  });
};

var segmentize = function segmentize(uri) {
  return uri // strip starting/ending slashes
  .replace(/(^\/+|\/+$)/g, "").split("/");
};

var addQuery = function addQuery(pathname, query) {
  return pathname + (query ? "?" + query : "");
};

var reservedNames = ["uri", "path"];
/**
 * Shallow compares two objects.
 * @param {Object} obj1 The first object to compare.
 * @param {Object} obj2 The second object to compare.
 */

var shallowCompare = function shallowCompare(obj1, obj2) {
  var obj1Keys = Object.keys(obj1);
  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {
    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];
  });
}; ////////////////////////////////////////////////////////////////////////////////




/***/ }),

/***/ "Zv/C":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "a2XJ":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");

var _curry2 = __webpack_require__("OFPg");

var _isPlaceholder = __webpack_require__("SaPD");
/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


module.exports = function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;

      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        });

      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function (_c) {
          return fn(a, b, _c);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
};

/***/ }),

/***/ "aLAR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _CloseCircleOutlined = _interopRequireDefault(__webpack_require__("cK8K"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _CloseCircleOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "aNYv":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _slicedToArray; });

// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
var unsupportedIterableToArray = __webpack_require__("TJjZ");

// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || Object(unsupportedIterableToArray["a" /* default */])(arr, i) || _nonIterableRest();
}

/***/ }),

/***/ "aOS5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isNil = __webpack_require__("CL0D");

var _isNil2 = _interopRequireDefault(_isNil);

var _result = __webpack_require__("yMzA");

var _result2 = _interopRequireDefault(_result);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Get .pagesPaths from pluginOptions
 * @sig Options -> Result String[]
 * @param {{pagesPaths: String[]}} options plugin options
 * @return {Result<String[]>} pagesPaths Result
 */


var getPagesPaths = function getPagesPaths(options) {
  if ((0, _isNil2["default"])(options)) {
    return _result2["default"].Error('Null plugin options');
  }

  var pagesPaths = options.pagesPaths;

  if ((0, _isNil2["default"])(pagesPaths)) {
    return _result2["default"].Error('Null pluginOptions.pagesPaths');
  } // Should test if pagesPaths is an Array?
  // Should test if pagesPaths is empty?


  return _result2["default"].Ok(pagesPaths);
};

exports["default"] = getPagesPaths;

/***/ }),

/***/ "asZ9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__("NVL/");
var anObject = __webpack_require__("PAFS");
var speciesConstructor = __webpack_require__("5Fu2");
var advanceStringIndex = __webpack_require__("dVhv");
var toLength = __webpack_require__("Sp5b");
var callRegExpExec = __webpack_require__("Fu0I");
var regexpExec = __webpack_require__("lAKj");
var fails = __webpack_require__("E7Vc");
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__("Wifh")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),

/***/ "at5L":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("ezc+");
var toIObject = __webpack_require__("ml72");
var arrayIndexOf = __webpack_require__("sdkr")(false);
var IE_PROTO = __webpack_require__("8kJd")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "b+fX":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("LAIM");

__webpack_require__("+3V6");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("GkPX");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("yIlq");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
}; //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------
// --[ Dependencies ]---------------------------------------------------


var _require = __webpack_require__("vgDc"),
    tagSymbol = _require.tagSymbol,
    typeSymbol = _require.typeSymbol; // --[ Helpers ]--------------------------------------------------------

/*~
 * type: (Object Any) => String
 */


var objectToKeyValuePairs = function objectToKeyValuePairs(object) {
  return Object.keys(object).map(function (key) {
    return key + ': ' + showValue(object[key]);
  }).join(', ');
};
/*~
 * type: (Object Any).() => String
 */


var plainObjectToString = function plainObjectToString() {
  return '{ ' + objectToKeyValuePairs(this) + ' }';
};
/*~
 * type: (Array Any).() => String
 */


var arrayToString = function arrayToString() {
  return '[' + this.map(showValue).join(', ') + ']';
};
/*~
 * type: (Function) => String
 */


var functionNameToString = function functionNameToString(fn) {
  return fn.name !== '' ? ': ' + fn.name : '';
};
/*~
 * type: (Function) => String
 */


var functionToString = function functionToString(fn) {
  return '[Function' + functionNameToString(fn) + ']';
};
/*~
 * type: () => String
 */


var nullToString = function nullToString() {
  return 'null';
};
/*~
 * type: (Any) => Bool
 */


var isPlainObject = function isPlainObject(object) {
  return !object.toString || object.toString === Object.prototype.toString;
};
/*~
 * type: (Null | Object Any) => String
 */


var objectToString = function objectToString(object) {
  return object === null ? nullToString : Array.isArray(object) ? arrayToString : isPlainObject(object) ? plainObjectToString :
  /* otherwise */
  object.toString;
};
/*~
 * type: (Any) => String
 */


var showValue = function showValue(value) {
  return typeof value === 'undefined' ? 'undefined' : typeof value === 'function' ? functionToString(value) : Object.is(value, -0) ? '-0' : typeof value === 'number' ? value : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' ? value.toString() : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? objectToString(value).call(value) :
  /* otherwise */
  JSON.stringify(value);
}; // --[ Implementation ]------------------------------------------------

/*~
 * stability: experimental
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   (Variant, Union) => Void
 */


var debugRepresentation = function debugRepresentation(variant, adt) {
  // eslint-disable-line max-statements
  var typeName = adt[typeSymbol];
  var variantName = adt[typeSymbol] + '.' + variant.prototype[tagSymbol]; // (for Object.prototype.toString)

  adt[Symbol.toStringTag] = typeName;
  variant.prototype[Symbol.toStringTag] = variantName; // (regular JavaScript representations)

  /*~
   * stability: experimental
   * module: null
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   () => String
   */

  adt.toString = function () {
    return typeName;
  };
  /*~
   * stability: experimental
   * mmodule: null
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   () => String
   */


  variant.toString = function () {
    return variantName;
  };
  /*~
   * stability: experimental
   * module: null
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   (Union).() => String
   */


  variant.prototype.toString = function () {
    return variantName + '(' + plainObjectToString.call(this) + ')';
  }; // (Node REPL representations)


  adt.inspect = adt.toString;
  variant.inspect = variant.toString;
  variant.prototype.inspect = variant.prototype.toString;
  return variant;
}; // --[ Exports ]-------------------------------------------------------


module.exports = debugRepresentation;

/***/ }),

/***/ "b01t":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__("GGqZ")) {
  var LIBRARY = __webpack_require__("wEu9");
  var global = __webpack_require__("P56o");
  var fails = __webpack_require__("E7Vc");
  var $export = __webpack_require__("X6VK");
  var $typed = __webpack_require__("tW8y");
  var $buffer = __webpack_require__("Dhml");
  var ctx = __webpack_require__("9liC");
  var anInstance = __webpack_require__("EusA");
  var propertyDesc = __webpack_require__("WWmS");
  var hide = __webpack_require__("tjmq");
  var redefineAll = __webpack_require__("+edc");
  var toInteger = __webpack_require__("mvii");
  var toLength = __webpack_require__("Sp5b");
  var toIndex = __webpack_require__("GdbT");
  var toAbsoluteIndex = __webpack_require__("BUlT");
  var toPrimitive = __webpack_require__("5MU4");
  var has = __webpack_require__("ezc+");
  var classof = __webpack_require__("OFVL");
  var isObject = __webpack_require__("Bsg+");
  var toObject = __webpack_require__("UnHL");
  var isArrayIter = __webpack_require__("2LOZ");
  var create = __webpack_require__("Vx+c");
  var getPrototypeOf = __webpack_require__("A1KM");
  var gOPN = __webpack_require__("zIds").f;
  var getIterFn = __webpack_require__("pB2m");
  var uid = __webpack_require__("1Alt");
  var wks = __webpack_require__("9dxi");
  var createArrayMethod = __webpack_require__("1wfo");
  var createArrayIncludes = __webpack_require__("sdkr");
  var speciesConstructor = __webpack_require__("5Fu2");
  var ArrayIterators = __webpack_require__("K/PF");
  var Iterators = __webpack_require__("Ibj2");
  var $iterDetect = __webpack_require__("zlqh");
  var setSpecies = __webpack_require__("E8p1");
  var arrayFill = __webpack_require__("Pfmf");
  var arrayCopyWithin = __webpack_require__("JKk3");
  var $DP = __webpack_require__("U1KF");
  var $GOPD = __webpack_require__("1Tj+");
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "b0rI":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return useChinaMirrorHost; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return usePrevAndNext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return useLogoLink; });
/* harmony import */ var core_js_modules_es6_string_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ScpY");
/* harmony import */ var core_js_modules_es6_string_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_link__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("lQyR");
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("YhIr");
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_array_find_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("2UZ+");
/* harmony import */ var core_js_modules_es6_array_find_index__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_find_index__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("oMRA");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("6d4m");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);







var useChinaMirrorHost = function useChinaMirrorHost() {
  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_6__["useState"])(false),
      isChinaMirrorHost = _useState[0],
      setIsChinaMirrorHost = _useState[1];

  Object(react__WEBPACK_IMPORTED_MODULE_6__["useEffect"])(function () {
    if (window.location.host.includes('gitee.io') && window.location.host.includes('antv')) {
      setIsChinaMirrorHost(true);
    }
  }, []);
  return [isChinaMirrorHost];
};
var usePrevAndNext = function usePrevAndNext() {
  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_6__["useState"])([]),
      prevAndNext = _useState2[0],
      setPrevAndNext = _useState2[1];

  Object(react__WEBPACK_IMPORTED_MODULE_6__["useEffect"])(function () {
    var menuNodes = document.querySelectorAll('aside .ant-menu-item a');
    var currentMenuNode = document.querySelector('aside .ant-menu-item-selected a');
    var currentIndex = Array.from(menuNodes).findIndex(function (node) {
      return node === currentMenuNode;
    });
    var prevNode = currentIndex - 1 >= 0 ? menuNodes[currentIndex - 1] : undefined;
    var nextNode = currentIndex + 1 < menuNodes.length ? menuNodes[currentIndex + 1] : undefined;
    var prev = prevNode ? {
      slug: prevNode.getAttribute('href') || undefined,
      title: prevNode.textContent || undefined
    } : undefined;
    var next = nextNode ? {
      slug: nextNode.getAttribute('href') || undefined,
      title: nextNode.textContent || undefined
    } : undefined;
    setPrevAndNext([prev, next]);
  }, []);
  return prevAndNext;
};
var useLogoLink = function useLogoLink(_ref) {
  var _ref$link = _ref.link,
      link = _ref$link === void 0 ? '' : _ref$link,
      _ref$siteUrl = _ref.siteUrl,
      siteUrl = _ref$siteUrl === void 0 ? '' : _ref$siteUrl,
      _ref$lang = _ref.lang,
      lang = _ref$lang === void 0 ? '' : _ref$lang;
  var defaultLogoLink;

  if (link) {
    defaultLogoLink = link;
  } else if (siteUrl === 'https://antv.vision') {
    defaultLogoLink = "/" + lang;
  } else {
    defaultLogoLink = "https://antv.vision/" + lang;
  }

  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_6__["useState"])(''),
      giteeLogoLink = _useState3[0],
      setGiteeLogoLink = _useState3[1];

  Object(react__WEBPACK_IMPORTED_MODULE_6__["useEffect"])(function () {
    if (window.location.host.includes('gitee.io') && window.location.host.includes('antv')) {
      setGiteeLogoLink("https://antv.gitee.io/" + lang);
    }
  }, []);
  return [giteeLogoLink || defaultLogoLink];
};

/***/ }),

/***/ "b8Rm":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "bIG9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return useNotification; });
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5hJT");
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("+3V6");
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("lQyR");
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("YhIr");
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("4aJ6");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_date_to_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("M/4x");
/* harmony import */ var core_js_modules_es6_date_to_string__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_date_to_string__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("+jjx");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("ABKx");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("W1QL");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _Notice__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("w37R");











function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}



function useNotification(notificationInstance) {
  var createdRef = react__WEBPACK_IMPORTED_MODULE_10__["useRef"]({});

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_10__["useState"]([]),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      elements = _React$useState2[0],
      setElements = _React$useState2[1];

  function notify(noticeProps) {
    notificationInstance.add(noticeProps, function (div, props) {
      var key = props.key;

      if (div && !createdRef.current[key]) {
        var noticeEle = react__WEBPACK_IMPORTED_MODULE_10__["createElement"](_Notice__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"], Object.assign({}, props, {
          holder: div
        }));
        createdRef.current[key] = noticeEle;
        setElements(function (originElements) {
          return [].concat(_toConsumableArray(originElements), [noticeEle]);
        });
      }
    });
  }

  return [notify, react__WEBPACK_IMPORTED_MODULE_10__["createElement"](react__WEBPACK_IMPORTED_MODULE_10__["Fragment"], null, elements)];
}

/***/ }),

/***/ "bh9w":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _DownOutlined = _interopRequireDefault(__webpack_require__("5ERL"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var DownOutlined = function DownOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _DownOutlined["default"]
  }));
};

DownOutlined.displayName = 'DownOutlined';

var _default = _react["default"].forwardRef(DownOutlined);

exports["default"] = _default;

/***/ }),

/***/ "bmJ9":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

var _curry1 = __webpack_require__("AN6r");

var _has = __webpack_require__("bprV");

var _isArguments = __webpack_require__("d075");
/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */


module.exports = function () {
  // cover IE < 9 keys issues
  var hasEnumBug = !{
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

  var hasArgsEnumBug = function () {
    'use strict';

    return arguments.propertyIsEnumerable('length');
  }();

  var contains = function contains(list, item) {
    var idx = 0;

    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }

      idx += 1;
    }

    return false;
  };

  return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : _curry1(function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }

    var prop, nIdx;
    var ks = [];

    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }

    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;

      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];

        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }

        nIdx -= 1;
      }
    }

    return ks;
  });
}();

/***/ }),

/***/ "bprV":
/***/ (function(module, exports) {

module.exports = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

/***/ }),

/***/ "bztI":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("IH2s");
var $Object = __webpack_require__("TaGV").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "cK8K":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _CloseCircleOutlined = _interopRequireDefault(__webpack_require__("/hZi"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var CloseCircleOutlined = function CloseCircleOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _CloseCircleOutlined["default"]
  }));
};

CloseCircleOutlined.displayName = 'CloseCircleOutlined';

var _default = _react["default"].forwardRef(CloseCircleOutlined);

exports["default"] = _default;

/***/ }),

/***/ "cSJ8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Remove a prefix from a string. Return the input string if the given prefix
 * isn't found.
 *//* harmony default export */ __webpack_exports__["a"] = (function(str,prefix){if(prefix===void 0){prefix="";}if(!prefix){return str;}prefix+="/";if(str.substr(0,prefix.length)===prefix){return str.slice(prefix.length-1);}return str;});

/***/ }),

/***/ "cl25":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("7lGJ");

var copyDocs = __webpack_require__("E6WT");

var defineAdtMethod = function defineAdtMethod(adt, definitions) {
  Object.keys(definitions).forEach(function (name) {
    var methods = definitions[name];
    adt.variants.forEach(function (variant) {
      var method = methods[variant.tag];

      if (!method) {
        throw new TypeError('Method ' + name + ' not defined for ' + variant.tag);
      }

      copyDocs(methods, method);
      variant.prototype[name] = method;
    });
  });
};

module.exports = defineAdtMethod;

/***/ }),

/***/ "cpHF":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var equals = __webpack_require__("LGMZ");

var take = __webpack_require__("XDlq");
/**
 * Checks if a list starts with the provided values
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> Boolean
 * @sig String -> Boolean
 * @param {*} prefix
 * @param {*} list
 * @return {Boolean}
 * @example
 *
 *      R.startsWith('a', 'abc')                //=> true
 *      R.startsWith('b', 'abc')                //=> false
 *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
 *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
 */


module.exports = _curry2(function (prefix, list) {
  return equals(take(prefix.length, list), prefix);
});

/***/ }),

/***/ "ct/D":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "d075":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

var _has = __webpack_require__("bprV");

module.exports = function () {
  var toString = Object.prototype.toString;
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return _has('callee', x);
  };
}();

/***/ }),

/***/ "d3/y":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__("GGqZ"), 'Object', { defineProperty: __webpack_require__("U1KF").f });


/***/ }),

/***/ "dCrc":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("Xj5l");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "dR8c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("G+Zn");
var descriptor = __webpack_require__("zJT+");
var setToStringTag = __webpack_require__("sWB5");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("PPkd")(IteratorPrototype, __webpack_require__("0Sp3")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "dVhv":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var at = __webpack_require__("uRBY")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "dXJ/":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.wrapPageElement=__webpack_require__("OdHn");

/***/ }),

/***/ "deSU":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _ExclamationCircleFilled = _interopRequireDefault(__webpack_require__("IqHs"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var ExclamationCircleFilled = function ExclamationCircleFilled(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _ExclamationCircleFilled["default"]
  }));
};

ExclamationCircleFilled.displayName = 'ExclamationCircleFilled';

var _default = _react["default"].forwardRef(ExclamationCircleFilled);

exports["default"] = _default;

/***/ }),

/***/ "dn9X":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("T/1i");
var gOPN = __webpack_require__("sqS1").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "doOt":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("3y5y");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("yIlq");

exports.__esModule = true;
var ATTRIBUTE_NAMES = exports.ATTRIBUTE_NAMES = {
  BODY: "bodyAttributes",
  HTML: "htmlAttributes",
  TITLE: "titleAttributes"
};
var TAG_NAMES = exports.TAG_NAMES = {
  BASE: "base",
  BODY: "body",
  HEAD: "head",
  HTML: "html",
  LINK: "link",
  META: "meta",
  NOSCRIPT: "noscript",
  SCRIPT: "script",
  STYLE: "style",
  TITLE: "title"
};
var VALID_TAG_NAMES = exports.VALID_TAG_NAMES = Object.keys(TAG_NAMES).map(function (name) {
  return TAG_NAMES[name];
});
var TAG_PROPERTIES = exports.TAG_PROPERTIES = {
  CHARSET: "charset",
  CSS_TEXT: "cssText",
  HREF: "href",
  HTTPEQUIV: "http-equiv",
  INNER_HTML: "innerHTML",
  ITEM_PROP: "itemprop",
  NAME: "name",
  PROPERTY: "property",
  REL: "rel",
  SRC: "src"
};
var REACT_TAG_MAP = exports.REACT_TAG_MAP = {
  accesskey: "accessKey",
  charset: "charSet",
  "class": "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
};
var HELMET_PROPS = exports.HELMET_PROPS = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate"
};
var HTML_TAG_MAP = exports.HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function (obj, key) {
  obj[REACT_TAG_MAP[key]] = key;
  return obj;
}, {});
var SELF_CLOSING_TAGS = exports.SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];
var HELMET_ATTRIBUTE = exports.HELMET_ATTRIBUTE = "data-react-helmet";

/***/ }),

/***/ "dtzt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__("LEAW")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),

/***/ "e+GP":
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "e2Kn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("P56o");
var has = __webpack_require__("ezc+");
var cof = __webpack_require__("n+VH");
var inheritIfRequired = __webpack_require__("jEou");
var toPrimitive = __webpack_require__("5MU4");
var fails = __webpack_require__("E7Vc");
var gOPN = __webpack_require__("zIds").f;
var gOPD = __webpack_require__("1Tj+").f;
var dP = __webpack_require__("U1KF").f;
var $trim = __webpack_require__("hGr/").trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__("Vx+c")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__("GGqZ") ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__("sU/p")(global, NUMBER, $Number);
}


/***/ }),

/***/ "eDOA":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createChainedFunction; });
/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @returns {function|null}
 */
function createChainedFunction() {
  var args = [].slice.call(arguments, 0);

  if (args.length === 1) {
    return args[0];
  }

  return function chainedFunction() {
    for (var i = 0; i < args.length; i++) {
      if (args[i] && args[i].apply) {
        args[i].apply(this, arguments);
      }
    }
  };
}

/***/ }),

/***/ "eOWL":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("ADe/");
var IE8_DOM_DEFINE = __webpack_require__("UTwT");
var toPrimitive = __webpack_require__("HbTz");
var dP = Object.defineProperty;

exports.f = __webpack_require__("lBnu") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "eR4j":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("gSCB"), __esModule: true };

/***/ }),

/***/ "eTWF":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("0Sp3");


/***/ }),

/***/ "emEt":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "PageResourceStatus", function() { return /* binding */ PageResourceStatus; });
__webpack_require__.d(__webpack_exports__, "BaseLoader", function() { return /* binding */ loader_BaseLoader; });
__webpack_require__.d(__webpack_exports__, "ProdLoader", function() { return /* binding */ loader_ProdLoader; });
__webpack_require__.d(__webpack_exports__, "setLoader", function() { return /* binding */ setLoader; });
__webpack_require__.d(__webpack_exports__, "publicLoader", function() { return /* binding */ publicLoader; });

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.reflect.construct.js
var es6_reflect_construct = __webpack_require__("LXYL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__("GkPX");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.from.js
var es6_array_from = __webpack_require__("YhIr");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.set.js
var es6_set = __webpack_require__("m1Dn");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.iterator.js
var es6_string_iterator = __webpack_require__("lQyR");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.map.js
var es6_map = __webpack_require__("zx98");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__("oMRA");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __webpack_require__("6d4m");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__("DbwS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.ends-with.js
var es6_string_ends_with = __webpack_require__("BDzi");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// CONCATENATED MODULE: ./.cache/prefetch.js
var support=function support(feature){if(typeof document==="undefined"){return false;}var fakeLink=document.createElement("link");try{if(fakeLink.relList&&typeof fakeLink.relList.supports==="function"){return fakeLink.relList.supports(feature);}}catch(err){return false;}return false;};var linkPrefetchStrategy=function linkPrefetchStrategy(url,options){return new Promise(function(resolve,reject){if(typeof document==="undefined"){reject();return;}var link=document.createElement("link");link.setAttribute("rel","prefetch");link.setAttribute("href",url);Object.keys(options).forEach(function(key){link.setAttribute(key,options[key]);});link.onload=resolve;link.onerror=reject;var parentElement=document.getElementsByTagName("head")[0]||document.getElementsByName("script")[0].parentNode;parentElement.appendChild(link);});};var xhrPrefetchStrategy=function xhrPrefetchStrategy(url){return new Promise(function(resolve,reject){var req=new XMLHttpRequest();req.open("GET",url,true);req.onload=function(){if(req.status===200){resolve();}else{reject();}};req.send(null);});};var supportedPrefetchStrategy=support("prefetch")?linkPrefetchStrategy:xhrPrefetchStrategy;var preFetched={};var prefetch_prefetch=function prefetch(url,options){return new Promise(function(resolve){if(preFetched[url]){resolve();return;}supportedPrefetchStrategy(url,options).then(function(){resolve();preFetched[url]=true;}).catch(function(){});// 404s are logged to the console anyway
});};/* harmony default export */ var _cache_prefetch = (prefetch_prefetch);
// EXTERNAL MODULE: ./.cache/emitter.js + 1 modules
var emitter = __webpack_require__("5yr3");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__("asZ9");

// EXTERNAL MODULE: ../node_modules/@reach/router/es/lib/utils.js
var utils = __webpack_require__("ZkUl");

// EXTERNAL MODULE: ./.cache/strip-prefix.js
var strip_prefix = __webpack_require__("cSJ8");

// CONCATENATED MODULE: ./.cache/normalize-page-path.js
/* harmony default export */ var normalize_page_path = (function(path){if(path===undefined){return path;}if(path==="/"){return"/";}if(path.charAt(path.length-1)==="/"){return path.slice(0,-1);}return path;});
// CONCATENATED MODULE: ./.cache/find-path.js
function _createForOfIteratorHelperLoose(o){var i=0;if(typeof Symbol==="undefined"||o[Symbol.iterator]==null){if(Array.isArray(o)||(o=_unsupportedIterableToArray(o)))return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}i=o[Symbol.iterator]();return i.next.bind(i);}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(n);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var pathCache=new Map();var find_path_matchPaths=[];var find_path_trimPathname=function trimPathname(rawPathname){var pathname=decodeURIComponent(rawPathname);// Remove the pathPrefix from the pathname.
var trimmedPathname=Object(strip_prefix["a" /* default */])(pathname,"/ucanlanding")// Remove any hashfragment
.split("#")[0]// Remove search query
.split("?")[0];return trimmedPathname;};/**
 * Set list of matchPaths
 *
 * @param {Array<{path: string, matchPath: string}>} value collection of matchPaths
 */var setMatchPaths=function setMatchPaths(value){find_path_matchPaths=value;};/**
 * Return a matchpath url
 * if `match-paths.json` contains `{ "/foo*": "/page1", ...}`, then
 * `/foo?bar=far` => `/page1`
 *
 * @param {string} rawPathname A raw pathname
 * @return {string|null}
 */var find_path_findMatchPath=function findMatchPath(rawPathname){var trimmedPathname=find_path_cleanPath(rawPathname);for(var _iterator=_createForOfIteratorHelperLoose(find_path_matchPaths),_step;!(_step=_iterator()).done;){var _step$value=_step.value,matchPath=_step$value.matchPath,path=_step$value.path;if(Object(utils["b" /* match */])(matchPath,trimmedPathname)){return normalize_page_path(path);}}return null;};// Given a raw URL path, returns the cleaned version of it (trim off
// `#` and query params), or if it matches an entry in
// `match-paths.json`, its matched path is returned
//
// E.g. `/foo?bar=far` => `/foo`
//
// Or if `match-paths.json` contains `{ "/foo*": "/page1", ...}`, then
// `/foo?bar=far` => `/page1`
var findPath=function findPath(rawPathname){var trimmedPathname=find_path_trimPathname(rawPathname);if(pathCache.has(trimmedPathname)){return pathCache.get(trimmedPathname);}var foundPath=find_path_findMatchPath(trimmedPathname);if(!foundPath){foundPath=find_path_cleanPath(rawPathname);}pathCache.set(trimmedPathname,foundPath);return foundPath;};/**
 * Clean a url and converts /index.html => /
 * E.g. `/foo?bar=far` => `/foo`
 *
 * @param {string} rawPathname A raw pathname
 * @return {string}
 */var find_path_cleanPath=function cleanPath(rawPathname){var trimmedPathname=find_path_trimPathname(rawPathname);var foundPath=trimmedPathname;if(foundPath==="/index.html"){foundPath="/";}foundPath=normalize_page_path(foundPath);return foundPath;};
// CONCATENATED MODULE: ./.cache/loader.js
function _createSuper(Derived){return function(){var Super=_getPrototypeOf(Derived),result;if(_isNativeReflectConstruct()){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(typeof call==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||loader_unsupportedIterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function loader_unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return loader_arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(n);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return loader_arrayLikeToArray(o,minLen);}function _iterableToArray(iter){if(typeof Symbol!=="undefined"&&Symbol.iterator in Object(iter))return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return loader_arrayLikeToArray(arr);}function loader_arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Available resource loading statuses
 */var PageResourceStatus={/**
   * At least one of critical resources failed to load
   */Error:"error",/**
   * Resources loaded successfully
   */Success:"success"};var preferDefault=function preferDefault(m){return m&&m.default||m;};var stripSurroundingSlashes=function stripSurroundingSlashes(s){s=s[0]==="/"?s.slice(1):s;s=s.endsWith("/")?s.slice(0,-1):s;return s;};var createPageDataUrl=function createPageDataUrl(path){var fixedPath=path==="/"?"index":stripSurroundingSlashes(path);return "/ucanlanding"+"/page-data/"+fixedPath+"/page-data.json";};var doFetch=function doFetch(url,method){if(method===void 0){method="GET";}return new Promise(function(resolve,reject){var req=new XMLHttpRequest();req.open(method,url,true);req.onreadystatechange=function(){if(req.readyState==4){resolve(req);}};req.send(null);});};var _loadPageDataJson=function loadPageDataJson(loadObj){var pagePath=loadObj.pagePath,_loadObj$retries=loadObj.retries,retries=_loadObj$retries===void 0?0:_loadObj$retries;var url=createPageDataUrl(pagePath);return doFetch(url).then(function(req){var status=req.status,responseText=req.responseText;// Handle 200
if(status===200){try{var jsonPayload=JSON.parse(responseText);if(jsonPayload.path===undefined){throw new Error("not a valid pageData response");}return Object.assign(loadObj,{status:PageResourceStatus.Success,payload:jsonPayload});}catch(err){// continue regardless of error
}}// Handle 404
if(status===404||status===200){// If the request was for a 404 page and it doesn't exist, we're done
if(pagePath==="/404.html"){return Object.assign(loadObj,{status:PageResourceStatus.Error});}// Need some code here to cache the 404 request. In case
// multiple loadPageDataJsons result in 404s
return _loadPageDataJson(Object.assign(loadObj,{pagePath:"/404.html",notFound:true}));}// handle 500 response (Unrecoverable)
if(status===500){return Object.assign(loadObj,{status:PageResourceStatus.Error});}// Handle everything else, including status === 0, and 503s. Should retry
if(retries<3){return _loadPageDataJson(Object.assign(loadObj,{retries:retries+1}));}// Retried 3 times already, result is an error.
return Object.assign(loadObj,{status:PageResourceStatus.Error});});};var doesConnectionSupportPrefetch=function doesConnectionSupportPrefetch(){if("connection"in navigator&&typeof navigator.connection!=="undefined"){if((navigator.connection.effectiveType||"").includes("2g")){return false;}if(navigator.connection.saveData){return false;}}return true;};var toPageResources=function toPageResources(pageData,component){if(component===void 0){component=null;}var page={componentChunkName:pageData.componentChunkName,path:pageData.path,webpackCompilationHash:pageData.webpackCompilationHash,matchPath:pageData.matchPath};return{component:component,json:pageData.result,page:page};};var loader_BaseLoader=/*#__PURE__*/function(){function BaseLoader(loadComponent,matchPaths){// Map of pagePath -> Page. Where Page is an object with: {
//   status: PageResourceStatus.Success || PageResourceStatus.Error,
//   payload: PageResources, // undefined if PageResourceStatus.Error
// }
// PageResources is {
//   component,
//   json: pageData.result,
//   page: {
//     componentChunkName,
//     path,
//     webpackCompilationHash,
//   }
// }
this.pageDb=new Map();this.inFlightDb=new Map();this.pageDataDb=new Map();this.prefetchTriggered=new Set();this.prefetchCompleted=new Set();this.loadComponent=loadComponent;setMatchPaths(matchPaths);}var _proto=BaseLoader.prototype;_proto.setApiRunner=function setApiRunner(apiRunner){this.apiRunner=apiRunner;this.prefetchDisabled=apiRunner("disableCorePrefetching").some(function(a){return a;});};_proto.loadPageDataJson=function loadPageDataJson(rawPath){var _this=this;var pagePath=findPath(rawPath);if(this.pageDataDb.has(pagePath)){return Promise.resolve(this.pageDataDb.get(pagePath));}return _loadPageDataJson({pagePath:pagePath}).then(function(pageData){_this.pageDataDb.set(pagePath,pageData);return pageData;});};_proto.findMatchPath=function findMatchPath(rawPath){return find_path_findMatchPath(rawPath);}// TODO check all uses of this and whether they use undefined for page resources not exist
;_proto.loadPage=function loadPage(rawPath){var _this2=this;var pagePath=findPath(rawPath);if(this.pageDb.has(pagePath)){var page=this.pageDb.get(pagePath);return Promise.resolve(page.payload);}if(this.inFlightDb.has(pagePath)){return this.inFlightDb.get(pagePath);}var inFlight=Promise.all([this.loadAppData(),this.loadPageDataJson(pagePath)]).then(function(allData){var result=allData[1];if(result.status===PageResourceStatus.Error){return{status:PageResourceStatus.Error};}var pageData=result.payload;var _pageData=pageData,componentChunkName=_pageData.componentChunkName;return _this2.loadComponent(componentChunkName).then(function(component){var finalResult={createdAt:new Date()};var pageResources;if(!component){finalResult.status=PageResourceStatus.Error;}else{finalResult.status=PageResourceStatus.Success;if(result.notFound===true){finalResult.notFound=true;}pageData=Object.assign(pageData,{webpackCompilationHash:allData[0]?allData[0].webpackCompilationHash:""});pageResources=toPageResources(pageData,component);finalResult.payload=pageResources;emitter["a" /* default */].emit("onPostLoadPageResources",{page:pageResources,pageResources:pageResources});}_this2.pageDb.set(pagePath,finalResult);// undefined if final result is an error
return pageResources;});})// prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox
.then(function(response){_this2.inFlightDb.delete(pagePath);return response;}).catch(function(err){_this2.inFlightDb.delete(pagePath);throw err;});this.inFlightDb.set(pagePath,inFlight);return inFlight;}// returns undefined if loading page ran into errors
;_proto.loadPageSync=function loadPageSync(rawPath){var pagePath=findPath(rawPath);if(this.pageDb.has(pagePath)){return this.pageDb.get(pagePath).payload;}return undefined;};_proto.shouldPrefetch=function shouldPrefetch(pagePath){// Skip prefetching if we know user is on slow or constrained connection
if(!doesConnectionSupportPrefetch()){return false;}// Check if the page exists.
if(this.pageDb.has(pagePath)){return false;}return true;};_proto.prefetch=function prefetch(pagePath){var _this3=this;if(!this.shouldPrefetch(pagePath)){return false;}// Tell plugins with custom prefetching logic that they should start
// prefetching this path.
if(!this.prefetchTriggered.has(pagePath)){this.apiRunner("onPrefetchPathname",{pathname:pagePath});this.prefetchTriggered.add(pagePath);}// If a plugin has disabled core prefetching, stop now.
if(this.prefetchDisabled){return false;}var realPath=findPath(pagePath);// Todo make doPrefetch logic cacheable
// eslint-disable-next-line consistent-return
this.doPrefetch(realPath).then(function(){if(!_this3.prefetchCompleted.has(pagePath)){_this3.apiRunner("onPostPrefetchPathname",{pathname:pagePath});_this3.prefetchCompleted.add(pagePath);}});return true;};_proto.doPrefetch=function doPrefetch(pagePath){throw new Error("doPrefetch not implemented");};_proto.hovering=function hovering(rawPath){this.loadPage(rawPath);};_proto.getResourceURLsForPathname=function getResourceURLsForPathname(rawPath){var pagePath=findPath(rawPath);var page=this.pageDataDb.get(pagePath);if(page){var pageResources=toPageResources(page.payload);return[].concat(_toConsumableArray(createComponentUrls(pageResources.page.componentChunkName)),[createPageDataUrl(pagePath)]);}else{return null;}};_proto.isPageNotFound=function isPageNotFound(rawPath){var pagePath=findPath(rawPath);var page=this.pageDb.get(pagePath);return page&&page.notFound===true;};_proto.loadAppData=function loadAppData(retries){var _this4=this;if(retries===void 0){retries=0;}return doFetch("/ucanlanding"+"/page-data/app-data.json").then(function(req){var status=req.status,responseText=req.responseText;var appData;if(status!==200&&retries<3){// Retry 3 times incase of non-200 responses
return _this4.loadAppData(retries+1);}// Handle 200
if(status===200){try{var jsonPayload=JSON.parse(responseText);if(jsonPayload.webpackCompilationHash===undefined){throw new Error("not a valid app-data response");}appData=jsonPayload;}catch(err){// continue regardless of error
}}return appData;});};return BaseLoader;}();var createComponentUrls=function createComponentUrls(componentChunkName){return(window.___chunkMapping[componentChunkName]||[]).map(function(chunk){return "/ucanlanding"+chunk;});};var loader_ProdLoader=/*#__PURE__*/function(_BaseLoader){_inheritsLoose(ProdLoader,_BaseLoader);var _super=_createSuper(ProdLoader);function ProdLoader(asyncRequires,matchPaths){var loadComponent=function loadComponent(chunkName){return asyncRequires.components[chunkName]?asyncRequires.components[chunkName]().then(preferDefault)// loader will handle the case when component is null
.catch(function(){return null;}):Promise.resolve();};return _BaseLoader.call(this,loadComponent,matchPaths)||this;}var _proto2=ProdLoader.prototype;_proto2.doPrefetch=function doPrefetch(pagePath){var _this5=this;var pageDataUrl=createPageDataUrl(pagePath);return _cache_prefetch(pageDataUrl,{crossOrigin:"anonymous",as:"fetch"}).then(function(){return(// This was just prefetched, so will return a response from
// the cache instead of making another request to the server
_this5.loadPageDataJson(pagePath));}).then(function(result){if(result.status!==PageResourceStatus.Success){return Promise.resolve();}var pageData=result.payload;var chunkName=pageData.componentChunkName;var componentUrls=createComponentUrls(chunkName);return Promise.all(componentUrls.map(_cache_prefetch)).then(function(){return pageData;});});};_proto2.loadPageDataJson=function loadPageDataJson(rawPath){return _BaseLoader.prototype.loadPageDataJson.call(this,rawPath).then(function(data){if(data.notFound){// check if html file exist using HEAD request:
// if it does we should navigate to it instead of showing 404
return doFetch(rawPath,"HEAD").then(function(req){if(req.status===200){// page (.html file) actually exist (or we asked for 404 )
// returning page resources status as errored to trigger
// regular browser navigation to given page
return{status:PageResourceStatus.Error};}// if HEAD request wasn't 200, return notFound result
// and show 404 page
return data;});}return data;});};return ProdLoader;}(loader_BaseLoader);var instance;var setLoader=function setLoader(_loader){instance=_loader;};var publicLoader={// Deprecated methods. As far as we're aware, these are only used by
// core gatsby and the offline plugin, however there's a very small
// chance they're called by others.
getResourcesForPathname:function getResourcesForPathname(rawPath){console.warn("Warning: getResourcesForPathname is deprecated. Use loadPage instead");return instance.i.loadPage(rawPath);},getResourcesForPathnameSync:function getResourcesForPathnameSync(rawPath){console.warn("Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead");return instance.i.loadPageSync(rawPath);},enqueue:function enqueue(rawPath){return instance.prefetch(rawPath);},// Real methods
getResourceURLsForPathname:function getResourceURLsForPathname(rawPath){return instance.getResourceURLsForPathname(rawPath);},loadPage:function loadPage(rawPath){return instance.loadPage(rawPath);},loadPageSync:function loadPageSync(rawPath){return instance.loadPageSync(rawPath);},prefetch:function prefetch(rawPath){return instance.prefetch(rawPath);},isPageNotFound:function isPageNotFound(rawPath){return instance.isPageNotFound(rawPath);},hovering:function hovering(rawPath){return instance.hovering(rawPath);},loadAppData:function loadAppData(){return instance.loadAppData();}};/* harmony default export */ var loader = __webpack_exports__["default"] = (publicLoader);

/***/ }),

/***/ "ex0g":
/***/ (function(module, exports, __webpack_require__) {

var _isArray = __webpack_require__("GwS+");

var _isTransformer = __webpack_require__("RQUx");
/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */


module.exports = function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }

    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();

    if (!_isArray(obj)) {
      var idx = 0;

      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }

        idx += 1;
      }

      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }

    return fn.apply(this, arguments);
  };
};

/***/ }),

/***/ "ezc+":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "f7TZ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("sfhO"),
    Error = _require.Error,
    Ok = _require.Ok;
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   forall a, b:
 *      (Validation a b) => Result a b
 */


var validationToResult = function validationToResult(aValidation) {
  return aValidation.matchWith({
    Failure: function Failure(_ref) {
      var value = _ref.value;
      return Error(value);
    },
    Success: function Success(_ref2) {
      var value = _ref2.value;
      return Ok(value);
    }
  });
};

module.exports = validationToResult;

/***/ }),

/***/ "fACT":
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  parse: __webpack_require__("fSXM"),
  stringify: __webpack_require__("46Dl")
};

/***/ }),

/***/ "fGh/":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "fIq3":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");
var $parseInt = __webpack_require__("SeNM");
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),

/***/ "fQty":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "fSXM":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("GkPX");

__webpack_require__("Z8gF");

__webpack_require__("V7cS");

__webpack_require__("PAbq");

/*jshint -W030 */
var tagRE = /(?:<!--[\S\s]*?-->|<(?:"[^"]*"['"]*|'[^']*'['"]*|[^'">])+>)/g;

var parseTag = __webpack_require__("9cvu"); // re-used obj for quick lookups of components


var empty = Object.create ? Object.create(null) : {}; // common logic for pushing a child node onto a list

function pushTextNode(list, html, level, start, ignoreWhitespace) {
  // calculate correct end of the content slice in case there's
  // no tag after the text node.
  var end = html.indexOf('<', start);
  var content = html.slice(start, end === -1 ? undefined : end); // if a node is nothing but whitespace, collapse it as the spec states:
  // https://www.w3.org/TR/html4/struct/text.html#h-9.1

  if (/^\s*$/.test(content)) {
    content = ' ';
  } // don't add whitespace-only text nodes if they would be trailing text nodes
  // or if they would be leading whitespace-only text nodes:
  //  * end > -1 indicates this is not a trailing text node
  //  * leading node is when level is -1 and list has length 0


  if (!ignoreWhitespace && end > -1 && level + list.length >= 0 || content !== ' ') {
    list.push({
      type: 'text',
      content: content
    });
  }
}

module.exports = function parse(html, options) {
  options || (options = {});
  options.components || (options.components = empty);
  var result = [];
  var current;
  var level = -1;
  var arr = [];
  var byTag = {};
  var inComponent = false;
  html.replace(tagRE, function (tag, index) {
    if (inComponent) {
      if (tag !== '</' + current.name + '>') {
        return;
      } else {
        inComponent = false;
      }
    }

    var isOpen = tag.charAt(1) !== '/';
    var isComment = tag.indexOf('<!--') === 0;
    var start = index + tag.length;
    var nextChar = html.charAt(start);
    var parent;

    if (isOpen && !isComment) {
      level++;
      current = parseTag(tag);

      if (current.type === 'tag' && options.components[current.name]) {
        current.type = 'component';
        inComponent = true;
      }

      if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {
        pushTextNode(current.children, html, level, start, options.ignoreWhitespace);
      }

      byTag[current.tagName] = current; // if we're at root, push new base node

      if (level === 0) {
        result.push(current);
      }

      parent = arr[level - 1];

      if (parent) {
        parent.children.push(current);
      }

      arr[level] = current;
    }

    if (isComment || !isOpen || current.voidElement) {
      if (!isComment) {
        level--;
      }

      if (!inComponent && nextChar !== '<' && nextChar) {
        // trailing text node
        // if we're at the root, push a base text node. otherwise add as
        // a child to the current node.
        parent = level === -1 ? result : arr[level].children;
        pushTextNode(parent, html, level, start, options.ignoreWhitespace);
      }
    }
  }); // If the "html" passed isn't actually html, add it as a text node.

  if (!result.length && html.length) {
    pushTextNode(result, html, 0, 0, options.ignoreWhitespace);
  }

  return result;
};

/***/ }),

/***/ "fj6J":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ LocaleReceiver_LocaleReceiver; });

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");

// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");

// EXTERNAL MODULE: ../node_modules/antd/es/locale/default.js + 4 modules
var locale_default = __webpack_require__("xp7Y");

// CONCATENATED MODULE: ../node_modules/antd/es/locale-provider/default.js

/* harmony default export */ var locale_provider_default = (locale_default["a" /* default */]);
// CONCATENATED MODULE: ../node_modules/antd/es/locale-provider/LocaleReceiver.js







function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}





var LocaleReceiver_LocaleReceiver = /*#__PURE__*/function (_React$Component) {
  _inherits(LocaleReceiver, _React$Component);

  function LocaleReceiver() {
    _classCallCheck(this, LocaleReceiver);

    return _possibleConstructorReturn(this, _getPrototypeOf(LocaleReceiver).apply(this, arguments));
  }

  _createClass(LocaleReceiver, [{
    key: "getLocale",
    value: function getLocale() {
      var _this$props = this.props,
          componentName = _this$props.componentName,
          defaultLocale = _this$props.defaultLocale;
      var locale = defaultLocale || locale_provider_default[componentName || 'global'];
      var antLocale = this.context.antLocale;
      var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _extends(_extends({}, typeof locale === 'function' ? locale() : locale), localeFromContext || {});
    }
  }, {
    key: "getLocaleCode",
    value: function getLocaleCode() {
      var antLocale = this.context.antLocale;
      var localeCode = antLocale && antLocale.locale; // Had use LocaleProvide but didn't set locale

      if (antLocale && antLocale.exist && !localeCode) {
        return locale_provider_default.locale;
      }

      return localeCode;
    }
  }, {
    key: "render",
    value: function render() {
      return this.props.children(this.getLocale(), this.getLocaleCode(), this.context.antLocale);
    }
  }]);

  return LocaleReceiver;
}(react["Component"]);


LocaleReceiver_LocaleReceiver.defaultProps = {
  componentName: 'global'
};
LocaleReceiver_LocaleReceiver.contextTypes = {
  antLocale: prop_types["object"]
};

/***/ }),

/***/ "foH5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * stability: experimental
 * name: module folktale/adt/union/derivations
 */

module.exports = {
  serialization: __webpack_require__("jWh4"),
  equality: __webpack_require__("68WS"),
  debugRepresentation: __webpack_require__("b+fX")
};

/***/ }),

/***/ "fqg9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _CheckCircleOutlined = _interopRequireDefault(__webpack_require__("NUlt"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _CheckCircleOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "fxUj":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("9dxi");


/***/ }),

/***/ "fy0x":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("sfhO"),
    Error = _require.Error,
    Ok = _require.Ok;
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   forall a, b: (() => b :: throws a) => Result a b
 */


var _try = function _try(f) {
  try {
    return Ok(f());
  } catch (e) {
    return Error(e);
  }
};

module.exports = _try;

/***/ }),

/***/ "g2V6":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _dispatchable = __webpack_require__("ex0g");

var _xdrop = __webpack_require__("CsEj");

var slice = __webpack_require__("w4Md");
/**
 * Returns all but the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `drop` method).
 *
 * Dispatches to the `drop` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*} A copy of list without the first `n` elements
 * @see R.take, R.transduce, R.dropLast, R.dropWhile
 * @example
 *
 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(3, 'ramda');               //=> 'da'
 */


module.exports = _curry2(_dispatchable(['drop'], _xdrop, function drop(n, xs) {
  return slice(Math.max(0, n), Infinity, xs);
}));

/***/ }),

/***/ "g2rQ":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "g4/d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _CloseCircleFilled = _interopRequireDefault(__webpack_require__("qbl3"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _CloseCircleFilled;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "gMWQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("gtwY");
var $export = __webpack_require__("/6KZ");
var redefine = __webpack_require__("5BpW");
var hide = __webpack_require__("PPkd");
var Iterators = __webpack_require__("N9zW");
var $iterCreate = __webpack_require__("dR8c");
var setToStringTag = __webpack_require__("sWB5");
var getPrototypeOf = __webpack_require__("GCLZ");
var ITERATOR = __webpack_require__("0Sp3")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "gRlk":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("X6VK");
var core = __webpack_require__("R5TD");
var fails = __webpack_require__("E7Vc");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "gSCB":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("WwSA");
__webpack_require__("k/kI");
module.exports = __webpack_require__("eTWF").f('iterator');


/***/ }),

/***/ "gVqz":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("DbwS");

__webpack_require__("VNvs");

__webpack_require__("o6jA");

__webpack_require__("9ZkT");

__webpack_require__("1qKx");

__webpack_require__("fIq3");

__webpack_require__("7t+O");

__webpack_require__("Gv0X");

__webpack_require__("NhxO");

__webpack_require__("Ndiv");

__webpack_require__("nd6X");

__webpack_require__("3DBk");

__webpack_require__("it7j");

__webpack_require__("nsbO");

__webpack_require__("9p7t");

__webpack_require__("6d4m");

__webpack_require__("7lGJ");

__webpack_require__("m8zh");

__webpack_require__("5hJT");

__webpack_require__("o7PZ");

__webpack_require__("3y5y");

__webpack_require__("Z8gF");

__webpack_require__("J8hF");

__webpack_require__("hMok");

__webpack_require__("9ovy");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

__webpack_require__("asZ9");

__webpack_require__("U8p0");

__webpack_require__("oMRA");

__webpack_require__("e2Kn");

__webpack_require__("MYxt");

__webpack_require__("yIlq");

__webpack_require__("GkPX");

__webpack_require__("PAbq");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("V7cS");

__webpack_require__("IKQL");

__webpack_require__("+3V6");

__webpack_require__("d3/y");

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(typeof self !== 'undefined' ? self : this, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 403);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The util method based on the lodash.
       * @author dxq613@gmail.com
       * @see https://github.com/lodash/lodash
       */
      var Utils = __webpack_require__(126);

      var G = __webpack_require__(16);

      var Util = Utils.mix({}, Utils, {
        assign: Utils.mix,
        // simple mix
        merge: Utils.deepMix,
        // deep mix
        cloneDeep: Utils.clone,
        isFinite: isFinite,
        isNaN: isNaN,
        snapEqual: Utils.isNumberEqual,
        remove: Utils.pull,
        inArray: Utils.contains,

        /**
         * 将用户输入的 padding 转换成 [top, right, bottom, right] 的模式
         * @param  {Number|Array} padding 输入的padding
         * @return {Array} 四个padding 值
         */
        toAllPadding: function toAllPadding(padding) {
          var top = 0;
          var left = 0;
          var right = 0;
          var bottom = 0;

          if (Util.isNumber(padding) || Util.isString(padding)) {
            top = left = right = bottom = padding;
          } else if (Util.isArray(padding)) {
            top = padding[0];
            right = !Util.isNil(padding[1]) ? padding[1] : padding[0];
            bottom = !Util.isNil(padding[2]) ? padding[2] : padding[0];
            left = !Util.isNil(padding[3]) ? padding[3] : right;
          } else if (Util.isObject(padding)) {
            top = padding.top || 0;
            right = padding.right || 0;
            bottom = padding.bottom || 0;
            left = padding.left || 0;
          }

          return [top, right, bottom, left];
        },
        getClipByRange: function getClipByRange(plotRange) {
          var tl = plotRange.tl,
              br = plotRange.br;
          var clip = new G.Rect({
            attrs: {
              x: tl.x,
              y: tl.y,
              width: br.x - tl.x,
              height: br.y - tl.y
            }
          });
          return clip;
        }
      });
      Util.Array = {
        groupToMap: Utils.groupToMap,
        group: Utils.group,
        merge: Utils.merge,
        values: Utils.valuesOfKey,
        getRange: Utils.getRange,
        firstValue: Utils.firstValue,
        remove: Utils.pull
      };
      module.exports = Util;
      /***/
    },
    /* 1 */

    /***/
    function (module, exports, __webpack_require__) {
      var CommonUtil = __webpack_require__(81);

      var Util = {};
      CommonUtil.merge(Util, CommonUtil, {
        mixin: function mixin(c, mixins) {
          var Param = c.CFG ? 'CFG' : 'ATTRS';

          if (c && mixins) {
            c._mixins = mixins;
            c[Param] = c[Param] || {};
            var temp = {};
            Util.each(mixins, function (mixin) {
              Util.augment(c, mixin);
              var attrs = mixin[Param];

              if (attrs) {
                Util.merge(temp, attrs);
              }
            });
            c[Param] = Util.merge(temp, c[Param]);
          }
        }
      });
      module.exports = Util;
      /***/
    },
    /* 2 */

    /***/
    function (module, exports, __webpack_require__) {
      var isObject = __webpack_require__(25);

      var isArray = __webpack_require__(4);

      var each = function each(elements, func) {
        if (!elements) {
          return;
        }

        var rst = void 0;

        if (isArray(elements)) {
          for (var i = 0, len = elements.length; i < len; i++) {
            rst = func(elements[i], i);

            if (rst === false) {
              break;
            }
          }
        } else if (isObject(elements)) {
          for (var k in elements) {
            if (elements.hasOwnProperty(k)) {
              rst = func(elements[k], k);

              if (rst === false) {
                break;
              }
            }
          }
        }
      };

      module.exports = each;
      /***/
    },
    /* 3 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The util method based on the lodash.
       * @author dxq613@gmail.com
       */
      var G = __webpack_require__(20);

      var Utils = __webpack_require__(126);

      var Util = Utils.mix({
        assign: Utils.mix,
        isFinite: isFinite,
        isNaN: isNaN,
        Group: G.Group,
        Event: G.Event
      }, Utils);
      module.exports = Util;
      /***/
    },
    /* 4 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(12);

      var isArray = Array.isArray ? Array.isArray : function (value) {
        return isType(value, 'Array');
      };
      module.exports = isArray;
      /***/
    },
    /* 5 */

    /***/
    function (module, exports) {
      // isFinite,
      var isNil = function isNil(value) {
        /**
         * isNil(null) => true
         * isNil() => true
         */
        return value === null || value === undefined;
      };

      module.exports = isNil;
      /***/
    },
    /* 6 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var isPointInPath = __webpack_require__(190);

      var Element = __webpack_require__(102);

      var Inside = __webpack_require__(55);

      var Shape = function Shape(cfg) {
        Shape.superclass.constructor.call(this, cfg);
      };

      Shape.ATTRS = {};
      Util.extend(Shape, Element);
      var ARRAY_ATTRS = {
        matrix: 'matrix',
        path: 'path',
        points: 'points',
        lineDash: 'lineDash'
      };

      function _cloneArrayAttr(arr) {
        var result = [];

        for (var i = 0; i < arr.length; i++) {
          if (Util.isArray(arr[i])) {
            result.push([].concat(arr[i]));
          } else {
            result.push(arr[i]);
          }
        }

        return result;
      }

      Util.augment(Shape, isPointInPath, {
        isShape: true,
        drawInner: function drawInner(context) {
          var self = this;
          var attrs = self._attrs;
          self.createPath(context);
          var originOpacity = context.globalAlpha;

          if (self.hasFill()) {
            var fillOpacity = attrs.fillOpacity;

            if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {
              context.globalAlpha = fillOpacity;
              context.fill();
              context.globalAlpha = originOpacity;
            } else {
              context.fill();
            }
          }

          if (self.hasStroke()) {
            var lineWidth = self._attrs.lineWidth;

            if (lineWidth > 0) {
              var strokeOpacity = attrs.strokeOpacity;

              if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {
                context.globalAlpha = strokeOpacity;
              }

              context.stroke();
            }
          }

          self.afterPath(context);
        },
        afterPath: function afterPath() {},

        /**
         * 击中图形时是否进行包围盒判断
         * @return {Boolean} [description]
         */
        isHitBox: function isHitBox() {
          return true;
        },

        /**
         * 节点是否能够被击中
         * @param {Number} x x坐标
         * @param {Number} y y坐标
         * @return {Boolean} 是否在图形中
         */
        isHit: function isHit(x, y) {
          var self = this;
          var v = [x, y, 1];
          self.invert(v); // canvas

          if (self.isHitBox()) {
            var box = self.getBBox();

            if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {
              return false;
            }
          }

          var clip = self._attrs.clip;

          if (clip) {
            clip.invert(v, self.get('canvas'));

            if (clip.isPointInPath(v[0], v[1])) {
              return self.isPointInPath(v[0], v[1]);
            }
          } else {
            return self.isPointInPath(v[0], v[1]);
          }

          return false;
        },

        /**
         * @protected
         * 计算包围盒
         * @return {Object} 包围盒
         */
        calculateBox: function calculateBox() {
          return null;
        },
        // 获取拾取时线的宽度，需要考虑附加的线的宽度
        getHitLineWidth: function getHitLineWidth() {
          var attrs = this._attrs; // if (!attrs.stroke) {
          //   return 0;
          // }

          var lineAppendWidth = attrs.lineAppendWidth || 0;
          var lineWidth = attrs.lineWidth || 0;
          return lineWidth + lineAppendWidth;
        },
        // 清除当前的矩阵
        clearTotalMatrix: function clearTotalMatrix() {
          this._cfg.totalMatrix = null;
          this._cfg.region = null;
        },
        clearBBox: function clearBBox() {
          this._cfg.box = null;
          this._cfg.region = null;
        },
        getBBox: function getBBox() {
          var box = this._cfg.box; // 延迟计算

          if (!box) {
            box = this.calculateBox();

            if (box) {
              box.x = box.minX;
              box.y = box.minY;
              box.width = box.maxX - box.minX;
              box.height = box.maxY - box.minY;
            }

            this._cfg.box = box;
          }

          return box;
        },
        clone: function clone() {
          var self = this;
          var clone = null;
          var _attrs = self._attrs;
          var attrs = {};
          Util.each(_attrs, function (i, k) {
            if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {
              attrs[k] = _cloneArrayAttr(_attrs[k]);
            } else {
              attrs[k] = _attrs[k];
            }
          });
          clone = new self.constructor({
            attrs: attrs
          }); // zIndex也是绘图属性，但是在cfg中，特殊处理

          clone._cfg.zIndex = self._cfg.zIndex;
          return clone;
        }
      });
      module.exports = Shape;
      /***/
    },
    /* 7 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 全局变量
       * @author dxq613
       */
      var Util = __webpack_require__(0);

      var Theme = __webpack_require__(150);

      var Global = {
        version: '3.5.12',
        renderer: 'canvas',
        // trackable: false,
        trackingInfo: {},
        animate: true,
        widthRatio: {
          // 宽度所占的分类的比例
          column: 1 / 2,
          // 一般的柱状图占比 1/2
          rose: 0.9999999,
          // 玫瑰图柱状占比 1
          multiplePie: 1 / 1.3 // 多层的饼图、环图

        },
        // 折线图、区域图、path 当只有一个数据时，是否显示成点
        showSinglePoint: false,
        connectNulls: false,
        scales: {},
        registerTheme: function registerTheme(name, theme) {
          Theme[name] = theme;
        },
        setTheme: function setTheme(theme) {
          var newTheme = {};

          if (Util.isObject(theme)) {
            newTheme = theme;
          } else if (Util.indexOf(Object.keys(Theme), theme) !== -1) {
            newTheme = Theme[theme];
          } else {
            newTheme = Theme["default"];
          }

          Util.deepMix(Global, newTheme);
        }
      };
      Global.setTheme('default');
      module.exports = Global;
      /***/
    },
    /* 8 */

    /***/
    function (module, exports) {
      function _mix(dist, obj) {
        for (var key in obj) {
          if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
            dist[key] = obj[key];
          }
        }
      }

      var mix = function mix(dist, src1, src2, src3) {
        if (src1) _mix(dist, src1);
        if (src2) _mix(dist, src2);
        if (src3) _mix(dist, src3);
        return dist;
      };

      module.exports = mix;
      /***/
    },
    /* 9 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 判断是否数字
       * @return {Boolean} 是否数字
       */
      var isType = __webpack_require__(12);

      var isNumber = function isNumber(value) {
        return isType(value, 'Number');
      };

      module.exports = isNumber;
      /***/
    },
    /* 10 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(12);

      var isString = function isString(str) {
        return isType(str, 'String');
      };

      module.exports = isString;
      /***/
    },
    /* 11 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 是否为函数
       * @param  {*} fn 对象
       * @return {Boolean}  是否函数
       */
      var isType = __webpack_require__(12);

      var isFunction = function isFunction(value) {
        return isType(value, 'Function');
      };

      module.exports = isFunction;
      /***/
    },
    /* 12 */

    /***/
    function (module, exports) {
      var toString = {}.toString;

      var isType = function isType(value, type) {
        return toString.call(value) === '[object ' + type + ']';
      };

      module.exports = isType;
      /***/
    },
    /* 13 */

    /***/
    function (module, exports) {
      var isArrayLike = function isArrayLike(value) {
        /**
         * isArrayLike([1, 2, 3]) => true
         * isArrayLike(document.body.children) => true
         * isArrayLike('abc') => true
         * isArrayLike(Function) => false
         */
        return value !== null && typeof value !== 'function' && isFinite(value.length);
      };

      module.exports = isArrayLike;
      /***/
    },
    /* 14 */

    /***/
    function (module, exports) {
      module.exports = {
        FONT_FAMILY: '"-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",SimSun, "sans-serif"'
      };
      /***/
    },
    /* 15 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Helper = __webpack_require__(155);

      var Component = __webpack_require__(32);

      var KEYWORDS = ['min', 'max', 'median', 'start', 'end'];

      var Guide = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Guide, _Component);

        function Guide() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = Guide.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Component.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            xScales: null,
            yScales: null,
            el: null
          });
        };

        _proto.render = function render() {}
        /**
         * clear container
         * @override
         */
        ;

        _proto.clear = function clear() {
          var self = this;
          var el = self.get('el');
          el && el.remove();
          this.set('el', null);
        };

        _proto.destroy = function destroy() {
          this.clear();

          _Component.prototype.destroy.call(this);
        }
        /**
         * show or hide
         * @protected
         * @param {Boolean} visible true means show, false means hide
         */
        ;

        _proto.changeVisible = function changeVisible(visible) {
          var self = this;
          self.set('visible', visible);
          var el = self.get('el');
          if (!el) return;

          if (el.set) {
            el.set('visible', visible);
          } else {
            el.style.display = visible ? '' : 'none';
          }
        }
        /**
         * calculate the canvas coordinate value
         * @protected
         * @param  {Coordinate} coord  the instance of Coordinate class
         * @param  {Object | Array | Function} position the value need to convert
         * @return {Object} return the result
         */
        ;

        _proto.parsePoint = function parsePoint(coord, position) {
          var self = this;
          var xScales = self.get('xScales');
          var yScales = self.get('yScales');

          if (Util.isFunction(position)) {
            position = position(xScales, yScales);
          }

          var x;
          var y; // 如果数据格式是 ['50%', '50%'] 的格式

          if (Util.isArray(position) && Util.isString(position[0]) && position[0].indexOf('%') !== -1) {
            return this._parsePercentPoint(coord, position);
          }

          if (Util.isArray(position)) {
            // Array，suuport for mixing of keyword, percent and value
            x = self._getNormalizedValue(position[0], Helper.getFirstScale(xScales));
            y = self._getNormalizedValue(position[1], Helper.getFirstScale(yScales));
          } else {
            for (var field in position) {
              var value = position[field];

              if (xScales[field]) {
                x = self._getNormalizedValue(value, xScales[field]);
              }

              if (yScales[field]) {
                y = self._getNormalizedValue(value, yScales[field], 'y');
              }
            }
          }

          if (!Util.isNil(x) && !Util.isNil(y) && !isNaN(x) && !isNaN(y)) {
            return coord.convert({
              x: x,
              y: y
            });
          }

          return null;
        }
        /**
         * Normalized the value
         * @param  {String | Number} val   param
         * @param  {Scale} scale the instance of Scale
         * @return {Number}       return the normalized value
         */
        ;

        _proto._getNormalizedValue = function _getNormalizedValue(val, scale) {
          var result;

          if (Util.indexOf(KEYWORDS, val) !== -1) {
            // keyword
            var scaleValue;

            if (val === 'start') {
              // the start of coordinate
              result = 0;
            } else if (val === 'end') {
              result = 1;
            } else if (val === 'median') {
              scaleValue = scale.isCategory ? (scale.values.length - 1) / 2 : (scale.min + scale.max) / 2;
              result = scale.scale(scaleValue);
            } else {
              if (scale.isCategory) {
                scaleValue = val === 'min' ? 0 : scale.values.length - 1;
              } else {
                scaleValue = scale[val];
              }

              result = scale.scale(scaleValue);
            }
          } else {
            // 数值
            result = scale.scale(val);
          }

          return result;
        };

        _proto._parsePercentPoint = function _parsePercentPoint(coord, position) {
          var xPercent = parseFloat(position[0]) / 100;
          var yPercent = parseFloat(position[1]) / 100;
          var start = coord.start,
              end = coord.end;
          var topLeft = {
            x: Math.min(start.x, end.x),
            y: Math.min(start.y, end.y)
          };
          var x = coord.width * xPercent + topLeft.x;
          var y = coord.height * yPercent + topLeft.y;
          return {
            x: x,
            y: y
          };
        };

        return Guide;
      }(Component);

      module.exports = Guide;
      /***/
    },
    /* 16 */

    /***/
    function (module, exports, __webpack_require__) {
      var G = __webpack_require__(20);

      module.exports = G;
      /***/
    },
    /* 17 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__color_js__ = __webpack_require__(61);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return __WEBPACK_IMPORTED_MODULE_0__color_js__["e"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "f", function () {
        return __WEBPACK_IMPORTED_MODULE_0__color_js__["g"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return __WEBPACK_IMPORTED_MODULE_0__color_js__["f"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__lab_js__ = __webpack_require__(205);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "e", function () {
        return __WEBPACK_IMPORTED_MODULE_1__lab_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "c", function () {
        return __WEBPACK_IMPORTED_MODULE_1__lab_js__["b"];
      });
      /* unused harmony reexport lch */

      /* unused harmony reexport gray */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__cubehelix_js__ = __webpack_require__(206);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return __WEBPACK_IMPORTED_MODULE_2__cubehelix_js__["a"];
      });
      /***/

    },
    /* 18 */

    /***/
    function (module, exports, __webpack_require__) {
      var mix = __webpack_require__(8);

      var each = __webpack_require__(2);

      var isObject = __webpack_require__(25);

      var isNil = __webpack_require__(5);

      var Scale = /*#__PURE__*/function () {
        var _proto = Scale.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          this.type = 'base';
          /**
           * 格式化函数,输出文本或者tick时的格式化函数
           * @type {Function}
           */

          this.formatter = null;
          /**
           * 输出的值域
           * @type {Array}
           */

          this.range = [0, 1];
          /**
           * 度量的标记
           * @type {Array}
           */

          this.ticks = null;
          /**
           * 参与度量计算的值，可选项
           * @type {Array}
           */

          this.values = [];
        };

        function Scale(cfg) {
          this._initDefaultCfg();

          mix(this, cfg);
          this.init();
        }
        /**
         * 度量初始化
         * @protected
         */


        _proto.init = function init() {}
        /**
         * 获取该度量的ticks,返回的是多个对象，
         *   - text: tick 的文本
         *   - value: 对应的度量转换后的值
         * <code>
         *   [
         *     {text: 0,value:0}
         *     {text: 1,value:0.2}
         *     {text: 2,value:0.4}
         *     {text: 3,value:0.6}
         *     {text: 4,value:0.8}
         *     {text: 5,value:1}
         *   ]
         * </code>
         * @param {Number} count 输出tick的个数的近似值，默认是 10
         * @return {Array} 返回 ticks 数组
         */
        ;

        _proto.getTicks = function getTicks() {
          var self = this;
          var ticks = self.ticks;
          var rst = [];
          each(ticks, function (tick) {
            var obj;

            if (isObject(tick)) {
              obj = tick;
            } else {
              obj = {
                text: self.getText(tick),
                tickValue: tick,
                value: self.scale(tick)
              };
            }

            rst.push(obj);
          });
          return rst;
        }
        /**
         * 获取格式化后的文本
         * @param  {*} value 输入的数据
         * @param  {*} key 字段的 key
         * @return {String} 格式化的文本
         */
        ;

        _proto.getText = function getText(value, key) {
          var formatter = this.formatter;
          value = formatter ? formatter(value, key) : value;

          if (isNil(value) || !value.toString) {
            value = '';
          }

          return value.toString();
        }
        /**
         * 输出的值域最小值
         * @protected
         * @return {Number} 返回最小的值
         */
        ;

        _proto.rangeMin = function rangeMin() {
          return this.range[0];
        }
        /**
         * 输出的值域最大值
         * @protected
         * @return {Number} 返回最大的值
         */
        ;

        _proto.rangeMax = function rangeMax() {
          var range = this.range;
          return range[range.length - 1];
        }
        /**
         * 度量转换后的结果，翻转回输入域
         * @param  {Number} value 需要翻转的数值
         * @return {*} 度量的输入值
         */
        ;

        _proto.invert = function invert(value) {
          return value;
        }
        /**
         * 将传入的值从非数值转换成数值格式，如分类字符串、时间字符串等
         * @param  {*} value 传入的值
         * @return {Number} 转换的值
         */
        ;

        _proto.translate = function translate(value) {
          return value;
        }
        /**
         * 进行度量转换
         * @param  {*} value 输入值
         * @return {Number} 输出值，在设定的输出值域之间，默认[0,1]
         */
        ;

        _proto.scale = function scale(value) {
          return value;
        }
        /**
         * 克隆一个新的scale,拥有跟当前scale相同的输入域、输出域等
         * @return {Scale} 克隆的度量
         */
        ;

        _proto.clone = function clone() {
          var self = this;
          var constr = self.constructor;
          var cfg = {};
          each(self, function (v, k) {
            cfg[k] = self[k];
          });
          return new constr(cfg);
        }
        /**
         * 更改度量的属性信息
         * @param  {Object} info 属性信息
         * @chainable
         * @return {Scale} 返回自身的引用
         */
        ;

        _proto.change = function change(info) {
          this.ticks = null;
          mix(this, info);
          this.init();
          return this;
        };

        return Scale;
      }();

      module.exports = Scale;
      /***/
    },
    /* 19 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 工厂类，管理各种类型的 shape
       * @author dxq613@gmail.com
       */
      var Util = __webpack_require__(0);

      var PathUtil = __webpack_require__(23);

      var GPath = Util.PathUtil;
      var Shape = {};
      var ShapeBase = {
        _coord: null,

        /**
         * 绘制图形
         * @param {Object} cfg 配置项
         * @param {Object} container 容器
         * @return {Object} shape 创建的 shape
         */
        draw: function draw(cfg, container) {
          if (this.drawShape) {
            return this.drawShape(cfg, container);
          }

          return null;
        },

        /**
         * 获取绘制图形需要的点, 可以不定义，则使用默认的
        getPoints(cfg) {
          if (this.getShapePoints) {
            return this.getShapePoints(cfg);
          }
          return null;
        },*/

        /**
         * 设置坐标系
         * @param {Coord} coord 坐标系
         */
        setCoord: function setCoord(coord) {
          this._coord = coord;
        },

        /**
         * 0～1 path 转 画布 path
         * @param  {path} path 路径
         * @param  {Boolean} islineToArc 是否转换成圆弧
         * @return {path} path 转换到画布坐标的path
         */
        parsePath: function parsePath(path, islineToArc) {
          var coord = this._coord;
          path = GPath.parsePathString(path);

          if (coord.isPolar && islineToArc !== false) {
            path = PathUtil.convertPolarPath(coord, path);
          } else {
            path = PathUtil.convertNormalPath(coord, path);
          }

          return path;
        },

        /**
         * 0～1 point 转 画布 point
         * @param  {point} point 节点
         * @return {point} point 转换后的点
         */
        parsePoint: function parsePoint(point) {
          var coord = this._coord;
          return coord.convertPoint(point);
        },

        /**
         * 0～1 points 转 画布 points
         * @param  {points} points 节点集合
         * @return {points} points 转换后的多个节点
         */
        parsePoints: function parsePoints(points) {
          var coord = this._coord;
          var rst = [];
          Util.each(points, function (point) {
            rst.push(coord.convertPoint(point));
          });
          return rst;
        }
      };
      var ShapeFactoryBase = {
        defaultShapeType: null,
        setCoord: function setCoord(coord) {
          this._coord = coord;
        },
        getShape: function getShape(type) {
          var self = this;

          if (Util.isArray(type)) {
            type = type[0];
          }

          var shape = self[type] || self[self.defaultShapeType];
          shape._coord = self._coord;
          return shape;
        },
        getShapePoints: function getShapePoints(type, cfg) {
          var shape = this.getShape(type);
          var fn = shape.getPoints || shape.getShapePoints || this.getDefaultPoints;
          var points = fn(cfg);
          return points;
        },
        getDefaultPoints: function getDefaultPoints()
        /* cfg */
        {
          return [];
        },
        getMarkerCfg: function getMarkerCfg(type, cfg) {
          var shape = this.getShape(type);

          if (!shape.getMarkerCfg) {
            var defaultShapeType = this.defaultShapeType;
            shape = this.getShape(defaultShapeType);
          }

          return shape.getMarkerCfg(cfg);
        },
        getSelectedCfg: function getSelectedCfg()
        /* type, cfg */
        {
          return {};
        },
        drawShape: function drawShape(type, cfg, container) {
          var shape = this.getShape(type);
          var gShape = shape.draw(cfg, container);

          if (gShape) {
            gShape.setSilent('origin', cfg.origin);
            gShape._id = cfg.yIndex ? cfg._id + cfg.yIndex : cfg._id;
            gShape.name = this.name;
          }

          return gShape;
        }
      }; // 注册 Geometry 获取图形的入口

      Shape.registerFactory = function (factoryName, cfg) {
        var className = Util.upperFirst(factoryName);
        var geomObj = Util.assign({}, ShapeFactoryBase, cfg);
        Shape[className] = geomObj;
        geomObj.name = factoryName;
        return geomObj;
      }; // 注册图形


      Shape.registerShape = function (factoryName, shapeType, cfg) {
        var className = Util.upperFirst(factoryName);
        var factory = Shape[className];
        var shapeObj = Util.assign({}, ShapeBase, cfg);
        factory[shapeType] = shapeObj;
        return shapeObj;
      }; // 获得Geom 对应的 shapeFactory


      Shape.getShapeFactory = function (factoryName) {
        var self = this;
        factoryName = factoryName || 'point';
        var className = Util.upperFirst(factoryName);
        return self[className];
      };

      module.exports = Shape;
      /***/
    },
    /* 20 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        Canvas: __webpack_require__(182),
        Group: __webpack_require__(101),
        Shape: __webpack_require__(6),
        Arc: __webpack_require__(105),
        Circle: __webpack_require__(106),
        Dom: __webpack_require__(107),
        Ellipse: __webpack_require__(108),
        Fan: __webpack_require__(109),
        Image: __webpack_require__(110),
        Line: __webpack_require__(111),
        Marker: __webpack_require__(57),
        Path: __webpack_require__(112),
        Polygon: __webpack_require__(113),
        Polyline: __webpack_require__(114),
        Rect: __webpack_require__(115),
        Text: __webpack_require__(116),
        PathSegment: __webpack_require__(39),
        PathUtil: __webpack_require__(58),
        Event: __webpack_require__(100),
        // version, etc.
        version: '3.3.6'
      };
      /***/
    },
    /* 21 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 所有 Geometry 的基类
       * @author dxq613@gmail.com
       */


      var Attr = __webpack_require__(73);

      var Adjust = __webpack_require__(299);

      var Base = __webpack_require__(147);

      var Util = __webpack_require__(0);

      var Global = __webpack_require__(7);

      var Labels = __webpack_require__(307);

      var Shape = __webpack_require__(19);

      var TooltipMixin = __webpack_require__(339);

      var ActiveMixin = __webpack_require__(340);

      var SelectMixin = __webpack_require__(341);

      var parseFields = __webpack_require__(342);

      var GROUP_ATTRS = ['color', 'shape', 'size'];
      var FIELD_ORIGIN = '_origin'; // 转换成对象的数组 [{type: 'adjust'}]

      function parseAdjusts(adjusts) {
        // 如果是字符串或者对象转换成数组
        if (Util.isString(adjusts) || Util.isPlainObject(adjusts)) {
          adjusts = [adjusts];
        }

        Util.each(adjusts, function (adjust, index) {
          if (!Util.isObject(adjust)) {
            adjusts[index] = {
              type: adjust
            };
          }
        });
        return adjusts;
      }
      /**
       * 几何标记
       * @class Geom
       */


      var GeomBase = /*#__PURE__*/function (_Base) {
        _inheritsLoose(GeomBase, _Base);

        var _proto = GeomBase.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {
            /**
             * 标记 _id 用于区分执行动画
             * @type {String}
             */
            _id: null,

            /**
             * 类型
             * @type {String}
             */
            type: 'base',

            /**
             * 坐标系
             * @type {Object}
             */
            coord: null,

            /**
             * 属性映射集
             * @protected
             * @type {Object}
             */
            attrs: {},

            /**
             * 所属的View
             * @type {View}
             */
            view: null,

            /**
             * 几何标记显示的数据
             * @type {Array}
             */
            data: [],

            /**
             * 相关的度量
             * @type {Object}
             */
            scales: {},

            /**
             * 绘图容器
             * @type {Object}
             */
            container: null,

            /**
             * 文本容器
             * @type {Object}
             */
            labelContainer: null,

            /**
             * 图形容器
             * @type {Object}
             */
            shapeContainer: null,

            /**
             * 几何标记的一些配置项，用于延迟生成图表
             * @type {Object}
             */
            attrOptions: {},
            // 样式配置项
            styleOptions: null,
            // 选中时的配置项
            selectedOptions: null,
            // active 时的配置项
            activedOptions: null,

            /**
             * 某些类存在默认的adjust，不能更改 adjust
             * @type {Boolean}
             */
            hasDefaultAdjust: false,
            // 数据调整类型
            adjusts: null,

            /**
             * 使用形状的类型
             * @protected
             * @type {String}
             */
            shapeType: null,

            /**
             * 是否生成多个点来绘制图形
             * @protected
             * @type {Boolean}
             */
            generatePoints: false,

            /**
             * 数据是否进行排序
             * @type {Boolean}
             */
            sortable: false,
            labelCfg: null,

            /**
             * 是否共享 tooltip
             * @type {Boolean}
             */
            shareTooltip: true,
            tooltipCfg: null,

            /**
             * 是否执行动画，默认执行
             * @type {Boolean}
             */
            animate: true,

            /**
             * 动画配置
             * @type {[type]}
             */
            animateCfg: null,
            visible: true
          };
        };

        function GeomBase(cfg) {
          var _this;

          _this = _Base.call(this, cfg) || this;
          _this.viewTheme = _this.get('viewTheme');
          Util.assign(_assertThisInitialized(_this), TooltipMixin, ActiveMixin, SelectMixin);

          if (_this.get('container')) {
            _this._initContainer();
          }

          _this._initOptions();

          return _this;
        } // 初始化时对配置项的格式化


        _proto._initOptions = function _initOptions() {
          var adjusts = this.get('adjusts');

          if (adjusts) {
            adjusts = parseAdjusts(adjusts);
            this.set('adjusts', adjusts);
          }
        };

        _proto._createScale = function _createScale(field, data) {
          var scales = this.get('scales');
          var scale = scales[field];

          if (!scale) {
            scale = this.get('view').createScale(field, data);
            scales[field] = scale;
          }

          return scale;
        };

        _proto._setAttrOptions = function _setAttrOptions(attrName, attrCfg) {
          var options = this.get('attrOptions');
          options[attrName] = attrCfg;
        };

        _proto._createAttrOption = function _createAttrOption(attrName, field, cfg, defaultValues) {
          var attrCfg = {};
          attrCfg.field = field;

          if (cfg) {
            if (Util.isFunction(cfg)) {
              attrCfg.callback = cfg;
            } else {
              attrCfg.values = cfg;
            }
          } else if (attrName !== 'color') {
            attrCfg.values = defaultValues;
          }

          this._setAttrOptions(attrName, attrCfg);
        }
        /**
         * 位置属性映射
         * @chainable
         * @param  {String} field 字段名
         * @return {Geom} geom 当前几何标记
         */
        ;

        _proto.position = function position(field) {
          this._setAttrOptions('position', {
            field: field
          });

          return this;
        }
        /**
         * 颜色属性映射
         * @chainable
         * @param  {String} field 字段名
         * @param  {Array|Function} values 颜色的数组或者回调函数
         * @return {Geom} geom 当前几何标记
         */
        ;

        _proto.color = function color(field, values) {
          var viewTheme = this.viewTheme || Global;

          this._createAttrOption('color', field, values, viewTheme.colors);

          return this;
        }
        /**
         * 大小属性映射
         * @chainable
         * @param  {String} field 字段名
         * @param  {Array|Function} values 大小的数组或者回调函数
         * @return {Geom} geom 当前几何标记
         */
        ;

        _proto.size = function size(field, values) {
          var viewTheme = this.viewTheme || Global;

          this._createAttrOption('size', field, values, viewTheme.sizes);

          return this;
        }
        /**
         * 形状属性映射
         * @chainable
         * @param  {String} field 字段名
         * @param  {Array|Function} values 大小的数组或者回调函数
         * @return {Geom} geom 当前几何标记
         */
        ;

        _proto.shape = function shape(field, values) {
          var viewTheme = this.viewTheme || Global;
          var type = this.get('type');
          var shapes = viewTheme.shapes[type] || [];

          this._createAttrOption('shape', field, values, shapes);

          return this;
        }
        /**
         * 透明度属性映射
         * @chainable
         * @param  {String} field 字段名
         * @param  {Array|Function} values 透明度的数组或者回调函数
         * @return {Geom} geom 当前几何标记
         */
        ;

        _proto.opacity = function opacity(field, values) {
          var viewTheme = this.viewTheme || Global;

          this._createAttrOption('opacity', field, values, viewTheme.opacities);

          return this;
        };

        _proto.style = function style(field, cfg) {
          var styleOptions = this.get('styleOptions');

          if (!styleOptions) {
            styleOptions = {};
            this.set('styleOptions', styleOptions);
          }

          if (Util.isObject(field)) {
            cfg = field;
            field = null;
          }

          var fields;

          if (field) {
            fields = parseFields(field);
          }

          styleOptions.fields = fields;
          styleOptions.style = cfg;
          return this;
        };

        _proto.label = function label(field, callback, cfg) {
          var self = this;
          var labelCfg = self.get('labelCfg'); // const scales = Util.map(self.get('labelCfg').fields, field => self._createScale(field));

          if (!labelCfg) {
            labelCfg = {};
            self.set('labelCfg', labelCfg);
          }

          var fields;

          if (field) {
            fields = parseFields(field);
          }

          labelCfg.fields = fields; // 如果存在回调函数

          if (Util.isFunction(callback)) {
            if (!cfg) {
              cfg = {};
            }

            labelCfg.callback = callback;
          } else if (Util.isObject(callback)) {
            // 如果没有设置回调函数
            cfg = callback;
          }

          labelCfg.globalCfg = cfg;
          return this;
        };

        _proto.tooltip = function tooltip(field, cfg) {
          var tooltipCfg = this.get('tooltipCfg');

          if (!tooltipCfg) {
            tooltipCfg = {};
          }

          if (field === false) {
            // geom 关闭 tooltip
            this.set('tooltipCfg', false);
          } else {
            var tooltipFields;

            if (field) {
              tooltipFields = parseFields(field);
            }

            tooltipCfg.fields = tooltipFields;
            tooltipCfg.cfg = cfg;
          }

          this.set('tooltipCfg', tooltipCfg);
          return this;
        };

        _proto.animate = function animate(cfg) {
          this.set('animateCfg', cfg);
          return this;
        }
        /**
         * 是否允许使用默认的图形激活交互
         * @param  {Boolean} enable 是否允许激活开关
         * @param {Object} cfg 激活的配置项
         * @return {Geom}    返回 geom 自身
         */
        ;

        _proto.active = function active(enable, cfg) {
          if (enable === false) {
            this.set('allowActive', false);
          } else if (Util.isObject(enable)) {
            this.set('allowActive', true);
            this.set('activedOptions', enable);
          } else {
            this.set('allowActive', true);
            this.set('activedOptions', cfg);
          }

          return this;
        }
        /**
         * 对 geometry 进行数据调整
         * @chainable
         * @param  {String|Array|null} adjusts 数据调整的类型
         * @return {Object} geometry 对象
         */
        ;

        _proto.adjust = function adjust(adjusts) {
          if (!this.get('hasDefaultAdjust')) {
            if (adjusts) {
              adjusts = parseAdjusts(adjusts);
            }

            this.set('adjusts', adjusts);
          }

          return this;
        }
        /**
         * 设置图形的选中模式
         * @param  {Boolean|Object} enable 布尔类型用于模式开关，对象类型用于配置
         * @param  {Object} cfg    选中配置项
         * @return {Geom}          返回 geom 自身
         */
        ;

        _proto.select = function select(enable, cfg) {
          if (enable === false) {
            this.set('allowSelect', false);
          } else if (Util.isObject(enable)) {
            this.set('allowSelect', true);
            this.set('selectedOptions', enable);
          } else {
            this.set('allowSelect', true);
            this.set('selectedOptions', cfg);
          }

          return this;
        };

        _proto.hasAdjust = function hasAdjust(adjustType) {
          var self = this;
          var adjusts = self.get('adjusts');

          if (!adjustType) {
            return false;
          }

          var rst = false;
          Util.each(adjusts, function (adjust) {
            if (adjust.type === adjustType) {
              rst = true;
              return false;
            }
          });
          return rst;
        };

        _proto.hasStack = function hasStack() {
          var isStacked = this.get('isStacked');

          if (Util.isNil(isStacked)) {
            isStacked = this.hasAdjust('stack');
            this.set('isStacked', isStacked);
          }

          return isStacked;
        };

        _proto.isInCircle = function isInCircle() {
          var coord = this.get('coord');
          return coord && coord.isPolar;
        };

        _proto._initContainer = function _initContainer() {
          var self = this;
          var shapeContainer = self.get('shapeContainer');

          if (!shapeContainer) {
            var container = self.get('container');
            var view = self.get('view');
            var viewId = view && view.get('_id');
            shapeContainer = container.addGroup({
              viewId: viewId,
              visible: self.get('visible')
            });
            self.set('shapeContainer', shapeContainer);
          }
        };

        _proto.init = function init() {
          var self = this;

          self._initContainer();

          self._initAttrs();

          if (self.get('tooltipCfg') && self.get('tooltipCfg').fields) {
            var tooltipFields = self.get('tooltipCfg').fields;
            Util.each(tooltipFields, function (field) {
              self._createScale(field);
            });
          }

          var dataArray = self._processData();

          if (self.get('adjusts')) {
            self._adjust(dataArray);
          }

          self.set('dataArray', dataArray);
        } // step 1: init attrs
        ;

        _proto._initAttrs = function _initAttrs() {
          var self = this;
          var attrs = self.get('attrs');
          var attrOptions = self.get('attrOptions');
          var coord = self.get('coord');
          var viewTheme = self.viewTheme || Global;
          var isPie = false;

          for (var type in attrOptions) {
            if (attrOptions.hasOwnProperty(type)) {
              var option = attrOptions[type];
              var className = Util.upperFirst(type);
              var fields = parseFields(option.field);

              if (type === 'position') {
                option.coord = coord; // 饼图坐标系下，填充一维

                if (fields.length === 1 && coord.type === 'theta') {
                  fields.unshift('1');
                  isPie = true;
                }
              }

              var scales = [];

              for (var i = 0; i < fields.length; i++) {
                var field = fields[i];

                var scale = self._createScale(field);

                if (type === 'color' && Util.isNil(option.values)) {
                  // 设置 color 的默认色值
                  if (scale.values.length <= 8) {
                    option.values = isPie ? viewTheme.colors_pie : viewTheme.colors;
                  } else if (scale.values.length <= 16) {
                    option.values = isPie ? viewTheme.colors_pie_16 : viewTheme.colors_16;
                  } else {
                    option.values = viewTheme.colors_24;
                  }

                  if (Util.isNil(option.values)) {
                    option.values = viewTheme.colors; // 防止主题没有声明诸如 colors_pie 的属性
                  }
                }

                scales.push(scale);
              } // 饼图需要填充满整个空间


              if (coord.type === 'theta' && type === 'position' && scales.length > 1) {
                var yScale = scales[1];
                var min = 0;
                var max = Math.max.apply(null, yScale.values);

                if (!isFinite(max)) {
                  max = 1;
                }

                yScale.change({
                  nice: false,
                  min: min,
                  max: max
                });
              }

              option.scales = scales;
              var attr = new Attr[className](option);
              attrs[type] = attr;
            }
          }
        } // step 2: 处理数据
        ;

        _proto._processData = function _processData() {
          var self = this;
          var data = this.get('data');
          var dataArray = [];

          var groupedArray = this._groupData(data);

          for (var i = 0; i < groupedArray.length; i++) {
            var subData = groupedArray[i];

            var tempData = self._saveOrigin(subData);

            dataArray.push(self._numberic(tempData));
          }

          return dataArray;
        } // step 2.1 数据分组
        ;

        _proto._groupData = function _groupData(data) {
          var groupScales = this._getGroupScales();

          var fields = groupScales.map(function (scale) {
            return scale.field;
          });
          return Util.Array.group(data, fields);
        } // step 2.2 数据调整前保存原始数据
        ;

        _proto._saveOrigin = function _saveOrigin(data) {
          var rst = [];

          for (var i = 0; i < data.length; i++) {
            var origin = data[i];
            var obj = {};

            for (var k in origin) {
              obj[k] = origin[k];
            } // const obj = Util.mix({}, origin);


            obj[FIELD_ORIGIN] = origin;
            rst.push(obj);
          }

          return rst;
        } // step 2.3 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理
        ;

        _proto._numberic = function _numberic(data) {
          var positionAttr = this.getAttr('position');
          var scales = positionAttr.scales;
          var result = [];

          for (var j = 0; j < data.length; j++) {
            var obj = data[j];
            var isValidate = true;

            for (var i = 0; i < Math.min(2, scales.length); i++) {
              var scale = scales[i];

              if (scale.isCategory) {
                var field = scale.field;
                obj[field] = scale.translate(obj[field]);

                if (Number.isNaN(obj[field])) {
                  // 当分类为 NaN 时，说明该条数据不在定义域内，需要过滤掉
                  isValidate = false;
                }
              }
            }

            if (isValidate) {
              result.push(obj);
            }
          }

          return result;
        };

        _proto._getGroupScales = function _getGroupScales() {
          var self = this;
          var scales = self.get('groupScales');

          if (!scales) {
            scales = [];
            var attrs = self.get('attrs');
            Util.each(attrs, function (attr) {
              if (GROUP_ATTRS.includes(attr.type)) {
                var attrScales = attr.scales;
                Util.each(attrScales, function (scale) {
                  if (scale.isCategory && Util.indexOf(scales, scale) === -1) {
                    scales.push(scale);
                  }
                });
              }
            });
            self.set('groupScales', scales);
          }

          return scales;
        };

        _proto._updateStackRange = function _updateStackRange(field, scale, dataArray) {
          var mergeArray = Util.Array.merge(dataArray);
          var min = scale.min;
          var max = scale.max;

          for (var i = 0; i < mergeArray.length; i++) {
            var obj = mergeArray[i]; // 过滤掉非法数据

            if (!Util.isArray(obj[field])) {
              continue;
            }

            var tmpMin = Math.min.apply(null, obj[field]);
            var tmpMax = Math.max.apply(null, obj[field]);

            if (tmpMin < min) {
              min = tmpMin;
            }

            if (tmpMax > max) {
              max = tmpMax;
            }
          }

          if (min < scale.min || max > scale.max) {
            scale.change({
              min: min,
              max: max
            });
          }
        } // step 2.2 调整数据
        ;

        _proto._adjust = function _adjust(dataArray) {
          // 当数据为空的时候，就不需要对数据进行调整了
          if (!dataArray || !dataArray.length) {
            return;
          }

          var self = this;
          var adjusts = self.get('adjusts');
          var viewTheme = this.viewTheme || Global;
          var yScale = self.getYScale();
          var xScale = self.getXScale();
          var xField = xScale.field;
          var yField = yScale ? yScale.field : null;
          Util.each(adjusts, function (adjust) {
            var adjustCfg = Util.mix({
              xField: xField,
              yField: yField
            }, adjust);
            var adjustType = Util.upperFirst(adjust.type);

            if (adjustType === 'Dodge') {
              var adjustNames = [];

              if (xScale.isCategory || xScale.isIdentity) {
                adjustNames.push('x');
              } else if (!yScale) {
                adjustNames.push('y');
              } else {
                throw new Error('dodge is not support linear attribute, please use category attribute!');
              }

              adjustCfg.adjustNames = adjustNames;
              adjustCfg.dodgeRatio = adjustCfg.dodgeRatio || viewTheme.widthRatio.column;
              /* if (self.isInCircle()) {
                adjustCfg.dodgeRatio = 1;
                adjustCfg.marginRatio = 0;
              }*/
            } else if (adjustType === 'Stack') {
              var coord = self.get('coord');

              if (!yScale) {
                // 一维的情况下获取高度和默认size
                adjustCfg.height = coord.getHeight();
                var size = self.getDefaultValue('size') || 3;
                adjustCfg.size = size;
              } // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下


              if (!coord.isTransposed && Util.isNil(adjustCfg.reverseOrder)) {
                adjustCfg.reverseOrder = true;
              }
            }

            var adjustElement = new Adjust[adjustType](adjustCfg);
            adjustElement.processAdjust(dataArray);

            if (adjustType === 'Stack' && yScale) {
              self._updateStackRange(yField, yScale, dataArray);
            }
          });
        }
        /**
         * @internal 设置coord，通常外部容器变化时，coord 会发生变化
         * @param {Object} coord 坐标系
         */
        ;

        _proto.setCoord = function setCoord(coord) {
          this.set('coord', coord);
          var position = this.getAttr('position');
          var shapeContainer = this.get('shapeContainer');
          shapeContainer.setMatrix(coord.matrix);

          if (position) {
            position.coord = coord;
          }
        } // step 3 绘制
        ;

        _proto.paint = function paint() {
          var self = this;
          var dataArray = self.get('dataArray');
          var mappedArray = [];
          var shapeFactory = self.getShapeFactory();
          shapeFactory.setCoord(self.get('coord'));
          self.set('shapeFactory', shapeFactory);
          var shapeContainer = self.get('shapeContainer');

          self._beforeMapping(dataArray);

          for (var i = 0; i < dataArray.length; i++) {
            var data = dataArray[i];
            var index = i;
            data = self._mapping(data);
            mappedArray.push(data);
            self.draw(data, shapeContainer, shapeFactory, index);
          }

          if (self.get('labelCfg')) {
            self._addLabels(Util.union.apply(null, mappedArray), shapeContainer.get('children'));
          }

          if (!self.get('sortable')) {
            self._sort(mappedArray); // 便于数据的查找，需要对数据进行排序，用于 geom.findPoint()

          } else {
            self.set('dataArray', mappedArray);
          }
        };

        _proto._sort = function _sort(mappedArray) {
          var self = this;
          var xScale = self.getXScale();
          var xField = xScale.field;
          Util.each(mappedArray, function (itemArr) {
            itemArr.sort(function (obj1, obj2) {
              return xScale.translate(obj1[FIELD_ORIGIN][xField]) - xScale.translate(obj2[FIELD_ORIGIN][xField]);
            });
          });
          self.set('dataArray', mappedArray);
        } // step 3.1 before mapping
        ;

        _proto._beforeMapping = function _beforeMapping(dataArray) {
          var self = this;

          if (self.get('sortable')) {
            var xScale = self.getXScale();
            var field = xScale.field;
            Util.each(dataArray, function (data) {
              data.sort(function (v1, v2) {
                return xScale.translate(v1[field]) - xScale.translate(v2[field]);
              });
            });
          }

          if (self.get('generatePoints')) {
            Util.each(dataArray, function (data) {
              self._generatePoints(data);
            });
            Util.each(dataArray, function (data, index) {
              var nextData = dataArray[index + 1];

              if (nextData) {
                data[0].nextPoints = nextData[0].points;
              }
            });
          }
        } // step 3.2 add labels
        ;

        _proto._addLabels = function _addLabels(points, shapes) {
          var self = this;
          var type = self.get('type');
          var viewTheme = self.get('viewTheme') || Global;
          var coord = self.get('coord');
          var C = Labels.getLabelsClass(coord.type, type);
          var container = self.get('container');
          var scales = Util.map(self.get('labelCfg').fields, function (field) {
            return self._createScale(field);
          });
          var labelContainer = container.addGroup(C, {
            _id: this.get('_id'),
            labelCfg: Util.mix({
              scales: scales
            }, self.get('labelCfg')),
            coord: coord,
            geom: self,
            geomType: type,
            yScale: self.getYScale(),
            viewTheme: viewTheme,
            visible: self.get('visible')
          });
          labelContainer.showLabels(points, shapes);
          self.set('labelContainer', labelContainer);
        }
        /**
         * @protected
         * 获取图形的工厂类
         * @return {Object} 工厂类对象
         */
        ;

        _proto.getShapeFactory = function getShapeFactory() {
          var shapeFactory = this.get('shapeFactory');

          if (!shapeFactory) {
            var shapeType = this.get('shapeType');
            shapeFactory = Shape.getShapeFactory(shapeType);
            this.set('shapeFactory', shapeFactory);
          }

          return shapeFactory;
        } // step 3.2 generate points
        ;

        _proto._generatePoints = function _generatePoints(data) {
          var self = this;
          var shapeFactory = self.getShapeFactory();
          var shapeAttr = self.getAttr('shape');

          for (var i = 0; i < data.length; i++) {
            var obj = data[i];
            var cfg = self.createShapePointsCfg(obj);
            var shape = shapeAttr ? self._getAttrValues(shapeAttr, obj) : null;
            var points = shapeFactory.getShapePoints(shape, cfg);
            obj.points = points;
          }
        }
        /**
         * 获取图形对应点的配置项
         * @protected
         * @param  {Object} obj 数据对象
         * @return {Object} cfg 获取图形对应点的配置项
         */
        ;

        _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
          var xScale = this.getXScale();
          var yScale = this.getYScale();

          var x = this._normalizeValues(obj[xScale.field], xScale);

          var y; // 存在没有 y 的情况

          if (yScale) {
            y = this._normalizeValues(obj[yScale.field], yScale);
          } else {
            y = obj.y ? obj.y : 0.1;
          }

          return {
            x: x,
            y: y,
            y0: yScale ? yScale.scale(this.getYMinValue()) : undefined
          };
        }
        /**
         * @protected
         * 如果y轴的最小值小于0则返回0，否则返回最小值
         * @return {Number} y轴上的最小值
         */
        ;

        _proto.getYMinValue = function getYMinValue() {
          var yScale = this.getYScale();
          var min = yScale.min,
              max = yScale.max;
          var value;

          if (min >= 0) {
            value = min;
          } else if (max <= 0) {
            // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0
            value = max;
          } else {
            value = 0;
          }

          return value;
        } // 将数据归一化
        ;

        _proto._normalizeValues = function _normalizeValues(values, scale) {
          var rst = [];

          if (Util.isArray(values)) {
            for (var i = 0; i < values.length; i++) {
              var v = values[i];
              rst.push(scale.scale(v));
            }
          } else {
            rst = scale.scale(values);
          }

          return rst;
        } // step 3.2 mapping
        ;

        _proto._mapping = function _mapping(data) {
          var self = this;
          var attrs = self.get('attrs');
          var mappedData = [];

          for (var i = 0; i < data.length; i++) {
            var record = data[i];
            var newRecord = {};
            newRecord[FIELD_ORIGIN] = record[FIELD_ORIGIN];
            newRecord.points = record.points;
            newRecord.nextPoints = record.nextPoints;

            for (var k in attrs) {
              if (attrs.hasOwnProperty(k)) {
                var attr = attrs[k];
                var names = attr.names;

                var values = self._getAttrValues(attr, record);

                if (names.length > 1) {
                  // position 之类的生成多个字段的属性
                  for (var j = 0; j < values.length; j++) {
                    var val = values[j];
                    var name = names[j];
                    newRecord[name] = Util.isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值
                  }
                } else {
                  newRecord[names[0]] = values.length === 1 ? values[0] : values;
                }
              }
            }

            mappedData.push(newRecord);
          }

          return mappedData;
        } // 获取属性映射的值
        ;

        _proto._getAttrValues = function _getAttrValues(attr, record) {
          var scales = attr.scales;
          var params = [];

          for (var i = 0; i < scales.length; i++) {
            var scale = scales[i];
            var field = scale.field;

            if (scale.type === 'identity') {
              params.push(scale.value);
            } else {
              params.push(record[field]);
            }
          }

          var values = attr.mapping.apply(attr, params);
          return values;
        };

        _proto.getAttrValue = function getAttrValue(attrName, record) {
          var attr = this.getAttr(attrName);
          var rst = null;

          if (attr) {
            var values = this._getAttrValues(attr, record);

            rst = values[0];
          }

          return rst;
        };

        _proto.getDefaultValue = function getDefaultValue(attrName) {
          var value = this.get(attrName);
          var attr = this.getAttr(attrName);

          if (attr) {
            var scale = attr.getScale(attrName);

            if (scale.type === 'identity') {
              value = scale.value;
            }
          }

          return value;
        }
        /**
         * step 3.3 draw
         * @protected
         * @param  {Array} data 绘制图形
         * @param {Object} container 绘图容器
         * @param {Object} shapeFactory 绘制图形的工厂类
         * @param {Number} index 每个 shape 的索引值
         */
        ;

        _proto.draw = function draw(data, container, shapeFactory, index) {
          var self = this;

          for (var i = 0; i < data.length; i++) {
            var obj = data[i];
            self.drawPoint(obj, container, shapeFactory, index + i);
          }
        };

        _proto.getCallbackCfg = function getCallbackCfg(fields, cfg, origin) {
          if (!fields) {
            return cfg;
          }

          var tmpCfg = {};
          var params = fields.map(function (field) {
            return origin[field];
          });
          Util.each(cfg, function (v, k) {
            if (Util.isFunction(v)) {
              tmpCfg[k] = v.apply(null, params);
            } else {
              tmpCfg[k] = v;
            }
          });
          return tmpCfg;
        };

        _proto._getShapeId = function _getShapeId(dataObj) {
          var id = this.get('_id');
          var keyFields = this.get('keyFields');

          if (keyFields && keyFields.length > 0) {
            Util.each(keyFields, function (key) {
              id += '-' + dataObj[key];
            });
          } else {
            var type = this.get('type');
            var xScale = this.getXScale();
            var yScale = this.getYScale();
            var xField = xScale.field || 'x';
            var yField = yScale.field || 'y';
            var yVal = dataObj[yField];
            var xVal;

            if (xScale.isIdentity) {
              xVal = xScale.value;
            } else {
              xVal = dataObj[xField];
            }

            if (type === 'interval' || type === 'schema') {
              id += '-' + xVal;
            } else if (type === 'line' || type === 'area' || type === 'path') {
              id += '-' + type;
            } else {
              id += '-' + xVal + '-' + yVal;
            }

            var groupScales = this._getGroupScales();

            if (!Util.isEmpty(groupScales)) {
              Util.each(groupScales, function (groupScale) {
                var field = groupScale.field;

                if (groupScale.type !== 'identity') {
                  id += '-' + dataObj[field];
                }
              });
            }
          }

          return id;
        };

        _proto.getDrawCfg = function getDrawCfg(obj) {
          var self = this;
          var cfg = {
            origin: obj,
            x: obj.x,
            y: obj.y,
            color: obj.color,
            size: obj.size,
            shape: obj.shape,
            isInCircle: self.isInCircle(),
            opacity: obj.opacity
          };
          var styleOptions = self.get('styleOptions');

          if (styleOptions && styleOptions.style) {
            cfg.style = self.getCallbackCfg(styleOptions.fields, styleOptions.style, obj[FIELD_ORIGIN]);
          }

          if (self.get('generatePoints')) {
            cfg.points = obj.points;
            cfg.nextPoints = obj.nextPoints;
          }

          if (self.get('animate')) {
            // _id 字段仅用于动画
            cfg._id = self._getShapeId(obj[FIELD_ORIGIN]);
          }

          return cfg;
        };

        _proto.appendShapeInfo = function appendShapeInfo(shape, index) {
          if (shape) {
            shape.setSilent('index', index);
            shape.setSilent('coord', this.get('coord'));

            if (this.get('animate') && this.get('animateCfg')) {
              shape.setSilent('animateCfg', this.get('animateCfg'));
            }
          }
        };

        _proto._applyViewThemeShapeStyle = function _applyViewThemeShapeStyle(cfg, shape, shapeFactory) {
          // applying view theme
          var self = this;
          var viewTheme = self.viewTheme || Global;
          var shapeName = shapeFactory.name;

          if (shape) {
            if (shape && (shape.indexOf('hollow') > -1 || shape.indexOf('liquid') > -1)) {
              shapeName = "hollow" + Util.upperFirst(shapeName);
            }
          } else if (shapeFactory.defaultShapeType.indexOf('hollow') > -1) {
            shapeName = "hollow" + Util.upperFirst(shapeName);
          }

          var defaultStyle = viewTheme.shape[shapeName] || {};
          cfg.style = Util.mix({}, defaultStyle, cfg.style);
        };

        _proto.drawPoint = function drawPoint(obj, container, shapeFactory, index) {
          var self = this;
          var shape = obj.shape;
          var cfg = self.getDrawCfg(obj);

          self._applyViewThemeShapeStyle(cfg, shape, shapeFactory);

          var geomShape = shapeFactory.drawShape(shape, cfg, container);
          self.appendShapeInfo(geomShape, index);
        }
        /**
         * 获取属性
         * @protected
         * @param {String} name 属性名
         * @return {Scale} 度量
         */
        ;

        _proto.getAttr = function getAttr(name) {
          return this.get('attrs')[name];
        }
        /**
         * 获取 x 对应的度量
         * @return {Scale} x 对应的度量
         */
        ;

        _proto.getXScale = function getXScale() {
          return this.getAttr('position').scales[0];
        }
        /**
         * 获取 y 对应的度量
         * @return {Scale} y 对应的度量
         */
        ;

        _proto.getYScale = function getYScale() {
          return this.getAttr('position').scales[1];
        };

        _proto.getShapes = function getShapes() {
          var result = [];
          var shapeContainer = this.get('shapeContainer');
          var children = shapeContainer.get('children');
          Util.each(children, function (child) {
            if (child.get('origin')) {
              // 过滤 label
              result.push(child);
            }
          });
          return result;
        };

        _proto.getAttrsForLegend = function getAttrsForLegend() {
          var attrs = this.get('attrs');
          var rst = [];
          Util.each(attrs, function (attr) {
            if (GROUP_ATTRS.includes(attr.type)) {
              rst.push(attr);
            }
          });
          return rst;
        };

        _proto.getFieldsForLegend = function getFieldsForLegend() {
          var fields = [];
          var attrOptions = this.get('attrOptions');
          Util.each(GROUP_ATTRS, function (attrName) {
            var attrCfg = attrOptions[attrName];

            if (attrCfg && attrCfg.field && Util.isString(attrCfg.field)) {
              fields = fields.concat(attrCfg.field.split('*'));
            }
          });
          return Util.uniq(fields);
        };

        _proto.changeVisible = function changeVisible(visible, stopDraw) {
          var me = this;
          me.set('visible', visible);
          var shapeContainer = this.get('shapeContainer');

          if (shapeContainer) {
            shapeContainer.set('visible', visible);
          }

          var labelContainer = this.get('labelContainer');

          if (labelContainer) {
            labelContainer.set('visible', visible);
          }

          if (!stopDraw && shapeContainer) {
            var canvas = shapeContainer.get('canvas');
            canvas.draw();
          }
        };

        _proto.reset = function reset() {
          this.set('attrOptions', {});
          this.clearInner();
        };

        _proto.clearInner = function clearInner() {
          this.clearActivedShapes();
          this.clearSelected();
          var shapeContainer = this.get('shapeContainer');
          shapeContainer && shapeContainer.clear(); // 由于 Labels 对应的模块需要生成group，所以这个地方需要删除

          var labelContainer = this.get('labelContainer');
          labelContainer && labelContainer.remove();
          this.set('attrs', {});
          this.set('groupScales', null); // if (!this.get('hasDefaultAdjust')) {
          //   this.set('adjusts', null);
          // }

          this.set('labelContainer', null);
          this.set('xDistance', null);
          this.set('isStacked', null);
        };

        _proto.clear = function clear() {
          this.clearInner();
          this.set('scales', {});
        };

        _proto.destroy = function destroy() {
          this.clear();
          var shapeContainer = this.get('shapeContainer');
          shapeContainer && shapeContainer.remove();
          this.offEvents();

          _Base.prototype.destroy.call(this);
        };

        _proto.bindEvents = function bindEvents() {
          if (this.get('view')) {
            this._bindActiveAction();

            this._bindSelectedAction();
          }
        };

        _proto.offEvents = function offEvents() {
          if (this.get('view')) {
            this._offActiveAction();

            this._offSelectedAction();
          }
        };

        return GeomBase;
      }(Base);

      module.exports = GeomBase;
      /***/
    },
    /* 22 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        Axis: __webpack_require__(308),
        Component: __webpack_require__(67),
        Guide: __webpack_require__(316),
        Label: __webpack_require__(325),
        Legend: __webpack_require__(326),
        Tooltip: __webpack_require__(332)
      };
      /***/
    },
    /* 23 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 计算path 使用的工具方法
       * @author dxq613@gmail.com
       */
      var Util = __webpack_require__(0);

      var Spline = __webpack_require__(336);

      function points2path(points, isInCircle) {
        if (!points.length) {
          return [];
        }

        var path = [];

        for (var i = 0, length = points.length; i < length; i++) {
          var item = points[i];

          if (i === 0) {
            path.push(['M', item.x, item.y]);
          } else {
            path.push(['L', item.x, item.y]);
          }
        }

        if (isInCircle) {
          path.push(['Z']);
        }

        return path;
      }

      function _getPointRadius(coord, point) {
        var center = coord.getCenter();
        var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
        return r;
      }

      function convertArr(arr, coord) {
        var len = arr.length;
        var tmp = [arr[0]];

        for (var i = 1; i < len; i = i + 2) {
          var point = coord.convertPoint({
            x: arr[i],
            y: arr[i + 1]
          });
          tmp.push(point.x, point.y);
        }

        return tmp;
      }

      function _convertPolarPath(pre, cur, coord) {
        // const radius = coord.getRadius();
        // const inner = coord.innerRadius || 0;
        // let innerRadius = inner * radius;
        var transposed = coord.isTransposed;
        var startAngle = coord.startAngle;
        var endAngle = coord.endAngle;
        var prePoint = {
          x: pre[1],
          y: pre[2]
        };
        var curPoint = {
          x: cur[1],
          y: cur[2]
        };
        var rst = []; // innerRadius = innerRadius || 0;

        var xDim = transposed ? 'y' : 'x';
        var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
        var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向

        var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位

        var convertPoint = coord.convertPoint(curPoint);

        var r = _getPointRadius(coord, convertPoint);

        if (r >= 0.5) {
          // 小于1像素的圆在图像上无法识别
          if (angleRange === Math.PI * 2) {
            var middlePoint = {
              x: (curPoint.x + prePoint.x) / 2,
              y: (curPoint.y + prePoint.y) / 2
            };
            var middleConvertPoint = coord.convertPoint(middlePoint);
            rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);
            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
          } else {
            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
          }
        }

        return rst;
      } // 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形


      function filterFullCirleLine(path) {
        Util.each(path, function (subPath, index) {
          var cur = subPath;

          if (cur[0].toLowerCase() === 'a') {
            var pre = path[index - 1];
            var next = path[index + 1];

            if (next && next[0].toLowerCase() === 'a') {
              if (pre && pre[0].toLowerCase() === 'l') {
                pre[0] = 'M';
              }
            } else if (pre && pre[0].toLowerCase() === 'a') {
              if (next && next[0].toLowerCase() === 'l') {
                next[0] = 'M';
              }
            }
          }
        });
      }

      var PathUtil = {
        // 线的path
        getLinePath: function getLinePath(points, isInCircle) {
          return points2path(points, isInCircle);
        },
        // get spline： 限定了范围的平滑线
        getSplinePath: function getSplinePath(points, isInCircle, constaint) {
          var data = [];
          var first = points[0];
          var prePoint = null;

          if (points.length <= 2) {
            return PathUtil.getLinePath(points, isInCircle);
          }

          Util.each(points, function (point) {
            if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
              data.push(point.x);
              data.push(point.y);
              prePoint = point;
            }
          });
          constaint = constaint || [// 范围
          [0, 0], [1, 1]];
          var splinePath = Spline.catmullRom2bezier(data, isInCircle, constaint);
          splinePath.unshift(['M', first.x, first.y]);
          return splinePath;
        },
        getPointRadius: function getPointRadius(coord, point) {
          var result = _getPointRadius(coord, point);

          return result;
        },
        getPointAngle: function getPointAngle(coord, point) {
          var center = coord.getCenter();
          var angle = Math.atan2(point.y - center.y, point.x - center.x);
          return angle;
        },
        convertNormalPath: function convertNormalPath(coord, path) {
          var tmp = [];
          Util.each(path, function (subPath) {
            var action = subPath[0];

            switch (action.toLowerCase()) {
              case 'm':
              case 'l':
              case 'c':
                tmp.push(convertArr(subPath, coord));
                break;

              case 'z':
              default:
                tmp.push(subPath);
                break;
            }
          });
          return tmp;
        },
        convertPolarPath: function convertPolarPath(coord, path) {
          var tmp = [];
          var pre;
          var cur;
          var transposed;
          var equals;
          Util.each(path, function (subPath, index) {
            var action = subPath[0];

            switch (action.toLowerCase()) {
              case 'm':
              case 'c':
              case 'q':
                tmp.push(convertArr(subPath, coord));
                break;

              case 'l':
                pre = path[index - 1];
                cur = subPath;
                transposed = coord.isTransposed; // 是否半径相同，转换成圆弧

                equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];

                if (equals) {
                  tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
                } else {
                  // y 不相等，所以直接转换
                  tmp.push(convertArr(subPath, coord));
                }

                break;

              case 'z':
              default:
                tmp.push(subPath);
                break;
            }
          });
          filterFullCirleLine(tmp); // 过滤多余的直线

          return tmp;
        }
      };
      module.exports = PathUtil;
      /***/
    },
    /* 24 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      function toString(value) {
        if (isNil(value)) return '';
        return value.toString();
      }

      module.exports = toString;
      /***/
    },
    /* 25 */

    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var isObject = function isObject(value) {
        /**
         * isObject({}) => true
         * isObject([1, 2, 3]) => true
         * isObject(Function) => true
         * isObject(null) => false
         */
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
        return value !== null && type === 'object' || type === 'function';
      };

      module.exports = isObject;
      /***/
    },
    /* 26 */

    /***/
    function (module, exports, __webpack_require__) {
      var isObjectLike = __webpack_require__(49);

      var isType = __webpack_require__(12);

      var isPlainObject = function isPlainObject(value) {
        /**
         * isObjectLike(new Foo) => false
         * isObjectLike([1, 2, 3]) => false
         * isObjectLike({ x: 0, y: 0 }) => true
         * isObjectLike(Object.create(null)) => true
         */
        if (!isObjectLike(value) || !isType(value, 'Object')) {
          return false;
        }

        if (Object.getPrototypeOf(value) === null) {
          return true;
        }

        var proto = value;

        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }

        return Object.getPrototypeOf(value) === proto;
      };

      module.exports = isPlainObject;
      /***/
    },
    /* 27 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
      var regexDot = /[^\s\,]+/ig;
      var numColorCache = {};
      module.exports = {
        parseRadius: function parseRadius(radius) {
          var r1 = 0,
              r2 = 0,
              r3 = 0,
              r4 = 0;

          if (Util.isArray(radius)) {
            if (radius.length === 1) {
              r1 = r2 = r3 = r4 = radius[0];
            } else if (radius.length === 2) {
              r1 = r3 = radius[0];
              r2 = r4 = radius[1];
            } else if (radius.length === 3) {
              r1 = radius[0];
              r2 = r4 = radius[1];
              r3 = radius[2];
            } else {
              r1 = radius[0];
              r2 = radius[1];
              r3 = radius[2];
              r4 = radius[3];
            }
          } else {
            r1 = r2 = r3 = r4 = radius;
          }

          return {
            r1: r1,
            r2: r2,
            r3: r3,
            r4: r4
          };
        },
        parsePath: function parsePath(path) {
          path = path || [];

          if (Util.isArray(path)) {
            return path;
          }

          if (Util.isString(path)) {
            path = path.match(regexTags);
            Util.each(path, function (item, index) {
              item = item.match(regexDot);

              if (item[0].length > 1) {
                var tag = item[0].charAt(0);
                item.splice(1, 0, item[0].substr(1));
                item[0] = tag;
              }

              Util.each(item, function (sub, i) {
                if (!isNaN(sub)) {
                  item[i] = +sub;
                }
              });
              path[index] = item;
            });
            return path;
          }
        },
        numberToColor: function numberToColor(num) {
          // 增加缓存
          var color = numColorCache[num];

          if (!color) {
            var str = num.toString(16);

            for (var i = str.length; i < 6; i++) {
              str = '0' + str;
            }

            color = '#' + str;
            numColorCache[num] = color;
          }

          return color;
        }
      };
      /***/
    },
    /* 28 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["c"] = hue;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = gamma;
      /* harmony export (immutable) */

      __webpack_exports__["a"] = nogamma;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(120);

      function linear(a, d) {
        return function (t) {
          return a + t * d;
        };
      }

      function exponential(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
          return Math.pow(a + t * b, y);
        };
      }

      function hue(a, b) {
        var d = b - a;
        return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a"
        /* default */
        ])(isNaN(a) ? b : a);
      }

      function gamma(y) {
        return (y = +y) === 1 ? nogamma : function (a, b) {
          return b - a ? exponential(a, b, y) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a"
          /* default */
          ])(isNaN(a) ? b : a);
        };
      }

      function nogamma(a, b) {
        var d = b - a;
        return d ? linear(a, d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a"
        /* default */
        ])(isNaN(a) ? b : a);
      }
      /***/

    },
    /* 29 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview the Attribute base class
       */
      var isString = __webpack_require__(10);

      var isArray = __webpack_require__(4);

      var isNil = __webpack_require__(5);

      var mix = __webpack_require__(8);

      var each = __webpack_require__(2);

      function toScaleString(scale, value) {
        if (isString(value)) {
          return value;
        }

        return scale.invert(scale.scale(value));
      }
      /**
       * 所有视觉通道属性的基类
       * @class Attr
       */


      var AttributeBase = /*#__PURE__*/function () {
        function AttributeBase(cfg) {
          var _this = this;
          /**
           * 属性的类型
           * @type {String}
           */


          this.type = 'base';
          /**
           * 属性的名称
           * @type {String}
           */

          this.name = null;
          /**
           * 回调函数
           * @type {Function}
           */

          this.method = null;
          /**
           * 备选的值数组
           * @type {Array}
           */

          this.values = [];
          /**
           * 属性内部的度量
           * @type {Array}
           */

          this.scales = [];
          /**
           * 是否通过线性取值, 如果未指定，则根据数值的类型判定
           * @type {Boolean}
           */

          this.linear = null;
          /**
           * 当用户设置的 callback 返回 null 时, 应该返回默认 callback 中的值
           */

          var mixedCallback = null;
          var defaultCallback = this.callback;

          if (cfg.callback) {
            var userCallback = cfg.callback;

            mixedCallback = function mixedCallback() {
              for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
                params[_key] = arguments[_key];
              }

              var ret = userCallback.apply(void 0, params);

              if (isNil(ret)) {
                ret = defaultCallback.apply(_this, params);
              }

              return ret;
            };
          }

          mix(this, cfg);

          if (mixedCallback) {
            mix(this, {
              callback: mixedCallback
            });
          }
        } // 获取属性值，将值映射到视觉通道


        var _proto = AttributeBase.prototype;

        _proto._getAttrValue = function _getAttrValue(scale, value) {
          var values = this.values;

          if (scale.isCategory && !this.linear) {
            var index = scale.translate(value);
            return values[index % values.length];
          }

          var percent = scale.scale(value);
          return this.getLinearValue(percent);
        };
        /**
         * 如果进行线性映射，返回对应的映射值
         * @protected
         * @param  {Number} percent 百分比
         * @return {*}  颜色值、形状、大小等
         */


        _proto.getLinearValue = function getLinearValue(percent) {
          var values = this.values;
          var steps = values.length - 1;
          var step = Math.floor(steps * percent);
          var leftPercent = steps * percent - step;
          var start = values[step];
          var end = step === steps ? start : values[step + 1];
          var rstValue = start + (end - start) * leftPercent;
          return rstValue;
        };
        /**
         * 默认的回调函数
         * @param {*} value 回调函数的值
         * @type {Function}
         * @return {Array} 返回映射后的值
         */


        _proto.callback = function callback(value) {
          var self = this;
          var scale = self.scales[0];
          var rstValue = null;

          if (scale.type === 'identity') {
            rstValue = scale.value;
          } else {
            rstValue = self._getAttrValue(scale, value);
          }

          return rstValue;
        };
        /**
         * 根据度量获取属性名
         * @return {Array} dims of this Attribute
         */


        _proto.getNames = function getNames() {
          var scales = this.scales;
          var names = this.names;
          var length = Math.min(scales.length, names.length);
          var rst = [];

          for (var i = 0; i < length; i++) {
            rst.push(names[i]);
          }

          return rst;
        };
        /**
         * 根据度量获取维度名
         * @return {Array} dims of this Attribute
         */


        _proto.getFields = function getFields() {
          var scales = this.scales;
          var rst = [];
          each(scales, function (scale) {
            rst.push(scale.field);
          });
          return rst;
        };
        /**
         * 根据名称获取度量
         * @param  {String} name the name of scale
         * @return {Scale} scale
         */


        _proto.getScale = function getScale(name) {
          var scales = this.scales;
          var names = this.names;
          var index = names.indexOf(name);
          return scales[index];
        };
        /**
         * 映射数据
         * @param {*} param1...paramn 多个数值
         * @return {Array} 映射的值组成的数组
         */


        _proto.mapping = function mapping() {
          var scales = this.scales;
          var callback = this.callback;

          for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            params[_key2] = arguments[_key2];
          }

          var values = params;

          if (callback) {
            for (var i = 0, len = params.length; i < len; i++) {
              params[i] = this._toOriginParam(params[i], scales[i]);
            }

            values = callback.apply(this, params);
          }

          values = [].concat(values);
          return values;
        }; // 原始的参数


        _proto._toOriginParam = function _toOriginParam(param, scale) {
          var rst = param;

          if (!scale.isLinear) {
            if (isArray(param)) {
              rst = [];

              for (var i = 0, len = param.length; i < len; i++) {
                rst.push(toScaleString(scale, param[i]));
              }
            } else {
              rst = toScaleString(scale, param);
            }
          }

          return rst;
        };

        return AttributeBase;
      }();

      module.exports = AttributeBase;
      /***/
    },
    /* 30 */

    /***/
    function (module, exports, __webpack_require__) {
      var mix = __webpack_require__(8);

      var Adjust = /*#__PURE__*/function () {
        var _proto = Adjust.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          this.adjustNames = ['x', 'y']; // 调整的维度，默认,x,y都做调整
        };

        function Adjust(cfg) {
          this._initDefaultCfg();

          mix(this, cfg);
        }
        /**
         * @override
         */


        _proto.processAdjust = function processAdjust()
        /* dataArray */
        {};

        return Adjust;
      }();

      module.exports = Adjust;
      /***/
    },
    /* 31 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Component = __webpack_require__(32);

      var Util = __webpack_require__(3);

      var Grid = __webpack_require__(152);

      var Label = __webpack_require__(153);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var Axis = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Axis, _Component);

        function Axis() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = Axis.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Component.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 用于动画，唯一标识的 id
             * @type {[type]}
             */
            _id: null,
            zIndex: 4,

            /**
             * 坐标轴上的坐标点
             * @type {Array}
             */
            ticks: null,

            /**
             * 坐标轴线的配置信息，如果设置成null，则不显示轴线
             * @type {Object}
             */
            line: null,

            /**
             * 坐标轴刻度线的配置,如果设置成null，则不显示刻度线
             * @type {Object}
             */
            tickLine: null,

            /**
             * 次刻度线个数配置
             * @type {Number}
             */
            subTickCount: 0,

            /**
             * 次刻度线样式配置
             * @type {Object}
             */
            subTickLine: null,

            /**
             * 网格线配置，如果值为 null，则不显示
             * @type {Object}
             */
            grid: null,

            /**
             * 坐标轴文本配置
             * @type {Object}
             */
            label: {
              offset: 0,
              offsetX: 0,
              offsetY: 0,
              textStyle: {},
              // 坐标轴文本样式
              autoRotate: true,
              autoHide: false,
              formatter: null // 坐标轴文本格式化回调函数

            },
            labelItems: [],

            /**
             * 坐标轴标题配置
             * @type {Object}
             */
            title: {
              autoRotate: true,
              // 文本是否自动旋转
              textStyle: {} // 坐标轴标题样式

            },
            autoPaint: true
          });
        };

        _proto.beforeRender = function beforeRender() {
          var self = this;
          var title = self.get('title');
          var label = self.get('label');
          var grid = self.get('grid');

          if (title) {
            self.set('title', Util.deepMix({
              autoRotate: true,
              textStyle: {
                fontSize: 12,
                fill: '#ccc',
                textBaseline: 'middle',
                fontFamily: FONT_FAMILY,
                textAlign: 'center'
              },
              offset: 48
            }, title));
          }

          if (label) {
            self.set('label', Util.deepMix({
              autoRotate: true,
              autoHide: true,
              textStyle: {
                fontSize: 12,
                fill: '#ccc',
                textBaseline: 'middle',
                fontFamily: FONT_FAMILY
              },
              offset: 10
            }, label));
          }

          if (grid) {
            self.set('grid', Util.deepMix({
              lineStyle: {
                lineWidth: 1,
                stroke: '#C0D0E0'
              }
            }, grid));
          }
        };

        _proto.render = function render() {
          var self = this;
          self.beforeRender();
          var labelCfg = self.get('label');

          if (labelCfg) {
            self.renderLabels();
          }

          if (self.get('autoPaint')) {
            self.paint();
          }

          if (!Util.isNil(self.get('title'))) {
            self.renderTitle();
          }

          self.get('group').sort();
        };

        _proto.renderLabels = function renderLabels() {
          var self = this;
          var group = self.get('group');
          var labelCfg = self.get('label');
          var labelRenderer = new Label({
            name: 'axis-label'
          });
          self.set('labelRenderer', labelRenderer);
          labelRenderer.set('labelCfg', labelCfg);
          var cfgs2copy = ['formatter', 'htmlTemplate', 'labelLine', 'textStyle', 'useHtml'];
          Util.each(cfgs2copy, function (cfg) {
            if (labelCfg[cfg]) {
              labelRenderer.set(cfg, labelCfg[cfg]);
            }
          });
          labelRenderer.set('coord', self.get('coord'));
          labelRenderer.set('group', group.addGroup());
          labelRenderer.set('canvas', self.get('canvas'));
        };

        _proto._parseTicks = function _parseTicks(ticks) {
          ticks = ticks || [];
          var ticksLength = ticks.length;

          for (var i = 0; i < ticksLength; i++) {
            var item = ticks[i];

            if (!Util.isObject(item)) {
              ticks[i] = this.parseTick(item, i, ticksLength);
            }
          }

          this.set('ticks', ticks);
          return ticks;
        };

        _proto._addTickItem = function _addTickItem(index, point, length, type) {
          if (type === void 0) {
            type = '';
          }

          var tickItems = this.get('tickItems');
          var subTickItems = this.get('subTickItems');
          var end = this.getTickEnd(point, length, index);
          var cfg = {
            x1: point.x,
            y1: point.y,
            x2: end.x,
            y2: end.y
          };

          if (!tickItems) {
            tickItems = [];
          }

          if (!subTickItems) {
            subTickItems = [];
          }

          if (type === 'sub') {
            subTickItems.push(cfg);
          } else {
            tickItems.push(cfg);
          }

          this.set('tickItems', tickItems);
          this.set('subTickItems', subTickItems);
        };

        _proto._renderLine = function _renderLine() {
          var self = this;
          var lineCfg = self.get('line');
          var path;

          if (lineCfg) {
            path = self.getLinePath();
            lineCfg = Util.mix({
              path: path
            }, lineCfg);
            var group = self.get('group');
            var lineShape = group.addShape('path', {
              attrs: lineCfg
            });
            lineShape.name = 'axis-line';
            self.get('appendInfo') && lineShape.setSilent('appendInfo', self.get('appendInfo'));
            self.set('lineShape', lineShape);
          }
        };

        _proto._processCatTicks = function _processCatTicks() {
          var self = this;
          var labelCfg = self.get('label');
          var tickLineCfg = self.get('tickLine');
          var ticks = self.get('ticks');
          ticks = self._parseTicks(ticks);

          var new_ticks = self._getNormalizedTicks(ticks);

          for (var i = 0; i < new_ticks.length; i += 3) {
            var p = self.getTickPoint(new_ticks[i]);
            var p0 = self.getTickPoint(new_ticks[i + 1]);
            var p1 = self.getTickPoint(new_ticks[i + 2]);
            var index = Math.floor(i / 3);
            var tick = ticks[index];

            if (tickLineCfg) {
              if (index === 0) {
                self._addTickItem(index, p0, tickLineCfg.length);
              }

              self._addTickItem(index, p1, tickLineCfg.length);
            }

            if (labelCfg) {
              self.addLabel(tick, p, index);
            }
          }
        };

        _proto._getNormalizedTicks = function _getNormalizedTicks(ticks) {
          var tickSeg = 0;

          if (ticks.length > 1) {
            tickSeg = (ticks[1].value - ticks[0].value) / 2;
          }

          var points = [];

          for (var i = 0; i < ticks.length; i++) {
            var tick = ticks[i];
            var p = tick.value;
            var p0 = tick.value - tickSeg;
            var p1 = tick.value + tickSeg;
            points.push(p, p0, p1);
          }

          var range = Util.arrayUtil.getRange(points);
          return points.map(function (p) {
            var norm = (p - range.min) / (range.max - range.min);
            return norm;
          });
        };

        _proto.addLabel = function addLabel(tick, point, index) {
          var self = this;
          var labelItems = self.get('labelItems');
          var labelRenderer = self.get('labelRenderer');
          var label = Util.deepMix({}, self.get('label'));
          var rst;

          if (labelRenderer) {
            var offset = self.get('_labelOffset');

            if (!Util.isNil(self.get('label').offset)) {
              offset = self.get('label').offset;
            }

            var vector = self.getSideVector(offset, point, index);
            point = {
              x: point.x + vector[0] + label.offsetX,
              y: point.y + vector[1] + label.offsetY
            };
            label.text = tick.text;
            label.x = point.x;
            label.y = point.y;
            label.point = point;
            label.textAlign = self.getTextAnchor(vector);

            if (point.rotate) {
              label.rotate = point.rotate;
            }

            labelItems.push(label);
          }

          return rst;
        };

        _proto._processTicks = function _processTicks() {
          var self = this;
          var labelCfg = self.get('label');
          var subTickCount = self.get('subTickCount');
          var tickLineCfg = self.get('tickLine');
          var ticks = self.get('ticks');
          ticks = self._parseTicks(ticks);
          Util.each(ticks, function (tick, index) {
            var tickPoint = self.getTickPoint(tick.value, index);

            if (tickLineCfg) {
              self._addTickItem(index, tickPoint, tickLineCfg.length);
            }

            if (labelCfg) {
              self.addLabel(tick, tickPoint, index);
            }
          });

          if (subTickCount) {
            // 如果有设置次级分点，添加次级tick
            var subTickLineCfg = self.get('subTickLine');
            Util.each(ticks, function (tick, index) {
              if (index > 0) {
                var diff = tick.value - ticks[index - 1].value;
                diff = diff / (self.get('subTickCount') + 1);

                for (var i = 1; i <= subTickCount; i++) {
                  var subTick = {
                    text: '',
                    value: index ? ticks[index - 1].value + i * diff : i * diff
                  };
                  var tickPoint = self.getTickPoint(subTick.value);
                  var subTickLength = void 0;

                  if (subTickLineCfg && subTickLineCfg.length) {
                    subTickLength = subTickLineCfg.length;
                  } else {
                    subTickLength = parseInt(tickLineCfg.length * (3 / 5), 10);
                  }

                  self._addTickItem(i - 1, tickPoint, subTickLength, 'sub');
                }
              }
            });
          }
        };

        _proto._addTickLine = function _addTickLine(ticks, lineCfg) {
          var self = this;
          var cfg = Util.mix({}, lineCfg);
          var path = [];
          Util.each(ticks, function (item) {
            path.push(['M', item.x1, item.y1]);
            path.push(['L', item.x2, item.y2]);
          });
          delete cfg.length;
          cfg.path = path;
          var group = self.get('group');
          var tickShape = group.addShape('path', {
            attrs: cfg
          });
          tickShape.name = 'axis-ticks';
          tickShape._id = self.get('_id') + '-ticks';
          tickShape.set('coord', self.get('coord'));
          self.get('appendInfo') && tickShape.setSilent('appendInfo', self.get('appendInfo'));
        };

        _proto._renderTicks = function _renderTicks() {
          var self = this;
          var tickItems = self.get('tickItems');
          var subTickItems = self.get('subTickItems');

          if (!Util.isEmpty(tickItems)) {
            var tickLineCfg = self.get('tickLine');

            self._addTickLine(tickItems, tickLineCfg);
          }

          if (!Util.isEmpty(subTickItems)) {
            var subTickLineCfg = self.get('subTickLine') || self.get('tickLine');

            self._addTickLine(subTickItems, subTickLineCfg);
          }
        };

        _proto._renderGrid = function _renderGrid() {
          var grid = this.get('grid');

          if (!grid) {
            return;
          }

          grid.coord = this.get('coord');
          grid.appendInfo = this.get('appendInfo');
          var group = this.get('group');
          this.set('gridGroup', group.addGroup(Grid, grid));
        };

        _proto._renderLabels = function _renderLabels() {
          var self = this;
          var labelRenderer = self.get('labelRenderer');
          var labelItems = self.get('labelItems');

          if (labelRenderer) {
            labelRenderer.set('items', labelItems);

            labelRenderer._dryDraw();
          }
        };

        _proto.paint = function paint() {
          var self = this;
          var tickLineCfg = self.get('tickLine');
          var alignWithLabel = true;

          if (tickLineCfg && tickLineCfg.hasOwnProperty('alignWithLabel')) {
            alignWithLabel = tickLineCfg.alignWithLabel;
          }

          self._renderLine();

          var type = self.get('type');
          var isCat = type === 'cat' || type === 'timeCat';

          if (isCat && alignWithLabel === false) {
            self._processCatTicks();
          } else {
            self._processTicks();
          }

          self._renderTicks();

          self._renderGrid();

          self._renderLabels();

          var labelCfg = this.get('label');

          if (labelCfg && labelCfg.autoRotate) {
            self.autoRotateLabels();
          }

          if (labelCfg && labelCfg.autoHide) {
            self.autoHideLabels();
          }
        };

        _proto.parseTick = function parseTick(tick, index, length) {
          return {
            text: tick,
            value: index / (length - 1)
          };
        };

        _proto.getTextAnchor = function getTextAnchor(vector) {
          var ratio = Math.abs(vector[1] / vector[0]);
          var align;

          if (ratio >= 1) {
            // 上面或者下面
            align = 'center';
          } else {
            if (vector[0] > 0) {
              // 右侧
              align = 'start';
            } else {
              // 左侧
              align = 'end';
            }
          }

          return align;
        };

        _proto.getMaxLabelWidth = function getMaxLabelWidth(labelRenderer) {
          var labels = labelRenderer.getLabels();
          var max = 0;
          Util.each(labels, function (label) {
            var bbox = label.getBBox();
            var width = bbox.width;

            if (max < width) {
              max = width;
            }
          });
          return max;
        };

        _proto.getMaxLabelHeight = function getMaxLabelHeight(labelRenderer) {
          var labels = labelRenderer.getLabels();
          var max = 0;
          Util.each(labels, function (label) {
            var bbox = label.getBBox();
            var height = bbox.height;

            if (max < height) {
              max = height;
            }
          });
          return max;
        };

        _proto.destroy = function destroy() {
          var self = this;

          if (!self.destroyed) {
            var gridGroup = self.get('gridGroup');
            gridGroup && gridGroup.remove();
            var labelRenderer = this.get('labelRenderer');
            labelRenderer && labelRenderer.destroy();
            var group = self.get('group');
            group.destroy();

            _Component.prototype.destroy.call(this); // 要最后调用 super.destroy 否则 get 属性会无效

          }
        };

        _proto.clear = function clear() {
          var self = this;
          var group = self.get('group');

          if (!group.get('destroyed') && group.get('children').length) {
            var gridGroup = self.get('gridGroup');
            gridGroup && gridGroup.clear();
            var labelRenderer = this.get('labelRenderer');
            labelRenderer && labelRenderer.clear();

            var _group = self.get('group');

            _group.clear();
          }
        }
        /**
         * 旋转文本
         * @abstract
         * @return {[type]} [description]
         */
        ;

        _proto.autoRotateLabels = function autoRotateLabels() {}
        /**
         * 文本自动防遮罩
         * @abstract
         * @return {[type]} [description]
         */
        ;

        _proto.autoHideLabels = function autoHideLabels() {}
        /**
         * 渲染标题
         * @abstract
         * @return {[type]} [description]
         */
        ;

        _proto.renderTitle = function renderTitle() {}
        /**
         * 获取坐标轴线的 path
         * @abstract
         * @return {[type]} [description]
         */
        ;

        _proto.getLinePath = function getLinePath() {}
        /**
         * 获取 tick 在画布上的位置
         * @abstract
         * @return {[type]} [description]
         */
        ;

        _proto.getTickPoint = function getTickPoint() {}
        /**
         * 获取标示坐标点的线的终点
         * @abstract
         * @return {[type]} [description]
         */
        ;

        _proto.getTickEnd = function getTickEnd() {}
        /**
         * 获取距离坐标轴的向量
         * @abstract
         * @return {[type]} [description]
         */
        ;

        _proto.getSideVector = function getSideVector() {};

        return Axis;
      }(Component);

      module.exports = Axis;
      /***/
    },
    /* 32 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Base = __webpack_require__(67);

      var Component = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Component, _Base);

        function Component() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Component.prototype; // 配置

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {
            // 顶层标志位
            _id: null,
            // 用于动画
            // 容器
            canvas: null,
            container: null,
            // html，可选
            group: null,
            // G Group，可选
            // 交互属性
            capture: false,
            // props
            coord: null,
            offset: [0, 0],
            plotRange: null,
            // BBox
            position: [0, 0],
            visible: true,
            zIndex: 1
          };
        } // 基础生命周期
        ;

        _proto._init = function _init() {};

        _proto.clear = function clear() {};

        _proto.destroy = function destroy() {
          // 之前未指定销毁
          _Base.prototype.destroy.call(this);
        } // 绘图
        ;

        _proto.beforeRender = function beforeRender() {};

        _proto.render = function render() {} // 初始化、绑事件和绘图
        ;

        _proto.afterRender = function afterRender() {};

        _proto.beforeDraw = function beforeDraw() {};

        _proto.draw = function draw() {} // 单纯更新视图
        ;

        _proto.afterDraw = function afterDraw() {} // visibility
        ;

        _proto.show = function show() {};

        _proto.hide = function hide() {} // props operating syntactic sugar
        ;

        _proto.setOffset = function setOffset() {};

        _proto.setPosition = function setPosition() {};

        _proto.setVisible = function setVisible() {};

        _proto.setZIndex = function setZIndex() {};

        return Component;
      }(Base);

      module.exports = Component;
      /***/
    },
    /* 33 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The measurement of linear data scale function
       * @author dxq613@gmail.com
       */


      var isNil = __webpack_require__(5);

      var each = __webpack_require__(2);

      var Base = __webpack_require__(18);

      var numberAuto = __webpack_require__(175);
      /**
       * 线性度量
       * @class Scale.Linear
       */


      var Linear = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Linear, _Base);

        function Linear() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Linear.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          _Base.prototype._initDefaultCfg.call(this);

          var self = this;
          self.type = 'linear';
          self.isLinear = true;
          /**
           * 是否为了用户习惯，优化min,max和ticks，如果进行优化，则会根据生成的ticks调整min,max，否则舍弃(min,max)范围之外的ticks
           * @type {Boolean}
           * @default false
           */

          self.nice = false;
          /**
           * min value of the scale
           * @type {Number}
           * @default null
           */

          self.min = null;
          /**
           * min value limitted of the scale
           * @type {Number}
           * @default null
           */

          self.minLimit = null;
          /**
           * max value of the scale
           * @type {Number}
           * @default null
           */

          self.max = null;
          /**
           * max value limitted of the scale
           * @type {Number}
           * @default null
           */

          self.maxLimit = null;
          /**
           * 自动生成标记时的个数
           * @type {Number}
           * @default null
           */

          self.tickCount = null;
          /**
           * 坐标轴点之间的间距，指的是真实数据的差值
           * @type {Number}
           * @default null
           */

          self.tickInterval = null;
          /**
           * 坐标轴点之间的最小间距，指的是真实数据的差值
           * @type {Number}
           * @default null
           */

          self.minTickInterval = null;
          /**
           * 用于计算坐标点时逼近的数组
           * @type {Array}
           */

          self.snapArray = null;
        }
        /**
         * @protected
         * @override
         */
        ;

        _proto.init = function init() {
          var self = this;

          if (!self.ticks) {
            self.min = self.translate(self.min);
            self.max = self.translate(self.max);
            self.initTicks();
          } else {
            var ticks = self.ticks;
            var firstValue = self.translate(ticks[0]);
            var lastValue = self.translate(ticks[ticks.length - 1]);

            if (isNil(self.min) || self.min > firstValue) {
              self.min = firstValue;
            }

            if (isNil(self.max) || self.max < lastValue) {
              self.max = lastValue;
            }
          }
        }
        /**
         * 计算坐标点
         * @protected
         * @return {Array} 计算完成的坐标点
         */
        ;

        _proto.calculateTicks = function calculateTicks() {
          var min = this.min,
              max = this.max,
              minLimit = this.minLimit,
              maxLimit = this.maxLimit,
              tickCount = this.tickCount,
              tickInterval = this.tickInterval,
              minTickInterval = this.minTickInterval,
              snapArray = this.snapArray;

          if (tickCount === 1) {
            throw new Error('linear scale\'tickCount should not be 1');
          }

          if (max < min) {
            throw new Error("max: " + max + " should not be less than min: " + min);
          }

          var tmp = numberAuto({
            min: min,
            max: max,
            minLimit: minLimit,
            maxLimit: maxLimit,
            minCount: tickCount,
            maxCount: tickCount,
            interval: tickInterval,
            minTickInterval: minTickInterval,
            snapArray: snapArray
          });
          return tmp.ticks;
        } // 初始化ticks
        ;

        _proto.initTicks = function initTicks() {
          var self = this;
          var calTicks = self.calculateTicks();

          if (self.nice) {
            // 如果需要优化显示的tick
            self.ticks = calTicks;
            self.min = calTicks[0];
            self.max = calTicks[calTicks.length - 1];
          } else {
            var ticks = [];
            each(calTicks, function (tick) {
              if (tick >= self.min && tick <= self.max) {
                ticks.push(tick);
              }
            }); // 如果 ticks 为空，直接输入最小值、最大值

            if (!ticks.length) {
              ticks.push(self.min);
              ticks.push(self.max);
            }

            self.ticks = ticks;
          }
        }
        /**
         * @override
         */
        ;

        _proto.scale = function scale(value) {
          if (isNil(value)) {
            return NaN;
          }

          var max = this.max;
          var min = this.min;

          if (max === min) {
            return 0;
          }

          var percent = (value - min) / (max - min);
          var rangeMin = this.rangeMin();
          var rangeMax = this.rangeMax();
          return rangeMin + percent * (rangeMax - rangeMin);
        }
        /**
         * @override
         */
        ;

        _proto.invert = function invert(value) {
          var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
          return this.min + percent * (this.max - this.min);
        };

        return Linear;
      }(Base);

      Base.Linear = Linear;
      module.exports = Linear;
      /***/
    },
    /* 34 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(13);

      function toArray(value) {
        return isArrayLike(value) ? Array.prototype.slice.call(value) : [];
      }

      module.exports = toArray;
      /***/
    },
    /* 35 */

    /***/
    function (module, exports) {
      var PRECISION = 0.00001; // numbers less than this is considered as 0

      module.exports = function isNumberEqual(a, b) {
        var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;
        return Math.abs(a - b) < precision;
      };
      /***/

    },
    /* 36 */

    /***/
    function (module, exports, __webpack_require__) {
      var vec2 = __webpack_require__(1).vec2;

      module.exports = {
        at: function at(p1, p2, t) {
          return (p2 - p1) * t + p1;
        },
        pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
          var d = [x2 - x1, y2 - y1];

          if (vec2.exactEquals(d, [0, 0])) {
            return NaN;
          }

          var u = [-d[1], d[0]];
          vec2.normalize(u, u);
          var a = [x - x1, y - y1];
          return Math.abs(vec2.dot(a, u));
        },
        box: function box(x1, y1, x2, y2, lineWidth) {
          var halfWidth = lineWidth / 2;
          var minX = Math.min(x1, x2);
          var maxX = Math.max(x1, x2);
          var minY = Math.min(y1, y2);
          var maxY = Math.max(y1, y2);
          return {
            minX: minX - halfWidth,
            minY: minY - halfWidth,
            maxX: maxX + halfWidth,
            maxY: maxY + halfWidth
          };
        },
        len: function len(x1, y1, x2, y2) {
          return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
      };
      /***/
    },
    /* 37 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      function circlePoint(cx, cy, r, angle) {
        return {
          x: Math.cos(angle) * r + cx,
          y: Math.sin(angle) * r + cy
        };
      }

      function angleNearTo(angle, min, max, out) {
        var v1;
        var v2;

        if (out) {
          if (angle < min) {
            v1 = min - angle;
            v2 = Math.PI * 2 - max + angle;
          } else if (angle > max) {
            v1 = Math.PI * 2 - angle + min;
            v2 = angle - max;
          }
        } else {
          v1 = angle - min;
          v2 = max - angle;
        }

        return v1 > v2 ? max : min;
      }

      function nearAngle(angle, startAngle, endAngle, clockwise) {
        var plus = 0;

        if (endAngle - startAngle >= Math.PI * 2) {
          plus = Math.PI * 2;
        }

        startAngle = Util.mod(startAngle, Math.PI * 2);
        endAngle = Util.mod(endAngle, Math.PI * 2) + plus;
        angle = Util.mod(angle, Math.PI * 2);

        if (clockwise) {
          if (startAngle >= endAngle) {
            if (angle > endAngle && angle < startAngle) {
              return angle;
            }

            return angleNearTo(angle, endAngle, startAngle, true);
          }

          if (angle < startAngle || angle > endAngle) {
            return angle;
          }

          return angleNearTo(angle, startAngle, endAngle);
        }

        if (startAngle <= endAngle) {
          if (startAngle < angle && angle < endAngle) {
            return angle;
          }

          return angleNearTo(angle, startAngle, endAngle, true);
        }

        if (angle > startAngle || angle < endAngle) {
          return angle;
        }

        return angleNearTo(angle, endAngle, startAngle);
      }

      function arcProjectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y, out) {
        var v = [x, y];
        var v0 = [cx, cy];
        var v1 = [1, 0];
        var subv = Util.vec2.subtract([], v, v0);
        var angle = Util.vec2.angleTo(v1, subv);
        angle = nearAngle(angle, startAngle, endAngle, clockwise);
        var vpoint = [r * Math.cos(angle) + cx, r * Math.sin(angle) + cy];

        if (out) {
          out.x = vpoint[0];
          out.y = vpoint[1];
        }

        var d = Util.vec2.distance(vpoint, v);
        return d;
      }

      function arcBox(cx, cy, r, startAngle, endAngle, clockwise) {
        var angleRight = 0;
        var angleBottom = Math.PI / 2;
        var angleLeft = Math.PI;
        var angleTop = Math.PI * 3 / 2;
        var points = [];
        var angle = nearAngle(angleRight, startAngle, endAngle, clockwise);

        if (angle === angleRight) {
          points.push(circlePoint(cx, cy, r, angleRight));
        }

        angle = nearAngle(angleBottom, startAngle, endAngle, clockwise);

        if (angle === angleBottom) {
          points.push(circlePoint(cx, cy, r, angleBottom));
        }

        angle = nearAngle(angleLeft, startAngle, endAngle, clockwise);

        if (angle === angleLeft) {
          points.push(circlePoint(cx, cy, r, angleLeft));
        }

        angle = nearAngle(angleTop, startAngle, endAngle, clockwise);

        if (angle === angleTop) {
          points.push(circlePoint(cx, cy, r, angleTop));
        }

        points.push(circlePoint(cx, cy, r, startAngle));
        points.push(circlePoint(cx, cy, r, endAngle));
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        Util.each(points, function (point) {
          if (minX > point.x) {
            minX = point.x;
          }

          if (maxX < point.x) {
            maxX = point.x;
          }

          if (minY > point.y) {
            minY = point.y;
          }

          if (maxY < point.y) {
            maxY = point.y;
          }
        });
        return {
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY
        };
      }

      module.exports = {
        nearAngle: nearAngle,
        projectPoint: function projectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y) {
          var rst = {};
          arcProjectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y, rst);
          return rst;
        },
        pointDistance: arcProjectPoint,
        box: arcBox
      };
      /***/
    },
    /* 38 */

    /***/
    function (module, exports, __webpack_require__) {
      var Format = __webpack_require__(27);

      var PathSegment = __webpack_require__(39);

      var PI = Math.PI;
      var sin = Math.sin;
      var cos = Math.cos;
      var atan2 = Math.atan2;
      var DEFAULT_LENGTH = 10;
      var DEFAULT_ANGLE = PI / 3;

      function _addArrow(ctx, attrs, x1, y1, x2, y2, isStart) {
        var leftX;
        var leftY;
        var rightX;
        var rightY;
        var offsetX;
        var offsetY;
        var angle;

        if (!attrs.fill) {
          // 闭合的不绘制箭头
          var arrowLength = attrs.arrowLength || DEFAULT_LENGTH;
          var arrowAngle = attrs.arrowAngle ? attrs.arrowAngle * PI / 180 : DEFAULT_ANGLE; // 转换为弧
          // Calculate angle

          angle = atan2(y1 - y2, x1 - x2);
          /* // Adjust angle correctly
          angle -= PI;*/
          // Calculate offset to place arrow at edge of path

          offsetX = Math.abs(attrs.lineWidth * cos(angle)) / 2;
          offsetY = Math.abs(attrs.lineWidth * sin(angle)) / 2;

          if (isStart) {
            offsetX = -offsetX;
            offsetY = -offsetY;
          } // Calculate coordinates for left half of arrow


          leftX = x2 + arrowLength * cos(angle + arrowAngle / 2);
          leftY = y2 + arrowLength * sin(angle + arrowAngle / 2); // Calculate coordinates for right half of arrow

          rightX = x2 + arrowLength * cos(angle - arrowAngle / 2);
          rightY = y2 + arrowLength * sin(angle - arrowAngle / 2);
          ctx.beginPath(); // Draw left half of arrow

          ctx.moveTo(leftX - offsetX, leftY - offsetY);
          ctx.lineTo(x2 - offsetX, y2 - offsetY); // Draw right half of arrow

          ctx.lineTo(rightX - offsetX, rightY - offsetY); // Visually connect arrow to path

          ctx.moveTo(x2 - offsetX, y2 - offsetY);
          ctx.lineTo(x2 + offsetX, y2 + offsetY); // Move back to end of path

          ctx.moveTo(x2, y2);
          ctx.stroke();
        }
      }

      function parsePath(attrs) {
        var segments = [];
        var pathArray = Format.parsePath(attrs.path);
        var preSegment;

        if (!Array.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {
          return false;
        }

        var count = pathArray.length;

        for (var i = 0; i < pathArray.length; i++) {
          var item = pathArray[i];
          preSegment = new PathSegment(item, preSegment, i === count - 1);
          segments.push(preSegment);
        }

        return segments;
      }

      function _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, isStart) {
        var shape = isStart ? attrs.startArrow : attrs.endArrow;
        var d = shape.d;
        var deg = 0;
        var x = x2 - x1;
        var y = y2 - y1;
        var tan = Math.atan(x / y);

        if (y === 0 && x < 0) {
          deg = Math.PI;
        } else if (x > 0 && y > 0) {
          deg = Math.PI / 2 - tan;
        } else if (x < 0 && y < 0) {
          deg = -Math.PI / 2 - tan;
        } else if (x >= 0 && y < 0) {
          deg = -tan - Math.PI / 2;
        } else if (x <= 0 && y > 0) {
          deg = Math.PI / 2 - tan;
        }

        var path = parsePath(shape);

        if (!path) {
          return;
        }

        if (d) {
          if (isStart) {
            x2 = x2 + Math.sin(Math.abs(tan)) * d;
            y2 = y2 + Math.cos(Math.abs(tan)) * d - 0.5 * ctx.lineWidth;
          } else {
            x2 = x2 - Math.sin(Math.abs(tan)) * d;
            y2 = y2 - Math.cos(Math.abs(tan)) * d + 0.5 * ctx.lineWidth;
          }
        }

        ctx.save();
        ctx.beginPath();
        ctx.translate(x2, y2);
        ctx.rotate(deg);

        for (var i = 0; i < path.length; i++) {
          path[i].draw(ctx);
        }

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fill();
        ctx.restore();
      }

      module.exports = {
        addStartArrow: function addStartArrow(ctx, attrs, x1, y1, x2, y2) {
          if (typeof attrs.startArrow === 'object') {
            _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, true);
          } else if (attrs.startArrow) {
            _addArrow(ctx, attrs, x1, y1, x2, y2, true);
          }
        },
        addEndArrow: function addEndArrow(ctx, attrs, x1, y1, x2, y2) {
          if (typeof attrs.endArrow === 'object') {
            _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, false);
          } else if (attrs.endArrow) {
            _addArrow(ctx, attrs, x1, y1, x2, y2, false);
          }
        }
      };
      /***/
    },
    /* 39 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Inside = __webpack_require__(55);

      var Cubic = __webpack_require__(56);

      var Quadratic = __webpack_require__(103);

      var Ellipse = __webpack_require__(104);

      var vec3 = Util.vec3;
      var mat3 = Util.mat3;
      var ARR_CMD = ['m', 'l', 'c', 'a', 'q', 'h', 'v', 't', 's', 'z'];

      function toAbsolute(x, y, curPoint) {
        // 获取绝对坐标
        return {
          x: curPoint.x + x,
          y: curPoint.y + y
        };
      }

      function toSymmetry(point, center) {
        // 点对称
        return {
          x: center.x + (center.x - point.x),
          y: center.y + (center.y - point.y)
        };
      }

      function vMag(v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      }

      function vRatio(u, v) {
        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
      }

      function vAngle(u, v) {
        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
      }

      function getArcParams(point1, point2, fa, fs, rx, ry, psiDeg) {
        var psi = Util.mod(Util.toRadian(psiDeg), Math.PI * 2);
        var x1 = point1.x;
        var y1 = point1.y;
        var x2 = point2.x;
        var y2 = point2.y;
        var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
        var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;
        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

        if (lambda > 1) {
          rx *= Math.sqrt(lambda);
          ry *= Math.sqrt(lambda);
        }

        var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
        var f = Math.sqrt((rx * rx * (ry * ry) - diff) / diff);

        if (fa === fs) {
          f *= -1;
        }

        if (isNaN(f)) {
          f = 0;
        }

        var cxp = f * rx * yp / ry;
        var cyp = f * -ry * xp / rx;
        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);

        if (vRatio(u, v) <= -1) {
          dTheta = Math.PI;
        }

        if (vRatio(u, v) >= 1) {
          dTheta = 0;
        }

        if (fs === 0 && dTheta > 0) {
          dTheta = dTheta - 2 * Math.PI;
        }

        if (fs === 1 && dTheta < 0) {
          dTheta = dTheta + 2 * Math.PI;
        }

        return [point1, cx, cy, rx, ry, theta, dTheta, psi, fs];
      }

      var PathSegment = function PathSegment(item, preSegment, isLast) {
        this.preSegment = preSegment;
        this.isLast = isLast;
        this.init(item, preSegment);
      };

      Util.augment(PathSegment, {
        init: function init(item, preSegment) {
          var command = item[0];
          preSegment = preSegment || {
            endPoint: {
              x: 0,
              y: 0
            }
          };
          var relative = ARR_CMD.indexOf(command) >= 0; // /[a-z]/.test(command);

          var cmd = relative ? command.toUpperCase() : command;
          var p = item;
          var point1;
          var point2;
          var point3;
          var point;
          var preEndPoint = preSegment.endPoint;
          var p1 = p[1];
          var p2 = p[2];

          switch (cmd) {
            default:
              break;

            case 'M':
              if (relative) {
                point = toAbsolute(p1, p2, preEndPoint);
              } else {
                point = {
                  x: p1,
                  y: p2
                };
              }

              this.command = 'M';
              this.params = [preEndPoint, point];
              this.subStart = point;
              this.endPoint = point;
              break;

            case 'L':
              if (relative) {
                point = toAbsolute(p1, p2, preEndPoint);
              } else {
                point = {
                  x: p1,
                  y: p2
                };
              }

              this.command = 'L';
              this.params = [preEndPoint, point];
              this.subStart = preSegment.subStart;
              this.endPoint = point;

              this.endTangent = function () {
                return [point.x - preEndPoint.x, point.y - preEndPoint.y];
              };

              this.startTangent = function () {
                return [preEndPoint.x - point.x, preEndPoint.y - point.y];
              };

              break;

            case 'H':
              if (relative) {
                point = toAbsolute(p1, 0, preEndPoint);
              } else {
                point = {
                  x: p1,
                  y: preEndPoint.y
                };
              }

              this.command = 'L';
              this.params = [preEndPoint, point];
              this.subStart = preSegment.subStart;
              this.endPoint = point;

              this.endTangent = function () {
                return [point.x - preEndPoint.x, point.y - preEndPoint.y];
              };

              this.startTangent = function () {
                return [preEndPoint.x - point.x, preEndPoint.y - point.y];
              };

              break;

            case 'V':
              if (relative) {
                point = toAbsolute(0, p1, preEndPoint);
              } else {
                point = {
                  x: preEndPoint.x,
                  y: p1
                };
              }

              this.command = 'L';
              this.params = [preEndPoint, point];
              this.subStart = preSegment.subStart;
              this.endPoint = point;

              this.endTangent = function () {
                return [point.x - preEndPoint.x, point.y - preEndPoint.y];
              };

              this.startTangent = function () {
                return [preEndPoint.x - point.x, preEndPoint.y - point.y];
              };

              break;

            case 'Q':
              if (relative) {
                point1 = toAbsolute(p1, p2, preEndPoint);
                point2 = toAbsolute(p[3], p[4], preEndPoint);
              } else {
                point1 = {
                  x: p1,
                  y: p2
                };
                point2 = {
                  x: p[3],
                  y: p[4]
                };
              }

              this.command = 'Q';
              this.params = [preEndPoint, point1, point2];
              this.subStart = preSegment.subStart;
              this.endPoint = point2;

              this.endTangent = function () {
                return [point2.x - point1.x, point2.y - point1.y];
              };

              this.startTangent = function () {
                return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
              };

              break;

            case 'T':
              if (relative) {
                point2 = toAbsolute(p1, p2, preEndPoint);
              } else {
                point2 = {
                  x: p1,
                  y: p2
                };
              }

              if (preSegment.command === 'Q') {
                point1 = toSymmetry(preSegment.params[1], preEndPoint);
                this.command = 'Q';
                this.params = [preEndPoint, point1, point2];
                this.subStart = preSegment.subStart;
                this.endPoint = point2;

                this.endTangent = function () {
                  return [point2.x - point1.x, point2.y - point1.y];
                };

                this.startTangent = function () {
                  return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
                };
              } else {
                this.command = 'TL';
                this.params = [preEndPoint, point2];
                this.subStart = preSegment.subStart;
                this.endPoint = point2;

                this.endTangent = function () {
                  return [point2.x - preEndPoint.x, point2.y - preEndPoint.y];
                };

                this.startTangent = function () {
                  return [preEndPoint.x - point2.x, preEndPoint.y - point2.y];
                };
              }

              break;

            case 'C':
              if (relative) {
                point1 = toAbsolute(p1, p2, preEndPoint);
                point2 = toAbsolute(p[3], p[4], preEndPoint);
                point3 = toAbsolute(p[5], p[6], preEndPoint);
              } else {
                point1 = {
                  x: p1,
                  y: p2
                };
                point2 = {
                  x: p[3],
                  y: p[4]
                };
                point3 = {
                  x: p[5],
                  y: p[6]
                };
              }

              this.command = 'C';
              this.params = [preEndPoint, point1, point2, point3];
              this.subStart = preSegment.subStart;
              this.endPoint = point3;

              this.endTangent = function () {
                return [point3.x - point2.x, point3.y - point2.y];
              };

              this.startTangent = function () {
                return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
              };

              break;

            case 'S':
              if (relative) {
                point2 = toAbsolute(p1, p2, preEndPoint);
                point3 = toAbsolute(p[3], p[4], preEndPoint);
              } else {
                point2 = {
                  x: p1,
                  y: p2
                };
                point3 = {
                  x: p[3],
                  y: p[4]
                };
              }

              if (preSegment.command === 'C') {
                point1 = toSymmetry(preSegment.params[2], preEndPoint);
                this.command = 'C';
                this.params = [preEndPoint, point1, point2, point3];
                this.subStart = preSegment.subStart;
                this.endPoint = point3;

                this.endTangent = function () {
                  return [point3.x - point2.x, point3.y - point2.y];
                };

                this.startTangent = function () {
                  return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
                };
              } else {
                this.command = 'SQ';
                this.params = [preEndPoint, point2, point3];
                this.subStart = preSegment.subStart;
                this.endPoint = point3;

                this.endTangent = function () {
                  return [point3.x - point2.x, point3.y - point2.y];
                };

                this.startTangent = function () {
                  return [preEndPoint.x - point2.x, preEndPoint.y - point2.y];
                };
              }

              break;

            case 'A':
              {
                var rx = p1;
                var ry = p2;
                var psi = p[3];
                var fa = p[4];
                var fs = p[5];

                if (relative) {
                  point = toAbsolute(p[6], p[7], preEndPoint);
                } else {
                  point = {
                    x: p[6],
                    y: p[7]
                  };
                }

                this.command = 'A';
                var params = getArcParams(preEndPoint, point, fa, fs, rx, ry, psi);
                this.params = params;
                var start = preSegment.subStart;
                this.subStart = start;
                this.endPoint = point;
                var startAngle = params[5] % (Math.PI * 2);

                if (Util.isNumberEqual(startAngle, Math.PI * 2)) {
                  startAngle = 0;
                }

                var endAngle = params[6] % (Math.PI * 2);

                if (Util.isNumberEqual(endAngle, Math.PI * 2)) {
                  endAngle = 0;
                }

                var d = 0.001;

                this.startTangent = function () {
                  if (fs === 0) {
                    d *= -1;
                  }

                  var dx = params[3] * Math.cos(startAngle - d) + params[1];
                  var dy = params[4] * Math.sin(startAngle - d) + params[2];
                  return [dx - start.x, dy - start.y];
                };

                this.endTangent = function () {
                  var endAngle = params[6];

                  if (endAngle - Math.PI * 2 < 0.0001) {
                    endAngle = 0;
                  }

                  var dx = params[3] * Math.cos(startAngle + endAngle + d) + params[1];
                  var dy = params[4] * Math.sin(startAngle + endAngle - d) + params[2];
                  return [preEndPoint.x - dx, preEndPoint.y - dy];
                };

                break;
              }

            case 'Z':
              {
                this.command = 'Z';
                this.params = [preEndPoint, preSegment.subStart];
                this.subStart = preSegment.subStart;
                this.endPoint = preSegment.subStart;
              }
          }
        },
        isInside: function isInside(x, y, lineWidth) {
          var self = this;
          var command = self.command;
          var params = self.params;
          var box = self.box;

          if (box) {
            if (!Inside.box(box.minX, box.maxX, box.minY, box.maxY, x, y)) {
              return false;
            }
          }

          switch (command) {
            default:
              break;

            case 'M':
              return false;

            case 'TL':
            case 'L':
            case 'Z':
              return Inside.line(params[0].x, params[0].y, params[1].x, params[1].y, lineWidth, x, y);

            case 'SQ':
            case 'Q':
              return Inside.quadraticline(params[0].x, params[0].y, params[1].x, params[1].y, params[2].x, params[2].y, lineWidth, x, y);

            case 'C':
              {
                return Inside.cubicline(params[0].x, params[0].y, params[1].x, params[1].y, params[2].x, params[2].y, params[3].x, params[3].y, lineWidth, x, y);
              }

            case 'A':
              {
                var p = params;
                var cx = p[1];
                var cy = p[2];
                var rx = p[3];
                var ry = p[4];
                var theta = p[5];
                var dTheta = p[6];
                var psi = p[7];
                var fs = p[8];
                var r = rx > ry ? rx : ry;
                var scaleX = rx > ry ? 1 : rx / ry;
                var scaleY = rx > ry ? ry / rx : 1;
                p = [x, y, 1];
                var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                mat3.translate(m, m, [-cx, -cy]);
                mat3.rotate(m, m, -psi);
                mat3.scale(m, m, [1 / scaleX, 1 / scaleY]);
                vec3.transformMat3(p, p, m);
                return Inside.arcline(0, 0, r, theta, theta + dTheta, 1 - fs, lineWidth, p[0], p[1]);
              }
          }

          return false;
        },
        draw: function draw(context) {
          var command = this.command;
          var params = this.params;
          var point1;
          var point2;
          var point3;

          switch (command) {
            default:
              break;

            case 'M':
              context.moveTo(params[1].x, params[1].y);
              break;

            case 'TL':
            case 'L':
              context.lineTo(params[1].x, params[1].y);
              break;

            case 'SQ':
            case 'Q':
              point1 = params[1];
              point2 = params[2];
              context.quadraticCurveTo(point1.x, point1.y, point2.x, point2.y);
              break;

            case 'C':
              point1 = params[1];
              point2 = params[2];
              point3 = params[3];
              context.bezierCurveTo(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y);
              break;

            case 'A':
              {
                var p = params;
                var p1 = p[1];
                var p2 = p[2];
                var cx = p1;
                var cy = p2;
                var rx = p[3];
                var ry = p[4];
                var theta = p[5];
                var dTheta = p[6];
                var psi = p[7];
                var fs = p[8];
                var r = rx > ry ? rx : ry;
                var scaleX = rx > ry ? 1 : rx / ry;
                var scaleY = rx > ry ? ry / rx : 1;
                context.translate(cx, cy);
                context.rotate(psi);
                context.scale(scaleX, scaleY);
                context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                context.scale(1 / scaleX, 1 / scaleY);
                context.rotate(-psi);
                context.translate(-cx, -cy);
                break;
              }

            case 'Z':
              context.closePath();
              break;
          }
        },
        getBBox: function getBBox(lineWidth) {
          var halfWidth = lineWidth / 2;
          var params = this.params;
          var yDims;
          var xDims;
          var i;
          var l;

          switch (this.command) {
            default:
            case 'M':
            case 'Z':
              break;

            case 'TL':
            case 'L':
              this.box = {
                minX: Math.min(params[0].x, params[1].x) - halfWidth,
                maxX: Math.max(params[0].x, params[1].x) + halfWidth,
                minY: Math.min(params[0].y, params[1].y) - halfWidth,
                maxY: Math.max(params[0].y, params[1].y) + halfWidth
              };
              break;

            case 'SQ':
            case 'Q':
              xDims = Quadratic.extrema(params[0].x, params[1].x, params[2].x);

              for (i = 0, l = xDims.length; i < l; i++) {
                xDims[i] = Quadratic.at(params[0].x, params[1].x, params[2].x, xDims[i]);
              }

              xDims.push(params[0].x, params[2].x);
              yDims = Quadratic.extrema(params[0].y, params[1].y, params[2].y);

              for (i = 0, l = yDims.length; i < l; i++) {
                yDims[i] = Quadratic.at(params[0].y, params[1].y, params[2].y, yDims);
              }

              yDims.push(params[0].y, params[2].y);
              this.box = {
                minX: Math.min.apply(Math, xDims) - halfWidth,
                maxX: Math.max.apply(Math, xDims) + halfWidth,
                minY: Math.min.apply(Math, yDims) - halfWidth,
                maxY: Math.max.apply(Math, yDims) + halfWidth
              };
              break;

            case 'C':
              xDims = Cubic.extrema(params[0].x, params[1].x, params[2].x, params[3].x);

              for (i = 0, l = xDims.length; i < l; i++) {
                xDims[i] = Cubic.at(params[0].x, params[1].x, params[2].x, params[3].x, xDims[i]);
              }

              yDims = Cubic.extrema(params[0].y, params[1].y, params[2].y, params[3].y);

              for (i = 0, l = yDims.length; i < l; i++) {
                yDims[i] = Cubic.at(params[0].y, params[1].y, params[2].y, params[3].y, yDims[i]);
              }

              xDims.push(params[0].x, params[3].x);
              yDims.push(params[0].y, params[3].y);
              this.box = {
                minX: Math.min.apply(Math, xDims) - halfWidth,
                maxX: Math.max.apply(Math, xDims) + halfWidth,
                minY: Math.min.apply(Math, yDims) - halfWidth,
                maxY: Math.max.apply(Math, yDims) + halfWidth
              };
              break;

            case 'A':
              {
                // todo 待优化
                var p = params;
                var cx = p[1];
                var cy = p[2];
                var rx = p[3];
                var ry = p[4];
                var theta = p[5];
                var dTheta = p[6];
                var psi = p[7];
                var fs = p[8];
                var start = theta;
                var end = theta + dTheta;
                var xDim = Ellipse.xExtrema(psi, rx, ry);
                var minX = Infinity;
                var maxX = -Infinity;
                var xs = [start, end];

                for (i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
                  var xAngle = xDim + i;

                  if (fs === 1) {
                    if (start < xAngle && xAngle < end) {
                      xs.push(xAngle);
                    }
                  } else {
                    if (end < xAngle && xAngle < start) {
                      xs.push(xAngle);
                    }
                  }
                }

                for (i = 0, l = xs.length; i < l; i++) {
                  var x = Ellipse.xAt(psi, rx, ry, cx, xs[i]);

                  if (x < minX) {
                    minX = x;
                  }

                  if (x > maxX) {
                    maxX = x;
                  }
                }

                var yDim = Ellipse.yExtrema(psi, rx, ry);
                var minY = Infinity;
                var maxY = -Infinity;
                var ys = [start, end];

                for (i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
                  var yAngle = yDim + i;

                  if (fs === 1) {
                    if (start < yAngle && yAngle < end) {
                      ys.push(yAngle);
                    }
                  } else {
                    if (end < yAngle && yAngle < start) {
                      ys.push(yAngle);
                    }
                  }
                }

                for (i = 0, l = ys.length; i < l; i++) {
                  var y = Ellipse.yAt(psi, rx, ry, cy, ys[i]);

                  if (y < minY) {
                    minY = y;
                  }

                  if (y > maxY) {
                    maxY = y;
                  }
                }

                this.box = {
                  minX: minX - halfWidth,
                  maxX: maxX + halfWidth,
                  minY: minY - halfWidth,
                  maxY: maxY + halfWidth
                };
                break;
              }
          }
        }
      });
      module.exports = PathSegment;
      /***/
    },
    /* 40 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b) {
        return a = +a, b -= a, function (t) {
          return a + b * t;
        };
      };
      /***/

    },
    /* 41 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(13);

      var indexOf = Array.prototype.indexOf;

      var contains = function contains(arr, value) {
        if (!isArrayLike(arr)) {
          return false;
        }

        return indexOf.call(arr, value) > -1;
      };

      module.exports = contains;
      /***/
    },
    /* 42 */

    /***/
    function (module, exports) {
      var merge = function merge(dataArray) {
        var rst = [];

        for (var i = 0; i < dataArray.length; i++) {
          rst = rst.concat(dataArray[i]);
        }

        return rst;
      };

      module.exports = merge;
      /***/
    },
    /* 43 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        mat3: __webpack_require__(52),
        vec2: __webpack_require__(97),
        vec3: __webpack_require__(98),
        transform: __webpack_require__(99)
      };
      /***/
    },
    /* 44 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /**
       * @fileOverview the base class of Coordinate
       * @author sima.zhang
       */


      var MatrixUtil = __webpack_require__(43);

      var mix = __webpack_require__(8);

      var mat3 = MatrixUtil.mat3;
      var vec3 = MatrixUtil.vec3;

      var Coord = /*#__PURE__*/function () {
        _createClass(Coord, [{
          key: "getDefaultCfg",

          /**
           * 获取默认的配置属性
           * @protected
           * @return {Object} 默认属性
           */
          value: function getDefaultCfg() {
            return {
              /**
               * Mark x y is transposed.
               * @type {Boolean}
               */
              isTransposed: false,

              /**
               * The matrix of coordinate
               * @type {Array}
               */
              matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
            };
          }
        }]);

        function Coord(cfg) {
          _classCallCheck(this, Coord);

          var defaultCfg = this.getDefaultCfg();
          mix(this, defaultCfg, cfg);
          this.init();
        }

        _createClass(Coord, [{
          key: "init",
          value: function init() {
            var start = this.start;
            var end = this.end;
            var center = {
              x: (start.x + end.x) / 2,
              y: (start.y + end.y) / 2
            };
            this.center = center;
            this.width = Math.abs(end.x - start.x);
            this.height = Math.abs(end.y - start.y);
          }
        }, {
          key: "_swapDim",
          value: function _swapDim(dim) {
            var dimRange = this[dim];

            if (dimRange) {
              var tmp = dimRange.start;
              dimRange.start = dimRange.end;
              dimRange.end = tmp;
            }
          }
        }, {
          key: "getCenter",
          value: function getCenter() {
            return this.center;
          }
        }, {
          key: "getWidth",
          value: function getWidth() {
            return this.width;
          }
        }, {
          key: "getHeight",
          value: function getHeight() {
            return this.height;
          }
        }, {
          key: "convertDim",
          value: function convertDim(percent, dim) {
            var _this$dim = this[dim],
                start = _this$dim.start,
                end = _this$dim.end;
            return start + percent * (end - start);
          }
        }, {
          key: "invertDim",
          value: function invertDim(value, dim) {
            var _this$dim2 = this[dim],
                start = _this$dim2.start,
                end = _this$dim2.end;
            return (value - start) / (end - start);
          }
          /**
           * 将归一化的坐标点数据转换为画布坐标
           * @override
           * @param  {Object} point 归一化的坐标点
           * @return {Object}       返回画布坐标
           */

        }, {
          key: "convertPoint",
          value: function convertPoint(point) {
            return point;
          }
          /**
           * 将画布坐标转换为归一化的坐标点数据
           * @override
           * @param  {Object} point 画布坐标点数据
           * @return {Object}       归一化后的数据点
           */

        }, {
          key: "invertPoint",
          value: function invertPoint(point) {
            return point;
          }
          /**
           * 将坐标点进行矩阵变换
           * @param  {Number} x   对应 x 轴画布坐标
           * @param  {Number} y   对应 y 轴画布坐标
           * @param  {Number} tag 默认为 0，可取值 0, 1
           * @return {Array}     返回变换后的三阶向量 [x, y, z]
           */

        }, {
          key: "applyMatrix",
          value: function applyMatrix(x, y) {
            var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var matrix = this.matrix;
            var vector = [x, y, tag];
            vec3.transformMat3(vector, vector, matrix);
            return vector;
          }
          /**
           * 将坐标点进行矩阵逆变换
           * @param  {Number} x   对应 x 轴画布坐标
           * @param  {Number} y   对应 y 轴画布坐标
           * @param  {Number} tag 默认为 0，可取值 0, 1
           * @return {Array}     返回矩阵逆变换后的三阶向量 [x, y, z]
           */

        }, {
          key: "invertMatrix",
          value: function invertMatrix(x, y) {
            var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var matrix = this.matrix;
            var inversedMatrix = mat3.invert([], matrix);
            var vector = [x, y, tag];
            vec3.transformMat3(vector, vector, inversedMatrix);
            return vector;
          }
          /**
           * 将归一化的坐标点数据转换为画布坐标，并根据坐标系当前矩阵进行变换
           * @param  {Object} point 归一化的坐标点
           * @return {Object}       返回进行矩阵变换后的画布坐标
           */

        }, {
          key: "convert",
          value: function convert(point) {
            var _this$convertPoint = this.convertPoint(point),
                x = _this$convertPoint.x,
                y = _this$convertPoint.y;

            var vector = this.applyMatrix(x, y, 1);
            return {
              x: vector[0],
              y: vector[1]
            };
          }
          /**
           * 将进行过矩阵变换画布坐标转换为归一化坐标
           * @param  {Object} point 画布坐标
           * @return {Object}       返回归一化的坐标点
           */

        }, {
          key: "invert",
          value: function invert(point) {
            var vector = this.invertMatrix(point.x, point.y, 1);
            return this.invertPoint({
              x: vector[0],
              y: vector[1]
            });
          }
          /**
           * 坐标系旋转变换
           * @param  {Number} radian 旋转弧度
           * @return {Object}        返回坐标系对象
           */

        }, {
          key: "rotate",
          value: function rotate(radian) {
            var matrix = this.matrix;
            var center = this.center;
            mat3.translate(matrix, matrix, [-center.x, -center.y]);
            mat3.rotate(matrix, matrix, radian);
            mat3.translate(matrix, matrix, [center.x, center.y]);
            return this;
          }
          /**
           * 坐标系反射变换
           * @param  {String} dim 反射维度
           * @return {Object}     返回坐标系对象
           */

        }, {
          key: "reflect",
          value: function reflect(dim) {
            switch (dim) {
              case 'x':
                this._swapDim('x');

                break;

              case 'y':
                this._swapDim('y');

                break;

              default:
                this._swapDim('y');

            }

            return this;
          }
          /**
           * 坐标系比例变换
           * @param  {Number} s1 x 方向缩放比例
           * @param  {Number} s2 y 方向缩放比例
           * @return {Object}    返回坐标系对象
           */

        }, {
          key: "scale",
          value: function scale(s1, s2) {
            var matrix = this.matrix;
            var center = this.center;
            mat3.translate(matrix, matrix, [-center.x, -center.y]);
            mat3.scale(matrix, matrix, [s1, s2]);
            mat3.translate(matrix, matrix, [center.x, center.y]);
            return this;
          }
          /**
           * 坐标系平移变换
           * @param  {Number} x x 方向平移像素
           * @param  {Number} y y 方向平移像素
           * @return {Object}   返回坐标系对象
           */

        }, {
          key: "translate",
          value: function translate(x, y) {
            var matrix = this.matrix;
            mat3.translate(matrix, matrix, [x, y]);
            return this;
          }
          /**
           * 将坐标系 x y 两个轴进行转置
           * @return {Object} 返回坐标系对象
           */

        }, {
          key: "transpose",
          value: function transpose() {
            this.isTransposed = !this.isTransposed;
            return this;
          }
        }]);

        return Coord;
      }();

      module.exports = Coord;
      /***/
    },
    /* 45 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview shape 的辅助方法
       * @author dxq613@gmail.com
       */
      var Util = __webpack_require__(0);

      var ShapeUtil = {
        splitPoints: function splitPoints(obj) {
          var points = [];
          var x = obj.x;
          var y = obj.y;
          y = Util.isArray(y) ? y : [y];
          Util.each(y, function (yItem, index) {
            var point = {
              x: Util.isArray(x) ? x[index] : x,
              y: yItem
            };
            points.push(point);
          });
          return points;
        },
        addFillAttrs: function addFillAttrs(attrs, cfg) {
          if (cfg.color) {
            attrs.fill = cfg.color;
          }

          if (Util.isNumber(cfg.opacity)) {
            attrs.opacity = attrs.fillOpacity = cfg.opacity;
          }
        },
        addStrokeAttrs: function addStrokeAttrs(attrs, cfg) {
          if (cfg.color) {
            attrs.stroke = cfg.color;
          }

          if (Util.isNumber(cfg.opacity)) {
            attrs.opacity = attrs.strokeOpacity = cfg.opacity;
          }
        }
      };
      module.exports = ShapeUtil;
      /***/
    },
    /* 46 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export CREATED */

      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "c", function () {
        return SCHEDULED;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return STARTING;
      });
      /* unused harmony export STARTED */

      /* unused harmony export RUNNING */

      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return ENDING;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return ENDED;
      });
      /* harmony export (immutable) */


      __webpack_exports__["g"] = init;
      /* harmony export (immutable) */

      __webpack_exports__["h"] = set;
      /* harmony export (immutable) */

      __webpack_exports__["f"] = get;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(453);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_d3_timer__ = __webpack_require__(170);

      var emptyOn = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a"
      /* dispatch */
      ])("start", "end", "cancel", "interrupt");
      var emptyTween = [];
      var CREATED = 0;
      var SCHEDULED = 1;
      var STARTING = 2;
      var STARTED = 3;
      var RUNNING = 4;
      var ENDING = 5;
      var ENDED = 6;
      /* harmony default export */

      __webpack_exports__["e"] = function (node, name, id, index, group, timing) {
        var schedules = node.__transition;
        if (!schedules) node.__transition = {};else if (id in schedules) return;
        create(node, id, {
          name: name,
          index: index,
          // For context during callback.
          group: group,
          // For context during callback.
          on: emptyOn,
          tween: emptyTween,
          time: timing.time,
          delay: timing.delay,
          duration: timing.duration,
          ease: timing.ease,
          timer: null,
          state: CREATED
        });
      };

      function init(node, id) {
        var schedule = get(node, id);
        if (schedule.state > CREATED) throw new Error("too late; already scheduled");
        return schedule;
      }

      function set(node, id) {
        var schedule = get(node, id);
        if (schedule.state > STARTED) throw new Error("too late; already running");
        return schedule;
      }

      function get(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
        return schedule;
      }

      function create(node, id, self) {
        var schedules = node.__transition,
            tween; // Initialize the self timer when the transition is created.
        // Note the actual delay is not known until the first callback!

        schedules[id] = self;
        self.timer = Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["timer"])(schedule, 0, self.time);

        function schedule(elapsed) {
          self.state = SCHEDULED;
          self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.

          if (self.delay <= elapsed) start(elapsed - self.delay);
        }

        function start(elapsed) {
          var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.

          if (self.state !== SCHEDULED) return stop();

          for (i in schedules) {
            o = schedules[i];
            if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,
            // defer starting an interrupting transition until that transition has a
            // chance to tick (and possibly end); see d3/d3-transition#54!

            if (o.state === STARTED) return Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["timeout"])(start); // Interrupt the active transition, if any.

            if (o.state === RUNNING) {
              o.state = ENDED;
              o.timer.stop();
              o.on.call("interrupt", node, node.__data__, o.index, o.group);
              delete schedules[i];
            } // Cancel any pre-empted transitions.
            else if (+i < id) {
                o.state = ENDED;
                o.timer.stop();
                o.on.call("cancel", node, node.__data__, o.index, o.group);
                delete schedules[i];
              }
          } // Defer the first tick to end of the current frame; see d3/d3#1576.
          // Note the transition may be canceled after start and before the first tick!
          // Note this must be scheduled before the start event; see d3/d3-transition#16!
          // Assuming this is successful, subsequent callbacks go straight to tick.


          Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["timeout"])(function () {
            if (self.state === STARTED) {
              self.state = RUNNING;
              self.timer.restart(tick, self.delay, self.time);
              tick(elapsed);
            }
          }); // Dispatch the start event.
          // Note this must be done before the tween are initialized.

          self.state = STARTING;
          self.on.call("start", node, node.__data__, self.index, self.group);
          if (self.state !== STARTING) return; // interrupted

          self.state = STARTED; // Initialize the tween, deleting null tween.

          tween = new Array(n = self.tween.length);

          for (i = 0, j = -1; i < n; ++i) {
            if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
              tween[++j] = o;
            }
          }

          tween.length = j + 1;
        }

        function tick(elapsed) {
          var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
              i = -1,
              n = tween.length;

          while (++i < n) {
            tween[i].call(node, t);
          } // Dispatch the end event.


          if (self.state === ENDING) {
            self.on.call("end", node, node.__data__, self.index, self.group);
            stop();
          }
        }

        function stop() {
          self.state = ENDED;
          self.timer.stop();
          delete schedules[id];

          for (var i in schedules) {
            return;
          } // eslint-disable-line no-unused-vars


          delete node.__transition;
        }
      }
      /***/

    },
    /* 47 */

    /***/
    function (module, exports, __webpack_require__) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var isArray = __webpack_require__(4);

      var clone = function clone(obj) {
        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
          return obj;
        }

        var rst = void 0;

        if (isArray(obj)) {
          rst = [];

          for (var i = 0, l = obj.length; i < l; i++) {
            if (_typeof(obj[i]) === 'object' && obj[i] != null) {
              rst[i] = clone(obj[i]);
            } else {
              rst[i] = obj[i];
            }
          }
        } else {
          rst = {};

          for (var k in obj) {
            if (_typeof(obj[k]) === 'object' && obj[k] != null) {
              rst[k] = clone(obj[k]);
            } else {
              rst[k] = obj[k];
            }
          }
        }

        return rst;
      };

      module.exports = clone;
      /***/
    },
    /* 48 */

    /***/
    function (module, exports, __webpack_require__) {
      var isPlainObject = __webpack_require__(26);

      var isArray = __webpack_require__(4);

      var MAX_MIX_LEVEL = 5;

      function _deepMix(dist, src, level, maxLevel) {
        level = level || 0;
        maxLevel = maxLevel || MAX_MIX_LEVEL;

        for (var key in src) {
          if (src.hasOwnProperty(key)) {
            var value = src[key];

            if (value !== null && isPlainObject(value)) {
              if (!isPlainObject(dist[key])) {
                dist[key] = {};
              }

              if (level < maxLevel) {
                _deepMix(dist[key], value, level + 1, maxLevel);
              } else {
                dist[key] = src[key];
              }
            } else if (isArray(value)) {
              dist[key] = [];
              dist[key] = dist[key].concat(value);
            } else if (value !== undefined) {
              dist[key] = value;
            }
          }
        }
      }

      var deepMix = function deepMix() {
        var args = new Array(arguments.length);
        var length = args.length;

        for (var i = 0; i < length; i++) {
          args[i] = arguments[i];
        }

        var rst = args[0];

        for (var _i = 1; _i < length; _i++) {
          _deepMix(rst, args[_i]);
        }

        return rst;
      };

      module.exports = deepMix;
      /***/
    },
    /* 49 */

    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var isObjectLike = function isObjectLike(value) {
        /**
         * isObjectLike({}) => true
         * isObjectLike([1, 2, 3]) => true
         * isObjectLike(Function) => false
         * isObjectLike(null) => false
         */
        return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
      };

      module.exports = isObjectLike;
      /***/
    },
    /* 50 */

    /***/
    function (module, exports, __webpack_require__) {
      var isObjectLike = __webpack_require__(49);

      var isArrayLike = __webpack_require__(13);

      var isString = __webpack_require__(10);

      var isEqual = function isEqual(value, other) {
        if (value === other) {
          return true;
        }

        if (!value || !other) {
          return false;
        }

        if (isString(value) || isString(other)) {
          return false;
        }

        if (isArrayLike(value) || isArrayLike(other)) {
          if (value.length !== other.length) {
            return false;
          }

          var rst = true;

          for (var i = 0; i < value.length; i++) {
            rst = isEqual(value[i], other[i]);

            if (!rst) {
              break;
            }
          }

          return rst;
        }

        if (isObjectLike(value) || isObjectLike(other)) {
          var valueKeys = Object.keys(value);
          var otherKeys = Object.keys(other);

          if (valueKeys.length !== otherKeys.length) {
            return false;
          }

          var _rst = true;

          for (var _i = 0; _i < valueKeys.length; _i++) {
            _rst = isEqual(value[valueKeys[_i]], other[valueKeys[_i]]);

            if (!_rst) {
              break;
            }
          }

          return _rst;
        }

        return false;
      };

      module.exports = isEqual;
      /***/
    },
    /* 51 */

    /***/
    function (module, exports) {
      var clamp = function clamp(a, min, max) {
        if (a < min) {
          return min;
        } else if (a > max) {
          return max;
        }

        return a;
      };

      module.exports = clamp;
      /***/
    },
    /* 52 */

    /***/
    function (module, exports, __webpack_require__) {
      var mat3 = __webpack_require__(183);

      mat3.translate = function (out, a, v) {
        var transMat = new Array(9);
        mat3.fromTranslation(transMat, v);
        return mat3.multiply(out, transMat, a);
      };

      mat3.rotate = function (out, a, rad) {
        var rotateMat = new Array(9);
        mat3.fromRotation(rotateMat, rad);
        return mat3.multiply(out, rotateMat, a);
      };

      mat3.scale = function (out, a, v) {
        var scaleMat = new Array(9);
        mat3.fromScaling(scaleMat, v);
        return mat3.multiply(out, scaleMat, a);
      };

      module.exports = mat3;
      /***/
    },
    /* 53 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setMatrixArrayType = setMatrixArrayType;
      exports.toRadian = toRadian;
      exports.equals = equals;
      /**
       * Common utilities
       * @module glMatrix
       */
      // Configuration Constants

      var EPSILON = exports.EPSILON = 0.000001;
      var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
      var RANDOM = exports.RANDOM = Math.random;
      /**
       * Sets the type of array used when creating new vectors and matrices
       *
       * @param {Type} type Array type, such as Float32Array or Array
       */

      function setMatrixArrayType(type) {
        exports.ARRAY_TYPE = ARRAY_TYPE = type;
      }

      var degree = Math.PI / 180;
      /**
       * Convert Degree To Radian
       *
       * @param {Number} a Angle in Degrees
       */

      function toRadian(a) {
        return a * degree;
      }
      /**
       * Tests whether or not the arguments have approximately the same value, within an absolute
       * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
       * than or equal to 1.0, and a relative tolerance is used for larger values)
       *
       * @param {Number} a The first number to test.
       * @param {Number} b The second number to test.
       * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
       */


      function equals(a, b) {
        return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
      }
      /***/

    },
    /* 54 */

    /***/
    function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*!
      * EventEmitter v5.1.0 - git.io/ee
      * Unlicense - http://unlicense.org/
      * Oliver Caldwell - http://oli.me.uk/
      * @preserve
      */


      ;

      (function (exports) {
        'use strict';
        /**
         * Class for managing events.
         * Can be extended to provide event functionality in other classes.
         *
         * @class EventEmitter Manages event registering and emitting.
         */

        function EventEmitter() {} // Shortcuts to improve speed and size


        var proto = EventEmitter.prototype;
        var originalGlobalValue = exports.EventEmitter;
        /**
         * Finds the index of the listener for the event in its storage array.
         *
         * @param {Function[]} listeners Array of listeners to search through.
         * @param {Function} listener Method to look for.
         * @return {Number} Index of the specified listener, -1 if not found
         * @api private
         */

        function indexOfListener(listeners, listener) {
          var i = listeners.length;

          while (i--) {
            if (listeners[i].listener === listener) {
              return i;
            }
          }

          return -1;
        }
        /**
         * Alias a method while keeping the context correct, to allow for overwriting of target method.
         *
         * @param {String} name The name of the target method.
         * @return {Function} The aliased method
         * @api private
         */


        function alias(name) {
          return function aliasClosure() {
            return this[name].apply(this, arguments);
          };
        }
        /**
         * Returns the listener array for the specified event.
         * Will initialise the event object and listener arrays if required.
         * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
         * Each property in the object response is an array of listener functions.
         *
         * @param {String|RegExp} evt Name of the event to return the listeners from.
         * @return {Function[]|Object} All listener functions for the event.
         */


        proto.getListeners = function getListeners(evt) {
          var events = this._getEvents();

          var response;
          var key; // Return a concatenated array of all matching events if
          // the selector is a regular expression.

          if (evt instanceof RegExp) {
            response = {};

            for (key in events) {
              if (events.hasOwnProperty(key) && evt.test(key)) {
                response[key] = events[key];
              }
            }
          } else {
            response = events[evt] || (events[evt] = []);
          }

          return response;
        };
        /**
         * Takes a list of listener objects and flattens it into a list of listener functions.
         *
         * @param {Object[]} listeners Raw listener objects.
         * @return {Function[]} Just the listener functions.
         */


        proto.flattenListeners = function flattenListeners(listeners) {
          var flatListeners = [];
          var i;

          for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
          }

          return flatListeners;
        };
        /**
         * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
         *
         * @param {String|RegExp} evt Name of the event to return the listeners from.
         * @return {Object} All listener functions for an event in an object.
         */


        proto.getListenersAsObject = function getListenersAsObject(evt) {
          var listeners = this.getListeners(evt);
          var response;

          if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
          }

          return response || listeners;
        };

        function isValidListener(listener) {
          if (typeof listener === 'function' || listener instanceof RegExp) {
            return true;
          } else if (listener && typeof listener === 'object') {
            return isValidListener(listener.listener);
          } else {
            return false;
          }
        }
        /**
         * Adds a listener function to the specified event.
         * The listener will not be added if it is a duplicate.
         * If the listener returns true then it will be removed after it is called.
         * If you pass a regular expression as the event name then the listener will be added to all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to attach the listener to.
         * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
         * @return {Object} Current instance of EventEmitter for chaining.
         */


        proto.addListener = function addListener(evt, listener) {
          if (!isValidListener(listener)) {
            throw new TypeError('listener must be a function');
          }

          var listeners = this.getListenersAsObject(evt);
          var listenerIsWrapped = typeof listener === 'object';
          var key;

          for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
              listeners[key].push(listenerIsWrapped ? listener : {
                listener: listener,
                once: false
              });
            }
          }

          return this;
        };
        /**
         * Alias of addListener
         */


        proto.on = alias('addListener');
        /**
         * Semi-alias of addListener. It will add a listener that will be
         * automatically removed after its first execution.
         *
         * @param {String|RegExp} evt Name of the event to attach the listener to.
         * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
         * @return {Object} Current instance of EventEmitter for chaining.
         */

        proto.addOnceListener = function addOnceListener(evt, listener) {
          return this.addListener(evt, {
            listener: listener,
            once: true
          });
        };
        /**
         * Alias of addOnceListener.
         */


        proto.once = alias('addOnceListener');
        /**
         * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
         * You need to tell it what event names should be matched by a regex.
         *
         * @param {String} evt Name of the event to create.
         * @return {Object} Current instance of EventEmitter for chaining.
         */

        proto.defineEvent = function defineEvent(evt) {
          this.getListeners(evt);
          return this;
        };
        /**
         * Uses defineEvent to define multiple events.
         *
         * @param {String[]} evts An array of event names to define.
         * @return {Object} Current instance of EventEmitter for chaining.
         */


        proto.defineEvents = function defineEvents(evts) {
          for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
          }

          return this;
        };
        /**
         * Removes a listener function from the specified event.
         * When passed a regular expression as the event name, it will remove the listener from all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to remove the listener from.
         * @param {Function} listener Method to remove from the event.
         * @return {Object} Current instance of EventEmitter for chaining.
         */


        proto.removeListener = function removeListener(evt, listener) {
          var listeners = this.getListenersAsObject(evt);
          var index;
          var key;

          for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
              index = indexOfListener(listeners[key], listener);

              if (index !== -1) {
                listeners[key].splice(index, 1);
              }
            }
          }

          return this;
        };
        /**
         * Alias of removeListener
         */


        proto.off = alias('removeListener');
        /**
         * Adds listeners in bulk using the manipulateListeners method.
         * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
         * You can also pass it a regular expression to add the array of listeners to all events that match it.
         * Yeah, this function does quite a bit. That's probably a bad thing.
         *
         * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
         * @param {Function[]} [listeners] An optional array of listener functions to add.
         * @return {Object} Current instance of EventEmitter for chaining.
         */

        proto.addListeners = function addListeners(evt, listeners) {
          // Pass through to manipulateListeners
          return this.manipulateListeners(false, evt, listeners);
        };
        /**
         * Removes listeners in bulk using the manipulateListeners method.
         * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
         * You can also pass it an event name and an array of listeners to be removed.
         * You can also pass it a regular expression to remove the listeners from all events that match it.
         *
         * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
         * @param {Function[]} [listeners] An optional array of listener functions to remove.
         * @return {Object} Current instance of EventEmitter for chaining.
         */


        proto.removeListeners = function removeListeners(evt, listeners) {
          // Pass through to manipulateListeners
          return this.manipulateListeners(true, evt, listeners);
        };
        /**
         * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
         * The first argument will determine if the listeners are removed (true) or added (false).
         * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
         * You can also pass it an event name and an array of listeners to be added/removed.
         * You can also pass it a regular expression to manipulate the listeners of all events that match it.
         *
         * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
         * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
         * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
         * @return {Object} Current instance of EventEmitter for chaining.
         */


        proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
          var i;
          var value;
          var single = remove ? this.removeListener : this.addListener;
          var multiple = remove ? this.removeListeners : this.addListeners; // If evt is an object then pass each of its properties to this method

          if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
              if (evt.hasOwnProperty(i) && (value = evt[i])) {
                // Pass the single listener straight through to the singular method
                if (typeof value === 'function') {
                  single.call(this, i, value);
                } else {
                  // Otherwise pass back to the multiple function
                  multiple.call(this, i, value);
                }
              }
            }
          } else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;

            while (i--) {
              single.call(this, evt, listeners[i]);
            }
          }

          return this;
        };
        /**
         * Removes all listeners from a specified event.
         * If you do not specify an event then all listeners will be removed.
         * That means every event will be emptied.
         * You can also pass a regex to remove all events that match it.
         *
         * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
         * @return {Object} Current instance of EventEmitter for chaining.
         */


        proto.removeEvent = function removeEvent(evt) {
          var type = typeof evt;

          var events = this._getEvents();

          var key; // Remove different things depending on the state of evt

          if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
          } else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for (key in events) {
              if (events.hasOwnProperty(key) && evt.test(key)) {
                delete events[key];
              }
            }
          } else {
            // Remove all listeners in all events
            delete this._events;
          }

          return this;
        };
        /**
         * Alias of removeEvent.
         *
         * Added to mirror the node API.
         */


        proto.removeAllListeners = alias('removeEvent');
        /**
         * Emits an event of your choice.
         * When emitted, every listener attached to that event will be executed.
         * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
         * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
         * So they will not arrive within the array on the other side, they will be separate.
         * You can also pass a regular expression to emit to all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
         * @param {Array} [args] Optional array of arguments to be passed to each listener.
         * @return {Object} Current instance of EventEmitter for chaining.
         */

        proto.emitEvent = function emitEvent(evt, args) {
          var listenersMap = this.getListenersAsObject(evt);
          var listeners;
          var listener;
          var i;
          var key;
          var response;

          for (key in listenersMap) {
            if (listenersMap.hasOwnProperty(key)) {
              listeners = listenersMap[key].slice(0);

              for (i = 0; i < listeners.length; i++) {
                // If the listener returns true then it shall be removed from the event
                // The function is executed either with a basic call or an apply if there is an args array
                listener = listeners[i];

                if (listener.once === true) {
                  this.removeListener(evt, listener.listener);
                }

                response = listener.listener.apply(this, args || []);

                if (response === this._getOnceReturnValue()) {
                  this.removeListener(evt, listener.listener);
                }
              }
            }
          }

          return this;
        };
        /**
         * Alias of emitEvent
         */


        proto.trigger = alias('emitEvent');
        /**
         * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
         * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
         * @param {...*} Optional additional arguments to be passed to each listener.
         * @return {Object} Current instance of EventEmitter for chaining.
         */

        proto.emit = function emit(evt) {
          var args = Array.prototype.slice.call(arguments, 1);
          return this.emitEvent(evt, args);
        };
        /**
         * Sets the current value to check against when executing listeners. If a
         * listeners return value matches the one set here then it will be removed
         * after execution. This value defaults to true.
         *
         * @param {*} value The new value to check for when executing listeners.
         * @return {Object} Current instance of EventEmitter for chaining.
         */


        proto.setOnceReturnValue = function setOnceReturnValue(value) {
          this._onceReturnValue = value;
          return this;
        };
        /**
         * Fetches the current value to check against when executing listeners. If
         * the listeners return value matches this one then it should be removed
         * automatically. It will return true by default.
         *
         * @return {*|Boolean} The current value to check for or the default, true.
         * @api private
         */


        proto._getOnceReturnValue = function _getOnceReturnValue() {
          if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
          } else {
            return true;
          }
        };
        /**
         * Fetches the events object and creates one if required.
         *
         * @return {Object} The events storage object.
         * @api private
         */


        proto._getEvents = function _getEvents() {
          return this._events || (this._events = {});
        };
        /**
         * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
         *
         * @return {Function} Non conflicting EventEmitter class.
         */


        EventEmitter.noConflict = function noConflict() {
          exports.EventEmitter = originalGlobalValue;
          return EventEmitter;
        }; // Expose the class either via AMD, CommonJS or the global object


        if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return EventEmitter;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
      })(this || {});
      /***/

    },
    /* 55 */

    /***/
    function (module, exports, __webpack_require__) {
      var Line = __webpack_require__(36);

      var Quadratic = __webpack_require__(103);

      var Cubic = __webpack_require__(56);

      var Arc = __webpack_require__(37);

      module.exports = {
        line: function line(x1, y1, x2, y2, lineWidth, x, y) {
          var box = Line.box(x1, y1, x2, y2, lineWidth);

          if (!this.box(box.minX, box.maxX, box.minY, box.maxY, x, y)) {
            return false;
          }

          var d = Line.pointDistance(x1, y1, x2, y2, x, y);

          if (isNaN(d)) {
            return false;
          }

          return d <= lineWidth / 2;
        },
        polyline: function polyline(points, lineWidth, x, y) {
          var l = points.length - 1;

          if (l < 1) {
            return false;
          }

          for (var i = 0; i < l; i++) {
            var x1 = points[i][0];
            var y1 = points[i][1];
            var x2 = points[i + 1][0];
            var y2 = points[i + 1][1];

            if (this.line(x1, y1, x2, y2, lineWidth, x, y)) {
              return true;
            }
          }

          return false;
        },
        cubicline: function cubicline(x1, y1, x2, y2, x3, y3, x4, y4, lineWidth, x, y) {
          return Cubic.pointDistance(x1, y1, x2, y2, x3, y3, x4, y4, x, y) <= lineWidth / 2;
        },
        quadraticline: function quadraticline(x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
          return Quadratic.pointDistance(x1, y1, x2, y2, x3, y3, x, y) <= lineWidth / 2;
        },
        arcline: function arcline(cx, cy, r, startAngle, endAngle, clockwise, lineWidth, x, y) {
          return Arc.pointDistance(cx, cy, r, startAngle, endAngle, clockwise, x, y) <= lineWidth / 2;
        },
        rect: function rect(rx, ry, width, height, x, y) {
          return rx <= x && x <= rx + width && ry <= y && y <= ry + height;
        },
        circle: function circle(cx, cy, r, x, y) {
          return Math.pow(x - cx, 2) + Math.pow(y - cy, 2) <= Math.pow(r, 2);
        },
        box: function box(minX, maxX, minY, maxY, x, y) {
          return minX <= x && x <= maxX && minY <= y && y <= maxY;
        }
      };
      /***/
    },
    /* 56 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var vec2 = Util.vec2;

      function cubicAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return onet * onet * (onet * p3 + 3 * t * p2) + t * t * (t * p0 + 3 * onet * p1);
      }

      function cubicDerivativeAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
      }

      function cubicProjectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y, out) {
        var t;
        var interval = 0.005;
        var d = Infinity;

        var _t;

        var v1;
        var d1;
        var d2;
        var v2;
        var prev;
        var next;
        var EPSILON = 0.0001;
        var v0 = [x, y];

        for (_t = 0; _t < 1; _t += 0.05) {
          v1 = [cubicAt(x1, x2, x3, x4, _t), cubicAt(y1, y2, y3, y4, _t)];
          d1 = vec2.squaredDistance(v0, v1);

          if (d1 < d) {
            t = _t;
            d = d1;
          }
        }

        d = Infinity;

        for (var i = 0; i < 32; i++) {
          if (interval < EPSILON) {
            break;
          }

          prev = t - interval;
          next = t + interval;
          v1 = [cubicAt(x1, x2, x3, x4, prev), cubicAt(y1, y2, y3, y4, prev)];
          d1 = vec2.squaredDistance(v0, v1);

          if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
          } else {
            v2 = [cubicAt(x1, x2, x3, x4, next), cubicAt(y1, y2, y3, y4, next)];
            d2 = vec2.squaredDistance(v0, v2);

            if (next <= 1 && d2 < d) {
              t = next;
              d = d2;
            } else {
              interval *= 0.5;
            }
          }
        }

        if (out) {
          out.x = cubicAt(x1, x2, x3, x4, t);
          out.y = cubicAt(y1, y2, y3, y4, t);
        }

        return Math.sqrt(d);
      }

      function cubicExtrema(p0, p1, p2, p3) {
        var a = 3 * p0 - 9 * p1 + 9 * p2 - 3 * p3;
        var b = 6 * p1 - 12 * p2 + 6 * p3;
        var c = 3 * p2 - 3 * p3;
        var extrema = [];
        var t1;
        var t2;
        var discSqrt;

        if (Util.isNumberEqual(a, 0)) {
          if (!Util.isNumberEqual(b, 0)) {
            t1 = -c / b;

            if (t1 >= 0 && t1 <= 1) {
              extrema.push(t1);
            }
          }
        } else {
          var disc = b * b - 4 * a * c;

          if (Util.isNumberEqual(disc, 0)) {
            extrema.push(-b / (2 * a));
          } else if (disc > 0) {
            discSqrt = Math.sqrt(disc);
            t1 = (-b + discSqrt) / (2 * a);
            t2 = (-b - discSqrt) / (2 * a);

            if (t1 >= 0 && t1 <= 1) {
              extrema.push(t1);
            }

            if (t2 >= 0 && t2 <= 1) {
              extrema.push(t2);
            }
          }
        }

        return extrema;
      }

      function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
        var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
      }

      function cubiclLen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (Util.isNil(z)) {
          z = 1;
        }

        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2;
        var n = 12;
        var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
        var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
        var sum = 0;

        for (var i = 0; i < n; i++) {
          var ct = z2 * Tvalues[i] + z2;
          var xbase = base3(ct, x1, x2, x3, x4);
          var ybase = base3(ct, y1, y2, y3, y4);
          var comb = xbase * xbase + ybase * ybase;
          sum += Cvalues[i] * Math.sqrt(comb);
        }

        return z2 * sum;
      }

      module.exports = {
        at: cubicAt,
        derivativeAt: cubicDerivativeAt,
        projectPoint: function projectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y) {
          var rst = {};
          cubicProjectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y, rst);
          return rst;
        },
        pointDistance: cubicProjectPoint,
        extrema: cubicExtrema,
        len: cubiclLen
      };
      /***/
    },
    /* 57 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var Format = __webpack_require__(27);

      var PathSegment = __webpack_require__(39);

      var Marker = function Marker(cfg) {
        Marker.superclass.constructor.call(this, cfg);
      };

      Marker.Symbols = {
        // 圆
        circle: function circle(x, y, r) {
          return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];
        },
        // 正方形
        square: function square(x, y, r) {
          return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
        },
        // 菱形
        diamond: function diamond(x, y, r) {
          return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
        },
        // 三角形
        triangle: function triangle(x, y, r) {
          var diffY = r * Math.sin(1 / 3 * Math.PI);
          return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['z']];
        },
        // 倒三角形
        'triangle-down': function triangleDown(x, y, r) {
          var diffY = r * Math.sin(1 / 3 * Math.PI);
          return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
        }
      };
      Marker.ATTRS = {
        path: null,
        lineWidth: 1
      };
      Util.extend(Marker, Shape);
      Util.augment(Marker, {
        type: 'marker',
        canFill: true,
        canStroke: true,
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            x: 0,
            y: 0,
            lineWidth: 1
          };
        },
        calculateBox: function calculateBox() {
          var attrs = this._attrs;
          var cx = attrs.x;
          var cy = attrs.y;
          var r = attrs.radius;
          var lineWidth = this.getHitLineWidth();
          var halfWidth = lineWidth / 2 + r;
          return {
            minX: cx - halfWidth,
            minY: cy - halfWidth,
            maxX: cx + halfWidth,
            maxY: cy + halfWidth
          };
        },
        _getPath: function _getPath() {
          var attrs = this._attrs;
          var x = attrs.x;
          var y = attrs.y;
          var r = attrs.radius || attrs.r;
          var symbol = attrs.symbol || 'circle';
          var method;

          if (Util.isFunction(symbol)) {
            method = symbol;
          } else {
            method = Marker.Symbols[symbol];
          }

          if (!method) {
            console.warn(symbol + " marker is not supported.");
            return null;
          }

          return method(x, y, r);
        },
        createPath: function createPath(context) {
          var segments = this._cfg.segments;

          if (segments && !this._cfg.hasUpdate) {
            context.beginPath();

            for (var i = 0; i < segments.length; i++) {
              segments[i].draw(context);
            }

            return;
          }

          var path = Format.parsePath(this._getPath());
          context.beginPath();
          var preSegment;
          segments = [];

          for (var _i = 0; _i < path.length; _i++) {
            var item = path[_i];
            preSegment = new PathSegment(item, preSegment, _i === path.length - 1);
            segments.push(preSegment);
            preSegment.draw(context);
          }

          this._cfg.segments = segments;
          this._cfg.hasUpdate = false;
        }
      });
      module.exports = Marker;
      /***/
    },
    /* 58 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(81);

      var SPACES = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
      var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
      var PATH_VALUES = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments

      var parsePathString = function parsePathString(pathString) {
        if (!pathString) {
          return null;
        }

        if (typeof pathString === typeof []) {
          return pathString;
        }

        var paramCounts = {
          a: 7,
          c: 6,
          o: 2,
          h: 1,
          l: 2,
          m: 2,
          r: 4,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          u: 3,
          z: 0
        };
        var data = [];
        String(pathString).replace(PATH_COMMAND, function (a, b, c) {
          var params = [];
          var name = b.toLowerCase();
          c.replace(PATH_VALUES, function (a, b) {
            b && params.push(+b);
          });

          if (name === 'm' && params.length > 2) {
            data.push([b].concat(params.splice(0, 2)));
            name = 'l';
            b = b === 'm' ? 'l' : 'L';
          }

          if (name === 'o' && params.length === 1) {
            data.push([b, params[0]]);
          }

          if (name === 'r') {
            data.push([b].concat(params));
          } else {
            while (params.length >= paramCounts[name]) {
              data.push([b].concat(params.splice(0, paramCounts[name])));

              if (!paramCounts[name]) {
                break;
              }
            }
          }
        });
        return data;
      }; // http://schepers.cc/getting-to-the-point


      var catmullRom2bezier = function catmullRom2bezier(crp, z) {
        var d = [];

        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
          var p = [{
            x: +crp[i - 2],
            y: +crp[i - 1]
          }, {
            x: +crp[i],
            y: +crp[i + 1]
          }, {
            x: +crp[i + 2],
            y: +crp[i + 3]
          }, {
            x: +crp[i + 4],
            y: +crp[i + 5]
          }];

          if (z) {
            if (!i) {
              p[0] = {
                x: +crp[iLen - 2],
                y: +crp[iLen - 1]
              };
            } else if (iLen - 4 === i) {
              p[3] = {
                x: +crp[0],
                y: +crp[1]
              };
            } else if (iLen - 2 === i) {
              p[2] = {
                x: +crp[0],
                y: +crp[1]
              };
              p[3] = {
                x: +crp[2],
                y: +crp[3]
              };
            }
          } else {
            if (iLen - 4 === i) {
              p[3] = p[2];
            } else if (!i) {
              p[0] = {
                x: +crp[i],
                y: +crp[i + 1]
              };
            }
          }

          d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
        }

        return d;
      };

      var ellipsePath = function ellipsePath(x, y, rx, ry, a) {
        var res = [];

        if (a === null && ry === null) {
          ry = rx;
        }

        x = +x;
        y = +y;
        rx = +rx;
        ry = +ry;

        if (a !== null) {
          var rad = Math.PI / 180;
          var x1 = x + rx * Math.cos(-ry * rad);
          var x2 = x + rx * Math.cos(-a * rad);
          var y1 = y + rx * Math.sin(-ry * rad);
          var y2 = y + rx * Math.sin(-a * rad);
          res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
          res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
        }

        return res;
      };

      var pathToAbsolute = function pathToAbsolute(pathArray) {
        pathArray = parsePathString(pathArray);

        if (!pathArray || !pathArray.length) {
          return [['M', 0, 0]];
        }

        var res = [];
        var x = 0;
        var y = 0;
        var mx = 0;
        var my = 0;
        var start = 0;
        var pa0;
        var dots;

        if (pathArray[0][0] === 'M') {
          x = +pathArray[0][1];
          y = +pathArray[0][2];
          mx = x;
          my = y;
          start++;
          res[0] = ['M', x, y];
        }

        var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';

        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
          res.push(r = []);
          pa = pathArray[i];
          pa0 = pa[0];

          if (pa0 !== pa0.toUpperCase()) {
            r[0] = pa0.toUpperCase();

            switch (r[0]) {
              case 'A':
                r[1] = pa[1];
                r[2] = pa[2];
                r[3] = pa[3];
                r[4] = pa[4];
                r[5] = pa[5];
                r[6] = +pa[6] + x;
                r[7] = +pa[7] + y;
                break;

              case 'V':
                r[1] = +pa[1] + y;
                break;

              case 'H':
                r[1] = +pa[1] + x;
                break;

              case 'R':
                dots = [x, y].concat(pa.slice(1));

                for (var j = 2, jj = dots.length; j < jj; j++) {
                  dots[j] = +dots[j] + x;
                  dots[++j] = +dots[j] + y;
                }

                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                break;

              case 'O':
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
                break;

              case 'U':
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ['U'].concat(res[res.length - 1].slice(-2));
                break;

              case 'M':
                mx = +pa[1] + x;
                my = +pa[2] + y;
                break;
              // for lint

              default:
                for (var _j = 1, _jj = pa.length; _j < _jj; _j++) {
                  r[_j] = +pa[_j] + (_j % 2 ? x : y);
                }

            }
          } else if (pa0 === 'R') {
            dots = [x, y].concat(pa.slice(1));
            res.pop();
            res = res.concat(catmullRom2bezier(dots, crz));
            r = ['R'].concat(pa.slice(-2));
          } else if (pa0 === 'O') {
            res.pop();
            dots = ellipsePath(x, y, pa[1], pa[2]);
            dots.push(dots[0]);
            res = res.concat(dots);
          } else if (pa0 === 'U') {
            res.pop();
            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
            r = ['U'].concat(res[res.length - 1].slice(-2));
          } else {
            for (var k = 0, kk = pa.length; k < kk; k++) {
              r[k] = pa[k];
            }
          }

          pa0 = pa0.toUpperCase();

          if (pa0 !== 'O') {
            switch (r[0]) {
              case 'Z':
                x = +mx;
                y = +my;
                break;

              case 'H':
                x = r[1];
                break;

              case 'V':
                y = r[1];
                break;

              case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                break;
              // for lint

              default:
                x = r[r.length - 2];
                y = r[r.length - 1];
            }
          }
        }

        return res;
      };

      var l2c = function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
      };

      var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3;

        var _23 = 2 / 3;

        return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
      };

      var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        if (rx === ry) {
          rx += 1;
        }

        var _120 = Math.PI * 120 / 180;

        var rad = Math.PI / 180 * (+angle || 0);
        var res = [];
        var xy;
        var f1;
        var f2;
        var cx;
        var cy;

        var rotate = function rotate(x, y, rad) {
          var X = x * Math.cos(rad) - y * Math.sin(rad);
          var Y = x * Math.sin(rad) + y * Math.cos(rad);
          return {
            x: X,
            y: Y
          };
        };

        if (!recursive) {
          xy = rotate(x1, y1, -rad);
          x1 = xy.x;
          y1 = xy.y;
          xy = rotate(x2, y2, -rad);
          x2 = xy.x;
          y2 = xy.y;

          if (x1 === x2 && y1 === y2) {
            // 若弧的起始点和终点重叠则错开一点
            x2 += 1;
            y2 += 1;
          } // const cos = Math.cos(Math.PI / 180 * angle);
          // const sin = Math.sin(Math.PI / 180 * angle);


          var x = (x1 - x2) / 2;
          var y = (y1 - y2) / 2;
          var h = x * x / (rx * rx) + y * y / (ry * ry);

          if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
          }

          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
          cx = k * rx * y / ry + (x1 + x2) / 2;
          cy = k * -ry * x / rx + (y1 + y2) / 2;
          f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
          f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
          f1 = x1 < cx ? Math.PI - f1 : f1;
          f2 = x2 < cx ? Math.PI - f2 : f2;
          f1 < 0 && (f1 = Math.PI * 2 + f1);
          f2 < 0 && (f2 = Math.PI * 2 + f2);

          if (sweep_flag && f1 > f2) {
            f1 = f1 - Math.PI * 2;
          }

          if (!sweep_flag && f2 > f1) {
            f2 = f2 - Math.PI * 2;
          }
        } else {
          f1 = recursive[0];
          f2 = recursive[1];
          cx = recursive[2];
          cy = recursive[3];
        }

        var df = f2 - f1;

        if (Math.abs(df) > _120) {
          var f2old = f2;
          var x2old = x2;
          var y2old = y2;
          f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
          x2 = cx + rx * Math.cos(f2);
          y2 = cy + ry * Math.sin(f2);
          res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }

        df = f2 - f1;
        var c1 = Math.cos(f1);
        var s1 = Math.sin(f1);
        var c2 = Math.cos(f2);
        var s2 = Math.sin(f2);
        var t = Math.tan(df / 4);
        var hx = 4 / 3 * rx * t;
        var hy = 4 / 3 * ry * t;
        var m1 = [x1, y1];
        var m2 = [x1 + hx * s1, y1 - hy * c1];
        var m3 = [x2 + hx * s2, y2 - hy * c2];
        var m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];

        if (recursive) {
          return [m2, m3, m4].concat(res);
        }

        res = [m2, m3, m4].concat(res).join().split(',');
        var newres = [];

        for (var i = 0, ii = res.length; i < ii; i++) {
          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        }

        return newres;
      };

      var pathTocurve = function pathTocurve(path, path2) {
        var p = pathToAbsolute(path);
        var p2 = path2 && pathToAbsolute(path2);
        var attrs = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        };
        var attrs2 = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        };
        var pcoms1 = []; // path commands of original path p

        var pcoms2 = []; // path commands of original path p2

        var pfirst = ''; // temporary holder for original path command

        var pcom = ''; // holder for previous path command of original path

        var ii;

        var processPath = function processPath(path, d, pcom) {
          var nx, ny;

          if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
          }

          !(path[0] in {
            T: 1,
            Q: 1
          }) && (d.qx = d.qy = null);

          switch (path[0]) {
            case 'M':
              d.X = path[1];
              d.Y = path[2];
              break;

            case 'A':
              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
              break;

            case 'S':
              if (pcom === 'C' || pcom === 'S') {
                // In "S" case we have to take into account, if the previous command is C/S.
                nx = d.x * 2 - d.bx; // And reflect the previous

                ny = d.y * 2 - d.by; // command's control point relative to the current point.
              } else {
                // or some else or nothing
                nx = d.x;
                ny = d.y;
              }

              path = ['C', nx, ny].concat(path.slice(1));
              break;

            case 'T':
              if (pcom === 'Q' || pcom === 'T') {
                // In "T" case we have to take into account, if the previous command is Q/T.
                d.qx = d.x * 2 - d.qx; // And make a reflection similar

                d.qy = d.y * 2 - d.qy; // to case "S".
              } else {
                // or something else or nothing
                d.qx = d.x;
                d.qy = d.y;
              }

              path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
              break;

            case 'Q':
              d.qx = path[1];
              d.qy = path[2];
              path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
              break;

            case 'L':
              path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
              break;

            case 'H':
              path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
              break;

            case 'V':
              path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
              break;

            case 'Z':
              path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
              break;

            default:
              break;
          }

          return path;
        };

        var fixArc = function fixArc(pp, i) {
          if (pp[i].length > 7) {
            pp[i].shift();
            var pi = pp[i];

            while (pi.length) {
              pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved

              p2 && (pcoms2[i] = 'A'); // the same as above

              pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
            }

            pp.splice(i, 1);
            ii = Math.max(p.length, p2 && p2.length || 0);
          }
        };

        var fixM = function fixM(path1, path2, a1, a2, i) {
          if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
            path2.splice(i, 0, ['M', a2.x, a2.y]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = Math.max(p.length, p2 && p2.length || 0);
          }
        };

        ii = Math.max(p.length, p2 && p2.length || 0);

        for (var i = 0; i < ii; i++) {
          p[i] && (pfirst = p[i][0]); // save current path command

          if (pfirst !== 'C') {
            // C is not saved yet, because it may be result of conversion
            pcoms1[i] = pfirst; // Save current path command

            i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
          }

          p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

          if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command
          // which may produce multiple C:s
          // so we have to make sure that C is also C in original path

          fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

          if (p2) {
            // the same procedures is done to p2
            p2[i] && (pfirst = p2[i][0]);

            if (pfirst !== 'C') {
              pcoms2[i] = pfirst;
              i && (pcom = pcoms2[i - 1]);
            }

            p2[i] = processPath(p2[i], attrs2, pcom);

            if (pcoms2[i] !== 'A' && pfirst === 'C') {
              pcoms2[i] = 'C';
            }

            fixArc(p2, i);
          }

          fixM(p, p2, attrs, attrs2, i);
          fixM(p2, p, attrs2, attrs, i);
          var seg = p[i];
          var seg2 = p2 && p2[i];
          var seglen = seg.length;
          var seg2len = p2 && seg2.length;
          attrs.x = seg[seglen - 2];
          attrs.y = seg[seglen - 1];
          attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
          attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
          attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
          attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
          attrs2.x = p2 && seg2[seg2len - 2];
          attrs2.y = p2 && seg2[seg2len - 1];
        }

        return p2 ? [p, p2] : p;
      };

      var p2s = /,?([a-z]),?/gi;

      var parsePathArray = function parsePathArray(path) {
        return path.join(',').replace(p2s, '$1');
      };

      var base3 = function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
        var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
      };

      var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z === null) {
          z = 1;
        }

        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2;
        var n = 12;
        var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
        var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
        var sum = 0;

        for (var i = 0; i < n; i++) {
          var ct = z2 * Tvalues[i] + z2;
          var xbase = base3(ct, x1, x2, x3, x4);
          var ybase = base3(ct, y1, y2, y3, y4);
          var comb = xbase * xbase + ybase * ybase;
          sum += Cvalues[i] * Math.sqrt(comb);
        }

        return z2 * sum;
      };

      var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
        var tvalues = [];
        var bounds = [[], []];
        var a;
        var b;
        var c;
        var t;

        for (var i = 0; i < 2; ++i) {
          if (i === 0) {
            b = 6 * x0 - 12 * x1 + 6 * x2;
            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
            c = 3 * x1 - 3 * x0;
          } else {
            b = 6 * y0 - 12 * y1 + 6 * y2;
            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c = 3 * y1 - 3 * y0;
          }

          if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) < 1e-12) {
              continue;
            }

            t = -c / b;

            if (t > 0 && t < 1) {
              tvalues.push(t);
            }

            continue;
          }

          var b2ac = b * b - 4 * c * a;
          var sqrtb2ac = Math.sqrt(b2ac);

          if (b2ac < 0) {
            continue;
          }

          var t1 = (-b + sqrtb2ac) / (2 * a);

          if (t1 > 0 && t1 < 1) {
            tvalues.push(t1);
          }

          var t2 = (-b - sqrtb2ac) / (2 * a);

          if (t2 > 0 && t2 < 1) {
            tvalues.push(t2);
          }
        }

        var j = tvalues.length;
        var jlen = j;
        var mt;

        while (j--) {
          t = tvalues[j];
          mt = 1 - t;
          bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
          bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        }

        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        bounds[0].length = bounds[1].length = jlen + 2;
        return {
          min: {
            x: Math.min.apply(0, bounds[0]),
            y: Math.min.apply(0, bounds[1])
          },
          max: {
            x: Math.max.apply(0, bounds[0]),
            y: Math.max.apply(0, bounds[1])
          }
        };
      };

      var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
          return;
        }

        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
        var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
        var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
          return;
        }

        var px = nx / denominator;
        var py = ny / denominator;
        var px2 = +px.toFixed(2);
        var py2 = +py.toFixed(2);

        if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
          return;
        }

        return {
          x: px,
          y: py
        };
      };

      var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
      };

      var rectPath = function rectPath(x, y, w, h, r) {
        if (r) {
          return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
        }

        var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
        res.parsePathArray = parsePathArray;
        return res;
      };

      var box = function box(x, y, width, height) {
        if (x === null) {
          x = y = width = height = 0;
        }

        if (y === null) {
          y = x.y;
          width = x.width;
          height = x.height;
          x = x.x;
        }

        return {
          x: x,
          y: y,
          width: width,
          w: width,
          height: height,
          h: height,
          x2: x + width,
          y2: y + height,
          cx: x + width / 2,
          cy: y + height / 2,
          r1: Math.min(width, height) / 2,
          r2: Math.max(width, height) / 2,
          r0: Math.sqrt(width * width + height * height) / 2,
          path: rectPath(x, y, width, height),
          vb: [x, y, width, height].join(' ')
        };
      };

      var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
      };

      var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!Util.isArray(p1x)) {
          p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }

        var bbox = curveDim.apply(null, p1x);
        return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
      };

      var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        var t13 = Math.pow(t1, 3);
        var t12 = Math.pow(t1, 2);
        var t2 = t * t;
        var t3 = t2 * t;
        var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
        var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
        var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
        var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
        var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
        var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
        var ax = t1 * p1x + t * c1x;
        var ay = t1 * p1y + t * c1y;
        var cx = t1 * c2x + t * p2x;
        var cy = t1 * c2y + t * p2y;
        var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);

        return {
          x: x,
          y: y,
          m: {
            x: mx,
            y: my
          },
          n: {
            x: nx,
            y: ny
          },
          start: {
            x: ax,
            y: ay
          },
          end: {
            x: cx,
            y: cy
          },
          alpha: alpha
        };
      };

      var interHelper = function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1);
        var bbox2 = bezierBBox(bez2);

        if (!isBBoxIntersect(bbox1, bbox2)) {
          return justCount ? 0 : [];
        }

        var l1 = bezlen.apply(0, bez1);
        var l2 = bezlen.apply(0, bez2);
        var n1 = ~~(l1 / 8);
        var n2 = ~~(l2 / 8);
        var dots1 = [];
        var dots2 = [];
        var xy = {};
        var res = justCount ? 0 : [];

        for (var i = 0; i < n1 + 1; i++) {
          var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
          dots1.push({
            x: d.x,
            y: d.y,
            t: i / n1
          });
        }

        for (var _i = 0; _i < n2 + 1; _i++) {
          var _d = findDotsAtSegment.apply(0, bez2.concat(_i / n2));

          dots2.push({
            x: _d.x,
            y: _d.y,
            t: _i / n2
          });
        }

        for (var _i2 = 0; _i2 < n1; _i2++) {
          for (var j = 0; j < n2; j++) {
            var di = dots1[_i2];
            var di1 = dots1[_i2 + 1];
            var dj = dots2[j];
            var dj1 = dots2[j + 1];
            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

            if (is) {
              if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
                continue;
              }

              xy[is.x.toFixed(4)] = is.y.toFixed(4);
              var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
              var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

              if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                if (justCount) {
                  res++;
                } else {
                  res.push({
                    x: is.x,
                    y: is.y,
                    t1: t1,
                    t2: t2
                  });
                }
              }
            }
          }
        }

        return res;
      };

      var interPathHelper = function interPathHelper(path1, path2, justCount) {
        path1 = pathTocurve(path1);
        path2 = pathTocurve(path2);
        var x1;
        var y1;
        var x2;
        var y2;
        var x1m;
        var y1m;
        var x2m;
        var y2m;
        var bez1;
        var bez2;
        var res = justCount ? 0 : [];

        for (var i = 0, ii = path1.length; i < ii; i++) {
          var pi = path1[i];

          if (pi[0] === 'M') {
            x1 = x1m = pi[1];
            y1 = y1m = pi[2];
          } else {
            if (pi[0] === 'C') {
              bez1 = [x1, y1].concat(pi.slice(1));
              x1 = bez1[6];
              y1 = bez1[7];
            } else {
              bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
              x1 = x1m;
              y1 = y1m;
            }

            for (var j = 0, jj = path2.length; j < jj; j++) {
              var pj = path2[j];

              if (pj[0] === 'M') {
                x2 = x2m = pj[1];
                y2 = y2m = pj[2];
              } else {
                if (pj[0] === 'C') {
                  bez2 = [x2, y2].concat(pj.slice(1));
                  x2 = bez2[6];
                  y2 = bez2[7];
                } else {
                  bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                  x2 = x2m;
                  y2 = y2m;
                }

                var intr = interHelper(bez1, bez2, justCount);

                if (justCount) {
                  res += intr;
                } else {
                  for (var k = 0, kk = intr.length; k < kk; k++) {
                    intr[k].segment1 = i;
                    intr[k].segment2 = j;
                    intr[k].bez1 = bez1;
                    intr[k].bez2 = bez2;
                  }

                  res = res.concat(intr);
                }
              }
            }
          }
        }

        return res;
      };

      var pathIntersection = function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
      };

      function decasteljau(points, t) {
        var left = [];
        var right = [];

        function recurse(points, t) {
          if (points.length === 1) {
            left.push(points[0]);
            right.push(points[0]);
          } else {
            var middlePoints = [];

            for (var i = 0; i < points.length - 1; i++) {
              if (i === 0) {
                left.push(points[0]);
              }

              if (i === points.length - 2) {
                right.push(points[i + 1]);
              }

              middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
            }

            recurse(middlePoints, t);
          }
        }

        if (points.length) {
          recurse(points, t);
        }

        return {
          left: left,
          right: right.reverse()
        };
      }

      function splitCurve(start, end, count) {
        var points = [[start[1], start[2]]];
        count = count || 2;
        var segments = [];

        if (end[0] === 'A') {
          points.push(end[6]);
          points.push(end[7]);
        } else if (end[0] === 'C') {
          points.push([end[1], end[2]]);
          points.push([end[3], end[4]]);
          points.push([end[5], end[6]]);
        } else if (end[0] === 'S' || end[0] === 'Q') {
          points.push([end[1], end[2]]);
          points.push([end[3], end[4]]);
        } else {
          points.push([end[1], end[2]]);
        }

        var leftSegments = points;
        var t = 1 / count;

        for (var i = 0; i < count - 1; i++) {
          var rt = t / (1 - t * i);
          var split = decasteljau(leftSegments, rt);
          segments.push(split.left);
          leftSegments = split.right;
        }

        segments.push(leftSegments);
        var result = segments.map(function (segment) {
          var cmd = [];

          if (segment.length === 4) {
            cmd.push('C');
            cmd = cmd.concat(segment[2]);
          }

          if (segment.length >= 3) {
            if (segment.length === 3) {
              cmd.push('Q');
            }

            cmd = cmd.concat(segment[1]);
          }

          if (segment.length === 2) {
            cmd.push('L');
          }

          cmd = cmd.concat(segment[segment.length - 1]);
          return cmd;
        });
        return result;
      }

      var splitSegment = function splitSegment(start, end, count) {
        if (count === 1) {
          return [[].concat(start)];
        }

        var segments = [];

        if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
          segments = segments.concat(splitCurve(start, end, count));
        } else {
          var temp = [].concat(start);

          if (temp[0] === 'M') {
            temp[0] = 'L';
          }

          for (var i = 0; i <= count - 1; i++) {
            segments.push(temp);
          }
        }

        return segments;
      };

      var fillPath = function fillPath(source, target) {
        if (source.length === 1) {
          return source;
        }

        var sourceLen = source.length - 1;
        var targetLen = target.length - 1;
        var ratio = sourceLen / targetLen;
        var segmentsToFill = [];

        if (source.length === 1 && source[0][0] === 'M') {
          for (var i = 0; i < targetLen - sourceLen; i++) {
            source.push(source[0]);
          }

          return source;
        }

        for (var _i3 = 0; _i3 < targetLen; _i3++) {
          var index = Math.floor(ratio * _i3);
          segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
        }

        var filled = segmentsToFill.reduce(function (filled, count, i) {
          if (i === sourceLen) {
            return filled.concat(source[sourceLen]);
          }

          return filled.concat(splitSegment(source[i], source[i + 1], count));
        }, []);
        filled.unshift(source[0]);

        if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
          filled.push('Z');
        }

        return filled;
      };

      var isEqual = function isEqual(obj1, obj2) {
        if (obj1.length !== obj2.length) {
          return false;
        }

        var result = true;
        Util.each(obj1, function (item, i) {
          if (item !== obj2[i]) {
            result = false;
            return false;
          }
        });
        return result;
      };

      function getMinDiff(del, add, modify) {
        var type = null;
        var min = modify;

        if (add < min) {
          min = add;
          type = 'add';
        }

        if (del < min) {
          min = del;
          type = 'del';
        }

        return {
          type: type,
          min: min
        };
      }
      /*
       * https://en.wikipedia.org/wiki/Levenshtein_distance
       * 计算两条path的编辑距离
       */


      var levenshteinDistance = function levenshteinDistance(source, target) {
        var sourceLen = source.length;
        var targetLen = target.length;
        var sourceSegment, targetSegment;
        var temp = 0;

        if (sourceLen === 0 || targetLen === 0) {
          return null;
        }

        var dist = [];

        for (var i = 0; i <= sourceLen; i++) {
          dist[i] = [];
          dist[i][0] = {
            min: i
          };
        }

        for (var j = 0; j <= targetLen; j++) {
          dist[0][j] = {
            min: j
          };
        }

        for (var _i4 = 1; _i4 <= sourceLen; _i4++) {
          sourceSegment = source[_i4 - 1];

          for (var _j2 = 1; _j2 <= targetLen; _j2++) {
            targetSegment = target[_j2 - 1];

            if (isEqual(sourceSegment, targetSegment)) {
              temp = 0;
            } else {
              temp = 1;
            }

            var del = dist[_i4 - 1][_j2].min + 1;
            var add = dist[_i4][_j2 - 1].min + 1;
            var modify = dist[_i4 - 1][_j2 - 1].min + temp;
            dist[_i4][_j2] = getMinDiff(del, add, modify);
          }
        }

        return dist;
      };

      var fillPathByDiff = function fillPathByDiff(source, target) {
        var diffMatrix = levenshteinDistance(source, target);
        var sourceLen = source.length;
        var targetLen = target.length;
        var changes = [];
        var index = 1;
        var minPos = 1; // 如果source和target不是完全不相等

        if (diffMatrix[sourceLen][targetLen] !== sourceLen) {
          // 获取从source到target所需改动
          for (var i = 1; i <= sourceLen; i++) {
            var min = diffMatrix[i][i].min;
            minPos = i;

            for (var j = index; j <= targetLen; j++) {
              if (diffMatrix[i][j].min < min) {
                min = diffMatrix[i][j].min;
                minPos = j;
              }
            }

            index = minPos;

            if (diffMatrix[i][index].type) {
              changes.push({
                index: i - 1,
                type: diffMatrix[i][index].type
              });
            }
          } // 对source进行增删path


          for (var _i5 = changes.length - 1; _i5 >= 0; _i5--) {
            index = changes[_i5].index;

            if (changes[_i5].type === 'add') {
              source.splice(index, 0, [].concat(source[index]));
            } else {
              source.splice(index, 1);
            }
          }
        } // source尾部补齐


        sourceLen = source.length;
        var diff = targetLen - sourceLen;

        if (sourceLen < targetLen) {
          for (var _i6 = 0; _i6 < diff; _i6++) {
            if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
              source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
            } else {
              source.push(source[sourceLen - 1]);
            }

            sourceLen += 1;
          }
        }

        return source;
      }; // 将两个点均分成count个点


      function _splitPoints(points, former, count) {
        var result = [].concat(points);
        var index;
        var t = 1 / (count + 1);

        var formerEnd = _getSegmentPoints(former)[0];

        for (var i = 1; i <= count; i++) {
          t *= i;
          index = Math.floor(points.length * t);

          if (index === 0) {
            result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
          } else {
            result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
          }
        }

        return result;
      }
      /*
       * 抽取pathSegment中的关键点
       * M,L,A,Q,H,V一个端点
       * Q, S抽取一个端点，一个控制点
       * C抽取一个端点，两个控制点
       */


      function _getSegmentPoints(segment) {
        var points = [];

        switch (segment[0]) {
          case 'M':
            points.push([segment[1], segment[2]]);
            break;

          case 'L':
            points.push([segment[1], segment[2]]);
            break;

          case 'A':
            points.push([segment[6], segment[7]]);
            break;

          case 'Q':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;

          case 'T':
            points.push([segment[1], segment[2]]);
            break;

          case 'C':
            points.push([segment[5], segment[6]]);
            points.push([segment[1], segment[2]]);
            points.push([segment[3], segment[4]]);
            break;

          case 'S':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;

          case 'H':
            points.push([segment[1], segment[1]]);
            break;

          case 'V':
            points.push([segment[1], segment[1]]);
            break;

          default:
        }

        return points;
      }

      var formatPath = function formatPath(fromPath, toPath) {
        if (fromPath.length <= 1) {
          return fromPath;
        }

        var points;

        for (var i = 0; i < toPath.length; i++) {
          if (fromPath[i][0] !== toPath[i][0]) {
            // 获取fromPath的pathSegment的端点，根据toPath的指令对其改造
            points = _getSegmentPoints(fromPath[i]);

            switch (toPath[i][0]) {
              case 'M':
                fromPath[i] = ['M'].concat(points[0]);
                break;

              case 'L':
                fromPath[i] = ['L'].concat(points[0]);
                break;

              case 'A':
                fromPath[i] = [].concat(toPath[i]);
                fromPath[i][6] = points[0][0];
                fromPath[i][7] = points[0][1];
                break;

              case 'Q':
                if (points.length < 2) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 1);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              case 'T':
                fromPath[i] = ['T'].concat(points[0]);
                break;

              case 'C':
                if (points.length < 3) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 2);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              case 'S':
                if (points.length < 2) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 1);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              default:
                fromPath[i] = toPath[i];
            }
          }
        }

        return fromPath;
      };

      module.exports = {
        parsePathString: parsePathString,
        parsePathArray: parsePathArray,
        pathTocurve: pathTocurve,
        pathToAbsolute: pathToAbsolute,
        catmullRomToBezier: catmullRom2bezier,
        rectPath: rectPath,
        fillPath: fillPath,
        fillPathByDiff: fillPathByDiff,
        formatPath: formatPath,
        intersection: pathIntersection
      };
      /***/
    },
    /* 59 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["b"] = now;
      /* harmony export (immutable) */

      __webpack_exports__["a"] = Timer;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = timer;
      /* harmony export (immutable) */

      __webpack_exports__["d"] = timerFlush;
      var frame = 0,
          // is an animation frame pending?
      timeout = 0,
          // is a timeout pending?
      interval = 0,
          // are any timers active?
      pokeDelay = 1000,
          // how frequently we check for clock skew
      taskHead,
          taskTail,
          clockLast = 0,
          clockNow = 0,
          clockSkew = 0,
          clock = typeof performance === "object" && performance.now ? performance : Date,
          setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
        setTimeout(f, 17);
      };

      function now() {
        return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
      }

      function clearNow() {
        clockNow = 0;
      }

      function Timer() {
        this._call = this._time = this._next = null;
      }

      Timer.prototype = timer.prototype = {
        constructor: Timer,
        restart: function restart(callback, delay, time) {
          if (typeof callback !== "function") throw new TypeError("callback is not a function");
          time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

          if (!this._next && taskTail !== this) {
            if (taskTail) taskTail._next = this;else taskHead = this;
            taskTail = this;
          }

          this._call = callback;
          this._time = time;
          sleep();
        },
        stop: function stop() {
          if (this._call) {
            this._call = null;
            this._time = Infinity;
            sleep();
          }
        }
      };

      function timer(callback, delay, time) {
        var t = new Timer();
        t.restart(callback, delay, time);
        return t;
      }

      function timerFlush() {
        now(); // Get the current time, if not already set.

        ++frame; // Pretend we’ve set an alarm, if we haven’t already.

        var t = taskHead,
            e;

        while (t) {
          if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
          t = t._next;
        }

        --frame;
      }

      function wake() {
        clockNow = (clockLast = clock.now()) + clockSkew;
        frame = timeout = 0;

        try {
          timerFlush();
        } finally {
          frame = 0;
          nap();
          clockNow = 0;
        }
      }

      function poke() {
        var now = clock.now(),
            delay = now - clockLast;
        if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
      }

      function nap() {
        var t0,
            t1 = taskHead,
            t2,
            time = Infinity;

        while (t1) {
          if (t1._call) {
            if (time > t1._time) time = t1._time;
            t0 = t1, t1 = t1._next;
          } else {
            t2 = t1._next, t1._next = null;
            t1 = t0 ? t0._next = t2 : taskHead = t2;
          }
        }

        taskTail = t0;
        sleep(time);
      }

      function sleep(time) {
        if (frame) return; // Soonest alarm already set, or will be.

        if (timeout) timeout = clearTimeout(timeout);
        var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

        if (delay > 24) {
          if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
          if (interval) interval = clearInterval(interval);
        } else {
          if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
          frame = 1, setFrame(wake);
        }
      }
      /***/

    },
    /* 60 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__rgb__ = __webpack_require__(118);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__array__ = __webpack_require__(121);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__date__ = __webpack_require__(122);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__number__ = __webpack_require__(40);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__object__ = __webpack_require__(123);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__string__ = __webpack_require__(124);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__constant__ = __webpack_require__(120);
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var t = typeof b,
            c;
        return b == null || t === "boolean" ? Object(__WEBPACK_IMPORTED_MODULE_7__constant__["a"
        /* default */
        ])(b) : (t === "number" ? __WEBPACK_IMPORTED_MODULE_4__number__["a"
        /* default */
        ] : t === "string" ? (c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a"
        /* color */
        ])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1__rgb__["a"
        /* default */
        ]) : __WEBPACK_IMPORTED_MODULE_6__string__["a"
        /* default */
        ] : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["a"
        /* color */
        ] ? __WEBPACK_IMPORTED_MODULE_1__rgb__["a"
        /* default */
        ] : b instanceof Date ? __WEBPACK_IMPORTED_MODULE_3__date__["a"
        /* default */
        ] : Array.isArray(b) ? __WEBPACK_IMPORTED_MODULE_2__array__["a"
        /* default */
        ] : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? __WEBPACK_IMPORTED_MODULE_5__object__["a"
        /* default */
        ] : __WEBPACK_IMPORTED_MODULE_4__number__["a"
        /* default */
        ])(a, b);
      };
      /***/

    },
    /* 61 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = Color;
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "d", function () {
        return _darker;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "c", function () {
        return _brighter;
      });
      /* harmony export (immutable) */


      __webpack_exports__["e"] = color;
      /* harmony export (immutable) */

      __webpack_exports__["h"] = rgbConvert;
      /* harmony export (immutable) */

      __webpack_exports__["g"] = rgb;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = Rgb;
      /* unused harmony export hslConvert */

      /* harmony export (immutable) */

      __webpack_exports__["f"] = hsl;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__define_js__ = __webpack_require__(62);

      function Color() {}

      var _darker = 0.7;

      var _brighter = 1 / _darker;

      var reI = "\\s*([+-]?\\d+)\\s*",
          reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
          reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
          reHex = /^#([0-9a-f]{3,8})$/,
          reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
          reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
          reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
          reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
          reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
          reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
      var named = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
      };
      Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["a"
      /* default */
      ])(Color, color, {
        copy: function copy(channels) {
          return Object.assign(new this.constructor(), this, channels);
        },
        displayable: function displayable() {
          return this.rgb().displayable();
        },
        hex: color_formatHex,
        // Deprecated! Use color.formatHex.
        formatHex: color_formatHex,
        formatHsl: color_formatHsl,
        formatRgb: color_formatRgb,
        toString: color_formatRgb
      });

      function color_formatHex() {
        return this.rgb().formatHex();
      }

      function color_formatHsl() {
        return hslConvert(this).formatHsl();
      }

      function color_formatRgb() {
        return this.rgb().formatRgb();
      }

      function color(format) {
        var m, l;
        format = (format + "").trim().toLowerCase();
        return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
        : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? new Rgb(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
        : null // invalid hex
        ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
      }

      function rgbn(n) {
        return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
      }

      function rgba(r, g, b, a) {
        if (a <= 0) r = g = b = NaN;
        return new Rgb(r, g, b, a);
      }

      function rgbConvert(o) {
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Rgb();
        o = o.rgb();
        return new Rgb(o.r, o.g, o.b, o.opacity);
      }

      function rgb(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
      }

      function Rgb(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
      }

      Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["a"
      /* default */
      ])(Rgb, rgb, Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["b"
      /* extend */
      ])(Color, {
        brighter: function brighter(k) {
          k = k == null ? _brighter : Math.pow(_brighter, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function darker(k) {
          k = k == null ? _darker : Math.pow(_darker, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function rgb() {
          return this;
        },
        displayable: function displayable() {
          return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
        },
        hex: rgb_formatHex,
        // Deprecated! Use color.formatHex.
        formatHex: rgb_formatHex,
        formatRgb: rgb_formatRgb,
        toString: rgb_formatRgb
      }));

      function rgb_formatHex() {
        return "#" + hex(this.r) + hex(this.g) + hex(this.b);
      }

      function rgb_formatRgb() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
      }

      function hex(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
      }

      function hsla(h, s, l, a) {
        if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
        return new Hsl(h, s, l, a);
      }

      function hslConvert(o) {
        if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Hsl();
        if (o instanceof Hsl) return o;
        o = o.rgb();
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            min = Math.min(r, g, b),
            max = Math.max(r, g, b),
            h = NaN,
            s = max - min,
            l = (max + min) / 2;

        if (s) {
          if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
          s /= l < 0.5 ? max + min : 2 - max - min;
          h *= 60;
        } else {
          s = l > 0 && l < 1 ? 0 : h;
        }

        return new Hsl(h, s, l, o.opacity);
      }

      function hsl(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
      }

      function Hsl(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
      }

      Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["a"
      /* default */
      ])(Hsl, hsl, Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["b"
      /* extend */
      ])(Color, {
        brighter: function brighter(k) {
          k = k == null ? _brighter : Math.pow(_brighter, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function darker(k) {
          k = k == null ? _darker : Math.pow(_darker, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function rgb() {
          var h = this.h % 360 + (this.h < 0) * 360,
              s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
              l = this.l,
              m2 = l + (l < 0.5 ? l : 1 - l) * s,
              m1 = 2 * l - m2;
          return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
        },
        displayable: function displayable() {
          return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
        },
        formatHsl: function formatHsl() {
          var a = this.opacity;
          a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
          return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
        }
      }));
      /* From FvD 13.37, CSS Color Module Level 3 */

      function hsl2rgb(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
      }
      /***/

    },
    /* 62 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["b"] = extend;
      /* harmony default export */

      __webpack_exports__["a"] = function (constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
      };

      function extend(parent, definition) {
        var prototype = Object.create(parent.prototype);

        for (var key in definition) {
          prototype[key] = definition[key];
        }

        return prototype;
      }
      /***/

    },
    /* 63 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = basis;

      function basis(t1, v0, v1, v2, v3) {
        var t2 = t1 * t1,
            t3 = t2 * t1;
        return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
      }
      /* harmony default export */


      __webpack_exports__["b"] = function (values) {
        var n = values.length - 1;
        return function (t) {
          var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
              v1 = values[i],
              v2 = values[i + 1],
              v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
              v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
          return basis((t - i / n) * n, v0, v1, v2, v3);
        };
      };
      /***/

    },
    /* 64 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var isArrayLike = __webpack_require__(13);

      var filter = function filter(arr, func) {
        if (!isArrayLike(arr)) {
          return arr;
        }

        var result = [];
        each(arr, function (value, index) {
          if (func(value, index)) {
            result.push(value);
          }
        });
        return result;
      };

      module.exports = filter;
      /***/
    },
    /* 65 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      var isArray = __webpack_require__(4);

      var each = __webpack_require__(2);

      module.exports = function valuesOfKey(data, name) {
        var rst = [];
        var tmpMap = {};

        for (var i = 0; i < data.length; i++) {
          var obj = data[i];
          var value = obj[name];

          if (!isNil(value)) {
            if (!isArray(value)) {
              value = [value];
            }

            each(value, function (val) {
              if (!tmpMap[val]) {
                rst.push(val);
                tmpMap[val] = true;
              }
            });
          }
        }

        return rst;
      };
      /***/

    },
    /* 66 */

    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(16),
          Group = _require.Group;

      var _require2 = __webpack_require__(22),
          Label = _require2.Label; // const visualCenter = require('@antv/component/lib/label/utils/visual-center');


      var Global = __webpack_require__(7);

      var Util = __webpack_require__(0);

      var IGNORE_ARR = ['line', 'point', 'path'];
      var ORIGIN = '_origin';

      function avg(arr) {
        var sum = 0;
        Util.each(arr, function (value) {
          sum += value;
        });
        return sum / arr.length;
      } // 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon


      function getCentroid(xs, ys) {
        if (Util.isNumber(xs) && Util.isNumber(ys)) {
          return [xs, ys];
        }

        var i = -1,
            x = 0,
            y = 0;
        var former,
            current = xs.length - 1;
        var diff,
            k = 0;

        while (++i < xs.length) {
          former = current;
          current = i;
          k += diff = xs[former] * ys[current] - xs[current] * ys[former];
          x += (xs[former] + xs[current]) * diff;
          y += (ys[former] + ys[current]) * diff;
        }

        k *= 3;
        return [x / k, y / k];
      }

      var GeomLabels = function GeomLabels(cfg) {
        GeomLabels.superclass.constructor.call(this, cfg);
      };

      Util.extend(GeomLabels, Group);
      Util.augment(GeomLabels, {
        getDefaultCfg: function getDefaultCfg() {
          return {
            label: Global.label,

            /**
             * 用户传入的文本配置信息
             * @type {Object}
             */
            labelCfg: null,

            /**
             * 所在的坐标系
             * @type {Object}
             */
            coord: null,

            /**
             * 图表的类型
             * @type {String}
             */
            geomType: null,
            zIndex: 6
          };
        },
        _renderUI: function _renderUI() {
          GeomLabels.superclass._renderUI.call(this);

          this.initLabelsCfg();
          var labelsGroup = this.addGroup();
          var lineGroup = this.addGroup({
            elCls: 'x-line-group'
          });
          var labelRenderer = this.get('labelRenderer');
          this.set('labelsGroup', labelsGroup);
          this.set('lineGroup', lineGroup);
          this.get('labelRenderer').set('group', labelsGroup);
          labelRenderer.set('group', labelsGroup);
          labelRenderer.set('lineGroup', lineGroup);
        },
        // 初始化labels的配置项
        initLabelsCfg: function initLabelsCfg() {
          var self = this;
          var labelRenderer = new Label();
          var labels = self.getDefaultLabelCfg();
          var labelCfg = self.get('labelCfg'); // Util.merge(labels, labelCfg.cfg);

          Util.deepMix(labels, labelCfg.globalCfg || labelCfg.cfg);
          labelRenderer.set('config', false);

          if (labels.labelLine) {
            labelRenderer.set('labelLine', labels.labelLine);
          }

          labelRenderer.set('coord', self.get('coord'));
          this.set('labelRenderer', labelRenderer);
          self.set('label', labels);
        },

        /**
         * @protected
         * 默认的文本样式
         * @return {Object} default label config
         */
        getDefaultLabelCfg: function getDefaultLabelCfg() {
          var self = this;
          var labelCfg = self.get('labelCfg').cfg || self.get('labelCfg').globalCfg;
          var geomType = self.get('geomType');
          var viewTheme = self.get('viewTheme') || Global;

          if (geomType === 'polygon' || labelCfg && labelCfg.offset < 0 && Util.indexOf(IGNORE_ARR, geomType) === -1) {
            return Util.deepMix({}, self.get('label'), viewTheme.innerLabels, labelCfg);
          }

          return Util.deepMix({}, self.get('label'), viewTheme.label, labelCfg);
        },

        /**
         * @protected
         * 获取labels
         * @param {Array} points points
         * @param {Array} shapes shapes
         * @return {Array} label items
         */
        getLabelsItems: function getLabelsItems(points, shapes) {
          var self = this;
          var items = [];
          var geom = self.get('geom');
          var coord = self.get('coord');

          self._getLabelCfgs(points, shapes);

          var labelCfg = self.get('labelItemCfgs'); // 获取label相关的x，y的值，获取具体的x,y,防止存在数组

          Util.each(points, function (point, i) {
            var origin = point[ORIGIN];
            var label = labelCfg[i];

            if (!label) {
              items.push(null);
              return;
            }

            if (!Util.isArray(label.text)) {
              label.text = [label.text];
            }

            var total = label.text.length;
            Util.each(label.text, function (sub, subIndex) {
              if (Util.isNil(sub) || sub === '') {
                items.push(null);
                return;
              }

              var obj = self.getLabelPoint(label, point, subIndex);
              obj = Util.mix({}, label, obj);

              if (!obj.textAlign) {
                obj.textAlign = self.getLabelAlign(obj, subIndex, total);
              }

              if (geom) {
                obj._id = geom._getShapeId(origin) + '-glabel-' + subIndex + '-' + obj.text;
              }

              obj.coord = coord;
              items.push(obj);
            });
          });
          return items;
        },

        /* /!*
         * @protected
         * 如果发生冲突则会调整文本的位置
         * @param {Array} items 文本的集合
         * @param {Array} shapes 关联形状
         * @return {Array} adjusted items
         *!/
        adjustItems(items, shapes) {
          // 多边形shape的label位于其可视中心
          if (this.get('geomType') === 'polygon') {
            let index,
              shape,
              path,
              center,
              points;
            Util.each(items, (item, i) => {
              if (!item) return;
              shape = shapes[ i ];
              path = shape.attr('path');
              points = [[]];
              index = 0;
              path.forEach((segment, i) => {
                if (segment[ 0 ] === 'z' || segment[ 0 ] === 'Z' && i !== path.length - 1) {
                  points.push([]);
                  index += 1;
                }
                if (segment.length === 3) {
                  points[ index ].push([ segment[ 1 ], segment[ 2 ] ]);
                }
              });
              center = visualCenter(points);
              item.x = center.x;
              item.y = center.y;
            });
          }
          return items;
        }
        */
        adjustItems: function adjustItems(items) {
          Util.each(items, function (item) {
            if (!item) {
              return;
            }

            if (item.offsetX) {
              item.x += item.offsetX;
            }

            if (item.offsetY) {
              item.y += item.offsetY;
            }
          });
          return items;
        },

        /**
         * drawing lines to labels
         * @param  {Array} items labels
         * @param  {Object} labelLine configuration for label lines
         */
        drawLines: function drawLines(items) {
          var self = this;
          Util.each(items, function (point) {
            if (!point) {
              return;
            }

            if (point.offset > 0) {
              self.lineToLabel(point);
            }
          });
        },
        // 定义连接线
        lineToLabel: function lineToLabel() {},

        /**
         * @protected
         * 获取文本的位置信息
         * @param {Array} labelCfg labels
         * @param {Object} point point
         * @param {Number} index index
         * @return {Object} point
         */
        getLabelPoint: function getLabelPoint(labelCfg, point, index) {
          var self = this;
          var coord = self.get('coord');
          var total = labelCfg.text.length;

          function getDimValue(value, idx) {
            if (Util.isArray(value)) {
              if (labelCfg.text.length === 1) {
                // 如果仅一个label,多个y,取最后一个y
                if (value.length <= 2) {
                  value = value[value.length - 1]; // value = value[0];
                } else {
                  value = avg(value);
                }
              } else {
                value = value[idx];
              }
            }

            return value;
          }

          var label = {
            text: labelCfg.text[index]
          }; // 多边形场景,多用于地图

          if (point && this.get('geomType') === 'polygon') {
            var centroid = getCentroid(point.x, point.y); // 多边形的场景也有 x 和 y 只是数字的情况，譬如当 x 和 y 都是分类字段的时候 @see #1184

            label.x = centroid[0];
            label.y = centroid[1];
          } else {
            label.x = getDimValue(point.x, index);
            label.y = getDimValue(point.y, index);
          } // get nearest point of the shape as the label line start point


          if (point && point.nextPoints && (point.shape === 'funnel' || point.shape === 'pyramid')) {
            var maxX = -Infinity;
            point.nextPoints.forEach(function (p) {
              p = coord.convert(p);

              if (p.x > maxX) {
                maxX = p.x;
              }
            });
            label.x = (label.x + maxX) / 2;
          } // sharp edge of the pyramid


          if (point.shape === 'pyramid' && !point.nextPoints && point.points) {
            point.points.forEach(function (p) {
              p = coord.convert(p);

              if (Util.isArray(p.x) && !point.x.includes(p.x) || Util.isNumber(p.x) && point.x !== p.x) {
                label.x = (label.x + p.x) / 2;
              }
            });
          }

          if (labelCfg.position) {
            self.setLabelPosition(label, point, index, labelCfg.position);
          }

          var offsetPoint = self.getLabelOffset(labelCfg, index, total);

          if (labelCfg.offsetX) {
            offsetPoint.x += labelCfg.offsetX;
          }

          if (labelCfg.offsetY) {
            offsetPoint.y += labelCfg.offsetY;
          }

          self.transLabelPoint(label);
          label.start = {
            x: label.x,
            y: label.y
          };
          label.x += offsetPoint.x;
          label.y += offsetPoint.y;
          label.color = point.color;
          return label;
        },
        setLabelPosition: function setLabelPosition() {},
        transLabelPoint: function transLabelPoint(point) {
          var self = this;
          var coord = self.get('coord');
          var tmpPoint = coord.applyMatrix(point.x, point.y, 1);
          point.x = tmpPoint[0];
          point.y = tmpPoint[1];
        },
        getOffsetVector: function getOffsetVector(point) {
          var self = this;
          var offset = point.offset || 0;
          var coord = self.get('coord');
          var vector;

          if (coord.isTransposed) {
            // 如果x,y翻转，则偏移x
            vector = coord.applyMatrix(offset, 0);
          } else {
            // 否则，偏转y
            vector = coord.applyMatrix(0, offset);
          }

          return vector;
        },
        // 获取默认的偏移量
        getDefaultOffset: function getDefaultOffset(point) {
          var self = this;
          var offset = 0;
          var coord = self.get('coord');
          var vector = self.getOffsetVector(point);

          if (coord.isTransposed) {
            // 如果x,y翻转，则偏移x
            offset = vector[0];
          } else {
            // 否则，偏转y
            offset = vector[1];
          }

          var yScale = this.get('yScale');

          if (yScale && point.point) {
            // 仅考虑 y 单值的情况，多值的情况在这里不考虑
            var yValue = point.point[yScale.field];

            if (yValue < 0) {
              offset = offset * -1; // 如果 y 值是负值，则反向
            }
          }

          return offset;
        },
        // 获取文本的偏移位置，x,y
        getLabelOffset: function getLabelOffset(point, index, total) {
          var self = this;
          var offset = self.getDefaultOffset(point);
          var coord = self.get('coord');
          var transposed = coord.isTransposed;
          var yField = transposed ? 'x' : 'y';
          var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成

          var offsetPoint = {
            x: 0,
            y: 0
          };

          if (index > 0 || total === 1) {
            // 判断是否小于0
            offsetPoint[yField] = offset * factor;
          } else {
            offsetPoint[yField] = offset * factor * -1;
          }

          return offsetPoint;
        },
        getLabelAlign: function getLabelAlign(point, index, total) {
          var self = this;
          var align = 'center';
          var coord = self.get('coord');

          if (coord.isTransposed) {
            var offset = self.getDefaultOffset(point); // var vector = coord.applyMatrix(offset,0);

            if (offset < 0) {
              align = 'right';
            } else if (offset === 0) {
              align = 'center';
            } else {
              align = 'left';
            }

            if (total > 1 && index === 0) {
              if (align === 'right') {
                align = 'left';
              } else if (align === 'left') {
                align = 'right';
              }
            }
          }

          return align;
        },
        _getLabelValue: function _getLabelValue(origin, scales) {
          if (!Util.isArray(scales)) {
            scales = [scales];
          }

          var text = [];
          Util.each(scales, function (scale) {
            var value = origin[scale.field];

            if (Util.isArray(value)) {
              var tmp = [];
              Util.each(value, function (subVal) {
                tmp.push(scale.getText(subVal));
              });
              value = tmp;
            } else {
              value = scale.getText(value);
            }

            if (Util.isNil(value) || value === '') {
              text.push(null);
            }

            text.push(value);
          });
          return text;
        },
        // 获取每个label的配置
        _getLabelCfgs: function _getLabelCfgs(points) {
          var self = this;
          var labelCfg = this.get('labelCfg');
          var scales = labelCfg.scales;
          var defaultCfg = this.get('label');
          var viewTheme = self.get('viewTheme') || Global;
          var cfgs = [];

          if (labelCfg.globalCfg && labelCfg.globalCfg.type) {
            self.set('type', labelCfg.globalCfg.type);
          }

          Util.each(points, function (point, i) {
            var cfg = {};
            var origin = point[ORIGIN];

            var originText = self._getLabelValue(origin, scales);

            if (labelCfg.callback) {
              // callback中应使用原始数据，而不是数据字符串
              var originValues = scales.map(function (scale) {
                return origin[scale.field];
              }); // 将point信息以及index信息也返回，方便能够根据point以及index，返回不同的配置

              cfg = labelCfg.callback.apply(null, [].concat(originValues, [point, i]));
            }

            if (!cfg && cfg !== 0) {
              cfgs.push(null);
              return;
            }

            if (Util.isString(cfg) || Util.isNumber(cfg)) {
              cfg = {
                text: cfg
              };
            } else {
              cfg.text = cfg.content || originText[0];
              delete cfg.content;
            }

            cfg = Util.mix({}, defaultCfg, labelCfg.globalCfg || {}, cfg); // 兼容旧的源数据写在item.point中

            point.point = origin;
            cfg.point = origin;

            if (cfg.htmlTemplate) {
              cfg.useHtml = true;
              cfg.text = cfg.htmlTemplate.call(null, cfg.text, point, i);
              delete cfg.htmlTemplate;
            }

            if (cfg.formatter) {
              cfg.text = cfg.formatter.call(null, cfg.text, point, i);
              delete cfg.formatter;
            }

            if (cfg.label) {
              // 兼容有些直接写在labelCfg.label的配置
              var label = cfg.label;
              delete cfg.label;
              cfg = Util.mix(cfg, label);
            }

            if (cfg.textStyle) {
              // 兼容旧写法，globalCfg的offset优先级高
              delete cfg.textStyle.offset;
              var textStyle = cfg.textStyle;

              if (Util.isFunction(textStyle)) {
                cfg.textStyle = textStyle.call(null, cfg.text, point, i);
              }
            }

            if (cfg.labelLine) {
              cfg.labelLine = Util.mix({}, defaultCfg.labelLine, cfg.labelLine);
            } // 因为 defaultCfg.textStyle 有可能是函数，所以这里可能没有把主题的 label 样式合进来


            cfg.textStyle = Util.mix({}, defaultCfg.textStyle, viewTheme.label.textStyle, cfg.textStyle);
            delete cfg.items;
            cfgs.push(cfg);
          });
          this.set('labelItemCfgs', cfgs);
        },
        showLabels: function showLabels(points, shapes) {
          var self = this;
          var labelRenderer = self.get('labelRenderer');
          var items = self.getLabelsItems(points, shapes);
          shapes = [].concat(shapes);
          var type = self.get('type');
          items = self.adjustItems(items, shapes);
          self.drawLines(items);
          labelRenderer.set('items', items.filter(function (item, i) {
            if (!item) {
              shapes.splice(i, 1);
              return false;
            }

            return true;
          }));

          if (type) {
            labelRenderer.set('shapes', shapes);
            labelRenderer.set('type', type);
            labelRenderer.set('points', points);
          }

          labelRenderer.set('canvas', this.get('canvas'));
          labelRenderer.draw();
        },
        destroy: function destroy() {
          this.get('labelRenderer').destroy(); // 清理文本

          GeomLabels.superclass.destroy.call(this);
        }
      }); // Util.assign(GeomLabels.prototype, Labels.LabelslabelRenderer);

      module.exports = GeomLabels;
      /***/
    },
    /* 67 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview Chart、View、Geometry 的基类
       * @author dxq613@gmail.com
       */


      var EventEmitter = __webpack_require__(54);

      var Util = __webpack_require__(3);

      var Base = /*#__PURE__*/function (_EventEmitter) {
        _inheritsLoose(Base, _EventEmitter);

        var _proto = Base.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {};
        };

        function Base(cfg) {
          var _this;

          _this = _EventEmitter.call(this) || this;

          var self = _assertThisInitialized(_this);

          var attrs = {
            visible: true
          };
          var defaultCfg = self.getDefaultCfg();
          self._attrs = attrs;
          Util.deepMix(attrs, defaultCfg, cfg);
          return _this;
        }

        _proto.get = function get(name) {
          return this._attrs[name];
        };

        _proto.set = function set(name, value) {
          this._attrs[name] = value;
        }
        /**
         * @protected
         * @param {Boolean} visible 是否可见
         * 显示、隐藏
         */
        ;

        _proto.changeVisible = function changeVisible()
        /* visible */
        {};

        _proto.destroy = function destroy() {
          var self = this;
          self._attrs = {};
          self.removeAllListeners();
          self.destroyed = true;
        };

        return Base;
      }(EventEmitter);

      module.exports = Base;
      /***/
    },
    /* 68 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The base class of continuous legend
       * @author sima.zhang
       */


      var Util = __webpack_require__(3);

      var Legend = __webpack_require__(157);

      var Slider = __webpack_require__(329);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var TRIGGER_WIDTH = 8;
      var Event = Util.Event;
      var Group = Util.Group;

      var Continuous = /*#__PURE__*/function (_Legend) {
        _inheritsLoose(Continuous, _Legend);

        function Continuous() {
          return _Legend.apply(this, arguments) || this;
        }

        var _proto = Continuous.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Legend.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 类型
             * @type {String}
             */
            type: 'continuous-legend',

            /**
             * 子项
             * @type {Array}
             */
            items: null,

            /**
             * 布局方式
             * horizontal 水平
             * vertical 垂直
             * @type {String}
             */
            layout: 'vertical',

            /**
             * 宽度
             * @type {Number}
             */
            width: 20,

            /**
             * 高度
             * @type {Number}
             */
            height: 156,

            /**
             * 默认文本图形属性
             * @type {ATTRS}
             */
            textStyle: {
              fill: '#333',
              textAlign: 'center',
              textBaseline: 'middle',
              stroke: '#fff',
              lineWidth: 5,
              fontFamily: FONT_FAMILY
            },
            hoverTextStyle: {
              fill: 'rgba(0,0,0,0.25)'
            },

            /**
             * 连续图例是否可滑动
             * @type {Boolean}
             */
            slidable: true,

            /**
             * 两头滑块的样式
             * @type {object}
             */
            triggerAttr: {
              fill: '#fff',
              // shadowOffsetX: -2,
              // shadowOffsetY: 2,
              shadowBlur: 10,
              shadowColor: 'rgba(0,0,0,0.65)',
              radius: 2
            },

            /**
             * slider 的范围
             * @type {array}}
             */
            _range: [0, 100],

            /**
             * 中间 bar 背景灰色
             * @type {ATTRS}
             */
            middleBackgroundStyle: {
              fill: '#D9D9D9'
            },

            /**
             * 文本与图例间距
             * @type {Number}
             */
            textOffset: 4,

            /**
             * line segment to seperate the unslidable slider blocks
             * @type {object}
             */
            lineStyle: {
              lineWidth: 1,
              stroke: '#fff'
            },

            /**
             * the pointer while activate the legend by mouse hovering or called by outside
             * @type {object}
             */
            pointerStyle: {
              // color: '#ccc',
              fill: 'rgb(230, 230, 230)'
            }
          });
        };

        _proto._calStartPoint = function _calStartPoint() {
          var start = {
            x: 10,
            y: this.get('titleGap') - TRIGGER_WIDTH
          };
          var titleShape = this.get('titleShape');

          if (titleShape) {
            var titleBox = titleShape.getBBox();
            start.y += titleBox.height;
          }

          return start;
        };

        _proto.beforeRender = function beforeRender() {
          var items = this.get('items');

          if (!Util.isArray(items) || Util.isEmpty(items)) {
            return;
          }

          _Legend.prototype.beforeRender.call(this);

          this.set('firstItem', items[0]);
          this.set('lastItem', items[items.length - 1]);
        };

        _proto._formatItemValue = function _formatItemValue(value) {
          var formatter = this.get('formatter') || this.get('itemFormatter');

          if (formatter) {
            value = formatter.call(this, value);
          }

          return value;
        };

        _proto.render = function render() {
          _Legend.prototype.render.call(this);

          if (this.get('slidable')) {
            this._renderSlider();
          } else {
            this._renderUnslidable();
          }
        };

        _proto._renderSlider = function _renderSlider() {
          var minHandleElement = new Group();
          var maxHandleElement = new Group();
          var backgroundElement = new Group();

          var start = this._calStartPoint();

          var group = this.get('group');
          var slider = group.addGroup(Slider, {
            minHandleElement: minHandleElement,
            maxHandleElement: maxHandleElement,
            backgroundElement: backgroundElement,
            layout: this.get('layout'),
            range: this.get('_range'),
            width: this.get('width'),
            height: this.get('height')
          });
          slider.translate(start.x, start.y);
          this.set('slider', slider);

          var shape = this._renderSliderShape();

          shape.attr('clip', slider.get('middleHandleElement'));

          this._renderTrigger();
        } // the middle bar
        ;

        _proto._addMiddleBar = function _addMiddleBar(parent, name, attrs) {
          // background of the middle bar
          parent.addShape(name, {
            attrs: Util.mix({}, attrs, this.get('middleBackgroundStyle'))
          }); // frontground of the middle bar

          return parent.addShape(name, {
            attrs: attrs
          });
        };

        _proto._renderTrigger = function _renderTrigger() {
          var min = this.get('firstItem');
          var max = this.get('lastItem');
          var layout = this.get('layout');
          var textStyle = this.get('textStyle');
          var triggerAttr = this.get('triggerAttr');
          var minBlockAttr = Util.mix({}, triggerAttr);
          var maxBlockAttr = Util.mix({}, triggerAttr);
          var minTextAttr = Util.mix({
            text: this._formatItemValue(min.value) + ''
          }, textStyle);
          var maxTextAttr = Util.mix({
            text: this._formatItemValue(max.value) + ''
          }, textStyle);

          if (layout === 'vertical') {
            this._addVerticalTrigger('min', minBlockAttr, minTextAttr);

            this._addVerticalTrigger('max', maxBlockAttr, maxTextAttr);
          } else {
            this._addHorizontalTrigger('min', minBlockAttr, minTextAttr);

            this._addHorizontalTrigger('max', maxBlockAttr, maxTextAttr);
          }
        };

        _proto._addVerticalTrigger = function _addVerticalTrigger(type, blockAttr, textAttr) {
          var slider = this.get('slider');
          var trigger = slider.get(type + 'HandleElement');
          var width = this.get('width');
          var button = trigger.addShape('rect', {
            attrs: Util.mix({
              x: width / 2 - TRIGGER_WIDTH - 2,
              y: type === 'min' ? 0 : -TRIGGER_WIDTH,
              width: 2 * TRIGGER_WIDTH + 2,
              height: TRIGGER_WIDTH
            }, blockAttr)
          });
          var text = trigger.addShape('text', {
            attrs: Util.mix(textAttr, {
              x: width + this.get('textOffset'),
              y: type === 'max' ? -4 : 4,
              textAlign: 'start',
              lineHeight: 1,
              textBaseline: 'middle'
            })
          });
          var layout = this.get('layout');
          var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
          button.attr('cursor', trigerCursor);
          text.attr('cursor', trigerCursor);
          this.set(type + 'ButtonElement', button);
          this.set(type + 'TextElement', text);
        };

        _proto._addHorizontalTrigger = function _addHorizontalTrigger(type, blockAttr, textAttr) {
          var slider = this.get('slider');
          var trigger = slider.get(type + 'HandleElement');
          var button = trigger.addShape('rect', {
            attrs: Util.mix({
              x: type === 'min' ? -TRIGGER_WIDTH : 0,
              y: -TRIGGER_WIDTH - this.get('height') / 2,
              width: TRIGGER_WIDTH,
              height: 2 * TRIGGER_WIDTH
            }, blockAttr)
          });
          var text = trigger.addShape('text', {
            attrs: Util.mix(textAttr, {
              x: type === 'min' ? -TRIGGER_WIDTH - 4 : TRIGGER_WIDTH + 4,
              y: TRIGGER_WIDTH / 2 + this.get('textOffset') + 10,
              textAlign: type === 'min' ? 'end' : 'start',
              textBaseline: 'middle'
            })
          });
          var layout = this.get('layout');
          var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
          button.attr('cursor', trigerCursor);
          text.attr('cursor', trigerCursor);
          this.set(type + 'ButtonElement', button);
          this.set(type + 'TextElement', text);
        };

        _proto._bindEvents = function _bindEvents() {
          var _this = this;

          if (this.get('slidable')) {
            var slider = this.get('slider');
            slider.on('sliderchange', function (ev) {
              var range = ev.range;

              var firstItemValue = _this.get('firstItem').value;

              var lastItemValue = _this.get('lastItem').value;

              var minValue = firstItemValue + range[0] / 100 * (lastItemValue - firstItemValue);
              var maxValue = firstItemValue + range[1] / 100 * (lastItemValue - firstItemValue);

              _this._updateElement(minValue, maxValue);

              var itemFiltered = new Event('itemfilter', ev, true, true);
              itemFiltered.range = [minValue, maxValue];

              _this.emit('itemfilter', itemFiltered);
            });
          }

          if (this.get('hoverable')) {
            this.get('group').on('mousemove', Util.wrapBehavior(this, '_onMouseMove'));
            this.get('group').on('mouseleave', Util.wrapBehavior(this, '_onMouseLeave'));
          }
        } // update the text of min and max trigger
        ;

        _proto._updateElement = function _updateElement(min, max) {
          var minTextElement = this.get('minTextElement');
          var maxTextElement = this.get('maxTextElement');

          if (max > 1) {
            // 对于大于 1 的值，默认显示为整数
            min = parseInt(min, 10);
            max = parseInt(max, 10);
          }

          minTextElement.attr('text', this._formatItemValue(min) + '');
          maxTextElement.attr('text', this._formatItemValue(max) + '');
        };

        _proto._onMouseLeave = function _onMouseLeave() {
          var hoverPointer = this.get('group').findById('hoverPointer');
          hoverPointer && hoverPointer.destroy();
          var hoverText = this.get('group').findById('hoverText');
          hoverText && hoverText.destroy();
          this.get('canvas').draw();
        } // activate the legend while mouse moving
        ;

        _proto._onMouseMove = function _onMouseMove(ev) {
          var height = this.get('height');
          var width = this.get('width');
          var items = this.get('items');
          var el = this.get('canvas').get('el');
          var el_bbox = el.getBoundingClientRect();
          var bbox = this.get('group').getBBox();
          var value;

          if (this.get('layout') === 'vertical') {
            var valuePadding = 5;

            if (this.get('type') === 'color-legend') {
              valuePadding = 30;
            }

            var titleOffset = this.get('titleGap');
            var titleShape = this.get('titleShape');
            if (titleShape) titleOffset += titleShape.getBBox().maxY - titleShape.getBBox().minY;
            var currentPage = ev.clientY || ev.event.clientY;
            currentPage = currentPage - el_bbox.y - this.get('group').attr('matrix')[7] + bbox.y - valuePadding + titleOffset;
            value = items[0].value + (1 - currentPage / height) * (items[items.length - 1].value - items[0].value);
          } else {
            var _currentPage = ev.clientX || ev.event.clientX;

            _currentPage = _currentPage - el_bbox.x - this.get('group').attr('matrix')[6];
            value = items[0].value + _currentPage / width * (items[items.length - 1].value - items[0].value);
          }

          value = value.toFixed(2);
          this.activate(value);
          this.emit('mousehover', {
            value: value
          });
        } // activated by mouse moving or being called
        ;

        _proto.activate = function activate(value) {
          if (!value) {
            return;
          }

          var hoverPointer = this.get('group').findById('hoverPointer');
          var hoverText = this.get('group').findById('hoverText');
          var items = this.get('items');

          if (value < items[0].value || value > items[items.length - 1].value) {
            return;
          }

          var height = this.get('height');
          var width = this.get('width');
          var titleShape = this.get('titleShape');
          var titleGap = this.get('titleGap');
          var points = [];
          var page = (value - items[0].value) / (items[items.length - 1].value - items[0].value);
          var textStyle;

          if (this.get('layout') === 'vertical') {
            // revise the offset
            var paddingY = 0,
                paddingX = 0;

            if (this.get('type') === 'color-legend') {
              paddingY = titleGap;
              if (titleShape) paddingY += titleShape.getBBox().height;
            }

            if (this.get('slidable')) {
              if (this.get('type') === 'color-legend') {
                paddingY -= 13;
              } else {
                paddingY = titleGap - 15;
                if (titleShape) paddingY += titleShape.getBBox().height;
              }

              paddingX += 10;
            }

            page = (1 - page) * height;
            points = [[paddingX, page + paddingY], [paddingX - 10, page + paddingY - 5], [paddingX - 10, page + paddingY + 5]];
            textStyle = Util.mix({}, {
              x: width + this.get('textOffset') / 2 + paddingX,
              y: page + paddingY,
              text: this._formatItemValue(value) + '' // 以字符串格式展示

            }, this.get('textStyle'), {
              textAlign: 'start'
            });
          } else {
            var _paddingY = 0,
                _paddingX = 0;

            if (this.get('type') === 'color-legend') {
              _paddingY = titleGap;
              if (titleShape) _paddingY += titleShape.getBBox().height;
            }

            if (this.get('slidable')) {
              if (this.get('type') === 'color-legend') {
                // hoverPointer三角形的高
                _paddingY -= 7;
              } else {
                _paddingY = titleGap;
                if (!titleShape) _paddingY -= 7;
              }

              _paddingX += 10;
            }

            page *= width;
            points = [[page + _paddingX, _paddingY], [page + _paddingX - 5, _paddingY - 10], [page + _paddingX + 5, _paddingY - 10]];
            textStyle = Util.mix({}, {
              x: page - 5,
              y: height + this.get('textOffset') + _paddingY,
              text: this._formatItemValue(value) + '' // 以字符串格式展示

            }, this.get('textStyle'));
          }

          var hoverTextStyle = Util.mix(textStyle, this.get('hoverTextStyle'));

          if (!hoverText) {
            // mouse enter the legend, add hoverText
            hoverText = this.get('group').addShape('text', {
              attrs: hoverTextStyle
            });
            hoverText.set('id', 'hoverText');
          } else {
            // mouse move, update hoverText
            hoverText.attr(hoverTextStyle);
          }

          if (!hoverPointer) {
            // mouse enter the legend, add hoverPointer
            hoverPointer = this.get('group').addShape('Polygon', {
              attrs: Util.mix({
                points: points
              }, this.get('pointerStyle'))
            });
            hoverPointer.set('id', 'hoverPointer');
          } else {
            // mouse move, update hoverPointer
            hoverPointer.attr(Util.mix({
              points: points
            }, this.get('pointerStyle')));
          }

          this.get('canvas').draw();
        };

        _proto.deactivate = function deactivate() {
          var hoverPointer = this.get('group').findById('hoverPointer');
          hoverPointer && hoverPointer.destroy();
          var hoverText = this.get('group').findById('hoverText');
          hoverText && hoverText.destroy();
          this.get('canvas').draw();
        };

        return Continuous;
      }(Legend);

      module.exports = Continuous;
      /***/
    },
    /* 69 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Component = __webpack_require__(67);

      var Util = __webpack_require__(3);

      var Tooltip = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Tooltip, _Component);

        function Tooltip() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = Tooltip.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Component.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * tooltip container
             * @type {Dom / String}
             */

            /**
             * 右下角坐标
             * @type {Number}
             */
            x: 0,

            /**
             * y 右下角坐标
             * @type {Number}
             */
            y: 0,

            /**
             * tooltip 记录项
             * @type {Array}
             */
            items: null,

            /**
             * tooltip 标题
             * @type {Array}
             */
            titleContent: null,

            /**
             * 是否展示 title
             * @type {Boolean}
             */
            showTitle: true,

            /**
             * 视图范围
             * @type {Object}
             */
            plotRange: null,

            /**
             * x轴上，移动到位置的偏移量
             * @type {Number}
             */
            offset: 10,
            // TODO:支持xy两个方向上的offset

            /**
             * 时间戳
             * @type {Number}
             */
            timeStamp: 0,

            /**
             * 将 tooltip 展示在指定区域内
             * @type {Boolean}
             */
            inPlot: true,

            /**
             * tooltip 辅助线配置
             * @type {Object}
             */
            crosshairs: null
          });
        };

        _proto.isContentChange = function isContentChange(title, items) {
          var titleContent = this.get('titleContent');
          var lastItems = this.get('items');
          var isChanged = !(title === titleContent && lastItems.length === items.length);

          if (!isChanged) {
            Util.each(items, function (item, index) {
              var preItem = lastItems[index];

              for (var key in item) {
                if (item.hasOwnProperty(key)) {
                  if (!Util.isObject(item[key]) && item[key] !== preItem[key]) {
                    isChanged = true;
                    break;
                  }
                }
              }

              if (isChanged) {
                return false;
              }
            });
          }

          return isChanged;
        };

        _proto.setContent = function setContent(title, items) {
          var timeStamp = new Date().valueOf();
          this.set('items', items);
          this.set('titleContent', title);
          this.set('timeStamp', timeStamp);
          this.render();
          return this;
        };

        _proto.setPosition = function setPosition(x, y) {
          this.set('x', x);
          this.set('y', y);
        };

        _proto.render = function render() {};

        _proto.clear = function clear() {};

        _proto.show = function show() {
          this.set('visible', true);
        };

        _proto.hide = function hide() {
          this.set('visible', false);
        };

        return Tooltip;
      }(Component);

      module.exports = Tooltip;
      /***/
    },
    /* 70 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "c", function () {
        return root;
      });
      /* harmony export (immutable) */


      __webpack_exports__["a"] = Selection;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__select__ = __webpack_require__(416);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__selectAll__ = __webpack_require__(417);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__filter__ = __webpack_require__(418);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__data__ = __webpack_require__(419);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__enter__ = __webpack_require__(389);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__exit__ = __webpack_require__(421);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__join__ = __webpack_require__(422);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__merge__ = __webpack_require__(423);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__order__ = __webpack_require__(424);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__sort__ = __webpack_require__(425);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_10__call__ = __webpack_require__(426);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_11__nodes__ = __webpack_require__(427);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_12__node__ = __webpack_require__(428);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_13__size__ = __webpack_require__(429);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_14__empty__ = __webpack_require__(430);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_15__each__ = __webpack_require__(431);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_16__attr__ = __webpack_require__(432);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_17__style__ = __webpack_require__(391);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_18__property__ = __webpack_require__(433);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_19__classed__ = __webpack_require__(434);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_20__text__ = __webpack_require__(435);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_21__html__ = __webpack_require__(436);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_22__raise__ = __webpack_require__(437);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_23__lower__ = __webpack_require__(438);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_24__append__ = __webpack_require__(439);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_25__insert__ = __webpack_require__(440);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_26__remove__ = __webpack_require__(441);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_27__clone__ = __webpack_require__(442);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_28__datum__ = __webpack_require__(443);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_29__on__ = __webpack_require__(377);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_30__dispatch__ = __webpack_require__(444);

      var root = [null];

      function Selection(groups, parents) {
        this._groups = groups;
        this._parents = parents;
      }

      function selection() {
        return new Selection([[document.documentElement]], root);
      }

      Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: __WEBPACK_IMPORTED_MODULE_0__select__["a"
        /* default */
        ],
        selectAll: __WEBPACK_IMPORTED_MODULE_1__selectAll__["a"
        /* default */
        ],
        filter: __WEBPACK_IMPORTED_MODULE_2__filter__["a"
        /* default */
        ],
        data: __WEBPACK_IMPORTED_MODULE_3__data__["a"
        /* default */
        ],
        enter: __WEBPACK_IMPORTED_MODULE_4__enter__["b"
        /* default */
        ],
        exit: __WEBPACK_IMPORTED_MODULE_5__exit__["a"
        /* default */
        ],
        join: __WEBPACK_IMPORTED_MODULE_6__join__["a"
        /* default */
        ],
        merge: __WEBPACK_IMPORTED_MODULE_7__merge__["a"
        /* default */
        ],
        order: __WEBPACK_IMPORTED_MODULE_8__order__["a"
        /* default */
        ],
        sort: __WEBPACK_IMPORTED_MODULE_9__sort__["a"
        /* default */
        ],
        call: __WEBPACK_IMPORTED_MODULE_10__call__["a"
        /* default */
        ],
        nodes: __WEBPACK_IMPORTED_MODULE_11__nodes__["a"
        /* default */
        ],
        node: __WEBPACK_IMPORTED_MODULE_12__node__["a"
        /* default */
        ],
        size: __WEBPACK_IMPORTED_MODULE_13__size__["a"
        /* default */
        ],
        empty: __WEBPACK_IMPORTED_MODULE_14__empty__["a"
        /* default */
        ],
        each: __WEBPACK_IMPORTED_MODULE_15__each__["a"
        /* default */
        ],
        attr: __WEBPACK_IMPORTED_MODULE_16__attr__["a"
        /* default */
        ],
        style: __WEBPACK_IMPORTED_MODULE_17__style__["a"
        /* default */
        ],
        property: __WEBPACK_IMPORTED_MODULE_18__property__["a"
        /* default */
        ],
        classed: __WEBPACK_IMPORTED_MODULE_19__classed__["a"
        /* default */
        ],
        text: __WEBPACK_IMPORTED_MODULE_20__text__["a"
        /* default */
        ],
        html: __WEBPACK_IMPORTED_MODULE_21__html__["a"
        /* default */
        ],
        raise: __WEBPACK_IMPORTED_MODULE_22__raise__["a"
        /* default */
        ],
        lower: __WEBPACK_IMPORTED_MODULE_23__lower__["a"
        /* default */
        ],
        append: __WEBPACK_IMPORTED_MODULE_24__append__["a"
        /* default */
        ],
        insert: __WEBPACK_IMPORTED_MODULE_25__insert__["a"
        /* default */
        ],
        remove: __WEBPACK_IMPORTED_MODULE_26__remove__["a"
        /* default */
        ],
        clone: __WEBPACK_IMPORTED_MODULE_27__clone__["a"
        /* default */
        ],
        datum: __WEBPACK_IMPORTED_MODULE_28__datum__["a"
        /* default */
        ],
        on: __WEBPACK_IMPORTED_MODULE_29__on__["b"
        /* default */
        ],
        dispatch: __WEBPACK_IMPORTED_MODULE_30__dispatch__["a"
        /* default */
        ]
      };
      /* harmony default export */

      __webpack_exports__["b"] = selection;
      /***/
    },
    /* 71 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 提取公共代码到util方法
       * @author dxq613@gmail.com
       */
      var isString = __webpack_require__(10);

      var isDate = __webpack_require__(80);

      module.exports = {
        toTimeStamp: function toTimeStamp(value) {
          if (isString(value)) {
            if (value.indexOf('T') > 0) {
              value = new Date(value).getTime();
            } else {
              value = new Date(value.replace(/-/ig, '/')).getTime();
            }
          }

          if (isDate(value)) {
            value = value.getTime();
          }

          return value;
        }
      };
      /***/
    },
    /* 72 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__create__ = __webpack_require__(415);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "create", function () {
        return __WEBPACK_IMPORTED_MODULE_0__create__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__creator__ = __webpack_require__(362);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "creator", function () {
        return __WEBPACK_IMPORTED_MODULE_1__creator__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__local__ = __webpack_require__(445);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "local", function () {
        return __WEBPACK_IMPORTED_MODULE_2__local__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__matcher__ = __webpack_require__(388);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "matcher", function () {
        return __WEBPACK_IMPORTED_MODULE_3__matcher__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__mouse__ = __webpack_require__(446);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "mouse", function () {
        return __WEBPACK_IMPORTED_MODULE_4__mouse__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__namespace__ = __webpack_require__(373);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "namespace", function () {
        return __WEBPACK_IMPORTED_MODULE_5__namespace__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__namespaces__ = __webpack_require__(374);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "namespaces", function () {
        return __WEBPACK_IMPORTED_MODULE_6__namespaces__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__point__ = __webpack_require__(363);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "clientPoint", function () {
        return __WEBPACK_IMPORTED_MODULE_7__point__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__select__ = __webpack_require__(386);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "select", function () {
        return __WEBPACK_IMPORTED_MODULE_8__select__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__selectAll__ = __webpack_require__(447);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "selectAll", function () {
        return __WEBPACK_IMPORTED_MODULE_9__selectAll__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_10__selection_index__ = __webpack_require__(70);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "selection", function () {
        return __WEBPACK_IMPORTED_MODULE_10__selection_index__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_11__selector__ = __webpack_require__(375);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "selector", function () {
        return __WEBPACK_IMPORTED_MODULE_11__selector__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_12__selectorAll__ = __webpack_require__(387);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "selectorAll", function () {
        return __WEBPACK_IMPORTED_MODULE_12__selectorAll__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_13__selection_style__ = __webpack_require__(391);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "style", function () {
        return __WEBPACK_IMPORTED_MODULE_13__selection_style__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_14__touch__ = __webpack_require__(448);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "touch", function () {
        return __WEBPACK_IMPORTED_MODULE_14__touch__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_15__touches__ = __webpack_require__(449);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "touches", function () {
        return __WEBPACK_IMPORTED_MODULE_15__touches__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_16__window__ = __webpack_require__(376);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "window", function () {
        return __WEBPACK_IMPORTED_MODULE_16__window__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_17__selection_on__ = __webpack_require__(377);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "event", function () {
        return __WEBPACK_IMPORTED_MODULE_17__selection_on__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "customEvent", function () {
        return __WEBPACK_IMPORTED_MODULE_17__selection_on__["a"];
      });
      /***/

    },
    /* 73 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        Position: __webpack_require__(294),
        Color: __webpack_require__(295),
        Shape: __webpack_require__(296),
        Size: __webpack_require__(297),
        Opacity: __webpack_require__(298),
        ColorUtil: __webpack_require__(148)
      };
      /***/
    },
    /* 74 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview Scale entry, used to reference all the scales
       * @author dxq613@gmail.com
       */
      var lowerFirst = __webpack_require__(75);

      var Base = __webpack_require__(18);

      Base.Linear = __webpack_require__(33);
      Base.Identity = __webpack_require__(176);
      Base.Cat = __webpack_require__(77);
      Base.Time = __webpack_require__(177);
      Base.TimeCat = __webpack_require__(179);
      Base.Log = __webpack_require__(180);
      Base.Pow = __webpack_require__(181);

      var _loop = function _loop(k) {
        if (Base.hasOwnProperty(k)) {
          var methodName = lowerFirst(k);

          Base[methodName] = function (cfg) {
            return new Base[k](cfg);
          };
        }
      };

      for (var k in Base) {
        _loop(k);
      }

      var CAT_ARR = ['cat', 'timeCat'];

      Base.isCategory = function (type) {
        return CAT_ARR.indexOf(type) >= 0;
      };

      module.exports = Base;
      /***/
    },
    /* 75 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(24);

      var lowerFirst = function lowerFirst(value) {
        var str = toString(value);
        return str.charAt(0).toLowerCase() + str.substring(1);
      };

      module.exports = lowerFirst;
      /***/
    },
    /* 76 */

    /***/
    function (module, exports) {
      /**
       * @fileOverview 计算方法
       * @author dxq613@gmail.com
       */
      // 如果小数点后面超过 10 位浮点数时进行一下处理
      var DECIMAL_LENGTH = 12; // 获取系数

      function getFactor(v) {
        var factor = 1;

        if (v === Infinity || v === -Infinity) {
          throw new Error('Not support Infinity!');
        }

        if (v < 1) {
          var count = 0;

          while (v < 1) {
            factor = factor / 10;
            v = v * 10;
            count++;
          } // 浮点数计算出现问题


          if (factor.toString().length > DECIMAL_LENGTH) {
            factor = parseFloat(factor.toFixed(count));
          }
        } else {
          while (v > 10) {
            factor = factor * 10;
            v = v / 10;
          }
        }

        return factor;
      } // 取小于当前值的


      function arrayFloor(values, value) {
        var length = values.length;

        if (length === 0) {
          return NaN;
        }

        var pre = values[0];

        if (value < values[0]) {
          return NaN;
        }

        if (value >= values[length - 1]) {
          return values[length - 1];
        }

        for (var i = 1; i < values.length; i++) {
          if (value < values[i]) {
            break;
          }

          pre = values[i];
        }

        return pre;
      } // 大于当前值的第一个


      function arrayCeiling(values, value) {
        var length = values.length;

        if (length === 0) {
          return NaN;
        } // var pre = values[0];


        var rst;

        if (value > values[length - 1]) {
          return NaN;
        }

        if (value < values[0]) {
          return values[0];
        }

        for (var i = 1; i < values.length; i++) {
          if (value <= values[i]) {
            rst = values[i];
            break;
          }
        }

        return rst;
      }

      var Util = {
        // 获取逼近的数值
        snapFactorTo: function snapFactorTo(v, arr, snapType) {
          // 假设 v = -512,isFloor = true
          if (isNaN(v)) {
            return NaN;
          }

          var factor = 1; // 计算系数

          if (v !== 0) {
            if (v < 0) {
              factor = -1;
            }

            v = v * factor; // v = 512

            var tmpFactor = getFactor(v);
            factor = factor * tmpFactor; // factor = -100

            v = v / tmpFactor; // v = 5.12
          }

          if (snapType === 'floor') {
            v = Util.snapFloor(arr, v); // v = 5
          } else if (snapType === 'ceil') {
            v = Util.snapCeiling(arr, v); // v = 6
          } else {
            v = Util.snapTo(arr, v); // 四舍五入 5
          }

          var rst = parseFloat((v * factor).toPrecision(DECIMAL_LENGTH)); // 如果出现浮点数计算问题，需要处理一下
          // 如果出现浮点数计算问题，需要处理一下

          if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {
            var decimalVal = parseInt(1 / factor);
            var symbol = factor > 0 ? 1 : -1;
            rst = v / decimalVal * symbol;
          }

          return rst;
        },
        // 获取逼近的倍数
        snapMultiple: function snapMultiple(v, base, snapType) {
          var div;

          if (snapType === 'ceil') {
            div = Math.ceil(v / base);
          } else if (snapType === 'floor') {
            div = Math.floor(v / base);
          } else {
            div = Math.round(v / base);
          }

          return div * base;
        },

        /**
         * 获取逼近的值，用于对齐数据
         * @param  {Array} values   数据集合
         * @param  {Number} value   数值
         * @return {Number} 逼近的值
         */
        snapTo: function snapTo(values, value) {
          // 这里假定values是升序排列
          var floorVal = arrayFloor(values, value);
          var ceilingVal = arrayCeiling(values, value);

          if (isNaN(floorVal) || isNaN(ceilingVal)) {
            if (values[0] >= value) {
              return values[0];
            }

            var last = values[values.length - 1];

            if (last <= value) {
              return last;
            }
          }

          if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {
            return floorVal;
          }

          return ceilingVal;
        },

        /**
         * 获取逼近的最小值，用于对齐数据
         * @param  {Array} values   数据集合
         * @param  {Number} value   数值
         * @return {Number} 逼近的最小值
         */
        snapFloor: function snapFloor(values, value) {
          // 这里假定values是升序排列
          return arrayFloor(values, value);
        },

        /**
         * 获取逼近的最大值，用于对齐数据
         * @param  {Array} values   数据集合
         * @param  {Number} value   数值
         * @return {Number} 逼近的最大值
         */
        snapCeiling: function snapCeiling(values, value) {
          // 这里假定values是升序排列
          return arrayCeiling(values, value);
        },
        fixedBase: function fixedBase(v, base) {
          var str = base.toString();
          var index = str.indexOf('.');
          var indexOfExp = str.indexOf('e-'); // 判断是否带小数点，1.000001 1.23e-9

          if (index < 0 && indexOfExp < 0) {
            // base为整数
            return Math.round(v);
          }

          var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;

          if (length > 20) {
            length = 20;
          }

          return parseFloat(v.toFixed(length));
        }
      };
      module.exports = Util;
      /***/
    },
    /* 77 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Base = __webpack_require__(18);

      var catAuto = __webpack_require__(78);

      var each = __webpack_require__(2);

      var isNumber = __webpack_require__(9);

      var isString = __webpack_require__(10);

      var Category = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Category, _Base);

        function Category() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Category.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          _Base.prototype._initDefaultCfg.call(this);

          this.type = 'cat';
          /**
           * 是否分类度量
           * @type {Boolean}
           */

          this.isCategory = true;
          this.isRounding = true; // 是否进行取整操作
        }
        /**
         * @override
         */
        ;

        _proto.init = function init() {
          var self = this;
          var values = self.values;
          var tickCount = self.tickCount;
          each(values, function (v, i) {
            values[i] = v.toString();
          });

          if (!self.ticks) {
            var ticks = values;

            if (tickCount) {
              var temp = catAuto({
                maxCount: tickCount,
                data: values,
                isRounding: self.isRounding
              });
              ticks = temp.ticks;
            }

            this.ticks = ticks;
          }
        }
        /**
         * @override
         */
        ;

        _proto.getText = function getText(value) {
          if (this.values.indexOf(value) === -1 && isNumber(value)) {
            value = this.values[Math.round(value)];
          }

          return _Base.prototype.getText.call(this, value);
        }
        /**
         * @override
         */
        ;

        _proto.translate = function translate(value) {
          var index = this.values.indexOf(value);

          if (index === -1 && isNumber(value)) {
            index = value;
          } else if (index === -1) {
            index = NaN;
          }

          return index;
        }
        /**
         * @override
         */
        ;

        _proto.scale = function scale(value) {
          var rangeMin = this.rangeMin();
          var rangeMax = this.rangeMax();
          var percent;

          if (isString(value) || this.values.indexOf(value) !== -1) {
            value = this.translate(value);
          }

          if (this.values.length > 1) {
            percent = value / (this.values.length - 1);
          } else {
            percent = value;
          }

          return rangeMin + percent * (rangeMax - rangeMin);
        }
        /**
         * @override
         */
        ;

        _proto.invert = function invert(value) {
          if (isString(value)) {
            // 如果已经是字符串
            return value;
          }

          var min = this.rangeMin();
          var max = this.rangeMax(); // 归一到 范围内

          if (value < min) {
            value = min;
          }

          if (value > max) {
            value = max;
          }

          var percent = (value - min) / (max - min);
          var index = Math.round(percent * (this.values.length - 1)) % this.values.length;
          index = index || 0;
          return this.values[index];
        };

        return Category;
      }(Base);

      Base.Cat = Category;
      module.exports = Category;
      /***/
    },
    /* 78 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 计算分类的的坐标点
       * @author dxq613@gmail.com
       */
      var each = __webpack_require__(2);

      var MAX_COUNT = 8;
      var SUB_COUNT = 4; // 控制个数不能过小

      function getSimpleArray(data) {
        var arr = [];
        each(data, function (sub) {
          arr = arr.concat(sub);
        });
        return arr;
      }

      function getGreatestFactor(count, number) {
        var i;

        for (i = number; i > 0; i--) {
          if (count % i === 0) {
            break;
          }
        } // 如果是素数，没有可以整除的数字


        if (i === 1) {
          for (i = number; i > 0; i--) {
            if ((count - 1) % i === 0) {
              break;
            }
          }
        }

        return i;
      }

      module.exports = function (info) {
        var rst = {};
        var ticks = [];
        var isRounding = info.isRounding;
        var categories = getSimpleArray(info.data);
        var length = categories.length;
        var maxCount = info.maxCount || MAX_COUNT;
        var tickCount;

        if (isRounding) {
          // 取整操作
          tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1; // 如果计算出来只有两个坐标点，则直接使用传入的 maxCount

          if (tickCount === 2) {
            tickCount = maxCount;
          } else if (tickCount < maxCount - SUB_COUNT) {
            tickCount = maxCount - SUB_COUNT;
          }
        } else {
          tickCount = maxCount;
        }

        if (!isRounding && length <= tickCount + tickCount / 2) {
          ticks = [].concat(categories);
        } else {
          var step = parseInt(length / (tickCount - 1), 10);
          var groups = categories.map(function (e, i) {
            return i % step === 0 ? categories.slice(i, i + step) : null;
          }).filter(function (e) {
            return e;
          });

          for (var i = 1, groupLen = groups.length; i < groupLen && (isRounding ? i * step < length - step : i < tickCount - 1); i++) {
            ticks.push(groups[i][0]);
          }

          if (categories.length) {
            ticks.unshift(categories[0]);
            var last = categories[length - 1];

            if (ticks.indexOf(last) === -1) {
              ticks.push(last);
            }
          }
        }

        rst.categories = categories;
        rst.ticks = ticks;
        return rst;
      };
      /***/

    },
    /* 79 */

    /***/
    function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;

      (function (main) {
        'use strict';
        /**
         * Parse or format dates
         * @class fecha
         */

        var fecha = {};
        var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
        var twoDigits = /\d\d?/;
        var threeDigits = /\d{3}/;
        var fourDigits = /\d{4}/;
        var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
        var literal = /\[([^]*?)\]/gm;

        var noop = function noop() {};

        function shorten(arr, sLen) {
          var newArr = [];

          for (var i = 0, len = arr.length; i < len; i++) {
            newArr.push(arr[i].substr(0, sLen));
          }

          return newArr;
        }

        function monthUpdate(arrName) {
          return function (d, v, i18n) {
            var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());

            if (~index) {
              d.month = index;
            }
          };
        }

        function pad(val, len) {
          val = String(val);
          len = len || 2;

          while (val.length < len) {
            val = '0' + val;
          }

          return val;
        }

        var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        var monthNamesShort = shorten(monthNames, 3);
        var dayNamesShort = shorten(dayNames, 3);
        fecha.i18n = {
          dayNamesShort: dayNamesShort,
          dayNames: dayNames,
          monthNamesShort: monthNamesShort,
          monthNames: monthNames,
          amPm: ['am', 'pm'],
          DoFn: function DoFn(D) {
            return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
          }
        };
        var formatFlags = {
          D: function D(dateObj) {
            return dateObj.getDate();
          },
          DD: function DD(dateObj) {
            return pad(dateObj.getDate());
          },
          Do: function Do(dateObj, i18n) {
            return i18n.DoFn(dateObj.getDate());
          },
          d: function d(dateObj) {
            return dateObj.getDay();
          },
          dd: function dd(dateObj) {
            return pad(dateObj.getDay());
          },
          ddd: function ddd(dateObj, i18n) {
            return i18n.dayNamesShort[dateObj.getDay()];
          },
          dddd: function dddd(dateObj, i18n) {
            return i18n.dayNames[dateObj.getDay()];
          },
          M: function M(dateObj) {
            return dateObj.getMonth() + 1;
          },
          MM: function MM(dateObj) {
            return pad(dateObj.getMonth() + 1);
          },
          MMM: function MMM(dateObj, i18n) {
            return i18n.monthNamesShort[dateObj.getMonth()];
          },
          MMMM: function MMMM(dateObj, i18n) {
            return i18n.monthNames[dateObj.getMonth()];
          },
          YY: function YY(dateObj) {
            return String(dateObj.getFullYear()).substr(2);
          },
          YYYY: function YYYY(dateObj) {
            return pad(dateObj.getFullYear(), 4);
          },
          h: function h(dateObj) {
            return dateObj.getHours() % 12 || 12;
          },
          hh: function hh(dateObj) {
            return pad(dateObj.getHours() % 12 || 12);
          },
          H: function H(dateObj) {
            return dateObj.getHours();
          },
          HH: function HH(dateObj) {
            return pad(dateObj.getHours());
          },
          m: function m(dateObj) {
            return dateObj.getMinutes();
          },
          mm: function mm(dateObj) {
            return pad(dateObj.getMinutes());
          },
          s: function s(dateObj) {
            return dateObj.getSeconds();
          },
          ss: function ss(dateObj) {
            return pad(dateObj.getSeconds());
          },
          S: function S(dateObj) {
            return Math.round(dateObj.getMilliseconds() / 100);
          },
          SS: function SS(dateObj) {
            return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
          },
          SSS: function SSS(dateObj) {
            return pad(dateObj.getMilliseconds(), 3);
          },
          a: function a(dateObj, i18n) {
            return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
          },
          A: function A(dateObj, i18n) {
            return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
          },
          ZZ: function ZZ(dateObj) {
            var o = dateObj.getTimezoneOffset();
            return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
          }
        };
        var parseFlags = {
          D: [twoDigits, function (d, v) {
            d.day = v;
          }],
          Do: [new RegExp(twoDigits.source + word.source), function (d, v) {
            d.day = parseInt(v, 10);
          }],
          M: [twoDigits, function (d, v) {
            d.month = v - 1;
          }],
          YY: [twoDigits, function (d, v) {
            var da = new Date(),
                cent = +('' + da.getFullYear()).substr(0, 2);
            d.year = '' + (v > 68 ? cent - 1 : cent) + v;
          }],
          h: [twoDigits, function (d, v) {
            d.hour = v;
          }],
          m: [twoDigits, function (d, v) {
            d.minute = v;
          }],
          s: [twoDigits, function (d, v) {
            d.second = v;
          }],
          YYYY: [fourDigits, function (d, v) {
            d.year = v;
          }],
          S: [/\d/, function (d, v) {
            d.millisecond = v * 100;
          }],
          SS: [/\d{2}/, function (d, v) {
            d.millisecond = v * 10;
          }],
          SSS: [threeDigits, function (d, v) {
            d.millisecond = v;
          }],
          d: [twoDigits, noop],
          ddd: [word, noop],
          MMM: [word, monthUpdate('monthNamesShort')],
          MMMM: [word, monthUpdate('monthNames')],
          a: [word, function (d, v, i18n) {
            var val = v.toLowerCase();

            if (val === i18n.amPm[0]) {
              d.isPm = false;
            } else if (val === i18n.amPm[1]) {
              d.isPm = true;
            }
          }],
          ZZ: [/([\+\-]\d\d:?\d\d|Z)/, function (d, v) {
            if (v === 'Z') v = '+00:00';
            var parts = (v + '').match(/([\+\-]|\d\d)/gi),
                minutes;

            if (parts) {
              minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
              d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
            }
          }]
        };
        parseFlags.dd = parseFlags.d;
        parseFlags.dddd = parseFlags.ddd;
        parseFlags.DD = parseFlags.D;
        parseFlags.mm = parseFlags.m;
        parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
        parseFlags.MM = parseFlags.M;
        parseFlags.ss = parseFlags.s;
        parseFlags.A = parseFlags.a; // Some common format strings

        fecha.masks = {
          "default": 'ddd MMM DD YYYY HH:mm:ss',
          shortDate: 'M/D/YY',
          mediumDate: 'MMM D, YYYY',
          longDate: 'MMMM D, YYYY',
          fullDate: 'dddd, MMMM D, YYYY',
          shortTime: 'HH:mm',
          mediumTime: 'HH:mm:ss',
          longTime: 'HH:mm:ss.SSS'
        };
        /***
         * Format a date
         * @method format
         * @param {Date|number} dateObj
         * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
         */

        fecha.format = function (dateObj, mask, i18nSettings) {
          var i18n = i18nSettings || fecha.i18n;

          if (typeof dateObj === 'number') {
            dateObj = new Date(dateObj);
          }

          if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
            throw new Error('Invalid Date in fecha.format');
          }

          mask = fecha.masks[mask] || mask || fecha.masks['default'];
          var literals = []; // Make literals inactive by replacing them with ??

          mask = mask.replace(literal, function ($0, $1) {
            literals.push($1);
            return '??';
          }); // Apply formatting rules

          mask = mask.replace(token, function ($0) {
            return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
          }); // Inline literal values back into the formatted value

          return mask.replace(/\?\?/g, function () {
            return literals.shift();
          });
        };
        /**
         * Parse a date string into an object, changes - into /
         * @method parse
         * @param {string} dateStr Date string
         * @param {string} format Date parse format
         * @returns {Date|boolean}
         */


        fecha.parse = function (dateStr, format, i18nSettings) {
          var i18n = i18nSettings || fecha.i18n;

          if (typeof format !== 'string') {
            throw new Error('Invalid format in fecha.parse');
          }

          format = fecha.masks[format] || format; // Avoid regular expression denial of service, fail early for really long strings
          // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS

          if (dateStr.length > 1000) {
            return false;
          }

          var isValid = true;
          var dateInfo = {};
          format.replace(token, function ($0) {
            if (parseFlags[$0]) {
              var info = parseFlags[$0];
              var index = dateStr.search(info[0]);

              if (!~index) {
                isValid = false;
              } else {
                dateStr.replace(info[0], function (result) {
                  info[1](dateInfo, result, i18n);
                  dateStr = dateStr.substr(index + result.length);
                  return result;
                });
              }
            }

            return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
          });

          if (!isValid) {
            return false;
          }

          var today = new Date();

          if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
            dateInfo.hour = +dateInfo.hour + 12;
          } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
            dateInfo.hour = 0;
          }

          var date;

          if (dateInfo.timezoneOffset != null) {
            dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
            date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
          } else {
            date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
          }

          return date;
        };
        /* istanbul ignore next */


        if (typeof module !== 'undefined' && module.exports) {
          module.exports = fecha;
        } else if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return fecha;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
      })(this);
      /***/

    },
    /* 80 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(12);

      var isDate = function isDate(value) {
        return isType(value, 'Date');
      };

      module.exports = isDate;
      /***/
    },
    /* 81 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        isFunction: __webpack_require__(11),
        isObject: __webpack_require__(25),
        isBoolean: __webpack_require__(82),
        isNil: __webpack_require__(5),
        isString: __webpack_require__(10),
        isArray: __webpack_require__(4),
        isNumber: __webpack_require__(9),
        isEmpty: __webpack_require__(83),
        // isBlank
        uniqueId: __webpack_require__(86),
        clone: __webpack_require__(47),
        deepMix: __webpack_require__(48),
        assign: __webpack_require__(8),
        // simpleMix
        merge: __webpack_require__(48),
        // mix
        upperFirst: __webpack_require__(87),
        // ucfirst
        each: __webpack_require__(2),
        isEqual: __webpack_require__(50),
        toArray: __webpack_require__(34),
        extend: __webpack_require__(88),
        augment: __webpack_require__(89),
        remove: __webpack_require__(90),
        isNumberEqual: __webpack_require__(35),
        toRadian: __webpack_require__(91),
        toDegree: __webpack_require__(92),
        mod: __webpack_require__(93),
        clamp: __webpack_require__(51),
        createDom: __webpack_require__(94),
        modifyCSS: __webpack_require__(95),
        requestAnimationFrame: __webpack_require__(96),
        getRatio: function getRatio() {
          return window.devicePixelRatio ? window.devicePixelRatio : 2;
        },
        mat3: __webpack_require__(52),
        vec2: __webpack_require__(97),
        vec3: __webpack_require__(98),
        transform: __webpack_require__(99)
      };
      /***/
    },
    /* 82 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 是否是布尔类型
       *
       * @param {Object} value 测试的值
       * @return {Boolean}
       */
      var isType = __webpack_require__(12);

      var isBoolean = function isBoolean(value) {
        return isType(value, 'Boolean');
      };

      module.exports = isBoolean;
      /***/
    },
    /* 83 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      var isArrayLike = __webpack_require__(13);

      var getType = __webpack_require__(84);

      var isPrototype = __webpack_require__(85);

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function isEmpty(value) {
        /**
         * isEmpty(null) => true
         * isEmpty() => true
         * isEmpty(true) => true
         * isEmpty(1) => true
         * isEmpty([1, 2, 3]) => false
         * isEmpty('abc') => false
         * isEmpty({ a: 1 }) => false
         */
        if (isNil(value)) {
          return true;
        }

        if (isArrayLike(value)) {
          return !value.length;
        }

        var type = getType(value);

        if (type === 'Map' || type === 'Set') {
          return !value.size;
        }

        if (isPrototype(value)) {
          return !Object.keys(value).length;
        }

        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }

        return true;
      }

      module.exports = isEmpty;
      /***/
    },
    /* 84 */

    /***/
    function (module, exports) {
      var toString = {}.toString;

      var getType = function getType(value) {
        return toString.call(value).replace(/^\[object /, '').replace(/\]$/, '');
      };

      module.exports = getType;
      /***/
    },
    /* 85 */

    /***/
    function (module, exports) {
      var objectProto = Object.prototype;

      var isPrototype = function isPrototype(value) {
        var Ctor = value && value.constructor;
        var proto = typeof Ctor === 'function' && Ctor.prototype || objectProto;
        return value === proto;
      };

      module.exports = isPrototype;
      /***/
    },
    /* 86 */

    /***/
    function (module, exports) {
      var uniqueId = function () {
        var map = {};
        return function (prefix) {
          prefix = prefix || 'g';

          if (!map[prefix]) {
            map[prefix] = 1;
          } else {
            map[prefix] += 1;
          }

          return prefix + map[prefix];
        };
      }();

      module.exports = uniqueId;
      /***/
    },
    /* 87 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(24);

      var upperFirst = function upperFirst(value) {
        var str = toString(value);
        return str.charAt(0).toUpperCase() + str.substring(1);
      };

      module.exports = upperFirst;
      /***/
    },
    /* 88 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(11);

      var mix = __webpack_require__(8);

      var extend = function extend(subclass, superclass, overrides, staticOverrides) {
        // 如果只提供父类构造函数，则自动生成子类构造函数
        if (!isFunction(superclass)) {
          overrides = superclass;
          superclass = subclass;

          subclass = function subclass() {};
        }

        var create = Object.create ? function (proto, c) {
          return Object.create(proto, {
            constructor: {
              value: c
            }
          });
        } : function (proto, c) {
          function Tmp() {}

          Tmp.prototype = proto;
          var o = new Tmp();
          o.constructor = c;
          return o;
        };
        var superObj = create(superclass.prototype, subclass); // new superclass(),//实例化父类作为子类的prototype

        subclass.prototype = mix(superObj, subclass.prototype); // 指定子类的prototype

        subclass.superclass = create(superclass.prototype, superclass);
        mix(superObj, overrides);
        mix(subclass, staticOverrides);
        return subclass;
      };

      module.exports = extend;
      /***/
    },
    /* 89 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(11);

      var toArray = __webpack_require__(34);

      var mix = __webpack_require__(8);

      var augment = function augment(c) {
        var args = toArray(arguments);

        for (var i = 1; i < args.length; i++) {
          var obj = args[i];

          if (isFunction(obj)) {
            obj = obj.prototype;
          }

          mix(c.prototype, obj);
        }
      };

      module.exports = augment;
      /***/
    },
    /* 90 */

    /***/
    function (module, exports) {
      var arrPrototype = Array.prototype;
      var splice = arrPrototype.splice;
      var indexOf = arrPrototype.indexOf;
      var slice = arrPrototype.slice;

      var pull = function pull(arr) {
        var values = slice.call(arguments, 1);

        for (var i = 0; i < values.length; i++) {
          var value = values[i];
          var fromIndex = -1;

          while ((fromIndex = indexOf.call(arr, value)) > -1) {
            splice.call(arr, fromIndex, 1);
          }
        }

        return arr;
      };

      module.exports = pull;
      /***/
    },
    /* 91 */

    /***/
    function (module, exports) {
      var RADIAN = Math.PI / 180;

      var toRadian = function toRadian(degree) {
        return RADIAN * degree;
      };

      module.exports = toRadian;
      /***/
    },
    /* 92 */

    /***/
    function (module, exports) {
      var DEGREE = 180 / Math.PI;

      var toDegree = function toDegree(radian) {
        return DEGREE * radian;
      };

      module.exports = toDegree;
      /***/
    },
    /* 93 */

    /***/
    function (module, exports) {
      var mod = function mod(n, m) {
        return (n % m + m) % m;
      };

      module.exports = mod;
      /***/
    },
    /* 94 */

    /***/
    function (module, exports) {
      /**
       * 创建DOM 节点
       * @param  {String} str Dom 字符串
       * @return {HTMLElement}  DOM 节点
       */
      var TABLE = document.createElement('table');
      var TABLE_TR = document.createElement('tr');
      var FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
      var CONTAINERS = {
        tr: document.createElement('tbody'),
        tbody: TABLE,
        thead: TABLE,
        tfoot: TABLE,
        td: TABLE_TR,
        th: TABLE_TR,
        '*': document.createElement('div')
      };

      module.exports = function createDom(str) {
        var name = FRAGMENT_REG.test(str) && RegExp.$1;

        if (!(name in CONTAINERS)) {
          name = '*';
        }

        var container = CONTAINERS[name];
        str = str.replace(/(^\s*)|(\s*$)/g, '');
        container.innerHTML = '' + str;
        var dom = container.childNodes[0];
        container.removeChild(dom);
        return dom;
      };
      /***/

    },
    /* 95 */

    /***/
    function (module, exports) {
      module.exports = function modifyCSS(dom, css) {
        if (dom) {
          for (var key in css) {
            if (css.hasOwnProperty(key)) {
              dom.style[key] = css[key];
            }
          }
        }

        return dom;
      };
      /***/

    },
    /* 96 */

    /***/
    function (module, exports) {
      module.exports = function requestAnimationFrame(fn) {
        var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
          return setTimeout(fn, 16);
        };

        return method(fn);
      };
      /***/

    },
    /* 97 */

    /***/
    function (module, exports, __webpack_require__) {
      var vec2 = __webpack_require__(184);

      var clamp = __webpack_require__(51);

      vec2.angle = function (v1, v2) {
        var theta = vec2.dot(v1, v2) / (vec2.length(v1) * vec2.length(v2));
        return Math.acos(clamp(theta, -1, 1));
      };
      /**
       * 向量 v1 到 向量 v2 夹角的方向
       * @param  {Array} v1 向量
       * @param  {Array} v2 向量
       * @return {Boolean} >= 0 顺时针 < 0 逆时针
       */


      vec2.direction = function (v1, v2) {
        return v1[0] * v2[1] - v2[0] * v1[1];
      };

      vec2.angleTo = function (v1, v2, direct) {
        var angle = vec2.angle(v1, v2);
        var angleLargeThanPI = vec2.direction(v1, v2) >= 0;

        if (direct) {
          if (angleLargeThanPI) {
            return Math.PI * 2 - angle;
          }

          return angle;
        }

        if (angleLargeThanPI) {
          return angle;
        }

        return Math.PI * 2 - angle;
      };

      vec2.vertical = function (out, v, flag) {
        if (flag) {
          out[0] = v[1];
          out[1] = -1 * v[0];
        } else {
          out[0] = -1 * v[1];
          out[1] = v[0];
        }

        return out;
      };

      module.exports = vec2;
      /***/
    },
    /* 98 */

    /***/
    function (module, exports, __webpack_require__) {
      var vec3 = __webpack_require__(185);

      module.exports = vec3;
      /***/
    },
    /* 99 */

    /***/
    function (module, exports, __webpack_require__) {
      var clone = __webpack_require__(47);

      var each = __webpack_require__(2);

      var mat3 = __webpack_require__(52);

      module.exports = function transform(m, ts) {
        m = clone(m);
        each(ts, function (t) {
          switch (t[0]) {
            case 't':
              mat3.translate(m, m, [t[1], t[2]]);
              break;

            case 's':
              mat3.scale(m, m, [t[1], t[2]]);
              break;

            case 'r':
              mat3.rotate(m, m, t[1]);
              break;

            case 'm':
              mat3.multiply(m, m, t[1]);
              break;

            default:
              return false;
          }
        });
        return m;
      };
      /***/

    },
    /* 100 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Event = function Event(type, event, bubbles, cancelable) {
        this.type = type; // 事件类型

        this.target = null; // 目标

        this.currentTarget = null; // 当前目标

        this.bubbles = bubbles; // 冒泡

        this.cancelable = cancelable; // 是否能够阻止

        this.timeStamp = new Date().getTime(); // 时间戳

        this.defaultPrevented = false; // 阻止默认

        this.propagationStopped = false; // 阻止冒泡

        this.removed = false; // 是否被移除

        this.event = event; // 触发的原生事件
      };

      Util.augment(Event, {
        preventDefault: function preventDefault() {
          this.defaultPrevented = this.cancelable && true;
        },
        stopPropagation: function stopPropagation() {
          this.propagationStopped = true;
        },
        remove: function remove() {
          this.remove = true;
        },
        clone: function clone() {
          return Util.clone(this);
        },
        toString: function toString() {
          return '[Event (type=' + this.type + ')]';
        }
      });
      module.exports = Event;
      /***/
    },
    /* 101 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Element = __webpack_require__(102);

      var Shape = __webpack_require__(189);

      var SHAPE_MAP = {}; // 缓存图形类型

      var INDEX = '_INDEX';

      function getComparer(compare) {
        return function (left, right) {
          var result = compare(left, right);
          return result === 0 ? left[INDEX] - right[INDEX] : result;
        };
      }

      function find(children, x, y) {
        var rst;

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          if (child._cfg.visible && child._cfg.capture) {
            if (child.isGroup) {
              rst = child.getShape(x, y);
            } else if (child.isHit(x, y)) {
              rst = child;
            }
          }

          if (rst) {
            break;
          }
        }

        return rst;
      }

      var Group = function Group(cfg) {
        Group.superclass.constructor.call(this, cfg);
        this.set('children', []);
        this.set('tobeRemoved', []);

        this._beforeRenderUI();

        this._renderUI();

        this._bindUI();
      };

      function initClassCfgs(c) {
        if (c._cfg || c === Group) {
          return;
        }

        var superCon = c.superclass.constructor;

        if (superCon && !superCon._cfg) {
          initClassCfgs(superCon);
        }

        c._cfg = {};
        Util.merge(c._cfg, superCon._cfg);
        Util.merge(c._cfg, c.CFG);
      }

      Util.extend(Group, Element);
      Util.augment(Group, {
        isGroup: true,
        type: 'group',
        canFill: true,
        canStroke: true,
        getDefaultCfg: function getDefaultCfg() {
          initClassCfgs(this.constructor);
          return Util.merge({}, this.constructor._cfg);
        },
        _beforeRenderUI: function _beforeRenderUI() {},
        _renderUI: function _renderUI() {},
        _bindUI: function _bindUI() {},
        addShape: function addShape(type, cfg) {
          var canvas = this.get('canvas');
          cfg = cfg || {};
          var shapeType = SHAPE_MAP[type];

          if (!shapeType) {
            shapeType = Util.upperFirst(type);
            SHAPE_MAP[type] = shapeType;
          }

          if (cfg.attrs && canvas) {
            var attrs = cfg.attrs;

            if (type === 'text') {
              // 临时解决
              var topFontFamily = canvas.get('fontFamily');

              if (topFontFamily) {
                attrs.fontFamily = attrs.fontFamily ? attrs.fontFamily : topFontFamily;
              }
            }
          }

          cfg.canvas = canvas;
          cfg.type = type;
          var rst = new Shape[shapeType](cfg);
          this.add(rst);
          return rst;
        },

        /** 添加图组
         * @param  {Function|Object|undefined} param 图组类
         * @param  {Object} cfg 配置项
         * @return {Object} rst 图组
         */
        addGroup: function addGroup(param, cfg) {
          var canvas = this.get('canvas');
          var rst;
          cfg = Util.merge({}, cfg);

          if (Util.isFunction(param)) {
            if (cfg) {
              cfg.canvas = canvas;
              cfg.parent = this;
              rst = new param(cfg);
            } else {
              rst = new param({
                canvas: canvas,
                parent: this
              });
            }

            this.add(rst);
          } else if (Util.isObject(param)) {
            param.canvas = canvas;
            rst = new Group(param);
            this.add(rst);
          } else if (param === undefined) {
            rst = new Group();
            this.add(rst);
          } else {
            return false;
          }

          return rst;
        },

        /** 绘制背景
         * @param  {Array} padding 内边距
         * @param  {Attrs} attrs 图形属性
         * @param  {Shape} backShape 背景图形
         * @return {Object} 背景层对象
         */
        renderBack: function renderBack(padding, attrs) {
          var backShape = this.get('backShape');
          var innerBox = this.getBBox(); // const parent = this.get('parent'); // getParent

          Util.merge(attrs, {
            x: innerBox.minX - padding[3],
            y: innerBox.minY - padding[0],
            width: innerBox.width + padding[1] + padding[3],
            height: innerBox.height + padding[0] + padding[2]
          });

          if (backShape) {
            backShape.attr(attrs);
          } else {
            backShape = this.addShape('rect', {
              zIndex: -1,
              attrs: attrs
            });
          }

          this.set('backShape', backShape);
          this.sort();
          return backShape;
        },
        removeChild: function removeChild(item, destroy) {
          if (arguments.length >= 2) {
            if (this.contain(item)) {
              item.remove(destroy);
            }
          } else {
            if (arguments.length === 1) {
              if (Util.isBoolean(item)) {
                destroy = item;
              } else {
                if (this.contain(item)) {
                  item.remove(true);
                }

                return this;
              }
            }

            if (arguments.length === 0) {
              destroy = true;
            }

            Group.superclass.remove.call(this, destroy);
          }

          return this;
        },

        /**
         * 向组中添加shape或者group
         * @param {Object} items 图形或者分组
         * @return {Object} group 本尊
         */
        add: function add(items) {
          var self = this;
          var children = self.get('children');

          if (Util.isArray(items)) {
            Util.each(items, function (item) {
              var parent = item.get('parent');

              if (parent) {
                parent.removeChild(item, false);
              }

              self._setCfgProperty(item);
            });
            self._cfg.children = children.concat(items);
          } else {
            var item = items;
            var parent = item.get('parent');

            if (parent) {
              parent.removeChild(item, false);
            }

            self._setCfgProperty(item);

            children.push(item);
          }

          return self;
        },
        _setCfgProperty: function _setCfgProperty(item) {
          var cfg = this._cfg;
          item.set('parent', this);
          item.set('canvas', cfg.canvas);

          if (cfg.timeline) {
            item.set('timeline', cfg.timeline);
          }
        },
        contain: function contain(item) {
          var children = this.get('children');
          return children.indexOf(item) > -1;
        },
        getChildByIndex: function getChildByIndex(index) {
          var children = this.get('children');
          return children[index];
        },
        getFirst: function getFirst() {
          return this.getChildByIndex(0);
        },
        getLast: function getLast() {
          var lastIndex = this.get('children').length - 1;
          return this.getChildByIndex(lastIndex);
        },
        getBBox: function getBBox() {
          var self = this;
          var minX = Infinity;
          var maxX = -Infinity;
          var minY = Infinity;
          var maxY = -Infinity;
          var children = self.get('children');

          if (children.length > 0) {
            Util.each(children, function (child) {
              if (child.get('visible')) {
                if (child.isGroup && child.get('children').length === 0) {
                  return;
                }

                var _box = child.getBBox();

                if (!_box) {
                  return true;
                }

                var leftTop = [_box.minX, _box.minY, 1];
                var leftBottom = [_box.minX, _box.maxY, 1];
                var rightTop = [_box.maxX, _box.minY, 1];
                var rightBottom = [_box.maxX, _box.maxY, 1];
                child.apply(leftTop);
                child.apply(leftBottom);
                child.apply(rightTop);
                child.apply(rightBottom);
                var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
                var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
                var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
                var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);

                if (boxMinX < minX) {
                  minX = boxMinX;
                }

                if (boxMaxX > maxX) {
                  maxX = boxMaxX;
                }

                if (boxMinY < minY) {
                  minY = boxMinY;
                }

                if (boxMaxY > maxY) {
                  maxY = boxMaxY;
                }
              }
            });
          } else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
          }

          var box = {
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY
          };
          box.x = box.minX;
          box.y = box.minY;
          box.width = box.maxX - box.minX;
          box.height = box.maxY - box.minY;
          return box;
        },
        getCount: function getCount() {
          return this.get('children').length;
        },
        sort: function sort() {
          var children = this.get('children'); // 稳定排序

          Util.each(children, function (child, index) {
            child[INDEX] = index;
            return child;
          });
          children.sort(getComparer(function (obj1, obj2) {
            return obj1.get('zIndex') - obj2.get('zIndex');
          }));
          return this;
        },
        findById: function findById(id) {
          return this.find(function (item) {
            return item.get('id') === id;
          });
        },

        /**
         * 根据查找函数查找分组或者图形
         * @param  {Function} fn 匹配函数
         * @return {Canvas.Base} 分组或者图形
         */
        find: function find(fn) {
          if (Util.isString(fn)) {
            return this.findById(fn);
          }

          var children = this.get('children');
          var rst = null;
          Util.each(children, function (item) {
            if (fn(item)) {
              rst = item;
            } else if (item.find) {
              rst = item.find(fn);
            }

            if (rst) {
              return false;
            }
          });
          return rst;
        },

        /**
         * @param  {Function} fn filter mathod
         * @return {Array} all the matching shapes and groups
         */
        findAll: function findAll(fn) {
          var children = this.get('children');
          var rst = [];
          var childRst = [];
          Util.each(children, function (item) {
            if (fn(item)) {
              rst.push(item);
            }

            if (item.findAllBy) {
              childRst = item.findAllBy(fn);
              rst = rst.concat(childRst);
            }
          });
          return rst;
        },

        /**
         * @Deprecated
         * @param  {Function} fn filter method
         * @return {Object} found shape or group
         */
        findBy: function findBy(fn) {
          var children = this.get('children');
          var rst = null;
          Util.each(children, function (item) {
            if (fn(item)) {
              rst = item;
            } else if (item.findBy) {
              rst = item.findBy(fn);
            }

            if (rst) {
              return false;
            }
          });
          return rst;
        },

        /**
         * @Deprecated
         * @param  {Function} fn filter mathod
         * @return {Array} all the matching shapes and groups
         */
        findAllBy: function findAllBy(fn) {
          var children = this.get('children');
          var rst = [];
          var childRst = [];
          Util.each(children, function (item) {
            if (fn(item)) {
              rst.push(item);
            }

            if (item.findAllBy) {
              childRst = item.findAllBy(fn);
              rst = rst.concat(childRst);
            }
          });
          return rst;
        },
        getShape: function getShape(x, y) {
          var self = this;
          var clip = self._attrs.clip;
          var children = self._cfg.children;
          var rst;

          if (clip) {
            var v = [x, y, 1];
            clip.invert(v, self.get('canvas')); // 已经在外面转换

            if (clip.isPointInPath(v[0], v[1])) {
              rst = find(children, x, y);
            }
          } else {
            rst = find(children, x, y);
          }

          return rst;
        },
        clearTotalMatrix: function clearTotalMatrix() {
          var m = this.get('totalMatrix');

          if (m) {
            this.setSilent('totalMatrix', null);
            var children = this._cfg.children;

            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              child.clearTotalMatrix();
            }
          }
        },
        clear: function clear(delayRemove) {
          var children = this._cfg.children;

          for (var i = children.length - 1; i >= 0; i--) {
            children[i].remove(true, delayRemove);
          }

          this._cfg.children = [];
          return this;
        },
        destroy: function destroy() {
          if (this.get('destroyed')) {
            return;
          }

          this.clear();
          Group.superclass.destroy.call(this);
        },
        clone: function clone() {
          var self = this;
          var children = self._cfg.children;
          var clone = new Group();
          Util.each(children, function (child) {
            clone.add(child.clone());
          });
          return clone;
        }
      });
      module.exports = Group;
      /***/
    },
    /* 102 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Attribute = __webpack_require__(186);

      var Transform = __webpack_require__(187);

      var Animate = __webpack_require__(188);

      var EventEmitter = __webpack_require__(54);

      var Element = function Element(cfg) {
        this._cfg = {
          zIndex: 0,
          capture: true,
          visible: true,
          destroyed: false
        }; // 配置存放地

        Util.assign(this._cfg, this.getDefaultCfg(), cfg); // Element.CFG不合并，提升性能 合并默认配置，用户配置->继承默认配置->Element默认配置

        this.initAttrs(this._cfg.attrs); // 初始化绘图属性

        this._cfg.attrs = {};
        this.initTransform(); // 初始化变换

        this.init(); // 类型初始化
      };

      Element.CFG = {
        /**
         * 唯一标示
         * @type {Number}
         */
        id: null,

        /**
         * Z轴的层叠关系，Z值越大离用户越近
         * @type {Number}
         */
        zIndex: 0,

        /**
         * Canvas对象
         * @type: {Object}
         */
        canvas: null,

        /**
         * 父元素指针
         * @type {Object}
         */
        parent: null,

        /**
         * 用来设置当前对象是否能被捕捉
         * true 能
         * false 不能
         * 对象默认是都可以被捕捉的, 当capture为false时，group.getShape(x, y)方法无法获得该元素
         * 通过将不必要捕捉的元素的该属性设置成false, 来提高捕捉性能
         * @type {Boolean}
         **/
        capture: true,

        /**
         * 画布的上下文
         * @type {Object}
         */
        context: null,

        /**
         * 是否显示
         * @type {Boolean}
         */
        visible: true,

        /**
         * 是否被销毁
         * @type: {Boolean}
         */
        destroyed: false
      };
      Util.augment(Element, Attribute, Transform, EventEmitter, Animate, {
        init: function init() {
          this.setSilent('animable', true);
          this.setSilent('animating', false); // 初始时不处于动画状态
        },
        getParent: function getParent() {
          return this._cfg.parent;
        },

        /**
         * 获取默认的配置信息
         * @protected
         * @return {Object} 默认的属性
         */
        getDefaultCfg: function getDefaultCfg() {
          return {};
        },
        set: function set(name, value) {
          if (name === 'zIndex' && this._beforeSetZIndex) {
            this._beforeSetZIndex(value);
          }

          if (name === 'loading' && this._beforeSetLoading) {
            this._beforeSetLoading(value);
          }

          this._cfg[name] = value;
          return this;
        },
        // deprecated
        setSilent: function setSilent(name, value) {
          this._cfg[name] = value;
        },
        get: function get(name) {
          return this._cfg[name];
        },
        show: function show() {
          this._cfg.visible = true;
          return this;
        },
        hide: function hide() {
          this._cfg.visible = false;
          return this;
        },
        remove: function remove(destroy, delayRemove) {
          var cfg = this._cfg;
          var parent = cfg.parent;
          var el = cfg.el;

          if (parent) {
            Util.remove(parent.get('children'), this);
          }

          if (el) {
            if (delayRemove) {
              parent && parent._cfg.tobeRemoved.push(el);
            } else {
              el.parentNode.removeChild(el);
            }
          }

          if (destroy || destroy === undefined) {
            this.destroy();
          }

          return this;
        },
        destroy: function destroy() {
          var destroyed = this.get('destroyed');

          if (destroyed) {
            return;
          }

          this._attrs = null;
          this.removeEvent(); // 移除所有的事件

          this._cfg = {
            destroyed: true
          };
        },
        toFront: function toFront() {
          var cfg = this._cfg;
          var parent = cfg.parent;

          if (!parent) {
            return;
          }

          var children = parent._cfg.children;
          var el = cfg.el;
          var index = children.indexOf(this);
          children.splice(index, 1);
          children.push(this);

          if (el) {
            el.parentNode.removeChild(el);
            cfg.el = null;
          }
        },
        toBack: function toBack() {
          var cfg = this._cfg;
          var parent = cfg.parent;

          if (!parent) {
            return;
          }

          var children = parent._cfg.children;
          var el = cfg.el;
          var index = children.indexOf(this);
          children.splice(index, 1);
          children.unshift(this);

          if (el) {
            var parentNode = el.parentNode;
            parentNode.removeChild(el);
            parentNode.insertBefore(el, parentNode.firstChild);
          }
        },
        _beforeSetZIndex: function _beforeSetZIndex(zIndex) {
          var parent = this._cfg.parent;
          this._cfg.zIndex = zIndex;

          if (!Util.isNil(parent)) {
            parent.sort();
          }

          var el = this._cfg.el;

          if (el) {
            var children = parent._cfg.children;
            var index = children.indexOf(this);
            var parentNode = el.parentNode;
            parentNode.removeChild(el);

            if (index === children.length - 1) {
              parentNode.appendChild(el);
            } else {
              parentNode.insertBefore(el, parentNode.childNodes[index]);
            }
          }

          return zIndex;
        },
        _setAttrs: function _setAttrs(attrs) {
          this.attr(attrs);
          return attrs;
        },
        setZIndex: function setZIndex(zIndex) {
          this._cfg.zIndex = zIndex;
          return this._beforeSetZIndex(zIndex);
        },
        clone: function clone() {
          return Util.clone(this);
        },
        getBBox: function getBBox() {}
      });
      module.exports = Element;
      /***/
    },
    /* 103 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var vec2 = Util.vec2;

      function quadraticAt(p0, p1, p2, t) {
        var onet = 1 - t;
        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
      }

      function quadraticProjectPoint(x1, y1, x2, y2, x3, y3, x, y, out) {
        var t;
        var interval = 0.005;
        var d = Infinity;
        var d1;
        var v1;
        var v2;

        var _t;

        var d2;
        var i;
        var EPSILON = 0.0001;
        var v0 = [x, y];

        for (_t = 0; _t < 1; _t += 0.05) {
          v1 = [quadraticAt(x1, x2, x3, _t), quadraticAt(y1, y2, y3, _t)];
          d1 = vec2.squaredDistance(v0, v1);

          if (d1 < d) {
            t = _t;
            d = d1;
          }
        }

        d = Infinity;

        for (i = 0; i < 32; i++) {
          if (interval < EPSILON) {
            break;
          }

          var prev = t - interval;
          var next = t + interval;
          v1 = [quadraticAt(x1, x2, x3, prev), quadraticAt(y1, y2, y3, prev)];
          d1 = vec2.squaredDistance(v0, v1);

          if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
          } else {
            v2 = [quadraticAt(x1, x2, x3, next), quadraticAt(y1, y2, y3, next)];
            d2 = vec2.squaredDistance(v0, v2);

            if (next <= 1 && d2 < d) {
              t = next;
              d = d2;
            } else {
              interval *= 0.5;
            }
          }
        }

        if (out) {
          out.x = quadraticAt(x1, x2, x3, t);
          out.y = quadraticAt(y1, y2, y3, t);
        }

        return Math.sqrt(d);
      }

      function quadraticExtrema(p0, p1, p2) {
        var a = p0 + p2 - 2 * p1;

        if (Util.isNumberEqual(a, 0)) {
          return [0.5];
        }

        var rst = (p0 - p1) / a;

        if (rst <= 1 && rst >= 0) {
          return [rst];
        }

        return [];
      }

      module.exports = {
        at: quadraticAt,
        projectPoint: function projectPoint(x1, y1, x2, y2, x3, y3, x, y) {
          var rst = {};
          quadraticProjectPoint(x1, y1, x2, y2, x3, y3, x, y, rst);
          return rst;
        },
        pointDistance: quadraticProjectPoint,
        extrema: quadraticExtrema
      };
      /***/
    },
    /* 104 */

    /***/
    function (module, exports) {
      module.exports = {
        xAt: function xAt(psi, rx, ry, cx, t) {
          return rx * Math.cos(psi) * Math.cos(t) - ry * Math.sin(psi) * Math.sin(t) + cx;
        },
        yAt: function yAt(psi, rx, ry, cy, t) {
          return rx * Math.sin(psi) * Math.cos(t) + ry * Math.cos(psi) * Math.sin(t) + cy;
        },
        xExtrema: function xExtrema(psi, rx, ry) {
          return Math.atan(-ry / rx * Math.tan(psi));
        },
        yExtrema: function yExtrema(psi, rx, ry) {
          return Math.atan(ry / (rx * Math.tan(psi)));
        }
      };
      /***/
    },
    /* 105 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var ArcMath = __webpack_require__(37);

      var Arrow = __webpack_require__(38);

      function _getArcX(x, radius, angle) {
        return x + radius * Math.cos(angle);
      }

      function _getArcY(y, radius, angle) {
        return y + radius * Math.sin(angle);
      }

      var Arc = function Arc(cfg) {
        Arc.superclass.constructor.call(this, cfg);
      };

      Arc.ATTRS = {
        x: 0,
        y: 0,
        r: 0,
        startAngle: 0,
        endAngle: 0,
        clockwise: false,
        lineWidth: 1,
        startArrow: false,
        endArrow: false
      };
      Util.extend(Arc, Shape);
      Util.augment(Arc, {
        canStroke: true,
        type: 'arc',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            x: 0,
            y: 0,
            r: 0,
            startAngle: 0,
            endAngle: 0,
            clockwise: false,
            lineWidth: 1,
            startArrow: false,
            endArrow: false
          };
        },
        calculateBox: function calculateBox() {
          var attrs = this._attrs;
          var x = attrs.x,
              y = attrs.y,
              r = attrs.r,
              startAngle = attrs.startAngle,
              endAngle = attrs.endAngle,
              clockwise = attrs.clockwise;
          var lineWidth = this.getHitLineWidth();
          var halfWidth = lineWidth / 2;
          var box = ArcMath.box(x, y, r, startAngle, endAngle, clockwise);
          box.minX -= halfWidth;
          box.minY -= halfWidth;
          box.maxX += halfWidth;
          box.maxY += halfWidth;
          return box;
        },
        getStartTangent: function getStartTangent() {
          var attrs = this._attrs;
          var x = attrs.x,
              y = attrs.y,
              startAngle = attrs.startAngle,
              r = attrs.r,
              clockwise = attrs.clockwise;
          var diff = Math.PI / 180;

          if (clockwise) {
            diff *= -1;
          }

          var result = [];

          var x1 = _getArcX(x, r, startAngle + diff);

          var y1 = _getArcY(y, r, startAngle + diff);

          var x2 = _getArcX(x, r, startAngle);

          var y2 = _getArcY(y, r, startAngle);

          result.push([x1, y1]);
          result.push([x2, y2]);
          return result;
        },
        getEndTangent: function getEndTangent() {
          var attrs = this._attrs;
          var x = attrs.x,
              y = attrs.y,
              endAngle = attrs.endAngle,
              r = attrs.r,
              clockwise = attrs.clockwise;
          var diff = Math.PI / 180;
          var result = [];

          if (clockwise) {
            diff *= -1;
          }

          var x1 = _getArcX(x, r, endAngle + diff);

          var y1 = _getArcY(y, r, endAngle + diff);

          var x2 = _getArcX(x, r, endAngle);

          var y2 = _getArcY(y, r, endAngle);

          result.push([x2, y2]);
          result.push([x1, y1]);
          return result;
        },
        createPath: function createPath(context) {
          var attrs = this._attrs;
          var x = attrs.x,
              y = attrs.y,
              r = attrs.r,
              startAngle = attrs.startAngle,
              endAngle = attrs.endAngle,
              clockwise = attrs.clockwise;
          context = context || self.get('context');
          context.beginPath();
          context.arc(x, y, r, startAngle, endAngle, clockwise);
        },
        afterPath: function afterPath(context) {
          var attrs = this._attrs;
          context = context || this.get('context');

          if (attrs.startArrow) {
            var startPoints = this.getStartTangent();
            Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);
          }

          if (attrs.endArrow) {
            var endPoints = this.getEndTangent();
            Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);
          }
        }
      });
      module.exports = Arc;
      /***/
    },
    /* 106 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var Circle = function Circle(cfg) {
        Circle.superclass.constructor.call(this, cfg);
      };

      Circle.ATTRS = {
        x: 0,
        y: 0,
        r: 0,
        lineWidth: 1
      };
      Util.extend(Circle, Shape);
      Util.augment(Circle, {
        canFill: true,
        canStroke: true,
        type: 'circle',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1
          };
        },
        calculateBox: function calculateBox() {
          var attrs = this._attrs;
          var cx = attrs.x;
          var cy = attrs.y;
          var r = attrs.r;
          var lineWidth = this.getHitLineWidth();
          var halfWidth = lineWidth / 2 + r;
          return {
            minX: cx - halfWidth,
            minY: cy - halfWidth,
            maxX: cx + halfWidth,
            maxY: cy + halfWidth
          };
        },
        createPath: function createPath(context) {
          var attrs = this._attrs;
          var cx = attrs.x;
          var cy = attrs.y;
          var r = attrs.r;
          context.beginPath();
          context.arc(cx, cy, r, 0, Math.PI * 2, false);
          context.closePath();
        }
      });
      module.exports = Circle;
      /***/
    },
    /* 107 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var Dom = function Dom(cfg) {
        Dom.superclass.constructor.call(this, cfg);
      };

      Util.extend(Dom, Shape);
      Util.augment(Dom, {
        canFill: true,
        canStroke: true,
        type: 'dom',
        calculateBox: function calculateBox() {
          var self = this;
          var attrs = self._attrs;
          var x = attrs.x;
          var y = attrs.y;
          var width = attrs.width;
          var height = attrs.height;
          var lineWidth = this.getHitLineWidth();
          var halfWidth = lineWidth / 2;
          return {
            minX: x - halfWidth,
            minY: y - halfWidth,
            maxX: x + width + halfWidth,
            maxY: y + height + halfWidth
          };
        }
      });
      module.exports = Dom;
      /***/
    },
    /* 108 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var Ellipse = function Ellipse(cfg) {
        Ellipse.superclass.constructor.call(this, cfg);
      };

      Ellipse.ATTRS = {
        x: 0,
        y: 0,
        rx: 1,
        ry: 1,
        lineWidth: 1
      };
      Util.extend(Ellipse, Shape);
      Util.augment(Ellipse, {
        canFill: true,
        canStroke: true,
        type: 'ellipse',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1
          };
        },
        calculateBox: function calculateBox() {
          var attrs = this._attrs;
          var cx = attrs.x;
          var cy = attrs.y;
          var rx = attrs.rx;
          var ry = attrs.ry;
          var lineWidth = this.getHitLineWidth();
          var halfXWidth = rx + lineWidth / 2;
          var halfYWidth = ry + lineWidth / 2;
          return {
            minX: cx - halfXWidth,
            minY: cy - halfYWidth,
            maxX: cx + halfXWidth,
            maxY: cy + halfYWidth
          };
        },
        createPath: function createPath(context) {
          var attrs = this._attrs;
          var cx = attrs.x;
          var cy = attrs.y;
          var rx = attrs.rx;
          var ry = attrs.ry;
          context = context || self.get('context');
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          Util.mat3.scale(m, m, [scaleX, scaleY]);
          Util.mat3.translate(m, m, [cx, cy]);
          context.beginPath();
          context.save();
          context.transform(m[0], m[1], m[3], m[4], m[6], m[7]);
          context.arc(0, 0, r, 0, Math.PI * 2);
          context.restore();
          context.closePath();
        }
      });
      module.exports = Ellipse;
      /***/
    },
    /* 109 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var ArcMath = __webpack_require__(37);

      var Fan = function Fan(cfg) {
        Fan.superclass.constructor.call(this, cfg);
      };

      Fan.ATTRS = {
        x: 0,
        y: 0,
        rs: 0,
        re: 0,
        startAngle: 0,
        endAngle: 0,
        clockwise: false,
        lineWidth: 1
      };
      Util.extend(Fan, Shape);
      Util.augment(Fan, {
        canFill: true,
        canStroke: true,
        type: 'fan',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            clockwise: false,
            lineWidth: 1,
            rs: 0,
            re: 0
          };
        },
        calculateBox: function calculateBox() {
          var self = this;
          var attrs = self._attrs;
          var cx = attrs.x;
          var cy = attrs.y;
          var rs = attrs.rs;
          var re = attrs.re;
          var startAngle = attrs.startAngle;
          var endAngle = attrs.endAngle;
          var clockwise = attrs.clockwise;
          var lineWidth = this.getHitLineWidth();
          var boxs = ArcMath.box(cx, cy, rs, startAngle, endAngle, clockwise);
          var boxe = ArcMath.box(cx, cy, re, startAngle, endAngle, clockwise);
          var minX = Math.min(boxs.minX, boxe.minX);
          var minY = Math.min(boxs.minY, boxe.minY);
          var maxX = Math.max(boxs.maxX, boxe.maxX);
          var maxY = Math.max(boxs.maxY, boxe.maxY);
          var halfWidth = lineWidth / 2;
          return {
            minX: minX - halfWidth,
            minY: minY - halfWidth,
            maxX: maxX + halfWidth,
            maxY: maxY + halfWidth
          };
        },
        createPath: function createPath(context) {
          var attrs = this._attrs;
          var cx = attrs.x;
          var cy = attrs.y;
          var rs = attrs.rs;
          var re = attrs.re;
          var startAngle = attrs.startAngle;
          var endAngle = attrs.endAngle;
          var clockwise = attrs.clockwise;
          var ssp = {
            x: Math.cos(startAngle) * rs + cx,
            y: Math.sin(startAngle) * rs + cy
          };
          var sep = {
            x: Math.cos(startAngle) * re + cx,
            y: Math.sin(startAngle) * re + cy
          };
          var esp = {
            x: Math.cos(endAngle) * rs + cx,
            y: Math.sin(endAngle) * rs + cy
          };
          context = context || self.get('context');
          context.beginPath();
          context.moveTo(ssp.x, ssp.y);
          context.lineTo(sep.x, sep.y);
          context.arc(cx, cy, re, startAngle, endAngle, clockwise);
          context.lineTo(esp.x, esp.y);
          context.arc(cx, cy, rs, endAngle, startAngle, !clockwise);
          context.closePath();
        }
      });
      module.exports = Fan;
      /***/
    },
    /* 110 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var CImage = function CImage(cfg) {
        CImage.superclass.constructor.call(this, cfg);
      };

      CImage.ATTRS = {
        x: 0,
        y: 0,
        img: undefined,
        width: 0,
        height: 0,
        sx: null,
        sy: null,
        swidth: null,
        sheight: null
      };
      Util.extend(CImage, Shape);
      Util.augment(CImage, {
        type: 'image',
        isHitBox: function isHitBox() {
          return false;
        },
        calculateBox: function calculateBox() {
          var attrs = this._attrs;

          if (!this._cfg.attrs || this._cfg.attrs.img !== attrs.img) {
            this._setAttrImg();
          }

          var x = attrs.x;
          var y = attrs.y;
          var width = attrs.width;
          var height = attrs.height;
          return {
            minX: x,
            minY: y,
            maxX: x + width,
            maxY: y + height
          };
        },
        _beforeSetLoading: function _beforeSetLoading(loading) {
          var canvas = this.get('canvas');

          if (loading === false && this.get('toDraw') === true) {
            this._cfg.loading = false;
            canvas.draw();
          }

          return loading;
        },
        _setAttrImg: function _setAttrImg() {
          var self = this;
          var attrs = self._attrs;
          var img = attrs.img;

          if (Util.isString(img)) {
            var image = new Image();

            image.onload = function () {
              if (self.get('destroyed')) return false;
              self.attr('imgSrc', img);
              self.attr('img', image);
              var callback = self.get('callback');

              if (callback) {
                callback.call(self);
              }

              self.set('loading', false);
            };

            image.src = img;
            image.crossOrigin = 'Anonymous';
            self.set('loading', true);
          } else if (img instanceof Image) {
            if (!attrs.width) {
              self.attr('width', img.width);
            }

            if (!attrs.height) {
              self.attr('height', img.height);
            }

            return img;
          } else if (img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
            if (!attrs.width) {
              self.attr('width', Number(img.getAttribute('width')));
            }

            if (!attrs.height) {
              self.attr('height', Number(img.getAttribute('height')));
            }

            return img;
          } else if (img instanceof ImageData) {
            if (!attrs.width) {
              self.attr('width', img.width);
            }

            if (!attrs.height) {
              self.attr('height', img.height);
            }

            return img;
          } else {
            return null;
          }
        },
        drawInner: function drawInner(context) {
          if (this._cfg.hasUpdate) {
            this._setAttrImg();
          }

          if (this.get('loading')) {
            this.set('toDraw', true);
            return;
          }

          this._drawImage(context);

          this._cfg.hasUpdate = false;
        },
        _drawImage: function _drawImage(context) {
          var attrs = this._attrs;
          var x = attrs.x;
          var y = attrs.y;
          var image = attrs.img;
          var width = attrs.width;
          var height = attrs.height;
          var sx = attrs.sx;
          var sy = attrs.sy;
          var swidth = attrs.swidth;
          var sheight = attrs.sheight;
          this.set('toDraw', false);
          var img = image;

          if (img instanceof ImageData) {
            img = new Image();
            img.src = image;
          }

          if (img instanceof Image || img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
            if (Util.isNil(sx) || Util.isNil(sy) || Util.isNil(swidth) || Util.isNil(sheight)) {
              context.drawImage(img, x, y, width, height);
              return;
            }

            if (!Util.isNil(sx) && !Util.isNil(sy) && !Util.isNil(swidth) && !Util.isNil(sheight)) {
              context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
              return;
            }
          }

          return;
        }
      });
      module.exports = CImage;
      /***/
    },
    /* 111 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var Arrow = __webpack_require__(38);

      var LineMath = __webpack_require__(36);

      var Line = function Line(cfg) {
        Line.superclass.constructor.call(this, cfg);
      };

      Line.ATTRS = {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        lineWidth: 1,
        startArrow: false,
        endArrow: false
      };
      Util.extend(Line, Shape);
      Util.augment(Line, {
        canStroke: true,
        type: 'line',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1,
            startArrow: false,
            endArrow: false
          };
        },
        calculateBox: function calculateBox() {
          var attrs = this._attrs;
          var x1 = attrs.x1,
              y1 = attrs.y1,
              x2 = attrs.x2,
              y2 = attrs.y2;
          var lineWidth = this.getHitLineWidth();
          return LineMath.box(x1, y1, x2, y2, lineWidth);
        },
        createPath: function createPath(context) {
          var attrs = this._attrs;
          var x1 = attrs.x1,
              y1 = attrs.y1,
              x2 = attrs.x2,
              y2 = attrs.y2;
          context = context || self.get('context');
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
        },
        afterPath: function afterPath(context) {
          var attrs = this._attrs;
          var x1 = attrs.x1,
              y1 = attrs.y1,
              x2 = attrs.x2,
              y2 = attrs.y2;
          context = context || this.get('context');

          if (attrs.startArrow) {
            Arrow.addStartArrow(context, attrs, x2, y2, x1, y1);
          }

          if (attrs.endArrow) {
            Arrow.addEndArrow(context, attrs, x1, y1, x2, y2);
          }
        },
        getPoint: function getPoint(t) {
          var attrs = this._attrs;
          return {
            x: LineMath.at(attrs.x1, attrs.x2, t),
            y: LineMath.at(attrs.y1, attrs.y2, t)
          };
        }
      });
      module.exports = Line;
      /***/
    },
    /* 112 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var PathSegment = __webpack_require__(39);

      var Format = __webpack_require__(27);

      var Arrow = __webpack_require__(38);

      var PathUtil = __webpack_require__(58);

      var CubicMath = __webpack_require__(56);

      var Path = function Path(cfg) {
        Path.superclass.constructor.call(this, cfg);
      };

      Path.ATTRS = {
        path: null,
        lineWidth: 1,
        startArrow: false,
        endArrow: false
      };
      Util.extend(Path, Shape);
      Util.augment(Path, {
        canFill: true,
        canStroke: true,
        type: 'path',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1,
            startArrow: false,
            endArrow: false
          };
        },
        _afterSetAttrPath: function _afterSetAttrPath(path) {
          var self = this;

          if (Util.isNil(path)) {
            self.setSilent('segments', null);
            self.setSilent('box', undefined);
            return;
          }

          var pathArray = Format.parsePath(path);
          var preSegment;
          var segments = [];

          if (!Util.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {
            return;
          }

          var count = pathArray.length;

          for (var i = 0; i < pathArray.length; i++) {
            var item = pathArray[i];
            preSegment = new PathSegment(item, preSegment, i === count - 1);
            segments.push(preSegment);
          }

          self.setSilent('segments', segments);
          self.setSilent('tCache', null);
          self.setSilent('box', null);
        },
        calculateBox: function calculateBox() {
          var self = this;
          var segments = self.get('segments');

          if (!segments) {
            return null;
          }

          var lineWidth = this.getHitLineWidth();
          var minX = Infinity;
          var maxX = -Infinity;
          var minY = Infinity;
          var maxY = -Infinity;
          Util.each(segments, function (segment) {
            segment.getBBox(lineWidth);
            var box = segment.box;

            if (box) {
              if (box.minX < minX) {
                minX = box.minX;
              }

              if (box.maxX > maxX) {
                maxX = box.maxX;
              }

              if (box.minY < minY) {
                minY = box.minY;
              }

              if (box.maxY > maxY) {
                maxY = box.maxY;
              }
            }
          });

          if (minX === Infinity || minY === Infinity) {
            return {
              minX: 0,
              minY: 0,
              maxX: 0,
              maxY: 0
            };
          }

          return {
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY
          };
        },
        _setTcache: function _setTcache() {
          var totalLength = 0;
          var tempLength = 0;
          var tCache = [];
          var segmentT;
          var segmentL;
          var segmentN;
          var l;
          var curve = this._cfg.curve;

          if (!curve) {
            return;
          }

          Util.each(curve, function (segment, i) {
            segmentN = curve[i + 1];
            l = segment.length;

            if (segmentN) {
              totalLength += CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
            }
          });
          Util.each(curve, function (segment, i) {
            segmentN = curve[i + 1];
            l = segment.length;

            if (segmentN) {
              segmentT = [];
              segmentT[0] = tempLength / totalLength;
              segmentL = CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
              tempLength += segmentL;
              segmentT[1] = tempLength / totalLength;
              tCache.push(segmentT);
            }
          });
          this._cfg.tCache = tCache;
        },
        _calculateCurve: function _calculateCurve() {
          var self = this;
          var attrs = self._attrs;
          var path = attrs.path;
          this._cfg.curve = PathUtil.pathTocurve(path);
        },
        getStartTangent: function getStartTangent() {
          var segments = this.get('segments');
          var startPoint, endPoint, tangent, result;

          if (segments.length > 1) {
            startPoint = segments[0].endPoint;
            endPoint = segments[1].endPoint;
            tangent = segments[1].startTangent;
            result = [];

            if (Util.isFunction(tangent)) {
              var v = tangent();
              result.push([startPoint.x - v[0], startPoint.y - v[1]]);
              result.push([startPoint.x, startPoint.y]);
            } else {
              result.push([endPoint.x, endPoint.y]);
              result.push([startPoint.x, startPoint.y]);
            }
          }

          return result;
        },
        getEndTangent: function getEndTangent() {
          var segments = this.get('segments');
          var segmentsLen = segments.length;
          var startPoint, endPoint, tangent, result;

          if (segmentsLen > 1) {
            startPoint = segments[segmentsLen - 2].endPoint;
            endPoint = segments[segmentsLen - 1].endPoint;
            tangent = segments[segmentsLen - 1].endTangent;
            result = [];

            if (Util.isFunction(tangent)) {
              var v = tangent();
              result.push([endPoint.x - v[0], endPoint.y - v[1]]);
              result.push([endPoint.x, endPoint.y]);
            } else {
              result.push([startPoint.x, startPoint.y]);
              result.push([endPoint.x, endPoint.y]);
            }
          }

          return result;
        },
        getPoint: function getPoint(t) {
          var tCache = this._cfg.tCache;
          var subt;
          var index;

          if (!tCache) {
            this._calculateCurve();

            this._setTcache();

            tCache = this._cfg.tCache;
          }

          var curve = this._cfg.curve;

          if (!tCache) {
            if (curve) {
              return {
                x: curve[0][1],
                y: curve[0][2]
              };
            }

            return null;
          }

          Util.each(tCache, function (v, i) {
            if (t >= v[0] && t <= v[1]) {
              subt = (t - v[0]) / (v[1] - v[0]);
              index = i;
            }
          });
          var seg = curve[index];

          if (Util.isNil(seg) || Util.isNil(index)) {
            return null;
          }

          var l = seg.length;
          var nextSeg = curve[index + 1];
          return {
            x: CubicMath.at(seg[l - 2], nextSeg[1], nextSeg[3], nextSeg[5], 1 - subt),
            y: CubicMath.at(seg[l - 1], nextSeg[2], nextSeg[4], nextSeg[6], 1 - subt)
          };
        },
        createPath: function createPath(context) {
          var self = this;
          var segments = self.get('segments');

          if (!Util.isArray(segments)) {
            return;
          }

          context = context || self.get('context');
          context.beginPath();
          var segmentsLen = segments.length;

          for (var i = 0; i < segmentsLen; i++) {
            segments[i].draw(context);
          }
        },
        afterPath: function afterPath(context) {
          var self = this;
          var attrs = self._attrs;
          var segments = self.get('segments');
          var path = attrs.path;
          context = context || self.get('context');

          if (!Util.isArray(segments)) {
            return;
          }

          if (segments.length === 1) {
            return;
          }

          if (!attrs.startArrow && !attrs.endArrow) {
            return;
          }

          if (path[path.length - 1] === 'z' || path[path.length - 1] === 'Z' || attrs.fill) {
            // 闭合路径不绘制箭头
            return;
          }

          var startPoints = self.getStartTangent();
          Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);
          var endPoints = self.getEndTangent();
          Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);
        }
      });
      module.exports = Path;
      /***/
    },
    /* 113 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var Polygon = function Polygon(cfg) {
        Polygon.superclass.constructor.call(this, cfg);
      };

      Polygon.ATTRS = {
        points: null,
        lineWidth: 1
      };
      Util.extend(Polygon, Shape);
      Util.augment(Polygon, {
        canFill: true,
        canStroke: true,
        type: 'polygon',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1
          };
        },
        calculateBox: function calculateBox() {
          var self = this;
          var attrs = self._attrs;
          var points = attrs.points;
          var lineWidth = this.getHitLineWidth();

          if (!points || points.length === 0) {
            return null;
          }

          var minX = Infinity;
          var minY = Infinity;
          var maxX = -Infinity;
          var maxY = -Infinity;
          Util.each(points, function (point) {
            var x = point[0];
            var y = point[1];

            if (x < minX) {
              minX = x;
            }

            if (x > maxX) {
              maxX = x;
            }

            if (y < minY) {
              minY = y;
            }

            if (y > maxY) {
              maxY = y;
            }
          });
          var halfWidth = lineWidth / 2;
          return {
            minX: minX - halfWidth,
            minY: minY - halfWidth,
            maxX: maxX + halfWidth,
            maxY: maxY + halfWidth
          };
        },
        createPath: function createPath(context) {
          var self = this;
          var attrs = self._attrs;
          var points = attrs.points;

          if (points.length < 2) {
            return;
          }

          context = context || self.get('context');
          context.beginPath();
          Util.each(points, function (point, index) {
            if (index === 0) {
              context.moveTo(point[0], point[1]);
            } else {
              context.lineTo(point[0], point[1]);
            }
          });
          context.closePath();
        }
      });
      module.exports = Polygon;
      /***/
    },
    /* 114 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var Arrow = __webpack_require__(38);

      var LineMath = __webpack_require__(36);

      var Polyline = function Polyline(cfg) {
        Polyline.superclass.constructor.call(this, cfg);
      };

      Polyline.ATTRS = {
        points: null,
        lineWidth: 1,
        startArrow: false,
        endArrow: false,
        tCache: null
      };
      Util.extend(Polyline, Shape);
      Util.augment(Polyline, {
        canStroke: true,
        type: 'polyline',
        tCache: null,
        // 缓存各点的t
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1,
            startArrow: false,
            endArrow: false
          };
        },
        calculateBox: function calculateBox() {
          var self = this;
          var attrs = self._attrs;
          var lineWidth = this.getHitLineWidth();
          var points = attrs.points;

          if (!points || points.length === 0) {
            return null;
          }

          var minX = Infinity;
          var minY = Infinity;
          var maxX = -Infinity;
          var maxY = -Infinity;
          Util.each(points, function (point) {
            var x = point[0];
            var y = point[1];

            if (x < minX) {
              minX = x;
            }

            if (x > maxX) {
              maxX = x;
            }

            if (y < minY) {
              minY = y;
            }

            if (y > maxY) {
              maxY = y;
            }
          });
          var halfWidth = lineWidth / 2;
          return {
            minX: minX - halfWidth,
            minY: minY - halfWidth,
            maxX: maxX + halfWidth,
            maxY: maxY + halfWidth
          };
        },
        _setTcache: function _setTcache() {
          var self = this;
          var attrs = self._attrs;
          var points = attrs.points;
          var totalLength = 0;
          var tempLength = 0;
          var tCache = [];
          var segmentT;
          var segmentL;

          if (!points || points.length === 0) {
            return;
          }

          Util.each(points, function (p, i) {
            if (points[i + 1]) {
              totalLength += LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);
            }
          });

          if (totalLength <= 0) {
            return;
          }

          Util.each(points, function (p, i) {
            if (points[i + 1]) {
              segmentT = [];
              segmentT[0] = tempLength / totalLength;
              segmentL = LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);
              tempLength += segmentL;
              segmentT[1] = tempLength / totalLength;
              tCache.push(segmentT);
            }
          });
          this.tCache = tCache;
        },
        createPath: function createPath(context) {
          var self = this;
          var attrs = self._attrs;
          var points = attrs.points;
          var l;
          var i;

          if (points.length < 2) {
            return;
          }

          context = context || self.get('context');
          context.beginPath();
          context.moveTo(points[0][0], points[0][1]);

          for (i = 1, l = points.length - 1; i < l; i++) {
            context.lineTo(points[i][0], points[i][1]);
          }

          context.lineTo(points[l][0], points[l][1]);
        },
        getStartTangent: function getStartTangent() {
          var points = this.__attrs.points;
          var result = [];
          result.push([points[1][0], points[1][1]]);
          result.push([points[0][0], points[0][1]]);
          return result;
        },
        getEndTangent: function getEndTangent() {
          var points = this.__attrs.points;
          var l = points.length - 1;
          var result = [];
          result.push([points[l - 1][0], points[l - 1][1]]);
          result.push([points[l][0], points[l][1]]);
          return result;
        },
        afterPath: function afterPath(context) {
          var self = this;
          var attrs = self._attrs;
          var points = attrs.points;
          var l = points.length - 1;
          context = context || self.get('context');

          if (attrs.startArrow) {
            Arrow.addStartArrow(context, attrs, points[1][0], points[1][1], points[0][0], points[0][1]);
          }

          if (attrs.endArrow) {
            Arrow.addEndArrow(context, attrs, points[l - 1][0], points[l - 1][1], points[l][0], points[l][1]);
          }
        },
        getPoint: function getPoint(t) {
          var attrs = this._attrs;
          var points = attrs.points;
          var tCache = this.tCache;
          var subt;
          var index;

          if (!tCache) {
            this._setTcache();

            tCache = this.tCache;
          }

          Util.each(tCache, function (v, i) {
            if (t >= v[0] && t <= v[1]) {
              subt = (t - v[0]) / (v[1] - v[0]);
              index = i;
            }
          });
          return {
            x: LineMath.at(points[index][0], points[index + 1][0], subt),
            y: LineMath.at(points[index][1], points[index + 1][1], subt)
          };
        }
      });
      module.exports = Polyline;
      /***/
    },
    /* 115 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var _require = __webpack_require__(27),
          parseRadius = _require.parseRadius;

      var Shape = __webpack_require__(6);

      var Rect = function Rect(cfg) {
        Rect.superclass.constructor.call(this, cfg);
      };

      Rect.ATTRS = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        radius: 0,
        lineWidth: 1
      };
      Util.extend(Rect, Shape);
      Util.augment(Rect, {
        canFill: true,
        canStroke: true,
        type: 'rect',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1,
            radius: 0
          };
        },
        calculateBox: function calculateBox() {
          var self = this;
          var attrs = self._attrs;
          var x = attrs.x;
          var y = attrs.y;
          var width = attrs.width;
          var height = attrs.height;
          var lineWidth = this.getHitLineWidth();
          var halfWidth = lineWidth / 2;
          return {
            minX: x - halfWidth,
            minY: y - halfWidth,
            maxX: x + width + halfWidth,
            maxY: y + height + halfWidth
          };
        },
        createPath: function createPath(context) {
          var self = this;
          var attrs = self._attrs;
          var x = attrs.x;
          var y = attrs.y;
          var width = attrs.width;
          var height = attrs.height;
          var radius = attrs.radius;
          context = context || self.get('context');
          context.beginPath();

          if (radius === 0) {
            // 改成原生的rect方法
            context.rect(x, y, width, height);
          } else {
            var r = parseRadius(radius);
            context.moveTo(x + r.r1, y);
            context.lineTo(x + width - r.r2, y);
            r.r2 !== 0 && context.arc(x + width - r.r2, y + r.r2, r.r2, -Math.PI / 2, 0);
            context.lineTo(x + width, y + height - r.r3);
            r.r3 !== 0 && context.arc(x + width - r.r3, y + height - r.r3, r.r3, 0, Math.PI / 2);
            context.lineTo(x + r.r4, y + height);
            r.r4 !== 0 && context.arc(x + r.r4, y + height - r.r4, r.r4, Math.PI / 2, Math.PI);
            context.lineTo(x, y + r.r1);
            r.r1 !== 0 && context.arc(x + r.r1, y + r.r1, r.r1, Math.PI, Math.PI * 1.5);
            context.closePath();
          }
        }
      });
      module.exports = Rect;
      /***/
    },
    /* 116 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Shape = __webpack_require__(6);

      var CText = function CText(cfg) {
        CText.superclass.constructor.call(this, cfg);
      };

      CText.ATTRS = {
        x: 0,
        y: 0,
        text: null,
        fontSize: 12,
        fontFamily: 'sans-serif',
        fontStyle: 'normal',
        fontWeight: 'normal',
        fontVariant: 'normal',
        textAlign: 'start',
        textBaseline: 'bottom',
        lineHeight: null,
        textArr: null
      };
      Util.extend(CText, Shape);
      Util.augment(CText, {
        canFill: true,
        canStroke: true,
        type: 'text',
        getDefaultAttrs: function getDefaultAttrs() {
          return {
            lineWidth: 1,
            lineCount: 1,
            fontSize: 12,
            fontFamily: 'sans-serif',
            fontStyle: 'normal',
            fontWeight: 'normal',
            fontVariant: 'normal',
            textAlign: 'start',
            textBaseline: 'bottom'
          };
        },
        initTransform: function initTransform() {
          var fontSize = this._attrs.fontSize;

          if (fontSize && +fontSize < 12) {
            // 小于 12 像素的文本进行 scale 处理
            this.transform([['t', -1 * this._attrs.x, -1 * this._attrs.y], ['s', +fontSize / 12, +fontSize / 12], ['t', this._attrs.x, this._attrs.y]]);
          }
        },
        _assembleFont: function _assembleFont() {
          // var self = this;
          var attrs = this._attrs;
          var fontSize = attrs.fontSize;
          var fontFamily = attrs.fontFamily;
          var fontWeight = attrs.fontWeight;
          var fontStyle = attrs.fontStyle; // self.attr('fontStyle');

          var fontVariant = attrs.fontVariant; // self.attr('fontVariant');
          // self.attr('font', [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' '));

          attrs.font = [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' ');
        },
        _setAttrText: function _setAttrText() {
          var attrs = this._attrs;
          var text = attrs.text;
          var textArr = null;

          if (Util.isString(text) && text.indexOf('\n') !== -1) {
            textArr = text.split('\n');
            var lineCount = textArr.length;
            attrs.lineCount = lineCount;
          }

          attrs.textArr = textArr;
        },
        _getTextHeight: function _getTextHeight() {
          var attrs = this._attrs;
          var lineCount = attrs.lineCount;
          var fontSize = attrs.fontSize * 1;

          if (lineCount > 1) {
            var spaceingY = this._getSpaceingY();

            return fontSize * lineCount + spaceingY * (lineCount - 1);
          }

          return fontSize;
        },
        isHitBox: function isHitBox() {
          return false;
        },
        calculateBox: function calculateBox() {
          var self = this;
          var attrs = self._attrs;
          var cfg = this._cfg;

          if (!cfg.attrs || cfg.hasUpdate) {
            this._assembleFont();

            this._setAttrText();
          }

          if (!attrs.textArr) {
            this._setAttrText();
          }

          var x = attrs.x;
          var y = attrs.y;
          var width = self.measureText(); // attrs.width

          if (!width) {
            // 如果width不存在，四点共其实点
            return {
              minX: x,
              minY: y,
              maxX: x,
              maxY: y
            };
          }

          var height = self._getTextHeight(); // attrs.height


          var textAlign = attrs.textAlign;
          var textBaseline = attrs.textBaseline;
          var lineWidth = self.getHitLineWidth();
          var point = {
            x: x,
            y: y - height
          };

          if (textAlign) {
            if (textAlign === 'end' || textAlign === 'right') {
              point.x -= width;
            } else if (textAlign === 'center') {
              point.x -= width / 2;
            }
          }

          if (textBaseline) {
            if (textBaseline === 'top') {
              point.y += height;
            } else if (textBaseline === 'middle') {
              point.y += height / 2;
            }
          }

          this.set('startPoint', point);
          var halfWidth = lineWidth / 2;
          return {
            minX: point.x - halfWidth,
            minY: point.y - halfWidth,
            maxX: point.x + width + halfWidth,
            maxY: point.y + height + halfWidth
          };
        },
        _getSpaceingY: function _getSpaceingY() {
          var attrs = this._attrs;
          var lineHeight = attrs.lineHeight;
          var fontSize = attrs.fontSize * 1;
          return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
        },
        drawInner: function drawInner(context) {
          var self = this;
          var attrs = self._attrs;
          var cfg = this._cfg;

          if (!cfg.attrs || cfg.hasUpdate) {
            this._assembleFont();

            this._setAttrText();
          }

          context.font = attrs.font;
          var text = attrs.text;

          if (!text) {
            return;
          }

          var textArr = attrs.textArr;
          var x = attrs.x;
          var y = attrs.y;
          context.beginPath();

          if (self.hasStroke()) {
            var strokeOpacity = attrs.strokeOpacity;

            if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {
              context.globalAlpha = strokeOpacity;
            }

            if (textArr) {
              self._drawTextArr(context, false);
            } else {
              context.strokeText(text, x, y);
            }

            context.globalAlpha = 1;
          }

          if (self.hasFill()) {
            var fillOpacity = attrs.fillOpacity;

            if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {
              context.globalAlpha = fillOpacity;
            }

            if (textArr) {
              self._drawTextArr(context, true);
            } else {
              context.fillText(text, x, y);
            }
          }

          cfg.hasUpdate = false;
        },
        _drawTextArr: function _drawTextArr(context, fill) {
          var textArr = this._attrs.textArr;
          var textBaseline = this._attrs.textBaseline;
          var fontSize = this._attrs.fontSize * 1;

          var spaceingY = this._getSpaceingY();

          var x = this._attrs.x;
          var y = this._attrs.y;
          var box = this.getBBox();
          var height = box.maxY - box.minY;
          var subY;
          Util.each(textArr, function (subText, index) {
            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;

            if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;
            if (textBaseline === 'top') subY += height - fontSize;

            if (fill) {
              context.fillText(subText, x, subY);
            } else {
              context.strokeText(subText, x, subY);
            }
          });
        },
        measureText: function measureText() {
          var self = this;
          var attrs = self._attrs;
          var text = attrs.text;
          var font = attrs.font;
          var textArr = attrs.textArr;
          var measureWidth;
          var width = 0;
          if (Util.isNil(text)) return undefined;
          var context = document.createElement('canvas').getContext('2d');
          context.save();
          context.font = font;

          if (textArr) {
            Util.each(textArr, function (subText) {
              measureWidth = context.measureText(subText).width;

              if (width < measureWidth) {
                width = measureWidth;
              }

              context.restore();
            });
          } else {
            width = context.measureText(text).width;
            context.restore();
          }

          return width;
        }
      });
      module.exports = CText;
      /***/
    },
    /* 117 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return deg2rad;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return rad2deg;
      });

      var deg2rad = Math.PI / 180;
      var rad2deg = 180 / Math.PI;
      /***/
    },
    /* 118 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return rgbBasis;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "c", function () {
        return rgbBasisClosed;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__basis__ = __webpack_require__(63);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__basisClosed__ = __webpack_require__(119);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__color__ = __webpack_require__(28);
      /* harmony default export */


      __webpack_exports__["a"] = function rgbGamma(y) {
        var color = Object(__WEBPACK_IMPORTED_MODULE_3__color__["b"
        /* gamma */
        ])(y);

        function rgb(start, end) {
          var r = color((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f"
          /* rgb */
          ])(start)).r, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f"
          /* rgb */
          ])(end)).r),
              g = color(start.g, end.g),
              b = color(start.b, end.b),
              opacity = Object(__WEBPACK_IMPORTED_MODULE_3__color__["a"
          /* default */
          ])(start.opacity, end.opacity);
          return function (t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
          };
        }

        rgb.gamma = rgbGamma;
        return rgb;
      }(1);

      function rgbSpline(spline) {
        return function (colors) {
          var n = colors.length,
              r = new Array(n),
              g = new Array(n),
              b = new Array(n),
              i,
              color;

          for (i = 0; i < n; ++i) {
            color = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f"
            /* rgb */
            ])(colors[i]);
            r[i] = color.r || 0;
            g[i] = color.g || 0;
            b[i] = color.b || 0;
          }

          r = spline(r);
          g = spline(g);
          b = spline(b);
          color.opacity = 1;
          return function (t) {
            color.r = r(t);
            color.g = g(t);
            color.b = b(t);
            return color + "";
          };
        };
      }

      var rgbBasis = rgbSpline(__WEBPACK_IMPORTED_MODULE_1__basis__["b"
      /* default */
      ]);
      var rgbBasisClosed = rgbSpline(__WEBPACK_IMPORTED_MODULE_2__basisClosed__["a"
      /* default */
      ]);
      /***/
    },
    /* 119 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__basis__ = __webpack_require__(63);
      /* harmony default export */


      __webpack_exports__["a"] = function (values) {
        var n = values.length;
        return function (t) {
          var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
              v0 = values[(i + n - 1) % n],
              v1 = values[i % n],
              v2 = values[(i + 1) % n],
              v3 = values[(i + 2) % n];
          return Object(__WEBPACK_IMPORTED_MODULE_0__basis__["a"
          /* basis */
          ])((t - i / n) * n, v0, v1, v2, v3);
        };
      };
      /***/

    },
    /* 120 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (x) {
        return function () {
          return x;
        };
      };
      /***/

    },
    /* 121 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(60);
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var nb = b ? b.length : 0,
            na = a ? Math.min(nb, a.length) : 0,
            x = new Array(na),
            c = new Array(nb),
            i;

        for (i = 0; i < na; ++i) {
          x[i] = Object(__WEBPACK_IMPORTED_MODULE_0__value__["a"
          /* default */
          ])(a[i], b[i]);
        }

        for (; i < nb; ++i) {
          c[i] = b[i];
        }

        return function (t) {
          for (i = 0; i < na; ++i) {
            c[i] = x[i](t);
          }

          return c;
        };
      };
      /***/

    },
    /* 122 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b) {
        var d = new Date();
        return a = +a, b -= a, function (t) {
          return d.setTime(a + b * t), d;
        };
      };
      /***/

    },
    /* 123 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(60);
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var i = {},
            c = {},
            k;
        if (a === null || typeof a !== "object") a = {};
        if (b === null || typeof b !== "object") b = {};

        for (k in b) {
          if (k in a) {
            i[k] = Object(__WEBPACK_IMPORTED_MODULE_0__value__["a"
            /* default */
            ])(a[k], b[k]);
          } else {
            c[k] = b[k];
          }
        }

        return function (t) {
          for (k in i) {
            c[k] = i[k](t);
          }

          return c;
        };
      };
      /***/

    },
    /* 124 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(40);

      var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          reB = new RegExp(reA.source, "g");

      function zero(b) {
        return function () {
          return b;
        };
      }

      function one(b) {
        return function (t) {
          return b(t) + "";
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0,
            // scan index for next number in b
        am,
            // current match in a
        bm,
            // current match in b
        bs,
            // string preceding current number in b, if any
        i = -1,
            // index in s
        s = [],
            // string constants and placeholders
        q = []; // number interpolators
        // Coerce inputs to strings.

        a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

        while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
          if ((bs = bm.index) > bi) {
            // a string precedes the next number in b
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs; // coalesce with previous string
            else s[++i] = bs;
          }

          if ((am = am[0]) === (bm = bm[0])) {
            // numbers in a & b match
            if (s[i]) s[i] += bm; // coalesce with previous string
            else s[++i] = bm;
          } else {
            // interpolate non-matching numbers
            s[++i] = null;
            q.push({
              i: i,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a"
              /* default */
              ])(am, bm)
            });
          }

          bi = reB.lastIndex;
        } // Add remains of b.


        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        } // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.


        return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
          for (var i = 0, o; i < b; ++i) {
            s[(o = q[i]).i] = o.x(t);
          }

          return s.join("");
        });
      };
      /***/

    },
    /* 125 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview Default animation configuration for geoms
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var Action = __webpack_require__(292);

      var defaultAnimationCfg = {
        appear: {
          duration: 450,
          easing: 'easeQuadOut'
        },
        // 初始入场动画配置
        update: {
          duration: 450,
          easing: 'easeQuadInOut'
        },
        // 更新时发生变更的动画配置
        enter: {
          duration: 400,
          easing: 'easeQuadInOut',
          delay: 100
        },
        // 更新时新增元素的入场动画配置
        leave: {
          duration: 350,
          easing: 'easeQuadIn'
        } // 更新时销毁动画配置

      };
      var Animate = {
        line: {
          appear: function appear() {
            return Action.appear.clipIn;
          },
          enter: function enter() {
            return Action.enter.clipIn;
          },
          leave: function leave() {
            return Action.leave.lineWidthOut;
          }
        },
        path: {
          appear: function appear() {
            return Action.appear.clipIn;
          },
          enter: function enter() {
            return Action.enter.clipIn;
          },
          leave: function leave() {
            return Action.leave.lineWidthOut;
          }
        },
        area: {
          appear: function appear() {
            return Action.appear.clipIn;
          },
          enter: function enter() {
            return Action.enter.fadeIn;
          },
          leave: function leave() {
            return Action.leave.fadeOut;
          },
          cfg: {
            appear: {
              duration: 500,
              easing: 'easeQuadOut'
            },
            update: {
              duration: 450,
              easing: 'easeQuadInOut'
            },
            enter: {
              duration: 600,
              delay: 150,
              easing: 'easeQuadInOut'
            },
            leave: {
              easing: 'easeQuadOut',
              duration: 350
            }
          }
        },
        polygon: {
          appear: function appear() {
            return Action.appear.zoomIn;
          },
          enter: function enter() {
            return Action.enter.zoomIn;
          },
          leave: function leave() {
            return Action.leave.zoomOut;
          }
        },
        edge: {
          appear: function appear() {
            return Action.appear.pathIn;
          },
          enter: function enter() {
            return Action.enter.pathIn;
          },
          leave: function leave() {
            return Action.leave.pathOut;
          }
        },
        interval: {
          appear: function appear(coord) {
            var result;

            if (coord.isPolar) {
              result = Action.appear.zoomIn;

              if (coord.isTransposed || coord.type === 'theta') {
                result = Action.appear.fanIn;
              }
            } else if (coord.isRect) {
              result = coord.isTransposed ? Action.appear.scaleInX : Action.appear.scaleInY;
            } else {
              result = Action.appear.zoomIn;
            }

            return result;
          },
          enter: function enter(coord) {
            if (coord.isRect || coord.isTransposed || coord.type === 'theta') {
              return Action.enter.fadeIn;
            }

            return Action.enter.zoomIn;
          },
          leave: function leave() {
            return Action.leave.fadeOut;
          },
          update: function update(coord) {
            if (coord.type === 'theta') {
              return Action.update.fanIn;
            }
          }
        },
        point: {
          appear: function appear() {
            return Action.appear.zoomIn;
          },
          enter: function enter() {
            return Action.enter.zoomIn;
          },
          leave: function leave() {
            return Action.leave.zoomOut;
          }
        },
        schema: {
          appear: function appear() {
            return Action.appear.clipIn;
          },
          enter: function enter() {
            return Action.enter.clipIn;
          },
          leave: function leave() {
            return Action.leave.lineWidthOut;
          }
        },
        contour: null,
        heatmap: null,
        label: {
          appear: function appear() {
            return Action.appear.fadeIn;
          },
          enter: function enter() {
            return Action.enter.fadeIn;
          },
          leave: function leave() {
            return Action.leave.fadeOut;
          },
          cfg: {
            appear: {
              duration: 900
            }
          }
        },
        'axis-label': {
          enter: function enter() {
            return Action.appear.fadeIn;
          },
          leave: function leave() {
            return Action.leave.fadeOut;
          },
          update: function update(coord) {
            if (coord.isPolar) {
              return Action.appear.fadeIn;
            }
          }
        },
        'axis-ticks': {
          enter: function enter() {
            return Action.appear.fadeIn;
          },
          leave: function leave() {
            return Action.leave.fadeOut;
          },
          update: function update(coord) {
            if (coord.isPolar) {
              return Action.appear.fadeIn;
            }
          }
        },
        'axis-grid': {
          enter: function enter() {
            return Action.appear.fadeIn;
          },
          leave: function leave() {
            return Action.leave.fadeOut;
          },
          update: function update(coord) {
            if (coord.isPolar) {
              return Action.appear.fadeIn;
            }
          }
        },
        'axis-grid-rect': {
          enter: function enter() {
            return Action.appear.fadeIn;
          },
          leave: function leave() {
            return Action.leave.fadeOut;
          },
          update: function update() {
            return Action.leave.fadeIn;
          }
        },
        labelLine: {
          appear: function appear() {
            return Action.appear.pathIn;
          },
          enter: function enter() {
            return Action.enter.pathIn;
          },
          leave: function leave() {
            return Action.leave.pathOut;
          }
        }
      };
      Animate.Action = Action;
      Animate.defaultCfg = defaultAnimationCfg; // 获取动画

      Animate.getAnimation = function (geomType, coord, animationType) {
        var geomAnimateCfg = this[geomType];

        if (geomAnimateCfg) {
          var animation = geomAnimateCfg[animationType];

          if (Util.isFunction(animation)) {
            return animation(coord);
          }
        }

        return false;
      }; // 获取动画配置


      Animate.getAnimateCfg = function (geomType, animationType) {
        var defaultCfg = defaultAnimationCfg[animationType];

        if (this[geomType] && this[geomType].cfg && this[geomType].cfg[animationType]) {
          return Util.deepMix({}, defaultCfg, this[geomType].cfg[animationType]);
        }

        return defaultCfg;
      }; // 注册动画


      Animate.registerAnimation = function (animationType, animationName, animationFun) {
        if (!this.Action[animationType]) {
          this.Action[animationType] = {};
        }

        this.Action[animationType][animationName] = animationFun;
      };

      module.exports = Animate;
      /***/
    },
    /* 126 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var mix = __webpack_require__(8); // collections


      var DOMUtil = __webpack_require__(230);

      var arrayUtil = __webpack_require__(239);

      var eventUtil = __webpack_require__(250);

      var formatUtil = __webpack_require__(253);

      var mathUtil = __webpack_require__(257);

      var matrixUtil = __webpack_require__(43);

      var objectUtil = __webpack_require__(266);

      var pathUtil = __webpack_require__(270);

      var stringUtil = __webpack_require__(276);

      var typeUtil = __webpack_require__(280);

      var util = {
        // collections
        DOMUtil: DOMUtil,
        DomUtil: DOMUtil,
        MatrixUtil: matrixUtil,
        PathUtil: pathUtil,
        arrayUtil: arrayUtil,
        domUtil: DOMUtil,
        eventUtil: eventUtil,
        formatUtil: formatUtil,
        mathUtil: mathUtil,
        matrixUtil: matrixUtil,
        objectUtil: objectUtil,
        stringUtil: stringUtil,
        pathUtil: pathUtil,
        typeUtil: typeUtil,
        // others
        augment: __webpack_require__(89),
        clone: __webpack_require__(47),
        debounce: __webpack_require__(286),
        deepMix: __webpack_require__(48),
        each: each,
        extend: __webpack_require__(88),
        filter: __webpack_require__(64),
        group: __webpack_require__(143),
        groupBy: __webpack_require__(145),
        groupToMap: __webpack_require__(144),
        indexOf: __webpack_require__(287),
        isEmpty: __webpack_require__(83),
        isEqual: __webpack_require__(50),
        isEqualWith: __webpack_require__(288),
        map: __webpack_require__(289),
        mix: mix,
        pick: __webpack_require__(290),
        throttle: __webpack_require__(291),
        toArray: __webpack_require__(34),
        toString: __webpack_require__(24),
        uniqueId: __webpack_require__(86)
      };
      each([DOMUtil, arrayUtil, eventUtil, formatUtil, mathUtil, matrixUtil, objectUtil, pathUtil, stringUtil, typeUtil], function (collection) {
        mix(util, collection);
      });
      module.exports = util;
      /***/
    },
    /* 127 */

    /***/
    function (module, exports, __webpack_require__) {
      var keys = __webpack_require__(128);

      var isNil = __webpack_require__(5);

      function isMatch(obj, attrs) {
        var _keys = keys(attrs);

        var length = _keys.length;
        if (isNil(obj)) return !length;

        for (var i = 0; i < length; i += 1) {
          var key = _keys[i];

          if (attrs[key] !== obj[key] || !(key in obj)) {
            return false;
          }
        }

        return true;
      }

      module.exports = isMatch;
      /***/
    },
    /* 128 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var isFunction = __webpack_require__(11);

      var keys = Object.keys ? function (obj) {
        return Object.keys(obj);
      } : function (obj) {
        var result = [];
        each(obj, function (value, key) {
          if (!(isFunction(obj) && key === 'prototype')) {
            result.push(key);
          }
        });
        return result;
      };
      module.exports = keys;
      /***/
    },
    /* 129 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(13);

      var splice = Array.prototype.splice;

      var pullAt = function pullAt(arr, indexes) {
        if (!isArrayLike(arr)) {
          return [];
        }

        var length = arr ? indexes.length : 0;
        var last = length - 1;

        while (length--) {
          var previous = void 0;
          var index = indexes[length];

          if (length === last || index !== previous) {
            previous = index;
            splice.call(arr, index, 1);
          }
        }

        return arr;
      };

      module.exports = pullAt;
      /***/
    },
    /* 130 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var contains = __webpack_require__(41);

      var uniq = function uniq(arr) {
        var resultArr = [];
        each(arr, function (item) {
          if (!contains(resultArr, item)) {
            resultArr.push(item);
          }
        });
        return resultArr;
      };

      module.exports = uniq;
      /***/
    },
    /* 131 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);

      var isFunction = __webpack_require__(11);

      var each = __webpack_require__(2);
      /**
       * @param {Array} arr The array to iterate over.
       * @param {Function} [fn] The iteratee invoked per element.
       * @return {*} Returns the maximum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * maxBy(objects, function(o) { return o.n; });
       * // => { 'n': 2 }
       *
       * maxBy(objects, 'n');
       * // => { 'n': 2 }
       */


      var maxBy = function maxBy(arr, fn) {
        if (!isArray(arr)) {
          return undefined;
        }

        var max = arr[0];
        var maxData = void 0;

        if (isFunction(fn)) {
          maxData = fn(arr[0]);
        } else {
          maxData = arr[0][fn];
        }

        var data = void 0;
        each(arr, function (val) {
          if (isFunction(fn)) {
            data = fn(val);
          } else {
            data = val[fn];
          }

          if (data > maxData) {
            max = val;
            maxData = data;
          }
        });
        return max;
      };

      module.exports = maxBy;
      /***/
    },
    /* 132 */

    /***/
    function (module, exports) {
      module.exports = parseInt;
      /***/
    },
    /* 133 */

    /***/
    function (module, exports) {
      module.exports = function (obj, key) {
        return obj.hasOwnProperty(key);
      };
      /***/

    },
    /* 134 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var isFunction = __webpack_require__(11);

      var values = Object.values ? function (obj) {
        return Object.values(obj);
      } : function (obj) {
        var result = [];
        each(obj, function (value, key) {
          if (!(isFunction(obj) && key === 'prototype')) {
            result.push(value);
          }
        });
        return result;
      };
      module.exports = values;
      /***/
    },
    /* 135 */

    /***/
    function (module, exports, __webpack_require__) {
      var parsePathArray = __webpack_require__(136);

      module.exports = function rectPath(x, y, w, h, r) {
        if (r) {
          return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
        }

        var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
        res.parsePathArray = parsePathArray;
        return res;
      };
      /***/

    },
    /* 136 */

    /***/
    function (module, exports) {
      var p2s = /,?([a-z]),?/gi;

      module.exports = function parsePathArray(path) {
        return path.join(',').replace(p2s, '$1');
      };
      /***/

    },
    /* 137 */

    /***/
    function (module, exports, __webpack_require__) {
      var pathToAbsolute = __webpack_require__(138);

      var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        if (rx === ry) {
          rx += 1;
        }

        var _120 = Math.PI * 120 / 180;

        var rad = Math.PI / 180 * (+angle || 0);
        var res = [];
        var xy = void 0;
        var f1 = void 0;
        var f2 = void 0;
        var cx = void 0;
        var cy = void 0;

        var rotate = function rotate(x, y, rad) {
          var X = x * Math.cos(rad) - y * Math.sin(rad);
          var Y = x * Math.sin(rad) + y * Math.cos(rad);
          return {
            x: X,
            y: Y
          };
        };

        if (!recursive) {
          xy = rotate(x1, y1, -rad);
          x1 = xy.x;
          y1 = xy.y;
          xy = rotate(x2, y2, -rad);
          x2 = xy.x;
          y2 = xy.y;

          if (x1 === x2 && y1 === y2) {
            // 若弧的起始点和终点重叠则错开一点
            x2 += 1;
            y2 += 1;
          } // const cos = Math.cos(Math.PI / 180 * angle);
          // const sin = Math.sin(Math.PI / 180 * angle);


          var x = (x1 - x2) / 2;
          var y = (y1 - y2) / 2;
          var h = x * x / (rx * rx) + y * y / (ry * ry);

          if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
          }

          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
          cx = k * rx * y / ry + (x1 + x2) / 2;
          cy = k * -ry * x / rx + (y1 + y2) / 2;
          f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
          f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
          f1 = x1 < cx ? Math.PI - f1 : f1;
          f2 = x2 < cx ? Math.PI - f2 : f2;
          f1 < 0 && (f1 = Math.PI * 2 + f1);
          f2 < 0 && (f2 = Math.PI * 2 + f2);

          if (sweep_flag && f1 > f2) {
            f1 = f1 - Math.PI * 2;
          }

          if (!sweep_flag && f2 > f1) {
            f2 = f2 - Math.PI * 2;
          }
        } else {
          f1 = recursive[0];
          f2 = recursive[1];
          cx = recursive[2];
          cy = recursive[3];
        }

        var df = f2 - f1;

        if (Math.abs(df) > _120) {
          var f2old = f2;
          var x2old = x2;
          var y2old = y2;
          f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
          x2 = cx + rx * Math.cos(f2);
          y2 = cy + ry * Math.sin(f2);
          res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }

        df = f2 - f1;
        var c1 = Math.cos(f1);
        var s1 = Math.sin(f1);
        var c2 = Math.cos(f2);
        var s2 = Math.sin(f2);
        var t = Math.tan(df / 4);
        var hx = 4 / 3 * rx * t;
        var hy = 4 / 3 * ry * t;
        var m1 = [x1, y1];
        var m2 = [x1 + hx * s1, y1 - hy * c1];
        var m3 = [x2 + hx * s2, y2 - hy * c2];
        var m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];

        if (recursive) {
          return [m2, m3, m4].concat(res);
        }

        res = [m2, m3, m4].concat(res).join().split(',');
        var newres = [];

        for (var i = 0, ii = res.length; i < ii; i++) {
          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        }

        return newres;
      };

      var l2c = function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
      };

      var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3;

        var _23 = 2 / 3;

        return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
      };

      module.exports = function pathTocurve(path, path2) {
        var p = pathToAbsolute(path);
        var p2 = path2 && pathToAbsolute(path2);
        var attrs = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        };
        var attrs2 = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        };
        var pcoms1 = []; // path commands of original path p

        var pcoms2 = []; // path commands of original path p2

        var pfirst = ''; // temporary holder for original path command

        var pcom = ''; // holder for previous path command of original path

        var ii = void 0;

        var processPath = function processPath(path, d, pcom) {
          var nx = void 0,
              ny = void 0;

          if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
          }

          !(path[0] in {
            T: 1,
            Q: 1
          }) && (d.qx = d.qy = null);

          switch (path[0]) {
            case 'M':
              d.X = path[1];
              d.Y = path[2];
              break;

            case 'A':
              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
              break;

            case 'S':
              if (pcom === 'C' || pcom === 'S') {
                // In "S" case we have to take into account, if the previous command is C/S.
                nx = d.x * 2 - d.bx; // And reflect the previous

                ny = d.y * 2 - d.by; // command's control point relative to the current point.
              } else {
                // or some else or nothing
                nx = d.x;
                ny = d.y;
              }

              path = ['C', nx, ny].concat(path.slice(1));
              break;

            case 'T':
              if (pcom === 'Q' || pcom === 'T') {
                // In "T" case we have to take into account, if the previous command is Q/T.
                d.qx = d.x * 2 - d.qx; // And make a reflection similar

                d.qy = d.y * 2 - d.qy; // to case "S".
              } else {
                // or something else or nothing
                d.qx = d.x;
                d.qy = d.y;
              }

              path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
              break;

            case 'Q':
              d.qx = path[1];
              d.qy = path[2];
              path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
              break;

            case 'L':
              path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
              break;

            case 'H':
              path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
              break;

            case 'V':
              path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
              break;

            case 'Z':
              path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
              break;

            default:
              break;
          }

          return path;
        };

        var fixArc = function fixArc(pp, i) {
          if (pp[i].length > 7) {
            pp[i].shift();
            var pi = pp[i];

            while (pi.length) {
              pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved

              p2 && (pcoms2[i] = 'A'); // the same as above

              pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
            }

            pp.splice(i, 1);
            ii = Math.max(p.length, p2 && p2.length || 0);
          }
        };

        var fixM = function fixM(path1, path2, a1, a2, i) {
          if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
            path2.splice(i, 0, ['M', a2.x, a2.y]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = Math.max(p.length, p2 && p2.length || 0);
          }
        };

        ii = Math.max(p.length, p2 && p2.length || 0);

        for (var i = 0; i < ii; i++) {
          p[i] && (pfirst = p[i][0]); // save current path command

          if (pfirst !== 'C') {
            // C is not saved yet, because it may be result of conversion
            pcoms1[i] = pfirst; // Save current path command

            i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
          }

          p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

          if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command
          // which may produce multiple C:s
          // so we have to make sure that C is also C in original path

          fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

          if (p2) {
            // the same procedures is done to p2
            p2[i] && (pfirst = p2[i][0]);

            if (pfirst !== 'C') {
              pcoms2[i] = pfirst;
              i && (pcom = pcoms2[i - 1]);
            }

            p2[i] = processPath(p2[i], attrs2, pcom);

            if (pcoms2[i] !== 'A' && pfirst === 'C') {
              pcoms2[i] = 'C';
            }

            fixArc(p2, i);
          }

          fixM(p, p2, attrs, attrs2, i);
          fixM(p2, p, attrs2, attrs, i);
          var seg = p[i];
          var seg2 = p2 && p2[i];
          var seglen = seg.length;
          var seg2len = p2 && seg2.length;
          attrs.x = seg[seglen - 2];
          attrs.y = seg[seglen - 1];
          attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
          attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
          attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
          attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
          attrs2.x = p2 && seg2[seg2len - 2];
          attrs2.y = p2 && seg2[seg2len - 1];
        }

        return p2 ? [p, p2] : p;
      };
      /***/

    },
    /* 138 */

    /***/
    function (module, exports, __webpack_require__) {
      var parsePathString = __webpack_require__(139);

      var catmullRom2bezier = __webpack_require__(140);

      function ellipsePath(x, y, rx, ry, a) {
        var res = [];

        if (a === null && ry === null) {
          ry = rx;
        }

        x = +x;
        y = +y;
        rx = +rx;
        ry = +ry;

        if (a !== null) {
          var rad = Math.PI / 180;
          var x1 = x + rx * Math.cos(-ry * rad);
          var x2 = x + rx * Math.cos(-a * rad);
          var y1 = y + rx * Math.sin(-ry * rad);
          var y2 = y + rx * Math.sin(-a * rad);
          res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
          res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
        }

        return res;
      }

      module.exports = function pathToAbsolute(pathArray) {
        pathArray = parsePathString(pathArray);

        if (!pathArray || !pathArray.length) {
          return [['M', 0, 0]];
        }

        var res = [];
        var x = 0;
        var y = 0;
        var mx = 0;
        var my = 0;
        var start = 0;
        var pa0 = void 0;
        var dots = void 0;

        if (pathArray[0][0] === 'M') {
          x = +pathArray[0][1];
          y = +pathArray[0][2];
          mx = x;
          my = y;
          start++;
          res[0] = ['M', x, y];
        }

        var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';

        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
          res.push(r = []);
          pa = pathArray[i];
          pa0 = pa[0];

          if (pa0 !== pa0.toUpperCase()) {
            r[0] = pa0.toUpperCase();

            switch (r[0]) {
              case 'A':
                r[1] = pa[1];
                r[2] = pa[2];
                r[3] = pa[3];
                r[4] = pa[4];
                r[5] = pa[5];
                r[6] = +pa[6] + x;
                r[7] = +pa[7] + y;
                break;

              case 'V':
                r[1] = +pa[1] + y;
                break;

              case 'H':
                r[1] = +pa[1] + x;
                break;

              case 'R':
                dots = [x, y].concat(pa.slice(1));

                for (var j = 2, jj = dots.length; j < jj; j++) {
                  dots[j] = +dots[j] + x;
                  dots[++j] = +dots[j] + y;
                }

                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                break;

              case 'O':
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
                break;

              case 'U':
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ['U'].concat(res[res.length - 1].slice(-2));
                break;

              case 'M':
                mx = +pa[1] + x;
                my = +pa[2] + y;
                break;
              // for lint

              default:
                for (var _j = 1, _jj = pa.length; _j < _jj; _j++) {
                  r[_j] = +pa[_j] + (_j % 2 ? x : y);
                }

            }
          } else if (pa0 === 'R') {
            dots = [x, y].concat(pa.slice(1));
            res.pop();
            res = res.concat(catmullRom2bezier(dots, crz));
            r = ['R'].concat(pa.slice(-2));
          } else if (pa0 === 'O') {
            res.pop();
            dots = ellipsePath(x, y, pa[1], pa[2]);
            dots.push(dots[0]);
            res = res.concat(dots);
          } else if (pa0 === 'U') {
            res.pop();
            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
            r = ['U'].concat(res[res.length - 1].slice(-2));
          } else {
            for (var k = 0, kk = pa.length; k < kk; k++) {
              r[k] = pa[k];
            }
          }

          pa0 = pa0.toUpperCase();

          if (pa0 !== 'O') {
            switch (r[0]) {
              case 'Z':
                x = +mx;
                y = +my;
                break;

              case 'H':
                x = r[1];
                break;

              case 'V':
                y = r[1];
                break;

              case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                break;
              // for lint

              default:
                x = r[r.length - 2];
                y = r[r.length - 1];
            }
          }
        }

        return res;
      };
      /***/

    },
    /* 139 */

    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var SPACES = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
      var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
      var PATH_VALUES = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments

      module.exports = function parsePathString(pathString) {
        if (!pathString) {
          return null;
        }

        if ((typeof pathString === 'undefined' ? 'undefined' : _typeof(pathString)) === _typeof([])) {
          return pathString;
        }

        var paramCounts = {
          a: 7,
          c: 6,
          o: 2,
          h: 1,
          l: 2,
          m: 2,
          r: 4,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          u: 3,
          z: 0
        };
        var data = [];
        String(pathString).replace(PATH_COMMAND, function (a, b, c) {
          var params = [];
          var name = b.toLowerCase();
          c.replace(PATH_VALUES, function (a, b) {
            b && params.push(+b);
          });

          if (name === 'm' && params.length > 2) {
            data.push([b].concat(params.splice(0, 2)));
            name = 'l';
            b = b === 'm' ? 'l' : 'L';
          }

          if (name === 'o' && params.length === 1) {
            data.push([b, params[0]]);
          }

          if (name === 'r') {
            data.push([b].concat(params));
          } else {
            while (params.length >= paramCounts[name]) {
              data.push([b].concat(params.splice(0, paramCounts[name])));

              if (!paramCounts[name]) {
                break;
              }
            }
          }
        });
        return data;
      };
      /***/

    },
    /* 140 */

    /***/
    function (module, exports) {
      // http://schepers.cc/getting-to-the-point
      module.exports = function catmullRom2bezier(crp, z) {
        var d = [];

        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
          var p = [{
            x: +crp[i - 2],
            y: +crp[i - 1]
          }, {
            x: +crp[i],
            y: +crp[i + 1]
          }, {
            x: +crp[i + 2],
            y: +crp[i + 3]
          }, {
            x: +crp[i + 4],
            y: +crp[i + 5]
          }];

          if (z) {
            if (!i) {
              p[0] = {
                x: +crp[iLen - 2],
                y: +crp[iLen - 1]
              };
            } else if (iLen - 4 === i) {
              p[3] = {
                x: +crp[0],
                y: +crp[1]
              };
            } else if (iLen - 2 === i) {
              p[2] = {
                x: +crp[0],
                y: +crp[1]
              };
              p[3] = {
                x: +crp[2],
                y: +crp[3]
              };
            }
          } else {
            if (iLen - 4 === i) {
              p[3] = p[2];
            } else if (!i) {
              p[0] = {
                x: +crp[i],
                y: +crp[i + 1]
              };
            }
          }

          d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
        }

        return d;
      };
      /***/

    },
    /* 141 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(24);

      var lowerCase = function lowerCase(str) {
        return toString(str).toLowerCase();
      };

      module.exports = lowerCase;
      /***/
    },
    /* 142 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(24);

      var upperCase = function upperCase(str) {
        return toString(str).toUpperCase();
      };

      module.exports = upperCase;
      /***/
    },
    /* 143 */

    /***/
    function (module, exports, __webpack_require__) {
      var groupToMap = __webpack_require__(144);

      var group = function group(data, condition) {
        if (!condition) {
          return [data];
        }

        var groups = groupToMap(data, condition);
        var array = [];

        for (var i in groups) {
          array.push(groups[i]);
        }

        return array;
      };

      module.exports = group;
      /***/
    },
    /* 144 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(11);

      var isArray = __webpack_require__(4);

      var groupBy = __webpack_require__(145);

      var groupToMap = function groupToMap(data, condition) {
        if (!condition) {
          return {
            0: data
          };
        }

        if (!isFunction(condition)) {
          var paramsCondition = isArray(condition) ? condition : condition.replace(/\s+/g, '').split('*');

          condition = function condition(row) {
            var unique = '_'; // 避免出现数字作为Key的情况，会进行按照数字的排序

            for (var i = 0, l = paramsCondition.length; i < l; i++) {
              unique += row[paramsCondition[i]] && row[paramsCondition[i]].toString();
            }

            return unique;
          };
        }

        var groups = groupBy(data, condition);
        return groups;
      };

      module.exports = groupToMap;
      /***/
    },
    /* 145 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var isArray = __webpack_require__(4);

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      var groupBy = function groupBy(data, condition) {
        if (!condition || !isArray(data)) {
          return data;
        }

        var result = {};
        var key = null;
        each(data, function (item) {
          key = condition(item);

          if (hasOwnProperty.call(result, key)) {
            result[key].push(item);
          } else {
            result[key] = [item];
          }
        });
        return result;
      };

      module.exports = groupBy;
      /***/
    },
    /* 146 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview G2 图表的入口文件
       * @author dxq613@gmail.com
       */


      var Util = __webpack_require__(0);

      var View = __webpack_require__(293);

      var G = __webpack_require__(16);

      var Canvas = G.Canvas;
      var DomUtil = Util.DomUtil;

      var Global = __webpack_require__(7);

      var Plot = __webpack_require__(358);

      var Controller = __webpack_require__(165);

      var mergeBBox = __webpack_require__(167);

      var bboxOfBackPlot = __webpack_require__(166);

      var plotRange2BBox = __webpack_require__(168);

      var AUTO_STR = 'auto';

      function _isScaleExist(scales, compareScale) {
        var flag = false;
        Util.each(scales, function (scale) {
          var scaleValues = [].concat(scale.values);
          var compareScaleValues = [].concat(compareScale.values);

          if (scale.type === compareScale.type && scale.field === compareScale.field && scaleValues.sort().toString() === compareScaleValues.sort().toString()) {
            flag = true;
            return;
          }
        });
        return flag;
      }

      function isEqualArray(arr1, arr2) {
        return Util.isEqualWith(arr1, arr2, function (v1, v2) {
          return v1 === v2;
        });
      }
      /**
       * 图表的入口
       * @class Chart
       */


      var Chart = /*#__PURE__*/function (_View) {
        _inheritsLoose(Chart, _View);

        function Chart() {
          return _View.apply(this, arguments) || this;
        }

        var _proto = Chart.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var viewCfg = _View.prototype.getDefaultCfg.call(this);

          return Util.mix(viewCfg, {
            id: null,
            forceFit: false,
            container: null,
            wrapperEl: null,
            canvas: null,
            width: 500,
            height: 500,
            pixelRatio: null,
            backPlot: null,
            frontPlot: null,
            plotBackground: null,
            padding: Global.plotCfg.padding,
            background: null,
            autoPaddingAppend: 5,
            limitInPlot: false,
            renderer: Global.renderer,
            // renderer: 'svg',
            views: []
          });
        };

        _proto.init = function init() {
          var self = this;
          var viewTheme = self.get('viewTheme');

          self._initCanvas();

          self._initPlot();

          self._initEvents();

          _View.prototype.init.call(this);

          var tooltipController = new Controller.Tooltip({
            chart: self,
            viewTheme: viewTheme,
            options: {}
          });
          self.set('tooltipController', tooltipController);
          var legendController = new Controller.Legend({
            chart: self,
            viewTheme: viewTheme
          });
          self.set('legendController', legendController);
          self.set('_id', 'chart'); // 防止同用户设定的 id 同名

          self.emit('afterinit'); // 初始化完毕
        };

        _proto._isAutoPadding = function _isAutoPadding() {
          var padding = this.get('padding');

          if (Util.isArray(padding)) {
            return padding.includes(AUTO_STR);
          }

          return padding === AUTO_STR;
        };

        _proto._getAutoPadding = function _getAutoPadding() {
          var padding = this.get('padding'); // 图例在最前面的一层

          var frontPlot = this.get('frontPlot');
          var frontBBox = frontPlot.getBBox(); // 坐标轴在最后面的一层

          var backPlot = this.get('backPlot'); // 这段代码临时处理了title 过长的情况，但是是非常不好的代码

          var backBBox = bboxOfBackPlot(backPlot, plotRange2BBox(this.get('plotRange')));
          var box = mergeBBox(frontBBox, backBBox);
          var outter = [0 - box.minY, // 上面超出的部分
          box.maxX - this.get('width'), // 右边超出的部分
          box.maxY - this.get('height'), // 下边超出的部分
          0 - box.minX]; // 如果原始的 padding 内部存在 'auto' 则替换对应的边

          var autoPadding = Util.toAllPadding(padding);

          for (var i = 0; i < autoPadding.length; i++) {
            if (autoPadding[i] === AUTO_STR) {
              var tmp = Math.max(0, outter[i]);
              autoPadding[i] = tmp + this.get('autoPaddingAppend');
            }
          }

          return autoPadding;
        } // 初始化画布
        ;

        _proto._initCanvas = function _initCanvas() {
          var container = this.get('container');
          var id = this.get('id'); // 如果未设置 container 使用 ID, 兼容 2.x 版本

          if (!container && id) {
            container = id;
            this.set('container', id);
          }

          var width = this.get('width');
          var height = this.get('height');

          if (Util.isString(container)) {
            container = document.getElementById(container);

            if (!container) {
              throw new Error('Please specify the container for the chart!');
            }

            this.set('container', container);
          }

          var wrapperEl = DomUtil.createDom('<div style="position:relative;"></div>');
          container.appendChild(wrapperEl);
          this.set('wrapperEl', wrapperEl);

          if (this.get('forceFit')) {
            width = DomUtil.getWidth(container, width);
            this.set('width', width);
          }

          var renderer = this.get('renderer');
          var canvas = new Canvas({
            containerDOM: wrapperEl,
            width: width,
            height: height,
            // NOTICE: 有问题找青湳
            pixelRatio: renderer === 'svg' ? 1 : this.get('pixelRatio'),
            renderer: renderer
          });
          this.set('canvas', canvas);
        } // 初始化绘图区间
        ;

        _proto._initPlot = function _initPlot() {
          var self = this;

          self._initPlotBack(); // 最底层的是背景相关的 group


          var canvas = self.get('canvas');
          var backPlot = canvas.addGroup({
            zIndex: 1
          }); // 图表最后面的容器

          var plotContainer = canvas.addGroup({
            zIndex: 0
          }); // 图表所在的容器

          var frontPlot = canvas.addGroup({
            zIndex: 3
          }); // 图表前面的容器

          self.set('backPlot', backPlot);
          self.set('middlePlot', plotContainer);
          self.set('frontPlot', frontPlot);
        } // 初始化背景
        ;

        _proto._initPlotBack = function _initPlotBack() {
          var self = this;
          var canvas = self.get('canvas');
          var viewTheme = self.get('viewTheme');
          var plot = canvas.addGroup(Plot, {
            padding: this.get('padding'),
            plotBackground: Util.mix({}, viewTheme.plotBackground, self.get('plotBackground')),
            background: Util.mix({}, viewTheme.background, self.get('background'))
          });
          self.set('plot', plot);
          self.set('plotRange', plot.get('plotRange'));
        };

        _proto._initEvents = function _initEvents() {
          if (this.get('forceFit')) {
            window.addEventListener('resize', Util.wrapBehavior(this, '_initForceFitEvent'));
          }
        };

        _proto._initForceFitEvent = function _initForceFitEvent() {
          var timer = setTimeout(Util.wrapBehavior(this, 'forceFit'), 200);
          clearTimeout(this.get('resizeTimer'));
          this.set('resizeTimer', timer);
        } // 绘制图例
        ;

        _proto._renderLegends = function _renderLegends() {
          var options = this.get('options');
          var legendOptions = options.legends;

          if (Util.isNil(legendOptions) || legendOptions !== false) {
            // 没有关闭图例
            var legendController = this.get('legendController');
            legendController.options = legendOptions || {};
            legendController.plotRange = this.get('plotRange');

            if (legendOptions && legendOptions.custom) {
              // 用户自定义图例
              legendController.addCustomLegend();
            } else {
              var geoms = this.getAllGeoms();
              var scales = [];
              Util.each(geoms, function (geom) {
                var view = geom.get('view');
                var attrs = geom.getAttrsForLegend();
                Util.each(attrs, function (attr) {
                  var type = attr.type;
                  var scale = attr.getScale(type);

                  if (scale.field && scale.type !== 'identity' && !_isScaleExist(scales, scale)) {
                    scales.push(scale);
                    var filteredValues = view.getFilteredOutValues(scale.field);
                    legendController.addLegend(scale, attr, geom, filteredValues);
                  }
                });
              }); // 双轴的情况

              var yScales = this.getYScales();

              if (scales.length === 0 && yScales.length > 1) {
                legendController.addMixedLegend(yScales, geoms);
              }
            }

            legendController.alignLegends();
          }
        } // 绘制 tooltip
        ;

        _proto._renderTooltips = function _renderTooltips() {
          var options = this.get('options');

          if (Util.isNil(options.tooltip) || options.tooltip !== false) {
            // 用户没有关闭 tooltip
            var tooltipController = this.get('tooltipController');
            tooltipController.options = options.tooltip || {};
            tooltipController.renderTooltip();
          }
        }
        /**
         * 获取所有的几何标记
         * @return {Array} 所有的几何标记
         */
        ;

        _proto.getAllGeoms = function getAllGeoms() {
          var geoms = [];
          geoms = geoms.concat(this.get('geoms'));
          var views = this.get('views');
          Util.each(views, function (view) {
            geoms = geoms.concat(view.get('geoms'));
          });
          return geoms;
        }
        /**
         * 自适应宽度
         * @chainable
         * @return {Chart} 图表对象
         */
        ;

        _proto.forceFit = function forceFit() {
          var self = this;

          if (!self || self.destroyed) {
            return;
          }

          var container = self.get('container');
          var oldWidth = self.get('width');
          var width = DomUtil.getWidth(container, oldWidth);

          if (width !== 0 && width !== oldWidth) {
            var height = self.get('height');
            self.changeSize(width, height);
          }

          return self;
        };

        _proto.resetPlot = function resetPlot() {
          var plot = this.get('plot');
          var padding = this.get('padding');

          if (!isEqualArray(padding, plot.get('padding'))) {
            // 重置 padding，仅当padding 发生更改
            plot.set('padding', padding);
            plot.repaint();
          }
        }
        /**
         * 改变大小
         * @param  {Number} width  图表宽度
         * @param  {Number} height 图表高度
         * @return {Chart} 图表对象
         */
        ;

        _proto.changeSize = function changeSize(width, height) {
          var self = this;
          var canvas = self.get('canvas');
          canvas.changeSize(width, height);
          var plot = this.get('plot');
          self.set('width', width);
          self.set('height', height); // change size 时重新计算边框

          plot.repaint(); // 保持边框不变，防止自动 padding 时绘制多遍

          this.set('keepPadding', true);
          self.repaint();
          this.set('keepPadding', false);
          this.emit('afterchangesize');
          return self;
        }
        /**
         * 改变宽度
         * @param  {Number} width  图表宽度
         * @return {Chart} 图表对象
         */
        ;

        _proto.changeWidth = function changeWidth(width) {
          return this.changeSize(width, this.get('height'));
        }
        /**
         * 改变宽度
         * @param  {Number} height  图表高度
         * @return {Chart} 图表对象
         */
        ;

        _proto.changeHeight = function changeHeight(height) {
          return this.changeSize(this.get('width'), height);
        }
        /**
         * 创建一个视图
         * @param  {Object} cfg 视图的配置项
         * @return {View} 视图对象
         */
        ;

        _proto.view = function view(cfg) {
          cfg = cfg || {};
          cfg.theme = this.get('theme');
          cfg.parent = this;
          cfg.backPlot = this.get('backPlot');
          cfg.middlePlot = this.get('middlePlot');
          cfg.frontPlot = this.get('frontPlot');
          cfg.canvas = this.get('canvas');

          if (Util.isNil(cfg.animate)) {
            cfg.animate = this.get('animate');
          }

          cfg.options = Util.mix({}, this._getSharedOptions(), cfg.options);
          var view = new View(cfg);
          view.set('_id', 'view' + this.get('views').length); // 标识 ID，防止同用户设定的 id 重名

          this.get('views').push(view);
          this.emit('addview', {
            view: view
          });
          return view;
        } // isShapeInView() {
        //   return true;
        // }
        ;

        _proto.removeView = function removeView(view) {
          var views = this.get('views');
          Util.Array.remove(views, view);
          view.destroy();
        };

        _proto._getSharedOptions = function _getSharedOptions() {
          var options = this.get('options');
          var sharedOptions = {};
          Util.each(['scales', 'coord', 'axes'], function (name) {
            sharedOptions[name] = Util.cloneDeep(options[name]);
          });
          return sharedOptions;
        }
        /**
         * @override
         * 当前chart 的范围
         */
        ;

        _proto.getViewRegion = function getViewRegion() {
          var plotRange = this.get('plotRange');
          return {
            start: plotRange.bl,
            end: plotRange.tr
          };
        }
        /**
         * 设置图例配置信息
         * @param  {String|Object} field 字段名
         * @param  {Object} [cfg] 图例的配置项
         * @return {Chart} 当前的图表对象
         */
        ;

        _proto.legend = function legend(field, cfg) {
          var options = this.get('options');

          if (!options.legends) {
            options.legends = {};
          }

          var legends = {};

          if (field === false) {
            options.legends = false;
          } else if (Util.isObject(field)) {
            legends = field;
          } else if (Util.isString(field)) {
            legends[field] = cfg;
          } else {
            legends = cfg;
          }

          Util.mix(options.legends, legends);
          return this;
        }
        /**
         * 设置提示信息
         * @param  {String|Object} visible 是否可见
         * @param  {Object} [cfg] 提示信息的配置项
         * @return {Chart} 当前的图表对象
         */
        ;

        _proto.tooltip = function tooltip(visible, cfg) {
          var options = this.get('options');

          if (!options.tooltip) {
            options.tooltip = {};
          }

          if (visible === false) {
            options.tooltip = false;
          } else if (Util.isObject(visible)) {
            Util.mix(options.tooltip, visible);
          } else {
            Util.mix(options.tooltip, cfg);
          }

          return this;
        }
        /**
         * 清空图表
         * @return {Chart} 当前的图表对象
         */
        ;

        _proto.clear = function clear() {
          this.emit('beforeclear');
          var views = this.get('views');

          while (views.length > 0) {
            var view = views.shift();
            view.destroy();
          }

          _View.prototype.clear.call(this);

          var canvas = this.get('canvas');
          this.resetPlot();
          canvas.draw();
          this.emit('afterclear');
          return this;
        };

        _proto.clearInner = function clearInner() {
          var views = this.get('views');
          Util.each(views, function (view) {
            view.clearInner();
          });
          var tooltipController = this.get('tooltipController');
          tooltipController && tooltipController.clear();

          if (!this.get('keepLegend')) {
            var legendController = this.get('legendController');
            legendController && legendController.clear();
          }

          _View.prototype.clearInner.call(this);
        } // chart 除了view 上绘制的组件外，还会绘制图例和 tooltip
        ;

        _proto.drawComponents = function drawComponents() {
          _View.prototype.drawComponents.call(this); // 一般是点击图例时，仅仅隐藏某些选项，而不销毁图例


          if (!this.get('keepLegend')) {
            this._renderLegends(); // 渲染图例

          }
        }
        /**
         * 绘制图表
         * @override
         */
        ;

        _proto.render = function render() {
          var self = this; // 需要自动计算边框，则重新设置

          if (!self.get('keepPadding') && self._isAutoPadding()) {
            self.beforeRender(); // 初始化各个 view 和 绘制

            self.drawComponents();

            var autoPadding = self._getAutoPadding();

            var plot = self.get('plot'); // 在计算出来的边框不一致的情况，重新改变边框

            if (!isEqualArray(plot.get('padding'), autoPadding)) {
              plot.set('padding', autoPadding);
              plot.repaint();
            }
          }

          var middlePlot = self.get('middlePlot');

          if (self.get('limitInPlot') && !middlePlot.attr('clip')) {
            var clip = Util.getClipByRange(self.get('plotRange')); // TODO Polar coord

            middlePlot.attr('clip', clip); // clip.attr('fill', 'grey');
            // clip.attr('opacity', 0.5);
            // middlePlot.add(clip);
          }

          _View.prototype.render.call(this);

          self._renderTooltips(); // 渲染 tooltip

        };

        _proto.repaint = function repaint() {
          // 重绘时需要判定当前的 padding 是否发生过改变，如果发生过改变进行调整
          // 需要判定是否使用了自动 padding
          if (!this.get('keepPadding')) {
            this.resetPlot();
          }

          _View.prototype.repaint.call(this);
        }
        /**
         * @override
         * 显示或者隐藏
         */
        ;

        _proto.changeVisible = function changeVisible(visible) {
          var wrapperEl = this.get('wrapperEl');
          var visibleStr = visible ? '' : 'none';
          wrapperEl.style.display = visibleStr;
        }
        /**
         * 返回图表的 dataUrl 用于生成图片
         * @return {String} dataUrl 路径
         */
        ;

        _proto.toDataURL = function toDataURL() {
          var chart = this;
          var canvas = chart.get('canvas');
          var renderer = chart.get('renderer');
          var canvasDom = canvas.get('el');
          var dataURL = '';

          if (renderer === 'svg') {
            var clone = canvasDom.cloneNode(true);
            var svgDocType = document.implementation.createDocumentType('svg', '-//W3C//DTD SVG 1.1//EN', 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd');
            var svgDoc = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', svgDocType);
            svgDoc.replaceChild(clone, svgDoc.documentElement);
            var svgData = new XMLSerializer().serializeToString(svgDoc);
            dataURL = 'data:image/svg+xml;charset=utf8,' + encodeURIComponent(svgData);
          } else if (renderer === 'canvas') {
            dataURL = canvasDom.toDataURL('image/png');
          }

          return dataURL;
        }
        /**
         * 图表导出功能
         * @param  {String} [name] 图片的名称，默认为 chart(.png|.svg)
         */
        ;

        _proto.downloadImage = function downloadImage(name) {
          var chart = this;
          var link = document.createElement('a');
          var renderer = chart.get('renderer');
          var filename = (name || 'chart') + (renderer === 'svg' ? '.svg' : '.png');
          var canvas = chart.get('canvas');
          canvas.get('timeline').stopAllAnimations();
          setTimeout(function () {
            var dataURL = chart.toDataURL();

            if (window.Blob && window.URL && renderer !== 'svg') {
              var arr = dataURL.split(',');
              var mime = arr[0].match(/:(.*?);/)[1];
              var bstr = atob(arr[1]);
              var n = bstr.length;
              var u8arr = new Uint8Array(n);

              while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
              }

              var blobObj = new Blob([u8arr], {
                type: mime
              });

              if (window.navigator.msSaveBlob) {
                window.navigator.msSaveBlob(blobObj, filename);
              } else {
                link.addEventListener('click', function () {
                  link.download = filename;
                  link.href = window.URL.createObjectURL(blobObj);
                });
              }
            } else {
              link.addEventListener('click', function () {
                link.download = filename;
                link.href = dataURL;
              });
            }

            var e = document.createEvent('MouseEvents');
            e.initEvent('click', false, false);
            link.dispatchEvent(e);
          }, 16);
        }
        /**
         * 根据坐标点显示对应的 tooltip
         * @param  {Object} point 画布上的点
         * @return {Chart}       返回 chart 实例
         */
        ;

        _proto.showTooltip = function showTooltip(point) {
          var views = this.getViewsByPoint(point);

          if (views.length) {
            var tooltipController = this.get('tooltipController');
            tooltipController.showTooltip(point, views);
          }

          return this;
        }
        /**
         * 将tooltip 锁定到当前位置不能移动
         * @return {Chart}       返回 chart 实例
         */
        ;

        _proto.lockTooltip = function lockTooltip() {
          var tooltipController = this.get('tooltipController');
          tooltipController.lockTooltip();
          return this;
        }
        /**
         * 将tooltip 锁定解除
         * @return {Chart}       返回 chart 实例
         */
        ;

        _proto.unlockTooltip = function unlockTooltip() {
          var tooltipController = this.get('tooltipController');
          tooltipController.unlockTooltip();
          return this;
        }
        /**
         * 隐藏 tooltip
        * @return {Chart}       返回 chart 实例
         */
        ;

        _proto.hideTooltip = function hideTooltip() {
          var tooltipController = this.get('tooltipController');
          tooltipController.hideTooltip();
          return this;
        }
        /**
         * 根据传入的画布坐标，获取该处的 tooltip 上的记录信息
         * @param  {Object} point 画布坐标点
         * @return {Array}       返回结果
         */
        ;

        _proto.getTooltipItems = function getTooltipItems(point) {
          var self = this;
          var views = self.getViewsByPoint(point);
          var rst = [];
          Util.each(views, function (view) {
            var geoms = view.get('geoms');
            Util.each(geoms, function (geom) {
              var dataArray = geom.get('dataArray');
              var items = [];
              Util.each(dataArray, function (data) {
                var tmpPoint = geom.findPoint(point, data);

                if (tmpPoint) {
                  var subItems = geom.getTipItems(tmpPoint);
                  items = items.concat(subItems);
                }
              });
              rst = rst.concat(items);
            });
          });
          return rst;
        }
        /**
         * @override
         * 销毁图表
         */
        ;

        _proto.destroy = function destroy() {
          this.emit('beforedestroy');
          clearTimeout(this.get('resizeTimer'));
          var canvas = this.get('canvas');
          var wrapperEl = this.get('wrapperEl');
          wrapperEl.parentNode.removeChild(wrapperEl);

          _View.prototype.destroy.call(this);

          canvas.destroy();
          window.removeEventListener('resize', Util.getWrapBehavior(this, '_initForceFitEvent'));
          this.emit('afterdestroy');
        };

        return Chart;
      }(View);

      module.exports = Chart;
      /***/
    },
    /* 147 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview Chart、View、Geometry 的基类
       * @author dxq613@gmail.com
       */


      var EventEmitter = __webpack_require__(54);

      var Util = __webpack_require__(0);

      var Base = /*#__PURE__*/function (_EventEmitter) {
        _inheritsLoose(Base, _EventEmitter);

        var _proto = Base.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {};
        };

        function Base(cfg) {
          var _this;

          _this = _EventEmitter.call(this) || this;
          var attrs = {
            visible: true
          };

          var defaultCfg = _this.getDefaultCfg();

          _this._attrs = attrs;
          Util.assign(attrs, defaultCfg, cfg);
          return _this;
        }

        _proto.get = function get(name) {
          return this._attrs[name];
        };

        _proto.set = function set(name, value) {
          this._attrs[name] = value;
        };

        _proto.show = function show() {
          var visible = this.get('visible');

          if (!visible) {
            this.set('visible', true);
            this.changeVisible(true);
          }
        };

        _proto.hide = function hide() {
          var visible = this.get('visible');

          if (visible) {
            this.set('visible', false);
            this.changeVisible(false);
          }
        }
        /**
         * @protected
         * @param {Boolean} visible 是否可见
         * 显示、隐藏
         */
        ;

        _proto.changeVisible = function changeVisible()
        /* visible */
        {};

        _proto.destroy = function destroy() {
          this._attrs = {};
          this.removeAllListeners();
          this.destroyed = true;
        };

        return Base;
      }(EventEmitter);

      module.exports = Base;
      /***/
    },
    /* 148 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 颜色计算的辅助方法
       * @author dxq613@gmail.com
       */
      var isNumber = __webpack_require__(9);

      var isString = __webpack_require__(10);

      var each = __webpack_require__(2); // const RGB_REG = /rgb\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;


      var RGB_REG = /rgba?\(([\s.,0-9]+)\)/; // 创建辅助 tag 取颜色

      function createTmp() {
        var i = document.createElement('i');
        i.title = 'Web Colour Picker';
        i.style.display = 'none';
        document.body.appendChild(i);
        return i;
      } // 获取颜色之间的插值


      function getValue(start, end, percent, index) {
        var value = start[index] + (end[index] - start[index]) * percent;
        return value;
      } // 数组转换成颜色


      function arr2rgb(arr) {
        return '#' + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
      } // 将数值从 0-255 转换成16进制字符串


      function toHex(value) {
        value = Math.round(value);
        value = value.toString(16);

        if (value.length === 1) {
          value = '0' + value;
        }

        return value;
      }

      function calColor(colors, percent) {
        if (isNaN(percent) || !isNumber(percent) || percent < 0) {
          percent = 0;
        }

        if (percent > 1) {
          percent = 1;
        }

        var steps = colors.length - 1;
        var step = Math.floor(steps * percent);
        var left = steps * percent - step;
        var start = colors[step];
        var end = step === steps ? start : colors[step + 1];
        var rgb = arr2rgb([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);
        return rgb;
      } // rgb 颜色转换成数组


      function rgb2arr(str) {
        var arr = [];
        arr.push(parseInt(str.substr(1, 2), 16));
        arr.push(parseInt(str.substr(3, 2), 16));
        arr.push(parseInt(str.substr(5, 2), 16));
        return arr;
      }

      var colorCache = {};
      var iEl = null;
      var ColorUtil = {
        /**
         * 将颜色转换到 rgb 的格式
         * @param  {String} color 颜色
         * @return {String} 将颜色转换到 '#ffffff' 的格式
         */
        toRGB: function toRGB(color) {
          // 如果已经是 rgb的格式
          if (color[0] === '#' && color.length === 7) {
            return color;
          }

          if (!iEl) {
            // 防止防止在页头报错
            iEl = createTmp();
          }

          var rst;

          if (colorCache[color]) {
            rst = colorCache[color];
          } else {
            iEl.style.color = color;
            rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');
            var matchs = RGB_REG.exec(rst);
            var cArray = matchs[1].split(/\s*,\s*/);
            rst = arr2rgb(cArray);
            colorCache[color] = rst;
          }

          return rst;
        },
        rgb2arr: rgb2arr,

        /**
         * 获取渐变函数
         * @param  {Array} colors 多个颜色
         * @return {String} 颜色值
         */
        gradient: function gradient(colors) {
          var points = [];

          if (isString(colors)) {
            colors = colors.split('-');
          }

          each(colors, function (color) {
            if (color.indexOf('#') === -1) {
              color = ColorUtil.toRGB(color);
            }

            points.push(rgb2arr(color));
          });
          return function (percent) {
            return calColor(points, percent);
          };
        }
      };
      module.exports = ColorUtil;
      /***/
    },
    /* 149 */

    /***/
    function (module, exports, __webpack_require__) {
      var DEFAULT_Y = 0; // 默认的y的值

      var each = __webpack_require__(2);

      var ArrayUtil = {
        values: __webpack_require__(65)
      };
      module.exports = {
        /**
         * 对应的维度是否可以调整
         * @protected
         * @param  {String}  dimName 可以调整的维度 x,y
         * @return {Boolean} 是否可以调整
         */
        isAdjust: function isAdjust(dimName) {
          return this.adjustNames.indexOf(dimName) >= 0;
        },

        /**
         * @protected
         * 获取可调整度量对应的值
         * @param  {Frame} mergeData 数据
         * @return {Object} 值的映射
         */
        _getDimValues: function _getDimValues(mergeData) {
          var self = this;
          var valuesMap = {};
          var dims = [];

          if (self.xField && self.isAdjust('x')) {
            dims.push(self.xField);
          }

          if (self.yField && self.isAdjust('y')) {
            dims.push(self.yField);
          }

          each(dims, function (dim) {
            var values = ArrayUtil.values(mergeData, dim);
            values.sort(function (v1, v2) {
              return v1 - v2;
            });
            valuesMap[dim] = values;
          });

          if (!self.yField && self.isAdjust('y')) {
            // 只有一维的情况下,同时调整y
            var dim = 'y';
            var values = [DEFAULT_Y, 1]; // 默认分布在y轴的 0.1 与 0.2 之间

            valuesMap[dim] = values;
          }

          return valuesMap;
        },
        adjustData: function adjustData(dataArray, mergeData) {
          var self = this;

          var valuesMap = self._getDimValues(mergeData);

          each(dataArray, function (data, index) {
            // 遍历所有数据集合
            each(valuesMap, function (values, dim) {
              // 根据不同的度量分别调整位置
              self.adjustDim(dim, values, data, dataArray.length, index);
            });
          });
        },
        getAdjustRange: function getAdjustRange(dim, key, values) {
          var self = this;
          var index = values.indexOf(key);
          var length = values.length;
          var pre;
          var next;

          if (!self.yField && self.isAdjust('y')) {
            pre = 0;
            next = 1;
          } else if (length > 1) {
            pre = index === 0 ? values[0] : values[index - 1];
            next = index === length - 1 ? values[length - 1] : values[index + 1];

            if (index !== 0) {
              pre += (key - pre) / 2;
            } else {
              pre -= (next - key) / 2;
            }

            if (index !== length - 1) {
              next -= (next - key) / 2;
            } else {
              next += (key - values[length - 2]) / 2;
            }
          } else {
            pre = key === 0 ? 0 : key - 0.5;
            next = key === 0 ? 1 : key + 0.5;
          }

          return {
            pre: pre,
            next: next
          };
        },

        /**
         * 对数据进行分组
         * @param  {Array} data 数据
         * @param  {String} dim 分组的字段
         * @return {Object}  分组的键值对映射
         */
        groupData: function groupData(data, dim) {
          var groups = {};
          each(data, function (record) {
            var value = record[dim];

            if (value === undefined) {
              value = record[dim] = DEFAULT_Y;
            }

            if (!groups[value]) {
              groups[value] = [];
            }

            groups[value].push(record);
          });
          return groups;
        }
      };
      /***/
    },
    /* 150 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview Theme entry
       * @author sima.zhang
       */
      var Theme = {
        "default": __webpack_require__(151),
        dark: __webpack_require__(306)
      };
      module.exports = Theme;
      /***/
    },
    /* 151 */

    /***/
    function (module, exports) {
      var _html, _tooltip;
      /**
       * @fileOverview G2 3.0 default theme
       * @author sima.zhang
       */


      var DEFAULT_COLOR = '#1890FF';
      var COLOR_PLATE_8 = ['#1890FF', '#2FC25B', '#FACC14', '#223273', '#8543E0', '#13C2C2', '#3436C7', '#F04864'];
      var COLOR_PLATE_16 = ['#1890FF', '#41D9C7', '#2FC25B', '#FACC14', '#E6965C', '#223273', '#7564CC', '#8543E0', '#5C8EE6', '#13C2C2', '#5CA3E6', '#3436C7', '#B381E6', '#F04864', '#D598D9'];
      var COLOR_PLATE_24 = ['#1890FF', '#66B5FF', '#41D9C7', '#2FC25B', '#6EDB8F', '#9AE65C', '#FACC14', '#E6965C', '#57AD71', '#223273', '#738AE6', '#7564CC', '#8543E0', '#A877ED', '#5C8EE6', '#13C2C2', '#70E0E0', '#5CA3E6', '#3436C7', '#8082FF', '#DD81E6', '#F04864', '#FA7D92', '#D598D9'];
      var COLOR_PIE = ['#1890FF', '#13C2C2', '#2FC25B', '#FACC14', '#F04864', '#8543E0', '#3436C7', '#223273'];
      var COLOR_PIE_16 = ['#1890FF', '#73C9E6', '#13C2C2', '#6CD9B3', '#2FC25B', '#9DD96C', '#FACC14', '#E6965C', '#F04864', '#D66BCA', '#8543E0', '#8E77ED', '#3436C7', '#737EE6', '#223273', '#7EA2E6'];
      var FONT_FAMILY = '"-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",SimSun, "sans-serif"'; // tooltip 相关 dom 的 css 类名

      var TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';
      var TOOLTIP_TITLE_CLASS = 'g2-tooltip-title';
      var TOOLTIP_LIST_CLASS = 'g2-tooltip-list';
      var TOOLTIP_LIST_ITEM_CLASS = 'g2-tooltip-list-item';
      var TOOLTIP_MARKER_CLASS = 'g2-tooltip-marker';
      var TOOLTIP_VALUE_CLASS = 'g2-tooltip-value'; // html 渲染的 legend 相关 dom 的 css 类型

      var LEGEND_CONTAINER_CLASS = 'g2-legend';
      var LEGEND_TITLE_CLASS = 'g2-legend-title';
      var LEGEND_LIST_CLASS = 'g2-legend-list';
      var LEGEND_LIST_ITEM_CLASS = 'g2-legend-list-item';
      var LEGEND_MARKER_CLASS = 'g2-legend-marker';
      var Theme = {
        defaultColor: DEFAULT_COLOR,
        // 默认主题色
        plotCfg: {
          padding: [20, 20, 95, 80]
        },
        fontFamily: FONT_FAMILY,
        defaultLegendPosition: 'bottom',
        // 默认图例的展示位置
        colors: COLOR_PLATE_8,
        colors_16: COLOR_PLATE_16,
        colors_24: COLOR_PLATE_24,
        colors_pie: COLOR_PIE,
        colors_pie_16: COLOR_PIE_16,
        shapes: {
          point: ['hollowCircle', 'hollowSquare', 'hollowDiamond', 'hollowBowtie', 'hollowTriangle', 'hollowHexagon', 'cross', 'tick', 'plus', 'hyphen', 'line'],
          line: ['line', 'dash', 'dot'],
          area: ['area']
        },
        sizes: [1, 10],
        opacities: [0.1, 0.9],
        axis: {
          top: {
            // zIndex: 1, // 默认上下方向的坐标轴位于左右坐标轴的上方
            position: 'top',
            title: null,
            label: {
              offset: 16,
              textStyle: {
                fill: '#545454',
                fontSize: 12,
                lineHeight: 16,
                textBaseline: 'middle',
                fontFamily: FONT_FAMILY
              },
              autoRotate: true
            },
            line: {
              lineWidth: 1,
              stroke: '#BFBFBF'
            },
            tickLine: {
              lineWidth: 1,
              stroke: '#BFBFBF',
              length: 4,
              alignWithLabel: true
            }
          },
          bottom: {
            position: 'bottom',
            title: null,
            label: {
              offset: 16,
              autoRotate: true,
              textStyle: {
                fill: '#545454',
                fontSize: 12,
                lineHeight: 16,
                textBaseline: 'middle',
                fontFamily: FONT_FAMILY
              }
            },
            line: {
              lineWidth: 1,
              stroke: '#BFBFBF'
            },
            tickLine: {
              lineWidth: 1,
              stroke: '#BFBFBF',
              length: 4,
              alignWithLabel: true
            }
          },
          left: {
            position: 'left',
            title: null,
            label: {
              offset: 8,
              autoRotate: true,
              textStyle: {
                fill: '#545454',
                fontSize: 12,
                lineHeight: 16,
                textBaseline: 'middle',
                fontFamily: FONT_FAMILY
              }
            },
            line: null,
            tickLine: null,
            grid: {
              zIndex: -1,
              lineStyle: {
                stroke: '#E9E9E9',
                lineWidth: 1,
                lineDash: [3, 3]
              },
              hideFirstLine: true
            }
          },
          right: {
            position: 'right',
            title: null,
            label: {
              offset: 8,
              autoRotate: true,
              textStyle: {
                fill: '#545454',
                fontSize: 12,
                lineHeight: 16,
                textBaseline: 'middle',
                fontFamily: FONT_FAMILY
              }
            },
            line: null,
            tickLine: null,
            grid: {
              lineStyle: {
                stroke: '#E9E9E9',
                lineWidth: 1,
                lineDash: [3, 3]
              },
              hideFirstLine: true
            }
          },
          circle: {
            zIndex: 1,
            title: null,
            label: {
              offset: 8,
              textStyle: {
                fill: '#545454',
                fontSize: 12,
                lineHeight: 16,
                fontFamily: FONT_FAMILY
              }
            },
            line: {
              lineWidth: 1,
              stroke: '#BFBFBF'
            },
            tickLine: {
              lineWidth: 1,
              stroke: '#BFBFBF',
              length: 4,
              alignWithLabel: true
            },
            grid: {
              lineStyle: {
                stroke: '#E9E9E9',
                lineWidth: 1,
                lineDash: [3, 3]
              },
              hideFirstLine: true
            }
          },
          radius: {
            zIndex: 0,
            label: {
              offset: 12,
              textStyle: {
                fill: '#545454',
                fontSize: 12,
                textBaseline: 'middle',
                lineHeight: 16,
                fontFamily: FONT_FAMILY
              }
            },
            line: {
              lineWidth: 1,
              stroke: '#BFBFBF'
            },
            tickLine: {
              lineWidth: 1,
              stroke: '#BFBFBF',
              length: 4,
              alignWithLabel: true
            },
            grid: {
              lineStyle: {
                stroke: '#E9E9E9',
                lineWidth: 1,
                lineDash: [3, 3]
              },
              type: 'circle'
            }
          },
          helix: {
            grid: null,
            label: null,
            title: null,
            line: {
              lineWidth: 1,
              stroke: '#BFBFBF'
            },
            tickLine: {
              lineWidth: 1,
              length: 4,
              stroke: '#BFBFBF',
              alignWithLabel: true
            }
          }
        },
        label: {
          offset: 20,
          textStyle: {
            fill: '#545454',
            fontSize: 12,
            textBaseline: 'middle',
            fontFamily: FONT_FAMILY
          }
        },
        treemapLabels: {
          offset: 10,
          textStyle: {
            fill: '#fff',
            fontSize: 12,
            textBaseline: 'top',
            fontStyle: 'bold',
            fontFamily: FONT_FAMILY
          }
        },
        innerLabels: {
          textStyle: {
            fill: '#fff',
            fontSize: 12,
            textBaseline: 'middle',
            fontFamily: FONT_FAMILY
          }
        },
        // 在theta坐标系下的饼图文本内部的样式
        thetaLabels: {
          labelHeight: 14,
          offset: 30 // 在theta坐标系下的饼图文本的样式

        },
        legend: {
          right: {
            position: 'right',
            layout: 'vertical',
            itemMarginBottom: 8,
            // layout 为 vertical 时各个图例项的间距
            width: 16,
            height: 156,
            title: null,
            legendStyle: {
              LIST_CLASS: {
                textAlign: 'left'
              }
            },
            textStyle: {
              fill: '#8C8C8C',
              fontSize: 12,
              textAlign: 'start',
              textBaseline: 'middle',
              lineHeight: 0,
              fontFamily: FONT_FAMILY
            },
            // 图例项文本的样式
            unCheckColor: '#bfbfbf'
          },
          left: {
            position: 'left',
            layout: 'vertical',
            itemMarginBottom: 8,
            width: 16,
            height: 156,
            title: null,
            textStyle: {
              fill: '#8C8C8C',
              fontSize: 12,
              textAlign: 'start',
              textBaseline: 'middle',
              lineHeight: 20,
              fontFamily: FONT_FAMILY
            },
            // 图例项文本的样式
            unCheckColor: '#bfbfbf'
          },
          top: {
            position: 'top',
            offset: [0, 6],
            layout: 'horizontal',
            title: null,
            itemGap: 10,
            width: 156,
            height: 16,
            textStyle: {
              fill: '#8C8C8C',
              fontSize: 12,
              textAlign: 'start',
              textBaseline: 'middle',
              lineHeight: 20,
              fontFamily: FONT_FAMILY
            },
            // 图例项文本的样式
            unCheckColor: '#bfbfbf'
          },
          bottom: {
            position: 'bottom',
            offset: [0, 6],
            layout: 'horizontal',
            title: null,
            itemGap: 10,
            width: 156,
            height: 16,
            textStyle: {
              fill: '#8C8C8C',
              fontSize: 12,
              textAlign: 'start',
              textBaseline: 'middle',
              lineHeight: 20,
              fontFamily: FONT_FAMILY
            },
            // 图例项文本的样式
            unCheckColor: '#bfbfbf'
          },
          // 定义 html 渲染图例的样式
          html: (_html = {}, _html["" + LEGEND_CONTAINER_CLASS] = {
            height: 'auto',
            width: 'auto',
            position: 'absolute',
            overflow: 'auto',
            fontSize: '12px',
            fontFamily: FONT_FAMILY,
            lineHeight: '20px',
            color: '#8C8C8C'
          }, _html["" + LEGEND_TITLE_CLASS] = {
            marginBottom: '4px'
          }, _html["" + LEGEND_LIST_CLASS] = {
            listStyleType: 'none',
            margin: 0,
            padding: 0
          }, _html["" + LEGEND_LIST_ITEM_CLASS] = {
            listStyleType: 'none',
            cursor: 'pointer',
            marginBottom: '5px',
            marginRight: '24px'
          }, _html["" + LEGEND_MARKER_CLASS] = {
            width: '9px',
            height: '9px',
            borderRadius: '50%',
            display: 'inline-block',
            marginRight: '8px',
            verticalAlign: 'middle'
          }, _html),
          // 不能滑动的连续图例样式
          gradient: {
            textStyle: {
              fill: '#8C8C8C',
              fontSize: 12,
              textAlign: 'center',
              textBaseline: 'middle',
              lineHeight: 20,
              fontFamily: FONT_FAMILY
            },
            // 图例项文本的样式
            lineStyle: {
              lineWidth: 1,
              stroke: '#fff'
            },
            unCheckColor: '#bfbfbf'
          },
          margin: [0, 5, 24, 5],
          // 图例跟四个边的坐标轴、绘图区域的间距
          legendMargin: 24 // 图例之间的间距

        },
        tooltip: (_tooltip = {
          useHtml: true,
          crosshairs: false,
          offset: 15,
          marker: {
            symbol: 'circle',
            activeSymbol: 'circle'
          }
        }, _tooltip["" + TOOLTIP_CONTAINER_CLASS] = {
          position: 'absolute',
          visibility: 'hidden',
          // @2018-07-25 by blue.lb 这里去掉浮动，火狐上存在样式错位
          // whiteSpace: 'nowrap',
          zIndex: 8,
          transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
          backgroundColor: 'rgba(255, 255, 255, 0.9)',
          boxShadow: '0px 0px 10px #aeaeae',
          borderRadius: '3px',
          color: 'rgb(87, 87, 87)',
          fontSize: '12px',
          fontFamily: FONT_FAMILY,
          lineHeight: '20px',
          padding: '10px 10px 6px 10px'
        }, _tooltip["" + TOOLTIP_TITLE_CLASS] = {
          marginBottom: '4px'
        }, _tooltip["" + TOOLTIP_LIST_CLASS] = {
          margin: 0,
          listStyleType: 'none',
          padding: 0
        }, _tooltip["" + TOOLTIP_LIST_ITEM_CLASS] = {
          listStyleType: 'none',
          marginBottom: '4px',
          padding: 0,
          marginTop: 0,
          marginLeft: 0,
          marginRight: 0
        }, _tooltip["" + TOOLTIP_MARKER_CLASS] = {
          width: '5px',
          height: '5px',
          display: 'inline-block',
          marginRight: '8px'
        }, _tooltip["" + TOOLTIP_VALUE_CLASS] = {
          display: 'inline-block',
          "float": 'right',
          marginLeft: '30px'
        }, _tooltip),
        tooltipMarker: {
          symbol: function symbol(x, y, r) {
            return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];
          },
          stroke: '#fff',
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffSetY: 0,
          shadowColor: 'rgba(0,0,0,0.09)',
          lineWidth: 2,
          radius: 4
        },
        // 提示信息在折线图、区域图上形成点的样式
        tooltipCrosshairsRect: {
          type: 'rect',
          rectStyle: {
            fill: '#CCD6EC',
            opacity: 0.3
          }
        },
        // tooltip 辅助背景框样式
        tooltipCrosshairsLine: {
          lineStyle: {
            stroke: 'rgba(0, 0, 0, 0.25)',
            lineWidth: 1
          }
        },
        shape: {
          point: {
            lineWidth: 1,
            fill: DEFAULT_COLOR,
            radius: 4
          },
          hollowPoint: {
            fill: '#fff',
            lineWidth: 1,
            stroke: DEFAULT_COLOR,
            radius: 3
          },
          interval: {
            lineWidth: 0,
            fill: DEFAULT_COLOR,
            fillOpacity: 0.85
          },
          hollowInterval: {
            fill: '#fff',
            stroke: DEFAULT_COLOR,
            fillOpacity: 0,
            lineWidth: 2
          },
          area: {
            lineWidth: 0,
            fill: DEFAULT_COLOR,
            fillOpacity: 0.6
          },
          polygon: {
            lineWidth: 0,
            fill: DEFAULT_COLOR,
            fillOpacity: 1
          },
          hollowPolygon: {
            fill: '#fff',
            stroke: DEFAULT_COLOR,
            fillOpacity: 0,
            lineWidth: 2
          },
          hollowArea: {
            fill: '#fff',
            stroke: DEFAULT_COLOR,
            fillOpacity: 0,
            lineWidth: 2
          },
          line: {
            stroke: DEFAULT_COLOR,
            lineWidth: 2,
            fill: null
          },
          edge: {
            stroke: DEFAULT_COLOR,
            lineWidth: 1,
            fill: null
          },
          schema: {
            stroke: DEFAULT_COLOR,
            lineWidth: 1,
            fill: null
          }
        },
        guide: {
          line: {
            lineStyle: {
              stroke: 'rgba(0, 0, 0, .65)',
              lineDash: [2, 2],
              lineWidth: 1
            },
            text: {
              position: 'start',
              autoRotate: true,
              style: {
                fill: 'rgba(0, 0, 0, .45)',
                fontSize: 12,
                textAlign: 'start',
                fontFamily: FONT_FAMILY,
                textBaseline: 'bottom'
              }
            }
          },
          text: {
            style: {
              fill: 'rgba(0,0,0,.5)',
              fontSize: 12,
              textBaseline: 'middle',
              textAlign: 'start',
              fontFamily: FONT_FAMILY
            }
          },
          region: {
            style: {
              lineWidth: 0,
              // 辅助框的边框宽度
              fill: '#000',
              // 辅助框填充的颜色
              fillOpacity: 0.04 // 辅助框的背景透明度

            } // 辅助框的图形样式属性

          },
          html: {
            alignX: 'middle',
            alignY: 'middle'
          },
          dataRegion: {
            style: {
              region: {
                lineWidth: 0,
                fill: '#000000',
                opacity: 0.04
              },
              text: {
                textAlign: 'center',
                textBaseline: 'bottom',
                fontSize: 12,
                fill: 'rgba(0, 0, 0, .65)'
              }
            }
          },
          dataMarker: {
            top: true,
            style: {
              point: {
                r: 3,
                fill: '#FFFFFF',
                stroke: '#1890FF',
                lineWidth: 2
              },
              line: {
                stroke: '#A3B1BF',
                lineWidth: 1
              },
              text: {
                fill: 'rgba(0, 0, 0, .65)',
                opacity: 1,
                fontSize: 12,
                textAlign: 'start'
              }
            },
            display: {
              point: true,
              line: true,
              text: true
            },
            lineLength: 20,
            direction: 'upward',
            autoAdjust: true
          }
        },
        pixelRatio: null
      };
      module.exports = Theme;
      /***/
    },
    /* 152 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var _require = __webpack_require__(20),
          Group = _require.Group;

      var Util = __webpack_require__(3);

      var Grid = /*#__PURE__*/function (_Group) {
        _inheritsLoose(Grid, _Group);

        function Grid() {
          return _Group.apply(this, arguments) || this;
        }

        var _proto = Grid.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          // const cfg = super.getDefaultCfg();
          return {
            zIndex: 1,

            /**
             * 栅格线的类型
             *  - line 不封闭的线
             *  - polygon 封闭的多边形
             * @type {String}
             */
            type: 'line',

            /**
             * 线的样式配置
             * @type {Object}
             */
            lineStyle: null,

            /**
             * 线集合的配置
             * @type {Array}
             */
            items: null,

            /**
             * 为网格设置交替的背景色，指定一个值则先渲染奇数层，两个值则交替渲染
             * @type {String | Array}
             */
            alternateColor: null,
            matrix: null,

            /**
             * 是否隐藏第一条网格线，默认为 false
             * @type {Boolean}
             */
            hideFirstLine: false,

            /**
             * 是否隐藏最后一条网格线，默认为 false
             * @type {Boolean}
             */
            hideLastLine: false,

            /**
             * 0基线不在轴线上时，是否强调0基线
             * @type {Boolean}
             */
            hightLightZero: false,

            /**
             * 0基线样式
             * @type {Object}
             */
            zeroLineStyle: {
              stroke: '#595959',
              lineDash: [0, 0]
            }
          };
        };

        _proto._renderUI = function _renderUI() {
          _Group.prototype._renderUI.call(this);

          this._drawLines();
        };

        _proto._drawLines = function _drawLines() {
          var self = this;
          var lineStyle = self.get('lineStyle');
          var items = self.get('items');

          if (items && items.length) {
            self._precessItems(items);

            self._drawGridLines(items, lineStyle);
          }
        };

        _proto._precessItems = function _precessItems(items) {
          var self = this;
          var preItem;
          Util.each(items, function (item, index) {
            if (preItem && self.get('alternateColor')) {
              self._drawAlternativeBg(item, preItem, index);
            }

            preItem = item;
          });
        };

        _proto._drawGridLines = function _drawGridLines(items, lineStyle) {
          var self = this;
          var type = this.get('type');
          var gridLine;
          var path;
          var cfg;
          var points;
          var itemsLength = items.length;

          if (type === 'line' || type === 'polygon') {
            Util.each(items, function (item, idx) {
              if (self.get('hideFirstLine') && idx === 0) {
                // 不展示第一条网格线
                return;
              }

              if (self.get('hideLastLine') && idx === itemsLength - 1) {
                // 不展示最后一条网格线
                return;
              }

              points = item.points;
              path = [];

              if (type === 'line') {
                path.push(['M', points[0].x, points[0].y]);
                path.push(['L', points[points.length - 1].x, points[points.length - 1].y]);
              } else {
                Util.each(points, function (point, index) {
                  if (index === 0) {
                    path.push(['M', point.x, point.y]);
                  } else {
                    path.push(['L', point.x, point.y]);
                  }
                });
              }

              if (self._drawZeroLine(type, idx)) {
                cfg = Util.mix({}, self.get('zeroLineStyle'), {
                  path: path
                });
              } else {
                cfg = Util.mix({}, lineStyle, {
                  path: path
                });
              }

              gridLine = self.addShape('path', {
                attrs: cfg
              });
              gridLine.name = 'axis-grid';
              gridLine._id = item._id;
              gridLine.set('coord', self.get('coord'));
              self.get('appendInfo') && gridLine.setSilent('appendInfo', self.get('appendInfo'));
            });
          } else {
            Util.each(items, function (item, idx) {
              if (self.get('hideFirstLine') && idx === 0) {
                // 不展示第一条网格线
                return;
              }

              if (self.get('hideLastLine') && idx === itemsLength - 1) {
                // 不展示最后一条网格线
                return;
              }

              points = item.points;
              path = [];
              Util.each(points, function (point, index) {
                var radius = point.radius;

                if (index === 0) {
                  path.push(['M', point.x, point.y]);
                } else {
                  path.push(['A', radius, radius, 0, 0, point.flag, point.x, point.y]);
                }
              });
              cfg = Util.mix({}, lineStyle, {
                path: path
              });
              gridLine = self.addShape('path', {
                attrs: cfg
              });
              gridLine.name = 'axis-grid';
              gridLine._id = item._id;
              gridLine.set('coord', self.get('coord'));
              self.get('appendInfo') && gridLine.setSilent('appendInfo', self.get('appendInfo'));
            });
          }
        };

        _proto._drawZeroLine = function _drawZeroLine(type, idx) {
          var self = this;
          var tickValues = self.get('tickValues');

          if (type === 'line' && tickValues) {
            if (tickValues[idx] === 0 && self.get('hightLightZero')) {
              return true;
            }
          }

          return false;
        };

        _proto._drawAlternativeBg = function _drawAlternativeBg(item, preItem, index) {
          var self = this;
          var alternateColor = self.get('alternateColor');
          var attrs;
          var oddColor;
          var evenColor;

          if (Util.isString(alternateColor)) {
            oddColor = alternateColor;
          } else if (Util.isArray(alternateColor)) {
            oddColor = alternateColor[0];
            evenColor = alternateColor[1];
          }

          if (index % 2 === 0) {
            if (evenColor) {
              attrs = self._getBackItem(preItem.points, item.points, evenColor);
            }
          } else if (oddColor) {
            attrs = self._getBackItem(preItem.points, item.points, oddColor);
          }

          var shape = self.addShape('Path', {
            attrs: attrs
          });
          shape.name = 'axis-grid-rect';
          shape._id = item._id && item._id.replace('grid', 'grid-rect');
          shape.set('coord', self.get('coord'));
          self.get('appendInfo') && shape.setSilent('appendInfo', self.get('appendInfo'));
        };

        _proto._getBackItem = function _getBackItem(start, end, bgColor) {
          var path = [];
          var type = this.get('type');

          if (type === 'line') {
            path.push(['M', start[0].x, start[0].y]);
            path.push(['L', start[start.length - 1].x, start[start.length - 1].y]);
            path.push(['L', end[end.length - 1].x, end[end.length - 1].y]);
            path.push(['L', end[0].x, end[0].y]);
            path.push(['Z']);
          } else if (type === 'polygon') {
            Util.each(start, function (subItem, index) {
              if (index === 0) {
                path.push(['M', subItem.x, subItem.y]);
              } else {
                path.push(['L', subItem.x, subItem.y]);
              }
            });

            for (var i = end.length - 1; i >= 0; i--) {
              path.push(['L', end[i].x, end[i].y]);
            }

            path.push(['Z']);
          } else {
            var flag = start[0].flag;
            Util.each(start, function (subItem, index) {
              var radius = subItem.radius;

              if (index === 0) {
                path.push(['M', subItem.x, subItem.y]);
              } else {
                path.push(['A', radius, radius, 0, 0, subItem.flag, subItem.x, subItem.y]);
              }
            });

            for (var j = end.length - 1; j >= 0; j--) {
              var endSubItem = end[j];
              var endRadius = endSubItem.radius;

              if (j === end.length - 1) {
                path.push(['M', endSubItem.x, endSubItem.y]);
              } else {
                path.push(['A', endRadius, endRadius, 0, 0, flag === 1 ? 0 : 1, endSubItem.x, endSubItem.y]);
              }
            }
          }

          return {
            fill: bgColor,
            path: path
          };
        };

        return Grid;
      }(Group);

      module.exports = Grid;
      /***/
    },
    /* 153 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var DomUtil = Util.DomUtil;

      var Component = __webpack_require__(32);

      var positionAdjust = __webpack_require__(309);

      var spirialAdjust = __webpack_require__(310);

      var bboxAdjust = __webpack_require__(311);

      var LAYOUTS = {
        scatter: positionAdjust,
        map: spirialAdjust,
        treemap: bboxAdjust
      };

      var Label = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Label, _Component);

        function Label() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = Label.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Component.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            name: 'label',

            /**
             * label类型
             * @type {(String)}
             */
            type: 'default',

            /**
             * 默认文本样式
             * @type {Array}
             */
            textStyle: null,

            /**
             * 文本显示格式化回调函数
             * @type {Function}
             */
            formatter: null,

            /**
             * 显示的文本集合
             * @type {Array}
             */
            items: null,

            /**
             * 是否使用html渲染label
             * @type {String}
             */
            useHtml: false,

            /**
             * html 渲染时用的容器的模板，必须存在 class = "g-labels"
             * @type {String}
             */
            containerTpl: '<div class="g-labels" style="position:absolute;top:0;left:0;"></div>',

            /**
             * html 渲染时单个 label 的模板，必须存在 class = "g-label"
             * @type {String}
             */
            itemTpl: '<div class="g-label" style="position:absolute;">{text}</div>',

            /**
             * label牵引线定义
             * @type {String || Object}
             */
            labelLine: false,

            /**
             * label牵引线容器
             * @type Object
             */
            lineGroup: null,

            /**
             * 需添加label的shape
             * @type Object
             */
            shapes: null,

            /**
             * 默认为true。为false时指定直接用items渲染文本，不进行config
             * @type Object
             */
            config: true,

            /**
             * 是否进行拾取
             * @type Object
             */
            capture: true
          });
        }
        /*
         * 清空label容器
         */
        ;

        _proto.clear = function clear() {
          var group = this.get('group');
          var container = this.get('container');

          if (group && !group.get('destroyed')) {
            group.clear();
          }

          if (container) {
            container.innerHTML = '';
          }

          _Component.prototype.clear.call(this);
        }
        /**
         * 销毁group
         */
        ;

        _proto.destroy = function destroy() {
          var group = this.get('group');
          var container = this.get('container');

          if (!group.destroy) {
            group.destroy();
          }

          if (container) {
            container.parentNode && container.parentNode.removeChild(container);
          }

          _Component.prototype.destroy.call(this); // 要最后调用 super.destroy 否则 get 属性会无效

        }
        /**
         * label绘制全过程
         */
        ;

        _proto.render = function render() {
          this.clear();

          this._init();

          this.beforeDraw();
          this.draw();
          this.afterDraw();
        };

        _proto._dryDraw = function _dryDraw() {
          var self = this;
          var items = self.get('items');
          var children = self.getLabels();
          var count = children.length;
          Util.each(items, function (item, index) {
            if (index < count) {
              var label = children[index];
              self.changeLabel(label, item);
            } else {
              var labelShape = self._addLabel(item, index);

              if (labelShape) {
                labelShape._id = item._id;
                labelShape.set('coord', item.coord);
              }
            }
          });

          for (var i = count - 1; i >= items.length; i--) {
            children[i].remove();
          }

          self._adjustLabels();

          if (self.get('labelLine') || !self.get('config')) {
            self.drawLines();
          }
        }
        /**
         * 更新label
         * 1. 将items与group中的children对比，更新/新增/删除labels
         * 2. labels布局优化
         * 3. 画label连接线
         * 4. 绘制到画布
         */
        ;

        _proto.draw = function draw() {
          this._dryDraw();

          this.get('canvas').draw();
        }
        /*
         * 更新label
         * oldLabel shape或label dom
         * newLabel label data
         * index items中的下标
         */
        ;

        _proto.changeLabel = function changeLabel(oldLabel, newLabel) {
          if (!oldLabel) {
            return;
          }

          if (oldLabel.tagName) {
            var node = this._createDom(newLabel);

            oldLabel.innerHTML = node.innerHTML;

            this._setCustomPosition(newLabel, oldLabel);
          } else {
            oldLabel._id = newLabel._id;
            oldLabel.attr('text', newLabel.text);

            if (oldLabel.attr('x') !== newLabel.x || oldLabel.attr('y') !== newLabel.y) {
              oldLabel.resetMatrix();

              if (newLabel.textStyle.rotate) {
                oldLabel.rotateAtStart(newLabel.textStyle.rotate);
                delete newLabel.textStyle.rotate;
              }

              oldLabel.attr(newLabel);
            }
          }
        }
        /**
         * 显示label
         */
        ;

        _proto.show = function show() {
          var group = this.get('group');
          var container = this.get('container');

          if (group) {
            group.show();
          }

          if (container) {
            container.style.opacity = 1;
          }
        }
        /**
         * 隐藏label
         */
        ;

        _proto.hide = function hide() {
          var group = this.get('group');
          var container = this.get('container');

          if (group) {
            group.hide();
          }

          if (container) {
            container.style.opacity = 0;
          }
        }
        /**
         * 画label连接线
         */
        ;

        _proto.drawLines = function drawLines() {
          var self = this;
          var lineStyle = self.get('labelLine');

          if (typeof lineStyle === 'boolean') {
            self.set('labelLine', {});
          }

          var lineGroup = self.get('lineGroup');

          if (!lineGroup || lineGroup.get('destroyed')) {
            lineGroup = self.get('group').addGroup({
              elCls: 'x-line-group'
            });
            self.set('lineGroup', lineGroup);
          } else {
            lineGroup.clear();
          }

          Util.each(self.get('items'), function (label) {
            self.lineToLabel(label, lineGroup);
          });
        };

        _proto.lineToLabel = function lineToLabel(label, lineGroup) {
          var self = this;

          if (!self.get('config') && !label.labelLine) {
            return;
          }

          var lineStyle = label.labelLine || self.get('labelLine');
          var capture = typeof label.capture === 'undefined' ? self.get('capture') : label.capture;
          var path = lineStyle.path;

          if (path && Util.isFunction(lineStyle.path)) {
            path = lineStyle.path(label);
          }

          if (!path) {
            var start = label.start || {
              x: label.x - label._offset.x,
              y: label.y - label._offset.y
            };
            path = [['M', start.x, start.y], ['L', label.x, label.y]];
          }

          var stroke = label.color;

          if (!stroke) {
            if (label.textStyle && label.textStyle.fill) {
              stroke = label.textStyle.fill;
            } else {
              stroke = '#000';
            }
          }

          var lineShape = lineGroup.addShape('path', {
            attrs: Util.mix({
              path: path,
              fill: null,
              stroke: stroke
            }, lineStyle),
            capture: capture
          }); // label 对应线的动画关闭

          lineShape.name = self.get('name'); // generate labelLine id according to label id

          lineShape._id = label._id && label._id.replace('glabel', 'glabelline');
          lineShape.set('coord', self.get('coord'));
        } // 根据type对label布局
        ;

        _proto._adjustLabels = function _adjustLabels() {
          var self = this;
          var type = self.get('type');
          var labels = self.getLabels();
          var shapes = self.get('shapes');
          var layout = LAYOUTS[type];

          if (type === 'default' || !layout) {
            return;
          }

          layout(labels, shapes);
        }
        /**
         * 获取当前所有label实例
         * @return {Array} 当前label实例
         */
        ;

        _proto.getLabels = function getLabels() {
          var container = this.get('container');

          if (container) {
            return Util.toArray(container.childNodes);
          }

          return this.get('group').get('children');
        } // 先计算label的所有配置项，然后生成label实例
        ;

        _proto._addLabel = function _addLabel(item, index) {
          var cfg = item;

          if (this.get('config')) {
            cfg = this._getLabelCfg(item, index);
          }

          return this._createText(cfg);
        };

        _proto._getLabelCfg = function _getLabelCfg(item, index) {
          var textStyle = this.get('textStyle') || {};
          var formatter = this.get('formatter');
          var htmlTemplate = this.get('htmlTemplate');

          if (!Util.isObject(item)) {
            var tmp = item;
            item = {};
            item.text = tmp;
          }

          if (Util.isFunction(textStyle)) {
            textStyle = textStyle(item.text, item, index);
          }

          if (formatter) {
            item.text = formatter(item.text, item, index);
          }

          if (htmlTemplate) {
            item.useHtml = true;

            if (Util.isFunction(htmlTemplate)) {
              item.text = htmlTemplate(item.text, item, index);
            }
          }

          if (Util.isNil(item.text)) {
            item.text = '';
          }

          item.text = item.text + ''; // ? 为什么转换为字符串

          var cfg = Util.mix({}, item, {
            textStyle: textStyle
          }, {
            x: item.x || 0,
            y: item.y || 0
          });
          return cfg;
        }
        /**
         * label初始化，主要针对html容器
         */
        ;

        _proto._init = function _init() {
          if (!this.get('group')) {
            var group = this.get('canvas').addGroup({
              id: 'label-group'
            });
            this.set('group', group);
          }
        };

        _proto.initHtmlContainer = function initHtmlContainer() {
          var container = this.get('container');

          if (!container) {
            var containerTpl = this.get('containerTpl');
            var wrapper = this.get('canvas').get('el').parentNode;
            container = DomUtil.createDom(containerTpl);
            wrapper.style.position = 'relative';
            wrapper.appendChild(container);
            this.set('container', container);
          } else if (Util.isString(container)) {
            container = document.getElementById(container);

            if (container) {
              this.set('container', container);
            }
          }

          return container;
        } // 分html dom和G shape两种情况生成label实例
        ;

        _proto._createText = function _createText(config) {
          // @2018-11-29 by blue.lb 这里由于使用delete导致之后的配置无法获取到point和rotate，出现问题，深拷贝一次比较好
          var cfg = Util.deepMix({}, config);
          var container = this.get('container');
          var capture = typeof cfg.capture === 'undefined' ? this.get('capture') : cfg.capture;
          var labelShape;

          if (cfg.useHtml || cfg.htmlTemplate) {
            if (!container) {
              container = this.initHtmlContainer();
            }

            var node = this._createDom(cfg);

            container.appendChild(node);

            this._setCustomPosition(cfg, node);
          } else {
            var name = this.get('name');
            var origin = cfg.point;
            var group = this.get('group');
            delete cfg.point; // 临时解决，否则影响动画

            var rotate = cfg.rotate; // textStyle中的rotate虽然可以正常画出，但是在做动画的时候可能会导致动画异常。移出，在定义好shape后通过transform实现效果。

            if (cfg.textStyle) {
              if (cfg.textStyle.rotate) {
                rotate = cfg.textStyle.rotate;
                delete cfg.textStyle.rotate;
              }

              cfg = Util.mix({
                x: cfg.x,
                y: cfg.y,
                textAlign: cfg.textAlign,
                text: cfg.text
              }, cfg.textStyle);
            }

            labelShape = group.addShape('text', {
              attrs: cfg,
              capture: capture
            });

            if (rotate) {
              // rotate是用角度定义的，转换为弧度
              if (Math.abs(rotate) > Math.PI * 2) {
                rotate = rotate / 180 * Math.PI;
              }

              labelShape.transform([['t', -cfg.x, -cfg.y], ['r', rotate], ['t', cfg.x, cfg.y]]);
            }

            labelShape.setSilent('origin', origin || cfg);
            labelShape.name = name; // 用于事件标注

            this.get('appendInfo') && labelShape.setSilent('appendInfo', this.get('appendInfo'));
            return labelShape;
          }
        };

        _proto._createDom = function _createDom(cfg) {
          var itemTpl = this.get('itemTpl');
          var str = Util.substitute(itemTpl, {
            text: cfg.text
          });
          return DomUtil.createDom(str);
        } // 根据文本对齐方式确定dom位置
        ;

        _proto._setCustomPosition = function _setCustomPosition(cfg, htmlDom) {
          var textAlign = cfg.textAlign || 'left';
          var top = cfg.y;
          var left = cfg.x;
          var width = DomUtil.getOuterWidth(htmlDom);
          var height = DomUtil.getOuterHeight(htmlDom);
          top = top - height / 2;

          if (textAlign === 'center') {
            left = left - width / 2;
          } else if (textAlign === 'right') {
            left = left - width;
          }

          htmlDom.style.top = parseInt(top, 10) + 'px';
          htmlDom.style.left = parseInt(left, 10) + 'px';
        };

        return Label;
      }(Component);

      module.exports = Label;
      /***/
    },
    /* 154 */

    /***/
    function (module, exports) {
      var Greedy = /*#__PURE__*/function () {
        function Greedy() {
          this.bitmap = [];
        }

        var _proto = Greedy.prototype;

        _proto.hasGap = function hasGap(bbox) {
          var hasGap = true;
          var bitmap = this.bitmap;
          var minX = Math.floor(bbox.minX);
          var maxX = Math.ceil(bbox.maxX);
          var minY = Math.floor(bbox.minY);
          var maxY = Math.ceil(bbox.maxY) - 1;

          for (var i = minX; i < maxX; i++) {
            if (!bitmap[i]) {
              bitmap[i] = [];
              continue;
            }

            if (i === minX || i === maxX - 1) {
              for (var j = minY; j <= maxY; j++) {
                if (bitmap[i][j]) {
                  hasGap = false;
                  break;
                }
              }
            } else {
              if (bitmap[i][minY] || bitmap[i][maxY]) {
                hasGap = false;
                break;
              }
            }
          }

          return hasGap;
        };

        _proto.fillGap = function fillGap(bbox) {
          var bitmap = this.bitmap;
          var minX = Math.floor(bbox.minX);
          var maxX = Math.ceil(bbox.maxX) - 1;
          var minY = Math.floor(bbox.minY);
          var maxY = Math.ceil(bbox.maxY) - 1;

          for (var i = minX; i <= maxX; i++) {
            for (var j = minY; j < maxY; j += 8) {
              if (!bitmap[i]) {
                bitmap[i] = [];
              }

              bitmap[i][j] = true;
            }

            bitmap[i][maxY] = true;
          }

          for (var _i = minY; _i <= maxY; _i++) {
            bitmap[minX][_i] = true;
            bitmap[maxX][_i] = true;
          }
        };

        return Greedy;
      }();

      module.exports = Greedy;
      /***/
    },
    /* 155 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(3);

      module.exports = {
        getFirstScale: function getFirstScale(scales) {
          var firstScale;
          Util.each(scales, function (scale) {
            if (scale) {
              firstScale = scale;
              return false;
            }
          });
          return firstScale;
        }
      };
      /***/
    },
    /* 156 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Legend = __webpack_require__(157);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY; // const DomUtil = Util.DomUtil;


      var Event = Util.Event;
      var Group = Util.Group; // const Global = require('../../global');
      // const CONTAINER_CLASS = 'g2-legend';

      function findItem(items, refer) {
        var rst = null;
        var value = refer instanceof Group || refer.name === 'legendGroup' ? refer.get('value') : refer;
        Util.each(items, function (item) {
          if (item.value === value) {
            rst = item;
            return false;
          }
        });
        return rst;
      }

      function findShapeByName(group, name) {
        return group.findBy(function (node) {
          return node.name === name;
        });
      }

      var Category = /*#__PURE__*/function (_Legend) {
        _inheritsLoose(Category, _Legend);

        function Category() {
          return _Legend.apply(this, arguments) || this;
        }

        var _proto = Category.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Legend.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * type标识
             * @type {String}
             */
            type: 'category-legend',

            /**
             * 子项集合
             * @type {Array}
             */
            items: null,

            /**
             * TODO：rename
             * 图例项水平方向的间距
             * @type {Number}
             */
            itemGap: 5,

            /**
             * TODO：rename
             * 图例项垂直方向的间距
             * @type {Number}
             */
            itemMarginBottom: 8,

            /**
             * 图例项图组
             * @type {Group}
             */
            itemsGroup: null,

            /**
             * 布局方式： horizontal，vertical
             * @type {String}
             */
            layout: 'horizontal',

            /**
             * 是否允许全部取消，默认 false，即必须保留一个被选中
             * @type {Boolean}
             */
            allowAllCanceled: false,

            /**
             * 边框内边距
             * @type {Array}
             */
            backPadding: [0, 0, 0, 0],

            /**
             * 图例项取消选中的颜色
             * @type {String}
             */
            unCheckColor: '#ccc',

            /**
             * 图例背景层属性设置
             * @type {Obejct}
             */
            background: {
              fill: '#fff',
              fillOpacity: 0
            },

            /**
             * 图例项的宽度，当图例有很多图例项，并且用户想要这些图例项在同一平面内垂直对齐，此时这个属性可帮用户实现此效果
             * @type {Number}
             */
            itemWidth: null,

            /**
             * 图例文字样式
             * @type {ATTRS}
             */
            textStyle: {
              fill: '#333',
              fontSize: 12,
              textAlign: 'start',
              textBaseline: 'middle',
              fontFamily: FONT_FAMILY
            },

            /**
             * marker 和文字的距离
             * @type {Number}
             */
            _wordSpaceing: 8,

            /**
             * 图例项是否可点击，默认为 true
             * @type {Boolean}
             */
            clickable: true,

            /**
             * TODO: rename
             * 图例项的选择模式，多选和单选 multiple、single
             * @type {String}
             */
            selectedMode: 'multiple',

            /**
             * 图例项的顺序是否要逆序，默认为 false
             * @type {Boolean}
             */
            reversed: false,

            /**
             * 是否自动换行
             * @type {Boolean}
             */
            autoWrap: true,

            /**
             * 是否以增加 border 的方式高亮 hover 的 item。若为 false ，则降低其他 item 的透明度。
             * @type {Boolean}
             */
            highlight: false,

            /**
             * 非highlight方式下，鼠标hover到legend样式
             * @type {Number}
             */
            activeOpacity: 0.7,

            /**
             * 非highlight方式下，非鼠标hover到的legend样式
             * @type {Number}
             */
            inactiveOpacity: 1
          });
        } // rendering
        ;

        _proto.render = function render() {
          _Legend.prototype.render.call(this);

          this._renderItems();

          this.get('autoWrap') && this._adjustItems(); // 默认自动换行
        } // user iteraction
        ;

        _proto._bindEvents = function _bindEvents() {
          if (this.get('hoverable')) {
            this.get('group').on('mousemove', Util.wrapBehavior(this, '_onMousemove'));
            this.get('group').on('mouseleave', Util.wrapBehavior(this, '_onMouseleave'));
          }

          if (this.get('clickable')) {
            this.get('group').on('click', Util.wrapBehavior(this, '_onClick'));
          }
        } // return the target's parent legend object
        ;

        _proto._getLegendItem = function _getLegendItem(target) {
          var item = target.get('parent');

          if (item && item.name === 'legendGroup') {
            return item;
          }

          return null;
        } // activate an item by reduce the opacity of other items.
        // it is reserved for bi-direction interaction between charts / graph and legend
        ;

        _proto.activate = function activate(value) {
          var _this = this;

          var self = this;
          var itemsGroup = self.get('itemsGroup');
          var children = itemsGroup.get('children');
          var markerItem = void 0;
          children.forEach(function (child) {
            markerItem = findShapeByName(child, 'legend-marker');
            if (!markerItem) return;
            var checked = child.get('checked');

            if (_this.get('highlight')) {
              // change stroke color
              if (child.get('value') === value && checked) {
                markerItem.attr('stroke', '#333');
              } else {
                markerItem.attr('stroke', null);
              }
            } else {
              // change opacity
              if (child.get('value') === value) {
                markerItem.attr('fillOpacity', self.get('activeOpacity'));
              }
            }
          });
          this.get('canvas').draw();
          return;
        } // restore the opacity of items
        // it is reserved for bi-direction interaction between charts / graph and legend
        ;

        _proto.deactivate = function deactivate() {
          var _this2 = this;

          var self = this;
          var itemsGroup = self.get('itemsGroup');
          var children = itemsGroup.get('children');
          var markerItem = void 0;
          var unCheckColor = this.get('unCheckColor');
          children.forEach(function (child) {
            markerItem = findShapeByName(child, 'legend-marker');
            if (!markerItem) return;

            if (_this2.get('highlight')) {
              var oriStroke = markerItem.get('oriStroke');
              var checked = child.get('checked');
              if (oriStroke && !checked) oriStroke = unCheckColor;else oriStroke = '';
              markerItem.attr('stroke', oriStroke);
            } else {
              markerItem.attr('fillOpacity', self.get('inactiveOpacity'));
            }
          });
          this.get('canvas').draw();
          return;
        } // mouse move listener of an item
        // when mouse over an item, reduce the opacity of the other items.
        ;

        _proto._onMousemove = function _onMousemove(ev) {
          var item = this._getLegendItem(ev.currentTarget);

          if (item && item.get('checked')) {
            var items = this.get('items');
            var itemhover = new Event('itemhover', ev, true, true);
            itemhover.item = findItem(items, item);
            itemhover.checked = item.get('checked');
            itemhover.currentTarget = ev.currentTarget; // change the opacity of other items

            this.deactivate();
            this.activate(item.get('value'));
            this.emit('itemhover', itemhover);
          } else {
            this.deactivate();
            this.emit('itemunhover', ev);
          }

          this.get('canvas').draw();
          return;
        } // mouse leave listener of an item
        ;

        _proto._onMouseleave = function _onMouseleave(ev) {
          this.deactivate();
          this.get('canvas').draw();
          this.emit('itemunhover', ev);
          return;
        } // the click listener of an item
        ;

        _proto._onClick = function _onClick(ev) {
          var clickedItem = this._getLegendItem(ev.currentTarget);

          var items = this.get('items');

          if (clickedItem && !clickedItem.get('destroyed')) {
            var checked = clickedItem.get('checked');
            var mode = this.get('selectedMode');
            var item = findItem(items, clickedItem);
            var itemclick = new Event('itemclick', ev, true, true);
            itemclick.item = item;
            itemclick.currentTarget = clickedItem;
            itemclick.appendInfo = ev.currentTarget.get('appendInfo');
            itemclick.checked = mode === 'single' ? true : !checked;

            if (!this.get('allowAllCanceled') && checked && this.getCheckedCount() === 1) {
              this.emit('clicklastitem', itemclick);
              return;
            }

            var unCheckColor = this.get('unCheckColor');
            var checkColor = this.get('textStyle').fill;
            var markerItem = void 0;
            var textItem = void 0;
            var legendItem = void 0;

            if (mode === 'single') {
              var itemsGroup = this.get('itemsGroup');
              var children = itemsGroup.get('children');
              Util.each(children, function (child) {
                markerItem = findShapeByName(child, 'legend-marker');
                textItem = findShapeByName(child, 'legend-text');
                legendItem = findShapeByName(child, 'legend-item');

                if (child !== clickedItem) {
                  if (markerItem.attr('fill')) {
                    markerItem.attr('fill', unCheckColor);
                  }

                  if (markerItem.attr('stroke')) {
                    markerItem.attr('stroke', unCheckColor);
                  }

                  textItem.attr('fill', unCheckColor);
                  markerItem.setSilent('checked', false);
                  textItem.setSilent('checked', false);
                  legendItem.setSilent('checked', false);
                  child.setSilent('checked', false);
                } else {
                  if (markerItem.attr('fill')) {
                    item && item.marker && markerItem.attr('fill', item.marker.fill);
                  }

                  if (markerItem.attr('stroke')) {
                    item && item.marker && markerItem.attr('stroke', item.marker.stroke);
                  }

                  textItem.attr('fill', checkColor);
                  markerItem.setSilent('checked', true);
                  textItem.setSilent('checked', true);
                  legendItem.setSilent('checked', true);
                  child.setSilent('checked', true);
                }
              });
            } else {
              markerItem = findShapeByName(clickedItem, 'legend-marker');
              textItem = findShapeByName(clickedItem, 'legend-text');
              legendItem = findShapeByName(clickedItem, 'legend-item');

              if (markerItem.attr('fill')) {
                item && item.marker && markerItem.attr('fill', checked ? unCheckColor : item.marker.fill);
              }

              if (markerItem.attr('stroke')) {
                item && item.marker && markerItem.attr('stroke', checked ? unCheckColor : item.marker.stroke);
              }

              textItem.attr('fill', checked ? unCheckColor : checkColor);
              clickedItem.setSilent('checked', !checked);
              markerItem.setSilent('checked', !checked);
              textItem.setSilent('checked', !checked);
              legendItem.setSilent('checked', !checked);
            }

            this.emit('itemclick', itemclick);
          }

          this.get('canvas').draw();
          return;
        } // render the items
        ;

        _proto._renderItems = function _renderItems() {
          var _this3 = this;

          var items = this.get('items');

          if (this.get('reversed')) {
            items.reverse();
          }

          Util.each(items, function (item, index) {
            _this3._addItem(item, index);
          });

          if (this.get('highlight')) {
            var itemsGroup = this.get('itemsGroup');
            var children = itemsGroup.get('children');
            var markerItem = void 0;
            children.forEach(function (child) {
              markerItem = findShapeByName(child, 'legend-marker');
              var oriStroke = markerItem.get('oriStroke');

              if (!oriStroke) {
                if (markerItem.attr('stroke')) markerItem.set('oriStroke', markerItem.attr('stroke'));else markerItem.set('oriStroke', '');
              }
            });
          }
        } // format the item value
        ;

        _proto._formatItemValue = function _formatItemValue(value) {
          var formatter = this.get('formatter') || this.get('itemFormatter');

          if (formatter) {
            value = formatter.call(this, value);
          }

          return value;
        } // find x of next item
        ;

        _proto._getNextX = function _getNextX() {
          var layout = this.get('layout');
          var itemGap = this.get('itemGap');
          var itemsGroup = this.get('itemsGroup');
          var itemWidth = this.get('itemWidth');
          var children = itemsGroup.get('children');
          var nextX = 0;

          if (layout === 'horizontal') {
            // 水平布局
            Util.each(children, function (v) {
              nextX += (itemWidth ? itemWidth : v.getBBox().width) + itemGap;
            });
          }

          return nextX;
        } // find y of next item
        ;

        _proto._getNextY = function _getNextY() {
          var itemMarginBottom = this.get('itemMarginBottom');
          var titleGap = this.get('titleShape') ? this.get('titleGap') : 0;
          var layout = this.get('layout');
          var itemsGroup = this.get('itemsGroup');
          var titleShape = this.get('titleShape');
          var children = itemsGroup.get('children');
          var nextY = titleGap;

          if (titleShape) {
            nextY += titleShape.getBBox().height;
          }

          if (layout === 'vertical') {
            // 竖直布局
            Util.each(children, function (v) {
              nextY += v.getBBox().height + itemMarginBottom;
            });
          }

          return nextY;
        } // add an item to the canvas
        ;

        _proto._addItem = function _addItem(item) {
          var itemsGroup = this.get('itemsGroup');

          var x = this._getNextX();

          var y = this._getNextY();

          var unCheckColor = this.get('unCheckColor');
          var itemGroup = itemsGroup.addGroup({
            x: x,
            y: y,
            value: item.value,
            checked: item.checked
          }); // @2018-10-20 by blue.lb 需要设置viewId，否则在emit的时候，parent获取不到viewId

          itemGroup.set('viewId', this.get('viewId'));
          var textStyle = this.get('textStyle');
          var wordSpace = this.get('_wordSpaceing');
          var startX = 0;

          if (item.marker) {
            // 如果有marker添加marker
            var markerAttrs = Util.mix({}, item.marker, {
              x: item.marker.radius + x,
              y: y
            });

            if (!item.checked) {
              if (markerAttrs.fill) {
                markerAttrs.fill = unCheckColor;
              }

              if (markerAttrs.stroke) {
                markerAttrs.stroke = unCheckColor;
              }
            }

            var markerShape = itemGroup.addShape('marker', {
              type: 'marker',
              attrs: markerAttrs
            });
            markerShape.attr('cursor', 'pointer');
            markerShape.name = 'legend-marker';
            startX += markerShape.getBBox().width + wordSpace;
          }

          var textAttrs = Util.mix({}, {
            fill: '#333',
            fontSize: 12,
            textAlign: 'start',
            textBaseline: 'middle',
            fontFamily: FONT_FAMILY
          }, textStyle, {
            x: startX + x,
            y: y,
            text: this._formatItemValue(item.value)
          });

          if (!item.checked) {
            Util.mix(textAttrs, {
              fill: unCheckColor
            });
          }

          var textShape = itemGroup.addShape('text', {
            attrs: textAttrs
          });
          textShape.attr('cursor', 'pointer');
          textShape.name = 'legend-text';
          this.get('appendInfo') && textShape.setSilent('appendInfo', this.get('appendInfo')); // 添加一个包围矩形，用于事件支持

          var bbox = itemGroup.getBBox();
          var itemWidth = this.get('itemWidth');
          var wrapperShape = itemGroup.addShape('rect', {
            attrs: {
              x: x,
              y: y - bbox.height / 2,
              fill: '#fff',
              fillOpacity: 0,
              width: itemWidth || bbox.width,
              height: bbox.height
            }
          });
          wrapperShape.attr('cursor', 'pointer');
          wrapperShape.setSilent('origin', item); // 保存图例项相关的数据，便于事件操作

          wrapperShape.name = 'legend-item';
          this.get('appendInfo') && wrapperShape.setSilent('appendInfo', this.get('appendInfo'));
          itemGroup.name = 'legendGroup';
          return itemGroup;
        } // auto break the line for horizontal layout
        ;

        _proto._adjustHorizontal = function _adjustHorizontal() {
          var itemsGroup = this.get('itemsGroup');
          var children = itemsGroup.get('children');
          var maxLength = this.get('maxLength');
          var itemGap = this.get('itemGap');
          var itemMarginBottom = this.get('itemMarginBottom');
          var titleGap = this.get('titleShape') ? this.get('titleGap') : 0;
          var row = 0;
          var rowLength = 0;
          var width = void 0;
          var height = void 0;
          var box = void 0;
          var itemWidth = this.get('itemWidth');

          if (itemsGroup.getBBox().width > maxLength) {
            Util.each(children, function (child) {
              box = child.getBBox();
              width = itemWidth || box.width;
              height = box.height + itemMarginBottom;

              if (maxLength - rowLength < width) {
                row++;
                rowLength = 0;
              }

              child.move(rowLength, row * height + titleGap);
              rowLength += width + itemGap;
            });
          }

          return;
        } // auto break the column for vertical layout
        ;

        _proto._adjustVertical = function _adjustVertical() {
          var itemsGroup = this.get('itemsGroup');
          var titleShape = this.get('titleShape');
          var children = itemsGroup.get('children');
          var maxLength = this.get('maxLength'); // 垂直布局，则 maxLength 代表容器的高度

          var itemGap = this.get('itemGap');
          var itemMarginBottom = this.get('itemMarginBottom');
          var titleGap = this.get('titleGap');
          var titleHeight = titleShape ? titleShape.getBBox().height + titleGap : 0;
          var itemWidth = this.get('itemWidth');
          var colLength = titleHeight;
          var width = void 0;
          var height = void 0;
          var box = void 0;
          var maxItemWidth = 0;
          var totalLength = 0;

          if (itemsGroup.getBBox().height > maxLength) {
            Util.each(children, function (v) {
              box = v.getBBox();
              width = box.width;
              height = box.height;

              if (itemWidth) {
                maxItemWidth = itemWidth + itemGap;
              } else if (width > maxItemWidth) {
                maxItemWidth = width + itemGap;
              }

              if (maxLength - colLength < height) {
                colLength = titleHeight;
                totalLength += maxItemWidth;
                v.move(totalLength, titleHeight);
              } else {
                v.move(totalLength, colLength);
              }

              colLength += height + itemMarginBottom;
            });
          }

          return;
        } // automatically break the line / column while the width / height exceeds maxLength
        ;

        _proto._adjustItems = function _adjustItems() {
          var layout = this.get('layout');

          if (layout === 'horizontal') {
            this._adjustHorizontal();
          } else {
            this._adjustVertical();
          }
        };

        _proto.getWidth = function getWidth() {
          return _Legend.prototype.getWidth.call(this);
        };

        _proto.getHeight = function getHeight() {
          return _Legend.prototype.getHeight.call(this);
        };

        _proto.move = function move(x, y) {
          _Legend.prototype.move.call(this, x, y);
        };

        return Category;
      }(Legend);

      module.exports = Category;
      /***/
    },
    /* 157 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Component = __webpack_require__(32);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var Legend = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Legend, _Component);

        var _proto = Legend.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {
            /**
             * Group 容器
             * @type {Object}
             */
            container: null,

            /**
             * 图例标题配置
             * @type {Object}
             */
            title: null,

            /**
             * 图例项文本格式化
             * @type {Function}
             */
            formatter: null,

            /**
             * 鼠标 hover 到图例上的默认交互是否开启
             * @type {Boolean}
             */
            hoverable: true,

            /**
             * TODO：rename
             * 图例标题距离图例项的距离
             * @type {Number}
             */
            titleGap: 15,

            /**
             * legend 相对于 container 的位置
             * @type {Array}
             */
            position: [0, 0],

            /**
             * legend 在 position 位置上的偏移量
             * @type {Array}
             */
            offset: [0, 0],

            /**
             * legend 在 position 位置上沿 x 轴的偏移量。若同时设置了 offset 和 offsetX， 以 offsetX 为准
             * @type {Number}
             */
            offsetX: null,

            /**
             * legend 在 position 位置上沿 y 轴的偏移量。若同时设置了 offset 和 offsetY， 以 offsetY 为准
             * @type {Number}
             */
            offsetY: null
          };
        };

        function Legend(cfg) {
          var _this;

          _this = _Component.call(this, cfg) || this;

          _this._init();

          _this.beforeRender();

          _this.render();

          _this._adjustPositionOffset();

          _this._bindEvents();

          return _this;
        }

        _proto._init = function _init() {
          var group = this.get('group');
          var container = this.get('container');
          this.set('canvas', container.get('canvas'));
          var position = this.get('position');
          if (!group) group = container.addGroup({
            x: 0 - position[0],
            y: 0 - position[1]
          });
          this.set('group', group);
        };

        _proto._adjustPositionOffset = function _adjustPositionOffset() {
          var position = this.get('position');
          var offset = this.get('offset');
          var offsetX = this.get('offsetX');
          var offsetY = this.get('offsetY');

          if (!Util.isArray(offset)) {
            var layout = this.get('layout');
            offset = layout === 'vertical' ? [offset, 0] : [0, offset];
          }

          if (offsetX) offset[0] = offsetX;
          if (offsetY) offset[1] = offsetY;
          var bbox = this.get('group').getBBox();
          this.move(-bbox.minX + position[0] + offset[0], -bbox.minY + position[1] + offset[1]);
        };

        _proto.beforeRender = function beforeRender() {
          var group = this.get('group');
          var itemsGroup = group.addGroup();
          this.set('itemsGroup', itemsGroup);
        };

        _proto.render = function render() {
          this._renderTitle();
        } // render the title of the legend
        ;

        _proto._renderTitle = function _renderTitle() {
          var title = this.get('title');
          var titleGap = this.get('titleGap');
          titleGap = titleGap || 0;

          if (title && title.text) {
            var group = this.get('group');
            var titleShape = group.addShape('text', {
              attrs: Util.mix({
                x: 0,
                y: 0 - titleGap,
                fill: '#333',
                textBaseline: 'middle',
                fontFamily: FONT_FAMILY
              }, title)
            });
            titleShape.name = 'legend-title';
            this.get('appendInfo') && titleShape.setSilent('appendInfo', this.get('appendInfo'));
            this.set('titleShape', titleShape);
          }
        } // return the count of checked items
        ;

        _proto.getCheckedCount = function getCheckedCount() {
          var itemsGroup = this.get('itemsGroup');
          var items = itemsGroup.get('children');
          var checkedArr = Util.filter(items, function (item) {
            return item.get('checked');
          });
          return checkedArr.length;
        } // set items for the legend
        ;

        _proto.setItems = function setItems(items) {
          this.set('items', items);
          this.clear();
          this.render();
        } // add an item into the legend
        ;

        _proto.addItem = function addItem(item) {
          var items = this.get('items');
          items.push(item);
          this.clear();
          this.render();
        } // clear all the items of the legend
        ;

        _proto.clear = function clear() {
          var itemsGroup = this.get('itemsGroup');
          itemsGroup.clear();
          var group = this.get('group');
          group.clear();
          this.beforeRender();
        } // destroy the legend
        ;

        _proto.destroy = function destroy() {
          var group = this.get('group');
          group && group.destroy();
          this._attrs = {};
          this.removeAllListeners();

          _Component.prototype.destroy.call(this); // 要最后调用 super.destroy 否则 get 属性会无效

        } // return the width of the legend
        ;

        _proto.getWidth = function getWidth() {
          var bbox = this.get('group').getBBox();
          return bbox.width;
        } // return the height of the legend
        ;

        _proto.getHeight = function getHeight() {
          var bbox = this.get('group').getBBox();
          return bbox.height;
        };

        _proto.move = function move(x, y) {
          this.get('group').move(x, y);
        };

        _proto.draw = function draw() {
          this.get('canvas').draw();
        };

        return Legend;
      }(Component);

      module.exports = Legend;
      /***/
    },
    /* 158 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Category = __webpack_require__(156);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var DomUtil = Util.DomUtil;
      var Group = Util.Group;
      var CONTAINER_CLASS = 'g2-legend';
      var TITLE_CLASS = 'g2-legend-title';
      var LIST_CLASS = 'g2-legend-list';
      var ITEM_CLASS = 'g2-legend-list-item';
      var TEXT_CLASS = 'g2-legend-text';
      var MARKER_CLASS = 'g2-legend-marker'; // find a dom node from the chidren of the node with className.

      function findNodeByClass(node, className) {
        return node.getElementsByClassName(className)[0];
      }

      function getParentNode(node, className) {
        var nodeClass = node.className;

        if (Util.isNil(nodeClass)) {
          return node;
        }

        nodeClass = nodeClass.split(' ');

        if (nodeClass.indexOf(className) > -1) {
          return node;
        }

        if (node.parentNode) {
          if (node.parentNode.className === CONTAINER_CLASS) {
            return node.parentNode;
          }

          return getParentNode(node.parentNode, className);
        }

        return null;
      }

      function findItem(items, refer) {
        var rst = null;
        var value = refer instanceof Group ? refer.get('value') : refer;
        Util.each(items, function (item) {
          if (item.value === value) {
            rst = item;
            return false;
          }
        });
        return rst;
      }

      var CatHtml = /*#__PURE__*/function (_Category) {
        _inheritsLoose(CatHtml, _Category);

        function CatHtml() {
          return _Category.apply(this, arguments) || this;
        }

        var _proto = CatHtml.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Category.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * type 标识
             * @type {String}
             */
            type: 'category-legend',

            /**
             * html 容器
             * @type {DOM}
             */
            container: null,

            /**
             * 使用html时的外层模板
             * @type {String}
             */
            containerTpl: '<div class="' + CONTAINER_CLASS + '">' + '<h4 class="' + TITLE_CLASS + '"></h4>' + '<ul class="' + LIST_CLASS + '"></ul>' + '</div>',

            /**
             * html 模板
             * @type {String|Function}
             */
            itemTpl: '<li class="' + ITEM_CLASS + ' item-{index} {checked}" data-color="{originColor}" data-value="{originValue}">' + '<i class="' + MARKER_CLASS + '" style="background-color:{color};"></i>' + '<span class="' + TEXT_CLASS + '">{value}</span></li>',

            /**
             * html style
             * @type {Attrs}
             */
            legendStyle: {},

            /**
             * 图例文字样式
             * @type {ATTRS}
             */
            textStyle: {
              fill: '#333',
              fontSize: 12,
              textAlign: 'middle',
              textBaseline: 'top',
              fontFamily: FONT_FAMILY
            },

            /**
             * 当文本太长时是否进行缩略
             * @type {Boolean}
             */
            abridgeText: false,

            /**
             * abridgeText 为 true 时，鼠标放置在 item 上时显示全称的悬浮 div 的 html 模板
             * @type {String}
             */
            tipTpl: '<div class="textTip"></div>',

            /**
             * abridgeText 为 true 时，鼠标放置在 item 上时显示全称的悬浮 div 的样式
             * @type {Attrs}
             */
            tipStyle: {
              display: 'none',
              fontSize: '12px',
              backgroundColor: '#fff',
              position: 'absolute',
              width: 'auto',
              height: 'auto',
              padding: '3px',
              boxShadow: '2px 2px 5px #888'
            },

            /**
             * useHtml 为 true 时生效，用于自动定位
             * @type {[type]}
             */
            autoPosition: true
          });
        };

        _proto._init = function _init() {
          return;
        };

        _proto.beforeRender = function beforeRender() {
          return;
        };

        _proto.render = function render() {
          this._renderHTML();
        } // user interaction
        ;

        _proto._bindEvents = function _bindEvents() {
          var _this = this;

          var legendWrapper = this.get('legendWrapper');
          var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);

          if (this.get('hoverable')) {
            itemListDom.onmousemove = function (ev) {
              return _this._onMousemove(ev);
            };

            itemListDom.onmouseout = function (ev) {
              return _this._onMouseleave(ev);
            };
          }

          if (this.get('clickable')) {
            itemListDom.onclick = function (ev) {
              return _this._onClick(ev);
            };
          }
        } // mouse move listener of an item
        // when mouse over an item, reduce the opacity of the other items.
        ;

        _proto._onMousemove = function _onMousemove(ev) {
          var items = this.get('items');
          var target = ev.target;
          var targetClass = target.className;
          targetClass = targetClass.split(' ');

          if (targetClass.indexOf(CONTAINER_CLASS) > -1 || targetClass.indexOf(LIST_CLASS) > -1) {
            return;
          }

          var parentDom = getParentNode(target, ITEM_CLASS);
          var hoveredItem = findItem(items, parentDom.getAttribute('data-value'));

          if (hoveredItem) {
            // change the opacity of other items
            this.deactivate();
            this.activate(parentDom.getAttribute('data-value'));
            this.emit('itemhover', {
              item: hoveredItem,
              currentTarget: parentDom,
              checked: hoveredItem.checked
            });
          } else if (!hoveredItem) {
            // restore the opacity of all the items
            this.deactivate();
            this.emit('itemunhover', ev);
          }

          return;
        } // mouse leave listener of an item
        ;

        _proto._onMouseleave = function _onMouseleave(ev) {
          // restore the opacity of all the items when mouse leave
          this.deactivate();
          this.emit('itemunhover', ev);
          return;
        } // the click listener of an item
        ;

        _proto._onClick = function _onClick(ev) {
          var _this2 = this;

          var legendWrapper = this.get('legendWrapper');
          var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
          var unCheckedColor = this.get('unCheckColor');
          var items = this.get('items');
          var mode = this.get('selectedMode');
          var childNodes = itemListDom.childNodes;
          var target = ev.target;
          var targetClass = target.className;
          targetClass = targetClass.split(' ');

          if (targetClass.indexOf(CONTAINER_CLASS) > -1 || targetClass.indexOf(LIST_CLASS) > -1) {
            return;
          }

          var parentDom = getParentNode(target, ITEM_CLASS);
          var textDom = findNodeByClass(parentDom, TEXT_CLASS);
          var markerDom = findNodeByClass(parentDom, MARKER_CLASS);
          var clickedItem = findItem(items, parentDom.getAttribute('data-value'));

          if (!clickedItem) {
            return;
          }

          var domClass = parentDom.className;
          var originColor = parentDom.getAttribute('data-color');

          if (mode === 'single') {
            // 单选模式
            // update checked status
            clickedItem.checked = true; // 其他图例项全部置灰

            Util.each(childNodes, function (child) {
              if (child !== parentDom) {
                var childMarkerDom = findNodeByClass(child, MARKER_CLASS);
                childMarkerDom.style.backgroundColor = unCheckedColor;
                child.className = child.className.replace('checked', 'unChecked');
                child.style.color = unCheckedColor;
                var childItem = findItem(items, child.getAttribute('data-value'));
                childItem.checked = false;
              } else {
                if (textDom) {
                  textDom.style.color = _this2.get('textStyle').fill;
                }

                if (markerDom) {
                  markerDom.style.backgroundColor = originColor;
                }

                parentDom.className = domClass.replace('unChecked', 'checked');
              }
            });
          } else {
            // 混合模式
            var clickedItemChecked = domClass.indexOf('checked') !== -1; // domClass.includes('checked');

            var count = 0;
            Util.each(childNodes, function (child) {
              if (child.className.indexOf('checked') !== -1) {
                // .includes('checked')
                count++;
              }
            });

            if (!this.get('allowAllCanceled') && clickedItemChecked && count === 1) {
              this.emit('clicklastitem', {
                item: clickedItem,
                currentTarget: parentDom,
                checked: mode === 'single' ? true : clickedItem.checked
              });
              return;
            } // 在判断最后一个图例后再更新checked状态，防止点击最后一个图例item时图例样式没有变化但是checked状态改变了 fix #422


            clickedItem.checked = !clickedItem.checked;

            if (clickedItemChecked) {
              if (markerDom) {
                markerDom.style.backgroundColor = unCheckedColor;
              }

              parentDom.className = domClass.replace('checked', 'unChecked');
              parentDom.style.color = unCheckedColor;
            } else {
              if (markerDom) {
                markerDom.style.backgroundColor = originColor;
              }

              parentDom.className = domClass.replace('unChecked', 'checked');
              parentDom.style.color = this.get('textStyle').fill;
            }
          }

          this.emit('itemclick', {
            item: clickedItem,
            currentTarget: parentDom,
            checked: mode === 'single' ? true : clickedItem.checked
          });
          return;
        } // activate an item by reduce the opacity of other items.
        // it is reserved for bi-direction interaction between charts / graph and legend
        ;

        _proto.activate = function activate(value) {
          var _this3 = this;

          var self = this;
          var items = self.get('items');
          var item = findItem(items, value);
          var legendWrapper = self.get('legendWrapper');
          var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
          var childNodes = itemListDom.childNodes;
          childNodes.forEach(function (child) {
            var childMarkerDom = findNodeByClass(child, MARKER_CLASS);
            var childItem = findItem(items, child.getAttribute('data-value'));

            if (_this3.get('highlight')) {
              if (childItem === item && childItem.checked) {
                childMarkerDom.style.border = '1px solid #333';
                return;
              }
            } else {
              if (childItem === item) {
                childMarkerDom.style.opacity = self.get('activeOpacity');
              } else {
                if (childItem.checked) childMarkerDom.style.opacity = self.get('inactiveOpacity');
              }
            } // if (childItem !== item && childItem.checked) {
            //   if (this.get('highlight')) {
            //     childMarkerDom.style.border = '1px solid #fff';
            //   } else childMarkerDom.style.opacity = 0.5;
            // } else {
            //   if (this.get('highlight')) {
            //     childMarkerDom.style.border = '1px solid #333';
            //   } else childMarkerDom.style.opacity = 1;
            // }

          });
          return;
        } // restore the opacity of items
        // it is reserved for bi-direction interaction between charts / graph and legend
        ;

        _proto.deactivate = function deactivate() {
          var _this4 = this;

          var self = this;
          var legendWrapper = self.get('legendWrapper');
          var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
          var childNodes = itemListDom.childNodes;
          childNodes.forEach(function (child) {
            var childMarkerDom = findNodeByClass(child, MARKER_CLASS);

            if (_this4.get('highlight')) {
              childMarkerDom.style.border = '1px solid #fff';
            } else {
              childMarkerDom.style.opacity = self.get('inactiveOpacity');
            }
          });
          return;
        };

        _proto._renderHTML = function _renderHTML() {
          var _this5 = this; // const canvas = this.get('canvas');


          var container = this.get('container'); // const outterNode = container.parentNode;

          var title = this.get('title');
          var containerTpl = this.get('containerTpl');
          var legendWrapper = DomUtil.createDom(containerTpl);
          var titleDom = findNodeByClass(legendWrapper, TITLE_CLASS);
          var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS); // ul

          var unCheckedColor = this.get('unCheckColor');
          var LEGEND_STYLE = Util.deepMix({}, {
            CONTAINER_CLASS: {
              height: 'auto',
              width: 'auto',
              position: 'absolute',
              overflowY: 'auto',
              fontSize: '12px',
              fontFamily: FONT_FAMILY,
              lineHeight: '20px',
              color: '#8C8C8C'
            },
            TITLE_CLASS: {
              marginBottom: this.get('titleGap') + 'px',
              fontSize: '12px',
              color: '#333',
              // 默认样式
              textBaseline: 'middle',
              fontFamily: FONT_FAMILY
            },
            LIST_CLASS: {
              listStyleType: 'none',
              margin: 0,
              padding: 0,
              textAlign: 'center'
            },
            LIST_ITEM_CLASS: {
              cursor: 'pointer',
              marginBottom: '5px',
              marginRight: '24px'
            },
            MARKER_CLASS: {
              width: '9px',
              height: '9px',
              borderRadius: '50%',
              display: 'inline-block',
              marginRight: '4px',
              verticalAlign: 'middle'
            }
          }, this.get('legendStyle')); // fix：IE 9 兼容问题，先加入 legendWrapper
          // let container = this.get('container');

          if (/^\#/.test(container) || typeof container === 'string' && container.constructor === String) {
            // 如果传入 dom 节点的 id
            var id = container.replace('#', '');
            container = document.getElementById(id);
            container.appendChild(legendWrapper);
          } else {
            var _position = this.get('position');

            var rangeStyle = {};

            if (_position === 'left' || _position === 'right') {
              rangeStyle = {
                maxHeight: (this.get('maxLength') || container.offsetHeight) + 'px'
              };
            } else {
              rangeStyle = {
                maxWidth: (this.get('maxLength') || container.offsetWidth) + 'px'
              };
            }

            DomUtil.modifyCSS(legendWrapper, Util.mix({}, LEGEND_STYLE.CONTAINER_CLASS, rangeStyle, this.get(CONTAINER_CLASS)));
            container.appendChild(legendWrapper);
          }

          DomUtil.modifyCSS(itemListDom, Util.mix({}, LEGEND_STYLE.LIST_CLASS, this.get(LIST_CLASS))); // render title

          if (titleDom) {
            if (title && title.text) {
              titleDom.innerHTML = title.text;
              DomUtil.modifyCSS(titleDom, Util.mix({}, LEGEND_STYLE.TITLE_CLASS, this.get(TITLE_CLASS), title));
            } else {
              legendWrapper.removeChild(titleDom);
            }
          } // 开始渲染图例项


          var items = this.get('items');
          var itemTpl = this.get('itemTpl');
          var position = this.get('position');
          var layout = this.get('layout');
          var itemDisplay = position === 'right' || position === 'left' || layout === 'vertical' ? 'block' : 'inline-block';
          var itemStyle = Util.mix({}, LEGEND_STYLE.LIST_ITEM_CLASS, {
            display: itemDisplay
          }, this.get(ITEM_CLASS));
          var markerStyle = Util.mix({}, LEGEND_STYLE.MARKER_CLASS, this.get(MARKER_CLASS));
          Util.each(items, function (item, index) {
            var checked = item.checked;

            var value = _this5._formatItemValue(item.value);

            var markerColor = item.marker.fill || item.marker.stroke;
            var color = checked ? markerColor : unCheckedColor;
            var domStr;

            if (Util.isFunction(itemTpl)) {
              domStr = itemTpl(value, color, checked, index);
            } else {
              domStr = itemTpl;
            }

            var itemDiv = Util.substitute(domStr, Util.mix({}, item, {
              index: index,
              checked: checked ? 'checked' : 'unChecked',
              value: value,
              color: color,
              originColor: markerColor,
              // @2018-07-09 by blue.lb 修复如果legend值中存在双引号"时, 导致的无法点击触发legend正常操作bug
              originValue: item.value.replace(/\"/g, '&quot;')
            })); // li

            var itemDom = DomUtil.createDom(itemDiv);
            itemDom.style.color = _this5.get('textStyle').fill;
            var markerDom = findNodeByClass(itemDom, MARKER_CLASS);
            var textDom = findNodeByClass(itemDom, TEXT_CLASS);
            DomUtil.modifyCSS(itemDom, itemStyle);
            markerDom && DomUtil.modifyCSS(markerDom, markerStyle); // textDom && DomUtil.modifyCSS(textDom, this.get('textStyle'));

            if (!checked) {
              itemDom.style.color = unCheckedColor;

              if (markerDom) {
                markerDom.style.backgroundColor = unCheckedColor;
              }
            }

            itemListDom.appendChild(itemDom); // abridge the text if the width of the text exceeds the width of the item

            if (_this5.get('abridgeText')) {
              var text = value; // const itemWidth = parseFloat(this.get(ITEM_CLASS).width.substr(0, this.get(ITEM_CLASS).width.length - 2));

              var itemWidth = itemDom.offsetWidth;

              var fs = _this5.get('textStyle').fontSize;

              if (isNaN(fs)) {
                // 6.5pt = 6.5 * 1/72 * 96 = 8.6px
                if (fs.indexOf('pt') !== -1) fs = parseFloat(fs.substr(0, fs.length - 2)) * 1 / 72 * 96;else if (fs.indexOf('px') !== -1) fs = parseFloat(fs.substr(0, fs.length - 2));
              }

              var textWidth = fs * text.length;
              var letterNum = Math.floor(itemWidth / fs);

              if (itemWidth < 2 * fs) {
                // unable to contain '...'
                text = '';
              } else if (itemWidth < textWidth) {
                // replace the tail as '...
                if (letterNum > 1) text = text.substr(0, letterNum - 1) + '...';
              }

              textDom.innerText = text; // show the text tip while mouse hovering an item

              itemDom.addEventListener('mouseover', function () {
                var tipDom = findNodeByClass(legendWrapper.parentNode, 'textTip');
                tipDom.style.display = 'block';
                tipDom.style.left = itemDom.offsetLeft + itemDom.offsetWidth + 'px';
                tipDom.style.top = itemDom.offsetTop + 15 + 'px';
                tipDom.innerText = value;
              }); // hide the text tip while mouse leave the item

              itemDom.addEventListener('mouseout', function () {
                var tipDom = findNodeByClass(legendWrapper.parentNode, 'textTip');
                tipDom.style.display = 'none';
              });
            }
          }); // append the tip div as a brother node of legend dom

          if (this.get('abridgeText')) {
            var tipTpl = this.get('tipTpl');
            var tipDom = DomUtil.createDom(tipTpl);
            var tipDomStyle = this.get('tipStyle');
            DomUtil.modifyCSS(tipDom, tipDomStyle);
            legendWrapper.parentNode.appendChild(tipDom); // hide the tip while mouse entering the tip dom

            tipDom.addEventListener('mouseover', function () {
              tipDom.style.display = 'none';
            });
          }

          this.set('legendWrapper', legendWrapper);
        };

        _proto._adjustPositionOffset = function _adjustPositionOffset() {
          var autoPosition = this.get('autoPosition'); // @2018-12-29 by maplor. if autoPosition is false, don't set inline-style

          if (autoPosition === false) {
            return;
          }

          var position = this.get('position');
          var offset = this.get('offset');
          var offsetX = this.get('offsetX');
          var offsetY = this.get('offsetY');
          if (offsetX) offset[0] = offsetX;
          if (offsetY) offset[1] = offsetY;
          var legendWrapper = this.get('legendWrapper');
          legendWrapper.style.left = position[0] + 'px';
          legendWrapper.style.top = position[1] + 'px';
          legendWrapper.style.marginLeft = offset[0] + 'px';
          legendWrapper.style.marginTop = offset[1] + 'px';
        };

        _proto.getWidth = function getWidth() {
          return DomUtil.getOuterWidth(this.get('legendWrapper'));
        };

        _proto.getHeight = function getHeight() {
          return DomUtil.getOuterHeight(this.get('legendWrapper'));
        };

        _proto.move = function move(x, y) {
          if (!/^\#/.test(this.get('container'))) {
            DomUtil.modifyCSS(this.get('legendWrapper'), {
              left: x + 'px',
              top: y + 'px'
            });
            this.set('x', x);
            this.set('y', y);
          } else {
            _Category.prototype.move.call(this, x, y);
          }
        };

        _proto.destroy = function destroy() {
          var legendWrapper = this.get('legendWrapper');

          if (legendWrapper && legendWrapper.parentNode) {
            legendWrapper.parentNode.removeChild(legendWrapper);
          }

          _Category.prototype.destroy.call(this);
        };

        return CatHtml;
      }(Category);

      module.exports = CatHtml;
      /***/
    },
    /* 159 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Component = __webpack_require__(32);

      var Util = __webpack_require__(3);

      var Crosshair = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Crosshair, _Component);

        var _proto = Crosshair.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Component.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
              * crosshair的类型
              * @type {String}
              */
            type: null,

            /**
             * 画在哪层视图
             * @type {G-Element}
             */
            plot: null,

            /**
             * x轴上，移动到位置的偏移量
             * @type {Number}
             */
            plotRange: null,

            /**
             * 默认rect crosshair样式
             * @type {Object}
             */
            rectStyle: {
              fill: '#CCD6EC',
              opacity: 0.3
            },

            /**
              * 默认line crosshair样式
              * @type {Object}
              */
            lineStyle: {
              stroke: 'rgba(0, 0, 0, 0.25)',
              lineWidth: 1
            },
            isTransposed: false
          });
        };

        function Crosshair(cfg) {
          var _this;

          _this = _Component.call(this, cfg) || this;

          _this._init_();

          _this.render();

          return _this;
        }

        _proto._init_ = function _init_() {
          var self = this;
          var plot = self.get('plot');
          var group;

          if (self.type === 'rect') {
            group = plot.addGroup({
              zIndex: 0
            });
          } else {
            group = plot.addGroup();
          }

          this.set('container', group);
        };

        _proto._addLineShape = function _addLineShape(attrs, type) {
          var container = this.get('container');
          var shape = container.addShape('line', {
            capture: false,
            attrs: attrs
          }); // shape.hide();

          this.set('crossLineShape' + type, shape);
          return shape;
        };

        _proto._renderHorizontalLine = function _renderHorizontalLine(canvas, plotRange) {
          var style = Util.mix(this.get('lineStyle'), this.get('style'));
          var attrs = Util.mix({
            x1: plotRange ? plotRange.bl.x : canvas.get('width'),
            y1: 0,
            x2: plotRange ? plotRange.br.x : 0,
            y2: 0
          }, style);

          this._addLineShape(attrs, 'X');
        };

        _proto._renderVerticalLine = function _renderVerticalLine(canvas, plotRange) {
          var style = Util.mix(this.get('lineStyle'), this.get('style'));
          var attrs = Util.mix({
            x1: 0,
            y1: plotRange ? plotRange.bl.y : canvas.get('height'),
            x2: 0,
            y2: plotRange ? plotRange.tl.y : 0
          }, style);

          this._addLineShape(attrs, 'Y');
        };

        _proto._renderBackground = function _renderBackground(canvas, plotRange) {
          var style = Util.mix(this.get('rectStyle'), this.get('style'));
          var container = this.get('container');
          var attrs = Util.mix({
            x: plotRange ? plotRange.tl.x : 0,
            y: plotRange ? plotRange.tl.y : canvas.get('height'),
            width: plotRange ? plotRange.br.x - plotRange.bl.x : canvas.get('width'),
            height: plotRange ? Math.abs(plotRange.tl.y - plotRange.bl.y) : canvas.get('height')
          }, style);
          var shape = container.addShape('rect', {
            attrs: attrs,
            capture: false
          }); // shape.hide();

          this.set('crosshairsRectShape', shape);
          return shape;
        };

        _proto._updateRectShape = function _updateRectShape(items) {
          var offset;
          var crosshairsRectShape = this.get('crosshairsRectShape');
          var isTransposed = this.get('isTransposed');
          var firstItem = items[0];
          var lastItem = items[items.length - 1];
          var dim = isTransposed ? 'y' : 'x';
          var attr = isTransposed ? 'height' : 'width';
          var startDim = firstItem[dim];

          if (items.length > 1 && firstItem[dim] > lastItem[dim]) {
            startDim = lastItem[dim];
          }

          if (this.get('width')) {
            // 用户定义了 width
            crosshairsRectShape.attr(dim, startDim - this.get('crosshairs').width / 2);
            crosshairsRectShape.attr(attr, this.get('width'));
          } else {
            if (Util.isArray(firstItem.point[dim]) && !firstItem.size) {
              // 直方图
              var width = firstItem.point[dim][1] - firstItem.point[dim][0];
              crosshairsRectShape.attr(dim, firstItem.point[dim][0]);
              crosshairsRectShape.attr(attr, width);
            } else {
              offset = 3 * firstItem.size / 4;
              crosshairsRectShape.attr(dim, startDim - offset);

              if (items.length === 1) {
                crosshairsRectShape.attr(attr, 3 * firstItem.size / 2);
              } else {
                crosshairsRectShape.attr(attr, Math.abs(lastItem[dim] - firstItem[dim]) + 2 * offset);
              }
            }
          }
        };

        _proto.render = function render() {
          var canvas = this.get('canvas');
          var plotRange = this.get('plotRange');
          var isTransposed = this.get('isTransposed');
          this.clear();

          switch (this.get('type')) {
            case 'x':
              this._renderHorizontalLine(canvas, plotRange);

              break;

            case 'y':
              this._renderVerticalLine(canvas, plotRange);

              break;

            case 'cross':
              this._renderHorizontalLine(canvas, plotRange);

              this._renderVerticalLine(canvas, plotRange);

              break;

            case 'rect':
              this._renderBackground(canvas, plotRange);

              break;

            default:
              isTransposed ? this._renderHorizontalLine(canvas, plotRange) : this._renderVerticalLine(canvas, plotRange);
          }
        };

        _proto.show = function show() {
          var container = this.get('container');

          _Component.prototype.show.call(this);

          container.show();
        };

        _proto.hide = function hide() {
          var container = this.get('container');

          _Component.prototype.hide.call(this);

          container.hide();
        };

        _proto.clear = function clear() {
          var container = this.get('container');
          this.set('crossLineShapeX', null);
          this.set('crossLineShapeY', null);
          this.set('crosshairsRectShape', null);

          _Component.prototype.clear.call(this);

          container.clear();
        };

        _proto.destroy = function destroy() {
          var container = this.get('container');

          _Component.prototype.destroy.call(this);

          container.remove();
        };

        _proto.setPosition = function setPosition(x, y, items) {
          var crossLineShapeX = this.get('crossLineShapeX');
          var crossLineShapeY = this.get('crossLineShapeY');
          var crosshairsRectShape = this.get('crosshairsRectShape');

          if (crossLineShapeY && !crossLineShapeY.get('destroyed')) {
            // 第一次进入时，画布需要单独绘制，所以需要先设定corss的位置
            crossLineShapeY.move(x, 0);
          }

          if (crossLineShapeX && !crossLineShapeX.get('destroyed')) {
            crossLineShapeX.move(0, y);
          }

          if (crosshairsRectShape && !crosshairsRectShape.get('destroyed')) {
            this._updateRectShape(items);
          }
        };

        return Crosshair;
      }(Component);

      module.exports = Crosshair;
      /***/
    },
    /* 160 */

    /***/
    function (module, exports) {
      var GAP = 20;
      var PositionMixin = {
        _calcTooltipPosition: function _calcTooltipPosition(x, y, position, containerWidth, containerHeight, target) {
          var rectWidth = 0;
          var rectHeight = 0;
          var gap = 20;

          if (target) {
            var rect = target.getBBox();
            rectWidth = rect.width;
            rectHeight = rect.height;
            x = rect.x;
            y = rect.y;
            gap = 5;
          }

          switch (position) {
            case 'inside':
              x = x + rectWidth / 2 - containerWidth / 2;
              y = y + rectHeight / 2 - containerHeight / 2;
              break;

            case 'top':
              x = x + rectWidth / 2 - containerWidth / 2;
              y = y - containerHeight - gap;
              break;

            case 'left':
              x = x - containerWidth - gap;
              y = y + rectHeight / 2 - containerHeight / 2;
              break;

            case 'right':
              x = x + rectWidth + gap;
              y = y + rectHeight / 2 - containerHeight / 2;
              break;

            case 'bottom':
            default:
              x = x + rectWidth / 2 - containerWidth / 2;
              y = y + rectHeight + gap;
              break;
          }

          return [x, y];
        },
        _constraintPositionInBoundary: function _constraintPositionInBoundary(x, y, width, height, viewWidth, viewHeight) {
          if (x + width + GAP > viewWidth) {
            x -= width + GAP;
            x = x < 0 ? 0 : x;
          } else if (x + GAP < 0) {
            x = GAP;
          } else {
            x += GAP;
          }

          if (y + height + GAP > viewHeight) {
            y -= height + GAP;
            y = y < 0 ? 0 : y;
          } else if (y + GAP < 0) {
            y = GAP;
          } else {
            y += GAP;
          }

          return [x, y];
        },
        _constraintPositionInPlot: function _constraintPositionInPlot(x, y, width, height, plotRange, enterable) {
          if (x + width > plotRange.tr.x) {
            if (enterable) {
              // fix: https://github.com/antvis/g2/issues/1414
              // 当 enterable 开启时，如果设置 tooltip 与鼠标的间距过大根本就追逐不上 tooltip
              x -= width + 1;
            } else {
              x -= width + 2 * GAP;
            }
          }

          if (x < plotRange.tl.x) {
            x = plotRange.tl.x;
          }

          if (!enterable) {
            if (y + height > plotRange.bl.y) {
              y -= height + 2 * GAP;
            }

            if (y < plotRange.tl.y) {
              y = plotRange.tl.y;
            }
          }

          return [x, y];
        }
      };
      module.exports = PositionMixin;
      /***/
    },
    /* 161 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(3);

      var MarkerGroupMixin = {
        setMarkers: function setMarkers(markerItems, markerCfg) {
          var self = this;
          var markerGroup = self.get('markerGroup');
          var frontPlot = self.get('frontPlot');

          if (!markerGroup) {
            markerGroup = frontPlot.addGroup({
              zIndex: 1,
              capture: false // 不进行拾取

            });
            self.set('markerGroup', markerGroup);
          } else {
            markerGroup.clear();
          }

          Util.each(markerItems, function (item) {
            var attrs = Util.mix({
              fill: item.color,
              symbol: 'circle',
              shadowColor: item.color
            }, markerCfg, {
              x: item.x,
              y: item.y
            });

            if (item.marker && item.marker.activeSymbol) {
              attrs.symbol = item.marker.activeSymbol;
            }

            markerGroup.addShape('marker', {
              color: item.color,
              attrs: attrs
            });
          });
          this.set('markerItems', markerItems);
        },
        clearMarkers: function clearMarkers() {
          var markerGroup = this.get('markerGroup');
          markerGroup && markerGroup.clear();
        }
      };
      module.exports = MarkerGroupMixin;
      /***/
    },
    /* 162 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var G = __webpack_require__(20);

      var Crosshair = __webpack_require__(159);

      var MarkerGroupMixin = __webpack_require__(161);

      var PositionMixin = __webpack_require__(160);

      var Tooltip = __webpack_require__(69);

      var Util = __webpack_require__(3);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var DomUtil = Util.DomUtil;
      var MatrixUtil = Util.MatrixUtil;

      var CanvasTooltip = /*#__PURE__*/function (_Tooltip) {
        _inheritsLoose(CanvasTooltip, _Tooltip);

        var _proto = CanvasTooltip.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Tooltip.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 默认背景板样式
             * @type {Object}
             */
            boardStyle: {
              x: 0,
              y: 0,
              width: 100,
              height: 100,
              fill: 'rgba(255, 255, 255, 0.9)',
              radius: 4,
              stroke: '#e2e2e2',
              lineWidth: 1
            },

            /**
             * 默认title样式
             * @type {Object}
             */
            titleStyle: {
              fontFamily: FONT_FAMILY,
              text: '',
              textBaseline: 'top',
              fontSize: 12,
              fill: 'rgb(87, 87, 87)',
              lineHeight: 20,
              padding: 20
            },

            /**
             * 默认marker样式
             * @type {Object}
             */
            markerStyle: {
              radius: 4
            },

            /**
             * 默认name样式
             * @type {Object}
             */
            nameStyle: {
              fontFamily: FONT_FAMILY,
              fontSize: 12,
              fill: 'rgb(87, 87, 87)',
              textBaseline: 'middle',
              textAlign: 'start',
              padding: 8
            },

            /**
             * 默认value样式
             * @type {Object}
             */
            valueStyle: {
              fontFamily: FONT_FAMILY,
              fontSize: 12,
              fill: 'rgb(87, 87, 87)',
              textBaseline: 'middle',
              textAlign: 'start',
              padding: 30
            },

            /**
             * 默认padding值
             * @type {Object}
             */
            padding: {
              top: 20,
              right: 20,
              bottom: 20,
              left: 20
            },

            /**
             * 默认item之间的gap
             * @type {Number}
             */
            itemGap: 10,

            /**
             * 默认tooltip位置移动动画的时长
             * @type {Number}
             */
            animationDuration: 200
          });
        };

        function CanvasTooltip(cfg) {
          var _this;

          _this = _Tooltip.call(this, cfg) || this;
          Util.assign(_assertThisInitialized(_this), PositionMixin);
          Util.assign(_assertThisInitialized(_this), MarkerGroupMixin); // crosshair

          var crosshair = _this.get('crosshairs');

          if (crosshair) {
            var plot = crosshair.type === 'rect' ? _this.get('backPlot') : _this.get('frontPlot');
            var crosshairGroup = new Crosshair(Util.mix({
              plot: plot,
              plotRange: _this.get('plotRange'),
              canvas: _this.get('canvas')
            }, _this.get('crosshairs')));
            crosshairGroup.hide();

            _this.set('crosshairGroup', crosshairGroup);
          }

          _this._init_();

          if (_this.get('items')) {
            _this.render();
          }

          return _this;
        }

        _proto._init_ = function _init_() {
          var self = this;
          var padding = self.get('padding');
          var parent = self.get('frontPlot'); // marker group

          var markerGroup = parent.addGroup({
            capture: false
          });
          self.set('markerGroup', markerGroup); // container

          var container = parent.addGroup();
          container.hide();
          self.set('container', container); // board

          var board = container.addShape('rect', {
            attrs: Util.mix({}, self.get('boardStyle'))
          });
          self.set('board', board); // title

          var titleStyle = self.get('titleStyle');

          if (self.get('showTitle')) {
            var titleShape = container.addShape('text', {
              attrs: Util.mix({
                x: padding.left,
                y: padding.top
              }, titleStyle)
            });
            self.set('titleShape', titleShape);
            titleShape.name = 'tooltip-title';
          } // items


          var itemsGroup = container.addGroup();
          itemsGroup.move(padding.left, padding.top + titleStyle.lineHeight + titleStyle.padding);
          self.set('itemsGroup', itemsGroup);
        };

        _proto.render = function render() {
          var self = this;
          self.clear();
          var container = self.get('container');
          var board = self.get('board');
          var showTitle = self.get('showTitle');
          var titleContent = self.get('titleContent');
          var titleShape = this.get('titleShape');
          var itemsGroup = this.get('itemsGroup');
          var items = self.get('items');
          var padding = self.get('padding');

          if (titleShape && showTitle) {
            titleShape.attr('text', titleContent);
          }

          if (itemsGroup) {
            var itemGap = self.get('itemGap');
            var x = 0;
            var y = 0;
            Util.each(items, function (item) {
              var itemGroup = self._addItem(item);

              itemGroup.move(x, y);
              itemsGroup.add(itemGroup);
              var itemHeight = itemGroup.getBBox().height;
              y += itemHeight + itemGap;
            });
          } // update board based on bbox


          var bbox = container.getBBox();
          var width = bbox.width + padding.right;
          var height = bbox.height + padding.bottom;
          board.attr('width', width);
          board.attr('height', height); // align value text to right

          self._alignToRight(width);
        };

        _proto.clear = function clear() {
          var titleShape = this.get('titleShape');
          var itemsGroup = this.get('itemsGroup');
          var board = this.get('board');
          titleShape.text = '';
          itemsGroup.clear();
          board.attr('width', 0);
          board.attr('height', 0);
        };

        _proto.show = function show() {
          var container = this.get('container');
          container.show();
          var crosshairGroup = this.get('crosshairGroup');
          crosshairGroup && crosshairGroup.show();
          var markerGroup = this.get('markerGroup');
          markerGroup && markerGroup.show();

          _Tooltip.prototype.show.call(this);

          this.get('canvas').draw();
        };

        _proto.hide = function hide() {
          var container = this.get('container');
          container.hide();
          var crosshairGroup = this.get('crosshairGroup');
          crosshairGroup && crosshairGroup.hide();
          var markerGroup = this.get('markerGroup');
          markerGroup && markerGroup.hide();

          _Tooltip.prototype.hide.call(this);

          this.get('canvas').draw();
        };

        _proto.destroy = function destroy() {
          var container = this.get('container');
          var crosshairGroup = this.get('crosshairGroup');
          crosshairGroup && crosshairGroup.destroy();
          var markerGroup = this.get('markerGroup');
          markerGroup && markerGroup.remove();

          _Tooltip.prototype.destroy.call(this);

          container.remove();
        };

        _proto.setPosition = function setPosition(x, y, target) {
          var container = this.get('container');
          var outterNode = this.get('canvas').get('el');
          var viewWidth = DomUtil.getWidth(outterNode);
          var viewHeight = DomUtil.getHeight(outterNode);
          var bbox = container.getBBox();
          var containerWidth = bbox.width;
          var containerHeight = bbox.height;
          var endx = x;
          var endy = y;
          var position;

          if (this.get('position')) {
            var _containerWidth = bbox.width;
            var _containerHeight = bbox.height;
            position = this._calcTooltipPosition(x, y, this.get('position'), _containerWidth, _containerHeight, target);
            x = position[0];
            y = position[1];
          } else {
            position = this._constraintPositionInBoundary(x, y, containerWidth, containerHeight, viewWidth, viewHeight);
            x = position[0];
            y = position[1];
          }

          if (this.get('inPlot')) {
            // tooltip 必须限制在绘图区域内
            var plotRange = this.get('plotRange');
            position = this._constraintPositionInPlot(x, y, containerWidth, containerHeight, plotRange, this.get('enterable'));
            x = position[0];
            y = position[1];
          }

          var markerItems = this.get('markerItems');

          if (!Util.isEmpty(markerItems)) {
            endx = markerItems[0].x;
            endy = markerItems[0].y;
          }

          var ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          var mat = MatrixUtil.transform(ulMatrix, [['t', x, y]]);
          container.stopAnimate();
          container.animate({
            matrix: mat
          }, this.get('animationDuration'));
          var crosshairGroup = this.get('crosshairGroup');

          if (crosshairGroup) {
            var items = this.get('items');
            crosshairGroup.setPosition(endx, endy, items);
          }

          _Tooltip.prototype.setPosition.call(this, x, y);
        };

        _proto._addItem = function _addItem(item) {
          var group = new G.Group();
          var markerRadius = this.get('markerStyle').radius; // marker

          if (item.marker) {
            var markerAttrs = Util.mix({}, item.marker, {
              x: item.marker.radius / 2,
              y: 0,
              symbol: item.marker.activeSymbol || item.marker.symbol
            });
            group.addShape('marker', {
              attrs: markerAttrs
            });
            markerRadius = item.marker.radius;
          } // name


          var nameStyle = this.get('nameStyle');
          group.addShape('text', {
            attrs: Util.mix({
              x: markerRadius + nameStyle.padding,
              y: 0,
              text: item.name
            }, nameStyle)
          }); // value

          var valueStyle = this.get('valueStyle');
          group.addShape('text', {
            attrs: Util.mix({
              x: group.getBBox().width + valueStyle.padding,
              y: 0,
              text: item.value
            }, valueStyle)
          });
          return group;
        };

        _proto._alignToRight = function _alignToRight(width) {
          var _this2 = this;

          var itemsGroup = this.get('itemsGroup');
          var groups = itemsGroup.get('children');
          Util.each(groups, function (g) {
            var children = g.get('children');
            var valueText = children[2];
            var w = valueText.getBBox().width;
            var x = width - w - _this2.get('padding').right * 2;
            valueText.attr('x', x);
          });
        };

        return CanvasTooltip;
      }(Tooltip);

      module.exports = CanvasTooltip;
      /***/
    },
    /* 163 */

    /***/
    function (module, exports, __webpack_require__) {
      var Labels = __webpack_require__(66);

      var PathUtil = __webpack_require__(23);

      var Util = __webpack_require__(0);

      var PolarLabels = function PolarLabels(cfg) {
        PolarLabels.superclass.constructor.call(this, cfg);
      };

      Util.extend(PolarLabels, Labels);
      Util.augment(PolarLabels, {
        getPointRauis: function getPointRauis(coord, point) {
          return PathUtil.getPointRadius(coord, point);
        },
        getCirclePoint: function getCirclePoint(angle, offset, point) {
          var self = this;
          var coord = self.get('coord');
          var center = coord.getCenter();

          var labelEmit = self._isEmitLabels();

          var r = self.getPointRauis(coord, point);

          if (r === 0) {
            return null;
          }

          if (coord.isTransposed && r > offset && !labelEmit) {
            var appendAngle = Math.asin(offset / (2 * r));
            angle = angle + appendAngle * 2;
          } else {
            r = r + offset;
          }

          return {
            x: center.x + r * Math.cos(angle),
            y: center.y + r * Math.sin(angle),
            angle: angle,
            r: r
          };
        },
        getArcPoint: function getArcPoint(point, index) {
          var self = this;
          var outerPoint; // 圆弧上的中点
          // var coord = self.get('coord');

          index = index || 0;

          if (Util.isArray(point.x) || Util.isArray(point.y)) {
            outerPoint = {
              x: Util.isArray(point.x) ? point.x[index] : point.x,
              y: Util.isArray(point.y) ? point.y[index] : point.y
            };
          } else {
            outerPoint = point;
          }

          self.transLabelPoint(outerPoint);
          return outerPoint;
        },
        // 获取点所在的角度
        getPointAngle: function getPointAngle(point) {
          var self = this;
          var coord = self.get('coord');
          return PathUtil.getPointAngle(coord, point);
        },
        // 获取中心的位置
        getMiddlePoint: function getMiddlePoint(points) {
          var self = this;
          var coord = self.get('coord');
          var count = points.length;
          var middlePoint = {
            x: 0,
            y: 0
          };
          Util.each(points, function (point) {
            middlePoint.x += point.x;
            middlePoint.y += point.y;
          });
          middlePoint.x /= count;
          middlePoint.y /= count;
          middlePoint = coord.convert(middlePoint);
          return middlePoint;
        },
        // 是否居中
        _isToMiddle: function _isToMiddle(point) {
          return point.x.length > 2;
        },

        /**
         * @protected
         * 获取文本的位置信息
         * @param {Array} label labels
         * @param {Object} point point
         * @param {Number} index index
         * @return {Object} point
         */
        getLabelPoint: function getLabelPoint(label, point, index) {
          // if (Util.isNil(point.x)) return;
          var self = this;
          var text = label.text[index];
          var factor = 1;
          var arcPoint;

          if (self._isToMiddle(point)) {
            arcPoint = self.getMiddlePoint(point.points);
          } else {
            if (label.text.length === 1 && index === 0) {
              index = 1;
            } else if (index === 0) {
              factor = -1;
            }

            arcPoint = self.getArcPoint(point, index);
          }

          var offset = self.getDefaultOffset(label);
          offset = offset * factor;
          var middleAngle = self.getPointAngle(arcPoint);
          var labelPoint = self.getCirclePoint(middleAngle, offset, arcPoint);

          if (!labelPoint) {
            labelPoint = {
              text: ''
            };
          } else {
            labelPoint.text = text;
            labelPoint.angle = middleAngle;
            labelPoint.color = point.color;
          }

          if (label.autoRotate || typeof label.autoRotate === 'undefined') {
            var rotate = labelPoint.textStyle ? labelPoint.textStyle.rotate : null;

            if (!rotate) {
              rotate = labelPoint.rotate || self.getLabelRotate(middleAngle, offset, point);
            }

            labelPoint.rotate = rotate;
          }

          labelPoint.start = {
            x: arcPoint.x,
            y: arcPoint.y
          };
          return labelPoint;
        },
        _isEmitLabels: function _isEmitLabels() {
          var labels = this.get('label');
          return labels.labelEmit;
        },

        /**
         * @protected
         * 获取文本旋转的方向
         * @param {Number} angle angle
         * @return {Number} angle
         */
        getLabelRotate: function getLabelRotate(angle) {
          var self = this;
          var rotate;
          rotate = angle * 180 / Math.PI;
          rotate += 90;

          if (self._isEmitLabels()) {
            rotate -= 90;
          }

          if (rotate) {
            if (rotate > 90) {
              rotate = rotate - 180;
            } else if (rotate < -90) {
              rotate = rotate + 180;
            }
          }

          return rotate / 180 * Math.PI;
        },
        // override
        getLabelAlign: function getLabelAlign(point) {
          var self = this;
          var coord = self.get('coord');
          var align;

          if (self._isEmitLabels()) {
            if (point.angle <= Math.PI / 2 && point.angle > -Math.PI / 2) {
              align = 'left';
            } else {
              align = 'right';
            }
          } else if (!coord.isTransposed) {
            align = 'center';
          } else {
            var center = coord.getCenter();
            var offset = self.getDefaultOffset(point);

            if (Math.abs(point.x - center.x) < 1) {
              align = 'center';
            } else if (point.angle > Math.PI || point.angle <= 0) {
              if (offset > 0) {
                align = 'left';
              } else {
                align = 'right';
              }
            } else {
              if (offset > 0) {
                align = 'right';
              } else {
                align = 'left';
              }
            }
          }

          return align;
        }
      });
      module.exports = PolarLabels;
      /***/
    },
    /* 164 */

    /***/
    function (module, exports) {
      module.exports = {
        toFront: function toFront(shape) {
          var parent = shape.get('parent');
          var originIndex = parent.get('children').indexOf(shape);
          shape.set('_originIndex', originIndex);
          shape.toFront(); // 移动到最上面
        },
        resetZIndex: function resetZIndex(shape) {
          var parent = shape.get('parent');
          var originIndex = shape.get('_originIndex');
          var siblings = parent.get('children');
          var currentIndex = siblings.indexOf(shape);

          if (originIndex >= 0 && originIndex !== currentIndex) {
            siblings.splice(currentIndex, 1); // 从数组中移除

            siblings.splice(originIndex, 0, shape); // 重新加入数组，返回原先的位置
          }
        }
      };
      /***/
    },
    /* 165 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        Scale: __webpack_require__(343),
        Coord: __webpack_require__(344),
        Axis: __webpack_require__(349),
        Guide: __webpack_require__(350),
        Legend: __webpack_require__(353),
        Tooltip: __webpack_require__(355),
        Event: __webpack_require__(356)
      };
      /***/
    },
    /* 166 */

    /***/
    function (module, exports, __webpack_require__) {
      var G = __webpack_require__(16);

      var Util = __webpack_require__(0);

      var mergeBBox = __webpack_require__(167);

      function applyMatrix(point, matrix, tag) {
        if (tag === void 0) {
          tag = 1;
        }

        var vector = [point.x, point.y, tag];
        Util.vec3.transformMat3(vector, vector, matrix);
        return {
          x: vector[0],
          y: vector[1]
        };
      }

      function getTitleBBox(title) {
        var bbox = title.getBBox();
        var leftTop = {
          x: bbox.minX,
          y: bbox.minY
        };
        var rightBottom = {
          x: bbox.maxX,
          y: bbox.maxY
        };
        var matrix = title.attr('matrix');
        leftTop = applyMatrix(leftTop, matrix);
        rightBottom = applyMatrix(rightBottom, matrix);
        return {
          minX: leftTop.x,
          minY: leftTop.y,
          maxX: rightBottom.x,
          maxY: rightBottom.y
        };
      }

      module.exports = function BBoxOfBackPlot(backPlot, defaultBBox) {
        var bbox = defaultBBox;
        Util.each(backPlot.get('children'), function (group) {
          // 这段代码假设了子元素是 axis，同时 title 超出长度，
          // 这种临时代码需要在 4.0 中修复掉
          if (group instanceof G.Group) {
            Util.each(group.get('children'), function (element) {
              if (element instanceof G.Group && element.get('children').length || element instanceof G.Path) {
                bbox = mergeBBox(bbox, element.getBBox());
              } else if (element instanceof G.Text) {
                // title
                var elementBBox = getTitleBBox(element);
                bbox = mergeBBox(bbox, elementBBox);
              }
            });
          }
        });
        return bbox;
      };
      /***/

    },
    /* 167 */

    /***/
    function (module, exports) {
      module.exports = function mergeBBox(box1, box2) {
        return {
          minX: Math.min(box1.minX, box2.minX),
          minY: Math.min(box1.minY, box2.minY),
          maxX: Math.max(box1.maxX, box2.maxX),
          maxY: Math.max(box1.maxY, box2.maxY)
        };
      };
      /***/

    },
    /* 168 */

    /***/
    function (module, exports) {
      module.exports = function plotRange2BBox(plotRange) {
        return {
          minX: plotRange.tl.x,
          minY: plotRange.tl.y,
          maxX: plotRange.br.x,
          maxY: plotRange.br.y
        };
      };
      /***/

    },
    /* 169 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = Transition;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = transition;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = newId;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__attr_js__ = __webpack_require__(456);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__attrTween_js__ = __webpack_require__(470);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__delay_js__ = __webpack_require__(471);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__duration_js__ = __webpack_require__(472);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__ease_js__ = __webpack_require__(473);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__filter_js__ = __webpack_require__(474);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__merge_js__ = __webpack_require__(475);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__on_js__ = __webpack_require__(476);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__remove_js__ = __webpack_require__(477);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_10__select_js__ = __webpack_require__(478);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_11__selectAll_js__ = __webpack_require__(479);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_12__selection_js__ = __webpack_require__(480);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_13__style_js__ = __webpack_require__(481);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_14__styleTween_js__ = __webpack_require__(482);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_15__text_js__ = __webpack_require__(483);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_16__textTween_js__ = __webpack_require__(484);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_17__transition_js__ = __webpack_require__(485);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_18__tween_js__ = __webpack_require__(365);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_19__end_js__ = __webpack_require__(486);

      var id = 0;

      function Transition(groups, parents, name, id) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id;
      }

      function transition(name) {
        return Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"])().transition(name);
      }

      function newId() {
        return ++id;
      }

      var selection_prototype = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype;
      Transition.prototype = transition.prototype = {
        constructor: Transition,
        select: __WEBPACK_IMPORTED_MODULE_10__select_js__["a"
        /* default */
        ],
        selectAll: __WEBPACK_IMPORTED_MODULE_11__selectAll_js__["a"
        /* default */
        ],
        filter: __WEBPACK_IMPORTED_MODULE_6__filter_js__["a"
        /* default */
        ],
        merge: __WEBPACK_IMPORTED_MODULE_7__merge_js__["a"
        /* default */
        ],
        selection: __WEBPACK_IMPORTED_MODULE_12__selection_js__["a"
        /* default */
        ],
        transition: __WEBPACK_IMPORTED_MODULE_17__transition_js__["a"
        /* default */
        ],
        call: selection_prototype.call,
        nodes: selection_prototype.nodes,
        node: selection_prototype.node,
        size: selection_prototype.size,
        empty: selection_prototype.empty,
        each: selection_prototype.each,
        on: __WEBPACK_IMPORTED_MODULE_8__on_js__["a"
        /* default */
        ],
        attr: __WEBPACK_IMPORTED_MODULE_1__attr_js__["a"
        /* default */
        ],
        attrTween: __WEBPACK_IMPORTED_MODULE_2__attrTween_js__["a"
        /* default */
        ],
        style: __WEBPACK_IMPORTED_MODULE_13__style_js__["a"
        /* default */
        ],
        styleTween: __WEBPACK_IMPORTED_MODULE_14__styleTween_js__["a"
        /* default */
        ],
        text: __WEBPACK_IMPORTED_MODULE_15__text_js__["a"
        /* default */
        ],
        textTween: __WEBPACK_IMPORTED_MODULE_16__textTween_js__["a"
        /* default */
        ],
        remove: __WEBPACK_IMPORTED_MODULE_9__remove_js__["a"
        /* default */
        ],
        tween: __WEBPACK_IMPORTED_MODULE_18__tween_js__["a"
        /* default */
        ],
        delay: __WEBPACK_IMPORTED_MODULE_3__delay_js__["a"
        /* default */
        ],
        duration: __WEBPACK_IMPORTED_MODULE_4__duration_js__["a"
        /* default */
        ],
        ease: __WEBPACK_IMPORTED_MODULE_5__ease_js__["a"
        /* default */
        ],
        end: __WEBPACK_IMPORTED_MODULE_19__end_js__["a"
        /* default */
        ]
      };
      /***/
    },
    /* 170 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__timer_js__ = __webpack_require__(59);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "now", function () {
        return __WEBPACK_IMPORTED_MODULE_0__timer_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "timer", function () {
        return __WEBPACK_IMPORTED_MODULE_0__timer_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "timerFlush", function () {
        return __WEBPACK_IMPORTED_MODULE_0__timer_js__["d"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__timeout_js__ = __webpack_require__(192);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "timeout", function () {
        return __WEBPACK_IMPORTED_MODULE_1__timeout_js__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__interval_js__ = __webpack_require__(193);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interval", function () {
        return __WEBPACK_IMPORTED_MODULE_2__interval_js__["a"];
      });
      /***/

    },
    /* 171 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      var DomUtil = Util.DomUtil;
      var EVENT_TYPES = ['start', 'process', 'end', 'reset'];

      var Interaction = /*#__PURE__*/function () {
        var _proto = Interaction.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {
            startEvent: 'mousedown',
            processEvent: 'mousemove',
            endEvent: 'mouseup',
            resetEvent: 'dblclick'
          };
        };

        _proto._start = function _start(ev) {
          var me = this;
          me.preStart && me.preStart(ev);
          me.start(ev);
          me.onStart && me.onStart(ev);
        };

        _proto._process = function _process(ev) {
          var me = this;
          me.preProcess && me.preProcess(ev);
          me.process(ev);
          me.onProcess && me.onProcess(ev);
        };

        _proto._end = function _end(ev) {
          var me = this;
          me.preEnd && me.preEnd(ev);
          me.end(ev);
          me.onEnd && me.onEnd(ev);
        };

        _proto._reset = function _reset(ev) {
          var me = this;
          me.preReset && me.preReset(ev);
          me.reset(ev);
          me.onReset && me.onReset(ev);
        };

        _proto.start = function start() {// TODO override
        };

        _proto.process = function process() {// TODO override
        };

        _proto.end = function end() {// TODO override
        };

        _proto.reset = function reset() {// TODO override
        };

        function Interaction(cfg, view) {
          var me = this;
          var defaultCfg = me.getDefaultCfg();
          Util.assign(me, defaultCfg, cfg);
          me.view = me.chart = view;
          me.canvas = view.get('canvas');

          me._bindEvents();
        }

        _proto._bindEvents = function _bindEvents() {
          var me = this;
          var canvas = me.canvas;
          var canvasDOM = canvas.get('canvasDOM');

          me._clearEvents();

          Util.each(EVENT_TYPES, function (type) {
            var ucType = Util.upperFirst(type);
            me["_on" + ucType + "Listener"] = DomUtil.addEventListener(canvasDOM, me[type + "Event"], Util.wrapBehavior(me, "_" + type));
          });
        };

        _proto._clearEvents = function _clearEvents() {
          var me = this;
          Util.each(EVENT_TYPES, function (type) {
            var listenerName = "_on" + Util.upperFirst(type) + "Listener";
            me[listenerName] && me[listenerName].remove();
          });
        };

        _proto.destroy = function destroy() {
          this._clearEvents();
        };

        return Interaction;
      }();

      module.exports = Interaction;
      /***/
    },
    /* 172 */

    /***/
    function (module, exports, __webpack_require__) {
      var Scale = __webpack_require__(74);

      var G = __webpack_require__(16);

      var Animate = __webpack_require__(125);

      var Chart = __webpack_require__(146);

      var Global = __webpack_require__(7);

      var Shape = __webpack_require__(19);

      var Util = __webpack_require__(0);

      var G2 = {
        // version
        version: Global.version,
        // visual encoding
        Animate: Animate,
        Chart: Chart,
        Global: Global,
        Scale: Scale,
        Shape: Shape,
        Util: Util,
        // render engine
        G: G,
        DomUtil: Util.DomUtil,
        MatrixUtil: Util.MatrixUtil,
        PathUtil: Util.PathUtil
      }; // G2.track = function(enable) {
      //   Global.trackable = enable;
      // };
      // require('./track');

      G2.track = function () {
        console.warn('G2 tracks nothing ;-)');
      }; // 保证两个版本共存


      if (typeof window !== 'undefined') {
        if (window.G2) {
          console.warn("There are multiple versions of G2. Version " + G2.version + "'s reference is 'window.G2_3'");
        } else {
          window.G2 = G2;
        }
      }

      module.exports = G2;
      /***/
    },
    /* 173 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__linear_js__ = __webpack_require__(194);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeLinear", function () {
        return __WEBPACK_IMPORTED_MODULE_0__linear_js__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__quad_js__ = __webpack_require__(195);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeQuad", function () {
        return __WEBPACK_IMPORTED_MODULE_1__quad_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeQuadIn", function () {
        return __WEBPACK_IMPORTED_MODULE_1__quad_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeQuadOut", function () {
        return __WEBPACK_IMPORTED_MODULE_1__quad_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_1__quad_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__cubic_js__ = __webpack_require__(196);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCubic", function () {
        return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCubicIn", function () {
        return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCubicOut", function () {
        return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__poly_js__ = __webpack_require__(197);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easePoly", function () {
        return __WEBPACK_IMPORTED_MODULE_3__poly_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easePolyIn", function () {
        return __WEBPACK_IMPORTED_MODULE_3__poly_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easePolyOut", function () {
        return __WEBPACK_IMPORTED_MODULE_3__poly_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easePolyInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_3__poly_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__sin_js__ = __webpack_require__(198);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeSin", function () {
        return __WEBPACK_IMPORTED_MODULE_4__sin_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeSinIn", function () {
        return __WEBPACK_IMPORTED_MODULE_4__sin_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeSinOut", function () {
        return __WEBPACK_IMPORTED_MODULE_4__sin_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeSinInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_4__sin_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__exp_js__ = __webpack_require__(199);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeExp", function () {
        return __WEBPACK_IMPORTED_MODULE_5__exp_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeExpIn", function () {
        return __WEBPACK_IMPORTED_MODULE_5__exp_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeExpOut", function () {
        return __WEBPACK_IMPORTED_MODULE_5__exp_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeExpInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_5__exp_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__circle_js__ = __webpack_require__(200);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCircle", function () {
        return __WEBPACK_IMPORTED_MODULE_6__circle_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCircleIn", function () {
        return __WEBPACK_IMPORTED_MODULE_6__circle_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCircleOut", function () {
        return __WEBPACK_IMPORTED_MODULE_6__circle_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_6__circle_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__bounce_js__ = __webpack_require__(201);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBounce", function () {
        return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBounceIn", function () {
        return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBounceOut", function () {
        return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__back_js__ = __webpack_require__(202);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBack", function () {
        return __WEBPACK_IMPORTED_MODULE_8__back_js__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBackIn", function () {
        return __WEBPACK_IMPORTED_MODULE_8__back_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBackOut", function () {
        return __WEBPACK_IMPORTED_MODULE_8__back_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeBackInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_8__back_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__elastic_js__ = __webpack_require__(203);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeElastic", function () {
        return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeElasticIn", function () {
        return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeElasticOut", function () {
        return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function () {
        return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["b"];
      });
      /***/

    },
    /* 174 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["c"] = hue;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = gamma;
      /* harmony export (immutable) */

      __webpack_exports__["a"] = nogamma;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__constant_js__ = __webpack_require__(395);

      function linear(a, d) {
        return function (t) {
          return a + t * d;
        };
      }

      function exponential(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
          return Math.pow(a + t * b, y);
        };
      }

      function hue(a, b) {
        var d = b - a;
        return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a"
        /* default */
        ])(isNaN(a) ? b : a);
      }

      function gamma(y) {
        return (y = +y) === 1 ? nogamma : function (a, b) {
          return b - a ? exponential(a, b, y) : Object(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a"
          /* default */
          ])(isNaN(a) ? b : a);
        };
      }

      function nogamma(a, b) {
        var d = b - a;
        return d ? linear(a, d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a"
        /* default */
        ])(isNaN(a) ? b : a);
      }
      /***/

    },
    /* 175 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 自动计算数字坐标轴
       * @author dxq613@gmail.com
       */
      var isNil = __webpack_require__(5);

      var isNumber = __webpack_require__(9);

      var AutoUtil = __webpack_require__(76);

      var MIN_COUNT = 5;
      var MAX_COUNT = 7;
      var SNAP_COUNT_ARRAY = [0, 1, 1.2, 1.5, 1.6, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];
      var SNAP_ARRAY = [0, 1, 2, 4, 5, 10];
      var EPS = 1e-12;

      module.exports = function (info) {
        var min = info.min;
        var max = info.max;
        var interval = info.interval;
        var minTickInterval = info.minTickInterval;
        var ticks = [];
        var minCount = info.minCount || MIN_COUNT;
        var maxCount = info.maxCount || MAX_COUNT;
        var isFixedCount = minCount === maxCount; // 是否限定死了个数

        var minLimit = isNil(info.minLimit) ? -Infinity : info.minLimit; // 限定的最小值

        var maxLimit = isNil(info.maxLimit) ? Infinity : info.maxLimit; // 限定最大值

        var avgCount = (minCount + maxCount) / 2;
        var count = avgCount; // 用户传入的逼近数组

        var snapArray = info.snapArray ? info.snapArray : isFixedCount ? SNAP_COUNT_ARRAY : SNAP_ARRAY; // 如果限定大小范围，同时大小范围等于用户传入的范围，同时限定了个数，interval 按照个数均分

        if (min === minLimit && max === maxLimit && isFixedCount) {
          interval = (max - min) / (count - 1);
        }

        if (isNil(min)) {
          min = 0;
        }

        if (isNil(max)) {
          max = 0;
        }

        if (Math.abs(max - min) < EPS) {
          if (min === 0) {
            max = 1;
          } else {
            if (min > 0) {
              min = 0;
            } else {
              max = 0;
            }
          }

          if (max - min < 5 && !interval && max - min >= 1) {
            interval = 1;
          }
        }

        if (isNil(interval)) {
          // 计算间距
          var temp = (max - min) / (avgCount - 1);
          interval = AutoUtil.snapFactorTo(temp, snapArray, 'ceil');

          if (maxCount !== minCount) {
            count = parseInt((max - min) / interval, 10);

            if (count > maxCount) {
              count = maxCount;
            }

            if (count < minCount) {
              count = minCount;
            } // 不确定tick的个数时，使得tick偏小


            interval = AutoUtil.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');
          }
        } // interval should not be less than minTickInterval


        if (isNumber(minTickInterval) && interval < minTickInterval) {
          interval = minTickInterval;
        }

        if (info.interval || maxCount !== minCount) {
          // 校正 max 和 min
          max = Math.min(AutoUtil.snapMultiple(max, interval, 'ceil'), maxLimit); // 向上逼近

          min = Math.max(AutoUtil.snapMultiple(min, interval, 'floor'), minLimit); // 向下逼近

          count = Math.round((max - min) / interval);
          min = AutoUtil.fixedBase(min, interval); // 当min为负数的时候，fixedBase后，min可能会大于minLimit，导致最终产出的tick是大于minLimit的，所以必须进行修正

          max = AutoUtil.fixedBase(max, interval);
          var prevMin = null;

          while (min > minLimit && minLimit > -Infinity && (prevMin === null || min < prevMin)) {
            // 保证计算出来的刻度最小值 min， 不大于数据最小值 min
            prevMin = min;
            min = AutoUtil.fixedBase(min - interval, interval);
          }
        } else {
          avgCount = parseInt(avgCount, 10); // 取整

          var avg = (max + min) / 2;
          var avgTick = AutoUtil.snapMultiple(avg, interval, 'ceil');
          var sideCount = Math.floor((avgCount - 2) / 2);
          var maxTick = avgTick + sideCount * interval;
          var minTick;

          if (avgCount % 2 === 0) {
            minTick = avgTick - sideCount * interval;
          } else {
            minTick = avgTick - (sideCount + 1) * interval;
          }

          var prevMaxTick = null; // 如果减去intervl, fixBase后，新的minTick没有大于之前的值，就退出，防止死循环

          while (maxTick < max && (prevMaxTick === null || maxTick > prevMaxTick)) {
            // 保证计算出来的刻度最大值 maxTick 不小于数据最大值 max
            prevMaxTick = maxTick;
            maxTick = AutoUtil.fixedBase(maxTick + interval, interval);
          }

          var prevMinTick = null; // 如果减去intervl, fixBase后，新的minTick没有小于之前的值，就退出，防止死循环

          while (minTick > min && (prevMinTick === null || minTick < prevMinTick)) {
            // 保证计算出来的刻度最小值 minTick 不大于数据最小值 min
            prevMinTick = minTick;
            minTick = AutoUtil.fixedBase(minTick - interval, interval); // 防止超常浮点数计算问题
          }

          max = maxTick;
          min = minTick;
        }

        max = Math.min(max, maxLimit);
        min = Math.max(min, minLimit);
        ticks.push(min);

        for (var i = 1; i < count; i++) {
          var tickValue = AutoUtil.fixedBase(interval * i + min, interval);

          if (tickValue < max) {
            ticks.push(tickValue);
          }
        }

        if (ticks[ticks.length - 1] < max) {
          ticks.push(max);
        }

        return {
          min: min,
          max: max,
          interval: interval,
          count: count,
          ticks: ticks
        };
      };
      /***/

    },
    /* 176 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Base = __webpack_require__(18);

      var isNumber = __webpack_require__(9);

      var Identity = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Identity, _Base);

        function Identity() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Identity.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          _Base.prototype._initDefaultCfg.call(this);

          this.isIdentity = true;
          this.type = 'identity';
          /**
           * 常量值
           * @type {*}
           */

          this.value = null;
        }
        /**
         * @override
         */
        ;

        _proto.getText = function getText() {
          return this.value.toString();
        }
        /**
         * @override
         */
        ;

        _proto.scale = function scale(value) {
          if (this.value !== value && isNumber(value)) {
            return value;
          }

          return this.range[0];
        }
        /**
         * @override
         */
        ;

        _proto.invert = function invert() {
          return this.value;
        };

        return Identity;
      }(Base);

      Base.Identity = Identity;
      module.exports = Identity;
      /***/
    },
    /* 177 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The measurement of linear data scale function
       * @author dxq613@gmail.com
       */


      var fecha = __webpack_require__(79);

      var each = __webpack_require__(2);

      var isNil = __webpack_require__(5);

      var isString = __webpack_require__(10);

      var Base = __webpack_require__(18);

      var Linear = __webpack_require__(33);

      var timeAuto = __webpack_require__(178);

      var TimeUtil = __webpack_require__(71);
      /**
       * 时间度量的构造函数
       * @class Scale.Time
       */


      var Time = /*#__PURE__*/function (_Linear) {
        _inheritsLoose(Time, _Linear);

        function Time() {
          return _Linear.apply(this, arguments) || this;
        }

        var _proto = Time.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          _Linear.prototype._initDefaultCfg.call(this);

          this.type = 'time';
          this.mask = 'YYYY-MM-DD';
        }
        /**
         * @override
         */
        ;

        _proto.init = function init() {
          var self = this;
          var values = self.values;

          if (values && values.length) {
            // 重新计算最大最小值
            var timeStamps = [];
            var min = Infinity; // 最小值

            var secondMin = min; // 次小值

            var max = 0; // 使用一个循环，计算min,max,secondMin

            each(values, function (v) {
              var timeStamp = self._toTimeStamp(v);

              if (isNaN(timeStamp)) {
                throw new TypeError("Invalid Time: " + v);
              }

              if (min > timeStamp) {
                secondMin = min;
                min = timeStamp;
              } else if (secondMin > timeStamp) {
                secondMin = timeStamp;
              }

              if (max < timeStamp) {
                max = timeStamp;
              }

              timeStamps.push(timeStamp);
            }); // 存在多个值时，设置最小间距

            if (values.length > 1) {
              self.minTickInterval = secondMin - min;
            }

            if (isNil(self.min) || self._toTimeStamp(self.min) > min) {
              self.min = min;
            }

            if (isNil(self.max) || self._toTimeStamp(self.max) < max) {
              self.max = max;
            }
          }

          _Linear.prototype.init.call(this);
        };

        _proto.calculateTicks = function calculateTicks() {
          var self = this;
          var min = self.min;
          var max = self.max;
          var count = self.tickCount;
          var interval = self.tickInterval;
          var tmp = timeAuto({
            min: min,
            max: max,
            minCount: count,
            maxCount: count,
            interval: interval,
            minInterval: self.minTickInterval
          });
          return tmp.ticks;
        }
        /**
         * @override
         */
        ;

        _proto.getText = function getText(value) {
          var formatter = this.formatter;
          value = this.translate(value);
          value = formatter ? formatter(value) : fecha.format(value, this.mask);
          return value;
        }
        /**
         * @override
         */
        ;

        _proto.scale = function scale(value) {
          if (isString(value)) {
            value = this.translate(value);
          }

          return _Linear.prototype.scale.call(this, value);
        }
        /**
         * @override
         */
        ;

        _proto.translate = function translate(value) {
          return this._toTimeStamp(value);
        } // 将时间转换为时间戳
        ;

        _proto._toTimeStamp = function _toTimeStamp(value) {
          return TimeUtil.toTimeStamp(value);
        };

        return Time;
      }(Linear);

      Base.Time = Time;
      module.exports = Time;
      /***/
    },
    /* 178 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 计算时间坐标轴
       * @author dxq613@gmail.com
       */
      var AutoUtil = __webpack_require__(76);

      var isNil = __webpack_require__(5);

      var MAX_COUNT = 6;
      var SNAP_ARRAY = [1, 2, 4, 6, 8, 12];
      var MINUTE_MS = 60 * 1000;
      var HOUR_MS = 3600 * 1000;
      var DAY_MS = 24 * 3600 * 1000;

      function getYear(date) {
        return new Date(date).getFullYear();
      }

      function createYear(year) {
        return new Date(year, 0, 1).getTime();
      }

      function getMonth(date) {
        return new Date(date).getMonth();
      }

      function diffMonth(min, max) {
        var minYear = getYear(min);
        var maxYear = getYear(max);
        var minMonth = getMonth(min);
        var maxMonth = getMonth(max);
        return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
      }

      function creatMonth(year, month) {
        return new Date(year, month, 1).getTime();
      }

      function diffDay(min, max) {
        return Math.ceil((max - min) / DAY_MS);
      }

      function diffHour(min, max) {
        return Math.ceil((max - min) / HOUR_MS);
      }

      function diffMinus(min, max) {
        return Math.ceil((max - min) / (60 * 1000));
      }

      module.exports = function (info) {
        var minInterval = info.minInterval;
        var ticks = [];
        var min = info.min;
        var max = info.max;
        var interval = info.interval;
        var count; // 如果最大值和最小值相等，则设置最大值大于最小值一天

        if (max === min) {
          max = min + DAY_MS;
        } // 计算间距


        if (isNil(interval)) {
          var innerTime = max - min;
          var dms = DAY_MS; // 天代表的秒

          var yms = 365 * dms; // 年代表的秒

          interval = parseInt(innerTime / (info.maxCount || MAX_COUNT), 10);

          if (minInterval && minInterval > interval) {
            interval = minInterval;
          }

          var yfactor = interval / yms;
          var minYear = getYear(min); // 大于半年

          if (yfactor > 0.51) {
            var year = Math.ceil(yfactor); // interval = year * yms;

            var maxYear = getYear(max);

            for (var i = minYear; i <= maxYear + year; i = i + year) {
              ticks.push(createYear(i));
            }

            interval = null;
          } else if (yfactor > 0.0834) {
            // 大于一个月
            var month = Math.ceil(yfactor / 0.0834);
            var mmMoth = getMonth(min);
            var dMonths = diffMonth(min, max);

            for (var _i = 0; _i <= dMonths + month; _i = _i + month) {
              ticks.push(creatMonth(minYear, _i + mmMoth));
            }

            interval = null;
          } else if (interval > dms * 0.5) {
            // 大于一天
            var date = new Date(min);

            var _year = date.getFullYear();

            var _month = date.getMonth(min);

            var mday = date.getDate();
            var day = Math.ceil(interval / dms);
            var ddays = diffDay(min, max);
            interval = day * dms;

            for (var _i2 = 0; _i2 < ddays + day; _i2 = _i2 + day) {
              ticks.push(new Date(_year, _month, mday + _i2).getTime());
            }
          } else if (interval > HOUR_MS) {
            // 大于一个小时
            var _date = new Date(min);

            var _year2 = _date.getFullYear();

            var _month2 = _date.getMonth(min);

            var _day = _date.getDate();

            var hour = _date.getHours();

            var hours = AutoUtil.snapTo(SNAP_ARRAY, Math.ceil(interval / HOUR_MS));
            var dHours = diffHour(min, max);
            interval = hours * HOUR_MS;

            for (var _i3 = 0; _i3 <= dHours + hours; _i3 = _i3 + hours) {
              ticks.push(new Date(_year2, _month2, _day, hour + _i3).getTime());
            }
          } else if (interval > MINUTE_MS) {
            // 最小单位是分钟
            var dMinus = diffMinus(min, max);
            var minutes = Math.ceil(interval / MINUTE_MS);
            interval = minutes * MINUTE_MS;

            for (var _i4 = 0; _i4 <= dMinus + minutes; _i4 = _i4 + minutes) {
              ticks.push(min + _i4 * MINUTE_MS);
            }
          } else {
            if (interval < 1000) {
              interval = 1000;
            }

            min = Math.floor(min / 1000) * 1000;
            var dSeconds = Math.ceil((max - min) / 1000);
            var seconds = Math.ceil(interval / 1000);
            interval = seconds * 1000;

            for (var _i5 = 0; _i5 < dSeconds + seconds; _i5 = _i5 + seconds) {
              ticks.push(min + _i5 * 1000);
            }
          }
        }

        if (!ticks.length) {
          min = Math.floor(min / 1000) * 1000;
          max = Math.ceil(max / 1000) * 1000;
          count = (max - min) / interval;

          for (var _i6 = 0; _i6 <= count; _i6++) {
            ticks.push(AutoUtil.fixedBase(interval * _i6 + min, interval));
          }
        }

        return {
          max: max,
          min: min,
          interval: interval,
          ticks: ticks,
          count: ticks.length
        };
      };
      /***/

    },
    /* 179 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 时间数据作为分类类型
       * @author dxq613@gmail.com
       */


      var Base = __webpack_require__(18);

      var Category = __webpack_require__(77);

      var fecha = __webpack_require__(79);

      var catAuto = __webpack_require__(78);

      var TimeUtil = __webpack_require__(71);

      var each = __webpack_require__(2);

      var isNumber = __webpack_require__(9);

      var isObject = __webpack_require__(25);

      var isString = __webpack_require__(10);
      /**
       * 度量的构造函数
       * @class Scale.TimeCategory
       */


      var TimeCategory = /*#__PURE__*/function (_Category) {
        _inheritsLoose(TimeCategory, _Category);

        function TimeCategory() {
          return _Category.apply(this, arguments) || this;
        }

        var _proto = TimeCategory.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          _Category.prototype._initDefaultCfg.call(this);

          this.type = 'timeCat';
          /**
           * 是否需要排序，默认进行排序
           * @type {Boolean}
           */

          this.sortable = true;
          this.tickCount = 5;
          /**
           * 时间格式化
           * @type {String}
           */

          this.mask = 'YYYY-MM-DD';
        };

        _proto.init = function init() {
          var self = this;
          var values = this.values; // 针对时间分类类型，会将时间统一转换为时间戳

          each(values, function (v, i) {
            values[i] = self._toTimeStamp(v);
          });

          if (this.sortable) {
            // 允许排序
            values.sort(function (v1, v2) {
              return v1 - v2;
            });
          }

          if (!self.ticks) {
            self.ticks = this.calculateTicks();
          }
        }
        /**
         * 计算 ticks
         * @return {array} 返回 ticks 数组
         */
        ;

        _proto.calculateTicks = function calculateTicks() {
          var self = this;
          var count = self.tickCount;
          var ticks;

          if (count) {
            var temp = catAuto({
              maxCount: count,
              data: self.values,
              isRounding: self.isRounding
            });
            ticks = temp.ticks;
          } else {
            ticks = self.values;
          }

          return ticks;
        }
        /**
         * @override
         */
        ;

        _proto.translate = function translate(value) {
          value = this._toTimeStamp(value);
          var index = this.values.indexOf(value);

          if (index === -1) {
            if (isNumber(value) && value < this.values.length) {
              index = value;
            } else {
              index = NaN;
            }
          }

          return index;
        }
        /**
         * @override
         */
        ;

        _proto.scale = function scale(value) {
          var rangeMin = this.rangeMin();
          var rangeMax = this.rangeMax();
          var index = this.translate(value);
          var percent;

          if (this.values.length === 1 || isNaN(index)) {
            // is index is NAN should not be set as 0
            percent = index;
          } else if (index > -1) {
            percent = index / (this.values.length - 1);
          } else {
            percent = 0;
          }

          return rangeMin + percent * (rangeMax - rangeMin);
        }
        /**
         * @override
         */
        ;

        _proto.getText = function getText(value) {
          var result = '';
          var index = this.translate(value);

          if (index > -1) {
            result = this.values[index];
          } else {
            result = value;
          }

          var formatter = this.formatter;
          result = parseInt(result, 10);
          result = formatter ? formatter(result) : fecha.format(result, this.mask);
          return result;
        }
        /**
         * @override
         */
        ;

        _proto.getTicks = function getTicks() {
          var self = this;
          var ticks = this.ticks;
          var rst = [];
          each(ticks, function (tick) {
            var obj;

            if (isObject(tick)) {
              obj = tick;
            } else {
              obj = {
                text: isString(tick) ? tick : self.getText(tick),
                value: self.scale(tick),
                tickValue: tick // 用于坐标轴上文本动画时确定前后帧的对应关系

              };
            }

            rst.push(obj);
          });
          return rst;
        } // 将时间转换为时间戳
        ;

        _proto._toTimeStamp = function _toTimeStamp(value) {
          return TimeUtil.toTimeStamp(value);
        };

        return TimeCategory;
      }(Category);

      Base.TimeCat = TimeCategory;
      module.exports = TimeCategory;
      /***/
    },
    /* 180 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 使用度量，进行log转换
       * @author dxq613@gmail.com
       */


      var each = __webpack_require__(2);

      var Base = __webpack_require__(18);

      var Linear = __webpack_require__(33); // 计算log


      function log(a, b) {
        if (a === 1) {
          return 1;
        }

        return Math.log(b) / Math.log(a);
      }
      /**
       * 度量的log计算
       * @class Scale.Log
       */


      var Log = /*#__PURE__*/function (_Linear) {
        _inheritsLoose(Log, _Linear);

        function Log() {
          return _Linear.apply(this, arguments) || this;
        }

        var _proto = Log.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          _Linear.prototype._initDefaultCfg.call(this);

          this.type = 'log';
          /**
           * @override
           * log 的坐标点的个数控制在10个以下
           * @type {Number}
           */

          this.tickCount = 10;
          /**
           * 进行log计算的基数
           * @type {Number}
           */

          this.base = 2; // 最小的tick，仅内部使用

          this._minTick = null;
        }
        /**
         * @override
         */
        ;

        _proto.calculateTicks = function calculateTicks() {
          var self = this;
          var base = self.base;
          var minTick;

          if (self.min < 0) {
            throw new Error('The minimum value must be greater than zero!');
          }

          var maxTick = log(base, self.max);

          if (self.min > 0) {
            minTick = Math.floor(log(base, self.min));
          } else {
            var values = self.values;
            var positiveMin = self.max; // 查找大于0的第一个值, 如果都小于0，默认为1

            each(values, function (value) {
              if (value > 0 && value < positiveMin) {
                positiveMin = value;
              }
            });

            if (positiveMin === self.max) {
              positiveMin = self.max / base;
            }

            if (positiveMin > 1) {
              positiveMin = 1;
            }

            minTick = Math.floor(log(base, positiveMin));
            self._minTick = minTick;
            self.positiveMin = positiveMin;
          }

          var count = maxTick - minTick;
          var tickCount = self.tickCount;
          var avg = Math.ceil(count / tickCount);
          var ticks = [];

          for (var i = minTick; i < maxTick + avg; i = i + avg) {
            ticks.push(Math.pow(base, i));
          }

          if (self.min === 0) {
            ticks.unshift(0);
          }

          return ticks;
        } // 获取度量计算时，value占的定义域百分比
        ;

        _proto._getScalePercent = function _getScalePercent(value) {
          var max = this.max;
          var min = this.min;

          if (max === min) {
            return 0;
          } // 如果值小于等于0，则按照0处理


          if (value <= 0) {
            return 0;
          }

          var base = this.base;
          var positiveMin = this.positiveMin; // 如果min == 0, 则根据比0大的最小值，计算比例关系。这个最小值作为坐标轴上的第二个tick，第一个是0但是不显示

          if (positiveMin) {
            min = positiveMin * 1 / base;
          }

          var percent; // 如果数值小于次小值，那么就计算 value / 次小值 占整体的比例

          if (value < positiveMin) {
            percent = value / positiveMin / (log(base, max) - log(base, min));
          } else {
            percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));
          }

          return percent;
        }
        /**
         * @override
         */
        ;

        _proto.scale = function scale(value) {
          var percent = this._getScalePercent(value);

          var rangeMin = this.rangeMin();
          var rangeMax = this.rangeMax();
          return rangeMin + percent * (rangeMax - rangeMin);
        }
        /**
         * @override
         */
        ;

        _proto.invert = function invert(value) {
          var base = this.base;
          var max = log(base, this.max);
          var rangeMin = this.rangeMin();
          var range = this.rangeMax() - rangeMin;
          var min;
          var positiveMin = this.positiveMin;

          if (positiveMin) {
            if (value === 0) {
              return 0;
            }

            min = log(base, positiveMin / base);
            var appendPercent = 1 / (max - min) * range; // 0 到 positiveMin的占比

            if (value < appendPercent) {
              // 落到 0 - positiveMin 之间
              return value / appendPercent * positiveMin;
            }
          } else {
            min = log(base, this.min);
          }

          var percent = (value - rangeMin) / range;
          var tmp = percent * (max - min) + min;
          return Math.pow(base, tmp);
        };

        return Log;
      }(Linear);

      Base.Log = Log;
      module.exports = Log;
      /***/
    },
    /* 181 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 使用pow进行度量计算
       * @author dxq613@gmail.com
       */


      var Base = __webpack_require__(18);

      var Linear = __webpack_require__(33); // 求以a为次幂，结果为b的基数，如 x^^a = b;求x


      function calBase(a, b) {
        var e = Math.E;
        var value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底

        return value;
      }
      /**
       * 度量的Pow计算
       * @class Scale.Log
       */


      var Pow = /*#__PURE__*/function (_Linear) {
        _inheritsLoose(Pow, _Linear);

        function Pow() {
          return _Linear.apply(this, arguments) || this;
        }

        var _proto = Pow.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          _Linear.prototype._initDefaultCfg.call(this);

          this.type = 'pow';
          /**
           * @override
           * pow 的坐标点的个数控制在10个以下
           * @type {Number}
           */

          this.tickCount = 10;
          /**
           * 进行pow计算的基数
           * @type {Number}
           */

          this.exponent = 2;
        }
        /**
         * @override
         */
        ;

        _proto.calculateTicks = function calculateTicks() {
          var self = this;
          var exponent = self.exponent;
          var min;
          var max = Math.ceil(calBase(exponent, self.max));

          if (self.min >= 0) {
            min = Math.floor(calBase(exponent, self.min));
          } else {
            min = 0;
          }

          if (min > max) {
            var tmp = max;
            max = min;
            min = tmp;
          }

          var count = max - min;
          var tickCount = self.tickCount;
          var avg = Math.ceil(count / tickCount);
          var ticks = [];

          for (var i = min; i < max + avg; i = i + avg) {
            ticks.push(Math.pow(i, exponent));
          }

          return ticks;
        } // 获取度量计算时，value占的定义域百分比
        ;

        _proto._getScalePercent = function _getScalePercent(value) {
          var max = this.max;
          var min = this.min;

          if (max === min) {
            return 0;
          }

          var exponent = this.exponent;
          var percent = (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));
          return percent;
        }
        /**
         * @override
         */
        ;

        _proto.scale = function scale(value) {
          var percent = this._getScalePercent(value);

          var rangeMin = this.rangeMin();
          var rangeMax = this.rangeMax();
          return rangeMin + percent * (rangeMax - rangeMin);
        }
        /**
         * @override
         */
        ;

        _proto.invert = function invert(value) {
          var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
          var exponent = this.exponent;
          var max = calBase(exponent, this.max);
          var min = calBase(exponent, this.min);
          var tmp = percent * (max - min) + min;
          return Math.pow(tmp, exponent);
        };

        return Pow;
      }(Linear);

      Base.Pow = Pow;
      module.exports = Pow;
      /***/
    },
    /* 182 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Event = __webpack_require__(100);

      var Group = __webpack_require__(101);

      var Timeline = __webpack_require__(191);

      var renderers = __webpack_require__(217);

      var Canvas = function Canvas(cfg) {
        Canvas.superclass.constructor.call(this, cfg);
      };

      Canvas.CFG = {
        eventEnable: true,

        /**
         * 像素宽度
         * @type {Number}
         */
        width: null,

        /**
         * 像素高度
         * @type {Number}
         */
        height: null,

        /**
         * 画布宽度
         * @type {Number}
         */
        widthCanvas: null,

        /**
         * 画布高度
         * @type {Number}
         */
        heightCanvas: null,

        /**
         * CSS宽
         * @type {String}
         */
        widthStyle: null,

        /**
         * CSS高
         * @type {String}
         */
        heightStyle: null,

        /**
         * 容器DOM
         * @type {Object}
         */
        containerDOM: null,

        /**
         * 当前Canvas的DOM
         * @type {Object}
         */
        canvasDOM: null,

        /**
         * 屏幕像素比
         * @type {Number}
         */
        pixelRatio: null,

        /**
         * 渲染器，默认是canvas
         * @type {String}
         */
        renderer: 'canvas'
      };
      Util.extend(Canvas, Group);
      Util.augment(Canvas, {
        init: function init() {
          Canvas.superclass.init.call(this);

          this._setGlobalParam();

          this._setContainer();

          this._initPainter();

          this._scale();

          if (this.get('eventEnable')) {
            this._registEvents();
          }
        },
        getEmitter: function getEmitter(element, event) {
          if (element) {
            if (Util.isEmpty(element._getEvents())) {
              var parent = element.get('parent');

              if (parent && !event.propagationStopped) {
                return this.getEmitter(parent, event);
              }
            } else {
              return element;
            }
          }
        },
        _getEventObj: function _getEventObj(type, e, point, target) {
          var event = new Event(type, e, true, true);
          event.x = point.x;
          event.y = point.y;
          event.clientX = e.clientX;
          event.clientY = e.clientY;
          event.currentTarget = target;
          event.target = target;
          return event;
        },
        _triggerEvent: function _triggerEvent(type, e) {
          var point = this.getPointByClient(e.clientX, e.clientY);
          var shape = this.getShape(point.x, point.y, e);
          var el = this.get('el');
          var emitObj;

          if (type === 'mousemove') {
            var preShape = this.get('preShape');

            if (preShape && preShape !== shape) {
              var mouseleave = this._getEventObj('mouseleave', e, point, preShape);

              emitObj = this.getEmitter(preShape, e);
              emitObj && emitObj.emit('mouseleave', mouseleave);
              el.style.cursor = 'default';
            }

            if (shape) {
              var mousemove = this._getEventObj('mousemove', e, point, shape);

              emitObj = this.getEmitter(shape, e);
              emitObj && emitObj.emit('mousemove', mousemove);

              if (preShape !== shape) {
                var mouseenter = this._getEventObj('mouseenter', e, point, shape);

                emitObj && emitObj.emit('mouseenter', mouseenter, e);
              }
            } else {
              var canvasmousemove = this._getEventObj('mousemove', e, point, this);

              this.emit('mousemove', canvasmousemove);
            }

            this.set('preShape', shape);
          } else {
            var event = this._getEventObj(type, e, point, shape || this);

            emitObj = this.getEmitter(shape, e);

            if (emitObj && emitObj !== this) {
              emitObj.emit(type, event);
            }

            this.emit(type, event);
          }

          if (shape && !shape.get('destroyed')) {
            el.style.cursor = shape.attr('cursor') || 'default';
          }
        },
        _registEvents: function _registEvents() {
          var self = this;
          var el = self.get('el');
          var events = ['mouseout', 'mouseover', 'mousemove', 'mousedown', 'mouseleave', 'mouseup', 'click', 'dblclick'];
          Util.each(events, function (event) {
            el.addEventListener(event, function (e) {
              self._triggerEvent(event, e);
            }, false);
          }); // special cases

          el.addEventListener('touchstart', function (e) {
            if (!Util.isEmpty(e.touches)) {
              self._triggerEvent('touchstart', e.touches[0]);
            }
          }, false);
          el.addEventListener('touchmove', function (e) {
            if (!Util.isEmpty(e.touches)) {
              self._triggerEvent('touchmove', e.touches[0]);
            }
          }, false);
          el.addEventListener('touchend', function (e) {
            if (!Util.isEmpty(e.changedTouches)) {
              self._triggerEvent('touchend', e.changedTouches[0]);
            }
          }, false);
        },
        _scale: function _scale() {
          var pixelRatio = this.get('pixelRatio');
          this.scale(pixelRatio, pixelRatio);
        },
        _setGlobalParam: function _setGlobalParam() {
          var pixelRatio = this.get('pixelRatio');

          if (!pixelRatio) {
            this.set('pixelRatio', Util.getRatio());
          }

          var renderer = renderers[this.get('renderer') || 'canvas'];
          this._cfg.renderer = renderer;
          this._cfg.canvas = this;
          var timeline = new Timeline(this);
          this._cfg.timeline = timeline;
        },
        _setContainer: function _setContainer() {
          var containerId = this.get('containerId');
          var containerDOM = this.get('containerDOM');

          if (!containerDOM) {
            containerDOM = document.getElementById(containerId);
            this.set('containerDOM', containerDOM);
          }

          Util.modifyCSS(containerDOM, {
            position: 'relative'
          });
        },
        _initPainter: function _initPainter() {
          var containerDOM = this.get('containerDOM');
          var painter = new this._cfg.renderer.painter(containerDOM);
          this._cfg.painter = painter;
          this._cfg.canvasDOM = this._cfg.el = painter.canvas;
          this.changeSize(this.get('width'), this.get('height'));
        },
        _resize: function _resize() {
          var canvasDOM = this.get('canvasDOM');
          var widthCanvas = this.get('widthCanvas');
          var heightCanvas = this.get('heightCanvas');
          var widthStyle = this.get('widthStyle');
          var heightStyle = this.get('heightStyle');
          canvasDOM.style.width = widthStyle;
          canvasDOM.style.height = heightStyle;
          canvasDOM.setAttribute('width', widthCanvas);
          canvasDOM.setAttribute('height', heightCanvas);
        },
        getWidth: function getWidth() {
          var pixelRatio = this.get('pixelRatio');
          var width = this.get('width');
          return width * pixelRatio;
        },
        getHeight: function getHeight() {
          var pixelRatio = this.get('pixelRatio');
          var height = this.get('height');
          return height * pixelRatio;
        },
        changeSize: function changeSize(width, height) {
          var pixelRatio = this.get('pixelRatio');
          var widthCanvas = width * pixelRatio;
          var heightCanvas = height * pixelRatio;
          this.set('widthCanvas', widthCanvas);
          this.set('heightCanvas', heightCanvas);
          this.set('widthStyle', width + 'px');
          this.set('heightStyle', height + 'px');
          this.set('width', width);
          this.set('height', height);

          this._resize();
        },

        /**
         * 将窗口坐标转变成 canvas 坐标
         * @param  {Number} clientX 窗口x坐标
         * @param  {Number} clientY 窗口y坐标
         * @return {Object} canvas坐标
         */
        getPointByClient: function getPointByClient(clientX, clientY) {
          var el = this.get('el');
          var pixelRatio = this.get('pixelRatio') || 1;
          var bbox = el.getBoundingClientRect();
          return {
            x: (clientX - bbox.left) * pixelRatio,
            y: (clientY - bbox.top) * pixelRatio
          };
        },
        getClientByPoint: function getClientByPoint(x, y) {
          var el = this.get('el');
          var bbox = el.getBoundingClientRect();
          var pixelRatio = this.get('pixelRatio') || 1;
          return {
            clientX: x / pixelRatio + bbox.left,
            clientY: y / pixelRatio + bbox.top
          };
        },
        draw: function draw() {
          this._cfg.painter.draw(this);
        },
        getShape: function getShape(x, y, e) {
          if (arguments.length === 3 && this._cfg.renderer.getShape) {
            return this._cfg.renderer.getShape.call(this, x, y, e);
          }

          return Canvas.superclass.getShape.call(this, x, y);
        },
        _drawSync: function _drawSync() {
          this._cfg.painter.drawSync(this);
        },
        destroy: function destroy() {
          var cfg = this._cfg;
          var containerDOM = cfg.containerDOM;
          var canvasDOM = cfg.canvasDOM;

          if (canvasDOM && containerDOM) {
            containerDOM.removeChild(canvasDOM);
          }

          cfg.timeline.stop();
          Canvas.superclass.destroy.call(this);
        }
      });
      module.exports = Canvas;
      /***/
    },
    /* 183 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sub = exports.mul = undefined;
      exports.create = create;
      exports.fromMat4 = fromMat4;
      exports.clone = clone;
      exports.copy = copy;
      exports.fromValues = fromValues;
      exports.set = set;
      exports.identity = identity;
      exports.transpose = transpose;
      exports.invert = invert;
      exports.adjoint = adjoint;
      exports.determinant = determinant;
      exports.multiply = multiply;
      exports.translate = translate;
      exports.rotate = rotate;
      exports.scale = scale;
      exports.fromTranslation = fromTranslation;
      exports.fromRotation = fromRotation;
      exports.fromScaling = fromScaling;
      exports.fromMat2d = fromMat2d;
      exports.fromQuat = fromQuat;
      exports.normalFromMat4 = normalFromMat4;
      exports.projection = projection;
      exports.str = str;
      exports.frob = frob;
      exports.add = add;
      exports.subtract = subtract;
      exports.multiplyScalar = multiplyScalar;
      exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
      exports.exactEquals = exactEquals;
      exports.equals = equals;

      var _common = __webpack_require__(53);

      var glMatrix = _interopRequireWildcard(_common);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj["default"] = obj;
          return newObj;
        }
      }
      /**
       * 3x3 Matrix
       * @module mat3
       */

      /**
       * Creates a new identity mat3
       *
       * @returns {mat3} a new 3x3 matrix
       */


      function create() {
        var out = new glMatrix.ARRAY_TYPE(9);

        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
        }

        out[0] = 1;
        out[4] = 1;
        out[8] = 1;
        return out;
      }
      /**
       * Copies the upper-left 3x3 values into the given mat3.
       *
       * @param {mat3} out the receiving 3x3 matrix
       * @param {mat4} a   the source 4x4 matrix
       * @returns {mat3} out
       */


      function fromMat4(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[4];
        out[4] = a[5];
        out[5] = a[6];
        out[6] = a[8];
        out[7] = a[9];
        out[8] = a[10];
        return out;
      }
      /**
       * Creates a new mat3 initialized with values from an existing matrix
       *
       * @param {mat3} a matrix to clone
       * @returns {mat3} a new 3x3 matrix
       */


      function clone(a) {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
      }
      /**
       * Copy the values from one mat3 to another
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
      }
      /**
       * Create a new mat3 with the given values
       *
       * @param {Number} m00 Component in column 0, row 0 position (index 0)
       * @param {Number} m01 Component in column 0, row 1 position (index 1)
       * @param {Number} m02 Component in column 0, row 2 position (index 2)
       * @param {Number} m10 Component in column 1, row 0 position (index 3)
       * @param {Number} m11 Component in column 1, row 1 position (index 4)
       * @param {Number} m12 Component in column 1, row 2 position (index 5)
       * @param {Number} m20 Component in column 2, row 0 position (index 6)
       * @param {Number} m21 Component in column 2, row 1 position (index 7)
       * @param {Number} m22 Component in column 2, row 2 position (index 8)
       * @returns {mat3} A new mat3
       */


      function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m10;
        out[4] = m11;
        out[5] = m12;
        out[6] = m20;
        out[7] = m21;
        out[8] = m22;
        return out;
      }
      /**
       * Set the components of a mat3 to the given values
       *
       * @param {mat3} out the receiving matrix
       * @param {Number} m00 Component in column 0, row 0 position (index 0)
       * @param {Number} m01 Component in column 0, row 1 position (index 1)
       * @param {Number} m02 Component in column 0, row 2 position (index 2)
       * @param {Number} m10 Component in column 1, row 0 position (index 3)
       * @param {Number} m11 Component in column 1, row 1 position (index 4)
       * @param {Number} m12 Component in column 1, row 2 position (index 5)
       * @param {Number} m20 Component in column 2, row 0 position (index 6)
       * @param {Number} m21 Component in column 2, row 1 position (index 7)
       * @param {Number} m22 Component in column 2, row 2 position (index 8)
       * @returns {mat3} out
       */


      function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m10;
        out[4] = m11;
        out[5] = m12;
        out[6] = m20;
        out[7] = m21;
        out[8] = m22;
        return out;
      }
      /**
       * Set a mat3 to the identity matrix
       *
       * @param {mat3} out the receiving matrix
       * @returns {mat3} out
       */


      function identity(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      /**
       * Transpose the values of a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function transpose(out, a) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (out === a) {
          var a01 = a[1],
              a02 = a[2],
              a12 = a[5];
          out[1] = a[3];
          out[2] = a[6];
          out[3] = a01;
          out[5] = a[7];
          out[6] = a02;
          out[7] = a12;
        } else {
          out[0] = a[0];
          out[1] = a[3];
          out[2] = a[6];
          out[3] = a[1];
          out[4] = a[4];
          out[5] = a[7];
          out[6] = a[2];
          out[7] = a[5];
          out[8] = a[8];
        }

        return out;
      }
      /**
       * Inverts a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function invert(out, a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        var b01 = a22 * a11 - a12 * a21;
        var b11 = -a22 * a10 + a12 * a20;
        var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

        var det = a00 * b01 + a01 * b11 + a02 * b21;

        if (!det) {
          return null;
        }

        det = 1.0 / det;
        out[0] = b01 * det;
        out[1] = (-a22 * a01 + a02 * a21) * det;
        out[2] = (a12 * a01 - a02 * a11) * det;
        out[3] = b11 * det;
        out[4] = (a22 * a00 - a02 * a20) * det;
        out[5] = (-a12 * a00 + a02 * a10) * det;
        out[6] = b21 * det;
        out[7] = (-a21 * a00 + a01 * a20) * det;
        out[8] = (a11 * a00 - a01 * a10) * det;
        return out;
      }
      /**
       * Calculates the adjugate of a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function adjoint(out, a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        out[0] = a11 * a22 - a12 * a21;
        out[1] = a02 * a21 - a01 * a22;
        out[2] = a01 * a12 - a02 * a11;
        out[3] = a12 * a20 - a10 * a22;
        out[4] = a00 * a22 - a02 * a20;
        out[5] = a02 * a10 - a00 * a12;
        out[6] = a10 * a21 - a11 * a20;
        out[7] = a01 * a20 - a00 * a21;
        out[8] = a00 * a11 - a01 * a10;
        return out;
      }
      /**
       * Calculates the determinant of a mat3
       *
       * @param {mat3} a the source matrix
       * @returns {Number} determinant of a
       */


      function determinant(a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
      }
      /**
       * Multiplies two mat3's
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @returns {mat3} out
       */


      function multiply(out, a, b) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        var b00 = b[0],
            b01 = b[1],
            b02 = b[2];
        var b10 = b[3],
            b11 = b[4],
            b12 = b[5];
        var b20 = b[6],
            b21 = b[7],
            b22 = b[8];
        out[0] = b00 * a00 + b01 * a10 + b02 * a20;
        out[1] = b00 * a01 + b01 * a11 + b02 * a21;
        out[2] = b00 * a02 + b01 * a12 + b02 * a22;
        out[3] = b10 * a00 + b11 * a10 + b12 * a20;
        out[4] = b10 * a01 + b11 * a11 + b12 * a21;
        out[5] = b10 * a02 + b11 * a12 + b12 * a22;
        out[6] = b20 * a00 + b21 * a10 + b22 * a20;
        out[7] = b20 * a01 + b21 * a11 + b22 * a21;
        out[8] = b20 * a02 + b21 * a12 + b22 * a22;
        return out;
      }
      /**
       * Translate a mat3 by the given vector
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to translate
       * @param {vec2} v vector to translate by
       * @returns {mat3} out
       */


      function translate(out, a, v) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            a20 = a[6],
            a21 = a[7],
            a22 = a[8],
            x = v[0],
            y = v[1];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a10;
        out[4] = a11;
        out[5] = a12;
        out[6] = x * a00 + y * a10 + a20;
        out[7] = x * a01 + y * a11 + a21;
        out[8] = x * a02 + y * a12 + a22;
        return out;
      }
      /**
       * Rotates a mat3 by the given angle
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to rotate
       * @param {Number} rad the angle to rotate the matrix by
       * @returns {mat3} out
       */


      function rotate(out, a, rad) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            a20 = a[6],
            a21 = a[7],
            a22 = a[8],
            s = Math.sin(rad),
            c = Math.cos(rad);
        out[0] = c * a00 + s * a10;
        out[1] = c * a01 + s * a11;
        out[2] = c * a02 + s * a12;
        out[3] = c * a10 - s * a00;
        out[4] = c * a11 - s * a01;
        out[5] = c * a12 - s * a02;
        out[6] = a20;
        out[7] = a21;
        out[8] = a22;
        return out;
      }

      ;
      /**
       * Scales the mat3 by the dimensions in the given vec2
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to rotate
       * @param {vec2} v the vec2 to scale the matrix by
       * @returns {mat3} out
       **/

      function scale(out, a, v) {
        var x = v[0],
            y = v[1];
        out[0] = x * a[0];
        out[1] = x * a[1];
        out[2] = x * a[2];
        out[3] = y * a[3];
        out[4] = y * a[4];
        out[5] = y * a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
      }
      /**
       * Creates a matrix from a vector translation
       * This is equivalent to (but much faster than):
       *
       *     mat3.identity(dest);
       *     mat3.translate(dest, dest, vec);
       *
       * @param {mat3} out mat3 receiving operation result
       * @param {vec2} v Translation vector
       * @returns {mat3} out
       */


      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = v[0];
        out[7] = v[1];
        out[8] = 1;
        return out;
      }
      /**
       * Creates a matrix from a given angle
       * This is equivalent to (but much faster than):
       *
       *     mat3.identity(dest);
       *     mat3.rotate(dest, dest, rad);
       *
       * @param {mat3} out mat3 receiving operation result
       * @param {Number} rad the angle to rotate the matrix by
       * @returns {mat3} out
       */


      function fromRotation(out, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad);
        out[0] = c;
        out[1] = s;
        out[2] = 0;
        out[3] = -s;
        out[4] = c;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      /**
       * Creates a matrix from a vector scaling
       * This is equivalent to (but much faster than):
       *
       *     mat3.identity(dest);
       *     mat3.scale(dest, dest, vec);
       *
       * @param {mat3} out mat3 receiving operation result
       * @param {vec2} v Scaling vector
       * @returns {mat3} out
       */


      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = v[1];
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      /**
       * Copies the values from a mat2d into a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat2d} a the matrix to copy
       * @returns {mat3} out
       **/


      function fromMat2d(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = 0;
        out[3] = a[2];
        out[4] = a[3];
        out[5] = 0;
        out[6] = a[4];
        out[7] = a[5];
        out[8] = 1;
        return out;
      }
      /**
      * Calculates a 3x3 matrix from the given quaternion
      *
      * @param {mat3} out mat3 receiving operation result
      * @param {quat} q Quaternion to create matrix from
      *
      * @returns {mat3} out
      */


      function fromQuat(out, q) {
        var x = q[0],
            y = q[1],
            z = q[2],
            w = q[3];
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        out[0] = 1 - yy - zz;
        out[3] = yx - wz;
        out[6] = zx + wy;
        out[1] = yx + wz;
        out[4] = 1 - xx - zz;
        out[7] = zy - wx;
        out[2] = zx - wy;
        out[5] = zy + wx;
        out[8] = 1 - xx - yy;
        return out;
      }
      /**
      * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
      *
      * @param {mat3} out mat3 receiving operation result
      * @param {mat4} a Mat4 to derive the normal matrix from
      *
      * @returns {mat3} out
      */


      function normalFromMat4(out, a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3];
        var a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];
        var a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
        var a30 = a[12],
            a31 = a[13],
            a32 = a[14],
            a33 = a[15];
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
          return null;
        }

        det = 1.0 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        return out;
      }
      /**
       * Generates a 2D projection matrix with the given bounds
       *
       * @param {mat3} out mat3 frustum matrix will be written into
       * @param {number} width Width of your gl context
       * @param {number} height Height of gl context
       * @returns {mat3} out
       */


      function projection(out, width, height) {
        out[0] = 2 / width;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = -2 / height;
        out[5] = 0;
        out[6] = -1;
        out[7] = 1;
        out[8] = 1;
        return out;
      }
      /**
       * Returns a string representation of a mat3
       *
       * @param {mat3} a matrix to represent as a string
       * @returns {String} string representation of the matrix
       */


      function str(a) {
        return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
      }
      /**
       * Returns Frobenius norm of a mat3
       *
       * @param {mat3} a the matrix to calculate Frobenius norm of
       * @returns {Number} Frobenius norm
       */


      function frob(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
      }
      /**
       * Adds two mat3's
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @returns {mat3} out
       */


      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        out[3] = a[3] + b[3];
        out[4] = a[4] + b[4];
        out[5] = a[5] + b[5];
        out[6] = a[6] + b[6];
        out[7] = a[7] + b[7];
        out[8] = a[8] + b[8];
        return out;
      }
      /**
       * Subtracts matrix b from matrix a
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @returns {mat3} out
       */


      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        out[3] = a[3] - b[3];
        out[4] = a[4] - b[4];
        out[5] = a[5] - b[5];
        out[6] = a[6] - b[6];
        out[7] = a[7] - b[7];
        out[8] = a[8] - b[8];
        return out;
      }
      /**
       * Multiply each element of the matrix by a scalar.
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to scale
       * @param {Number} b amount to scale the matrix's elements by
       * @returns {mat3} out
       */


      function multiplyScalar(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        out[3] = a[3] * b;
        out[4] = a[4] * b;
        out[5] = a[5] * b;
        out[6] = a[6] * b;
        out[7] = a[7] * b;
        out[8] = a[8] * b;
        return out;
      }
      /**
       * Adds two mat3's after multiplying each element of the second operand by a scalar value.
       *
       * @param {mat3} out the receiving vector
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @param {Number} scale the amount to scale b's elements by before adding
       * @returns {mat3} out
       */


      function multiplyScalarAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        out[2] = a[2] + b[2] * scale;
        out[3] = a[3] + b[3] * scale;
        out[4] = a[4] + b[4] * scale;
        out[5] = a[5] + b[5] * scale;
        out[6] = a[6] + b[6] * scale;
        out[7] = a[7] + b[7] * scale;
        out[8] = a[8] + b[8] * scale;
        return out;
      }
      /**
       * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
       *
       * @param {mat3} a The first matrix.
       * @param {mat3} b The second matrix.
       * @returns {Boolean} True if the matrices are equal, false otherwise.
       */


      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
      }
      /**
       * Returns whether or not the matrices have approximately the same elements in the same position.
       *
       * @param {mat3} a The first matrix.
       * @param {mat3} b The second matrix.
       * @returns {Boolean} True if the matrices are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3],
            a4 = a[4],
            a5 = a[5],
            a6 = a[6],
            a7 = a[7],
            a8 = a[8];
        var b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3],
            b4 = b[4],
            b5 = b[5],
            b6 = b[6],
            b7 = b[7],
            b8 = b[8];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
      }
      /**
       * Alias for {@link mat3.multiply}
       * @function
       */


      var mul = exports.mul = multiply;
      /**
       * Alias for {@link mat3.subtract}
       * @function
       */

      var sub = exports.sub = subtract;
      /***/
    },
    /* 184 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = undefined;
      exports.create = create;
      exports.clone = clone;
      exports.fromValues = fromValues;
      exports.copy = copy;
      exports.set = set;
      exports.add = add;
      exports.subtract = subtract;
      exports.multiply = multiply;
      exports.divide = divide;
      exports.ceil = ceil;
      exports.floor = floor;
      exports.min = min;
      exports.max = max;
      exports.round = round;
      exports.scale = scale;
      exports.scaleAndAdd = scaleAndAdd;
      exports.distance = distance;
      exports.squaredDistance = squaredDistance;
      exports.length = length;
      exports.squaredLength = squaredLength;
      exports.negate = negate;
      exports.inverse = inverse;
      exports.normalize = normalize;
      exports.dot = dot;
      exports.cross = cross;
      exports.lerp = lerp;
      exports.random = random;
      exports.transformMat2 = transformMat2;
      exports.transformMat2d = transformMat2d;
      exports.transformMat3 = transformMat3;
      exports.transformMat4 = transformMat4;
      exports.rotate = rotate;
      exports.angle = angle;
      exports.str = str;
      exports.exactEquals = exactEquals;
      exports.equals = equals;

      var _common = __webpack_require__(53);

      var glMatrix = _interopRequireWildcard(_common);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj["default"] = obj;
          return newObj;
        }
      }
      /**
       * 2 Dimensional Vector
       * @module vec2
       */

      /**
       * Creates a new, empty vec2
       *
       * @returns {vec2} a new 2D vector
       */


      function create() {
        var out = new glMatrix.ARRAY_TYPE(2);

        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
        }

        return out;
      }
      /**
       * Creates a new vec2 initialized with values from an existing vector
       *
       * @param {vec2} a vector to clone
       * @returns {vec2} a new 2D vector
       */


      function clone(a) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = a[0];
        out[1] = a[1];
        return out;
      }
      /**
       * Creates a new vec2 initialized with the given values
       *
       * @param {Number} x X component
       * @param {Number} y Y component
       * @returns {vec2} a new 2D vector
       */


      function fromValues(x, y) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = x;
        out[1] = y;
        return out;
      }
      /**
       * Copy the values from one vec2 to another
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the source vector
       * @returns {vec2} out
       */


      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        return out;
      }
      /**
       * Set the components of a vec2 to the given values
       *
       * @param {vec2} out the receiving vector
       * @param {Number} x X component
       * @param {Number} y Y component
       * @returns {vec2} out
       */


      function set(out, x, y) {
        out[0] = x;
        out[1] = y;
        return out;
      }
      /**
       * Adds two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        return out;
      }
      /**
       * Subtracts vector b from vector a
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        return out;
      }
      /**
       * Multiplies two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function multiply(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        return out;
      }
      /**
       * Divides two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function divide(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        return out;
      }
      /**
       * Math.ceil the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to ceil
       * @returns {vec2} out
       */


      function ceil(out, a) {
        out[0] = Math.ceil(a[0]);
        out[1] = Math.ceil(a[1]);
        return out;
      }
      /**
       * Math.floor the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to floor
       * @returns {vec2} out
       */


      function floor(out, a) {
        out[0] = Math.floor(a[0]);
        out[1] = Math.floor(a[1]);
        return out;
      }
      /**
       * Returns the minimum of two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function min(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        return out;
      }
      /**
       * Returns the maximum of two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function max(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        return out;
      }
      /**
       * Math.round the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to round
       * @returns {vec2} out
       */


      function round(out, a) {
        out[0] = Math.round(a[0]);
        out[1] = Math.round(a[1]);
        return out;
      }
      /**
       * Scales a vec2 by a scalar number
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to scale
       * @param {Number} b amount to scale the vector by
       * @returns {vec2} out
       */


      function scale(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        return out;
      }
      /**
       * Adds two vec2's after scaling the second operand by a scalar value
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @param {Number} scale the amount to scale b by before adding
       * @returns {vec2} out
       */


      function scaleAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        return out;
      }
      /**
       * Calculates the euclidian distance between two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} distance between a and b
       */


      function distance(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1];
        return Math.sqrt(x * x + y * y);
      }
      /**
       * Calculates the squared euclidian distance between two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} squared distance between a and b
       */


      function squaredDistance(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1];
        return x * x + y * y;
      }
      /**
       * Calculates the length of a vec2
       *
       * @param {vec2} a vector to calculate length of
       * @returns {Number} length of a
       */


      function length(a) {
        var x = a[0],
            y = a[1];
        return Math.sqrt(x * x + y * y);
      }
      /**
       * Calculates the squared length of a vec2
       *
       * @param {vec2} a vector to calculate squared length of
       * @returns {Number} squared length of a
       */


      function squaredLength(a) {
        var x = a[0],
            y = a[1];
        return x * x + y * y;
      }
      /**
       * Negates the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to negate
       * @returns {vec2} out
       */


      function negate(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        return out;
      }
      /**
       * Returns the inverse of the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to invert
       * @returns {vec2} out
       */


      function inverse(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        return out;
      }
      /**
       * Normalize a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to normalize
       * @returns {vec2} out
       */


      function normalize(out, a) {
        var x = a[0],
            y = a[1];
        var len = x * x + y * y;

        if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
        }

        return out;
      }
      /**
       * Calculates the dot product of two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} dot product of a and b
       */


      function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      /**
       * Computes the cross product of two vec2's
       * Note that the cross product must by definition produce a 3D vector
       *
       * @param {vec3} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec3} out
       */


      function cross(out, a, b) {
        var z = a[0] * b[1] - a[1] * b[0];
        out[0] = out[1] = 0;
        out[2] = z;
        return out;
      }
      /**
       * Performs a linear interpolation between two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec2} out
       */


      function lerp(out, a, b, t) {
        var ax = a[0],
            ay = a[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
      }
      /**
       * Generates a random vector with the given scale
       *
       * @param {vec2} out the receiving vector
       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
       * @returns {vec2} out
       */


      function random(out, scale) {
        scale = scale || 1.0;
        var r = glMatrix.RANDOM() * 2.0 * Math.PI;
        out[0] = Math.cos(r) * scale;
        out[1] = Math.sin(r) * scale;
        return out;
      }
      /**
       * Transforms the vec2 with a mat2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat2} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat2(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[2] * y;
        out[1] = m[1] * x + m[3] * y;
        return out;
      }
      /**
       * Transforms the vec2 with a mat2d
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat2d} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat2d(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[2] * y + m[4];
        out[1] = m[1] * x + m[3] * y + m[5];
        return out;
      }
      /**
       * Transforms the vec2 with a mat3
       * 3rd vector component is implicitly '1'
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat3} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat3(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[3] * y + m[6];
        out[1] = m[1] * x + m[4] * y + m[7];
        return out;
      }
      /**
       * Transforms the vec2 with a mat4
       * 3rd vector component is implicitly '0'
       * 4th vector component is implicitly '1'
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat4} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat4(out, a, m) {
        var x = a[0];
        var y = a[1];
        out[0] = m[0] * x + m[4] * y + m[12];
        out[1] = m[1] * x + m[5] * y + m[13];
        return out;
      }
      /**
       * Rotate a 2D vector
       * @param {vec2} out The receiving vec2
       * @param {vec2} a The vec2 point to rotate
       * @param {vec2} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec2} out
       */


      function rotate(out, a, b, c) {
        //Translate point to the origin
        var p0 = a[0] - b[0],
            p1 = a[1] - b[1],
            sinC = Math.sin(c),
            cosC = Math.cos(c); //perform rotation and translate to correct position

        out[0] = p0 * cosC - p1 * sinC + b[0];
        out[1] = p0 * sinC + p1 * cosC + b[1];
        return out;
      }
      /**
       * Get the angle between two 2D vectors
       * @param {vec2} a The first operand
       * @param {vec2} b The second operand
       * @returns {Number} The angle in radians
       */


      function angle(a, b) {
        var x1 = a[0],
            y1 = a[1],
            x2 = b[0],
            y2 = b[1];
        var len1 = x1 * x1 + y1 * y1;

        if (len1 > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len1 = 1 / Math.sqrt(len1);
        }

        var len2 = x2 * x2 + y2 * y2;

        if (len2 > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len2 = 1 / Math.sqrt(len2);
        }

        var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

        if (cosine > 1.0) {
          return 0;
        } else if (cosine < -1.0) {
          return Math.PI;
        } else {
          return Math.acos(cosine);
        }
      }
      /**
       * Returns a string representation of a vector
       *
       * @param {vec2} a vector to represent as a string
       * @returns {String} string representation of the vector
       */


      function str(a) {
        return 'vec2(' + a[0] + ', ' + a[1] + ')';
      }
      /**
       * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
       *
       * @param {vec2} a The first vector.
       * @param {vec2} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
      }
      /**
       * Returns whether or not the vectors have approximately the same elements in the same position.
       *
       * @param {vec2} a The first vector.
       * @param {vec2} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0],
            a1 = a[1];
        var b0 = b[0],
            b1 = b[1];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
      }
      /**
       * Alias for {@link vec2.length}
       * @function
       */


      var len = exports.len = length;
      /**
       * Alias for {@link vec2.subtract}
       * @function
       */

      var sub = exports.sub = subtract;
      /**
       * Alias for {@link vec2.multiply}
       * @function
       */

      var mul = exports.mul = multiply;
      /**
       * Alias for {@link vec2.divide}
       * @function
       */

      var div = exports.div = divide;
      /**
       * Alias for {@link vec2.distance}
       * @function
       */

      var dist = exports.dist = distance;
      /**
       * Alias for {@link vec2.squaredDistance}
       * @function
       */

      var sqrDist = exports.sqrDist = squaredDistance;
      /**
       * Alias for {@link vec2.squaredLength}
       * @function
       */

      var sqrLen = exports.sqrLen = squaredLength;
      /**
       * Perform some operation over an array of vec2s.
       *
       * @param {Array} a the array of vectors to iterate over
       * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
       * @param {Number} offset Number of elements to skip at the beginning of the array
       * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
       * @param {Function} fn Function to call for each vector in the array
       * @param {Object} [arg] additional argument to pass to fn
       * @returns {Array} a
       * @function
       */

      var forEach = exports.forEach = function () {
        var vec = create();
        return function (a, stride, offset, count, fn, arg) {
          var i = void 0,
              l = void 0;

          if (!stride) {
            stride = 2;
          }

          if (!offset) {
            offset = 0;
          }

          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }

          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
          }

          return a;
        };
      }();
      /***/

    },
    /* 185 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
      exports.create = create;
      exports.clone = clone;
      exports.length = length;
      exports.fromValues = fromValues;
      exports.copy = copy;
      exports.set = set;
      exports.add = add;
      exports.subtract = subtract;
      exports.multiply = multiply;
      exports.divide = divide;
      exports.ceil = ceil;
      exports.floor = floor;
      exports.min = min;
      exports.max = max;
      exports.round = round;
      exports.scale = scale;
      exports.scaleAndAdd = scaleAndAdd;
      exports.distance = distance;
      exports.squaredDistance = squaredDistance;
      exports.squaredLength = squaredLength;
      exports.negate = negate;
      exports.inverse = inverse;
      exports.normalize = normalize;
      exports.dot = dot;
      exports.cross = cross;
      exports.lerp = lerp;
      exports.hermite = hermite;
      exports.bezier = bezier;
      exports.random = random;
      exports.transformMat4 = transformMat4;
      exports.transformMat3 = transformMat3;
      exports.transformQuat = transformQuat;
      exports.rotateX = rotateX;
      exports.rotateY = rotateY;
      exports.rotateZ = rotateZ;
      exports.angle = angle;
      exports.str = str;
      exports.exactEquals = exactEquals;
      exports.equals = equals;

      var _common = __webpack_require__(53);

      var glMatrix = _interopRequireWildcard(_common);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj["default"] = obj;
          return newObj;
        }
      }
      /**
       * 3 Dimensional Vector
       * @module vec3
       */

      /**
       * Creates a new, empty vec3
       *
       * @returns {vec3} a new 3D vector
       */


      function create() {
        var out = new glMatrix.ARRAY_TYPE(3);

        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
        }

        return out;
      }
      /**
       * Creates a new vec3 initialized with values from an existing vector
       *
       * @param {vec3} a vector to clone
       * @returns {vec3} a new 3D vector
       */


      function clone(a) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
      }
      /**
       * Calculates the length of a vec3
       *
       * @param {vec3} a vector to calculate length of
       * @returns {Number} length of a
       */


      function length(a) {
        var x = a[0];
        var y = a[1];
        var z = a[2];
        return Math.sqrt(x * x + y * y + z * z);
      }
      /**
       * Creates a new vec3 initialized with the given values
       *
       * @param {Number} x X component
       * @param {Number} y Y component
       * @param {Number} z Z component
       * @returns {vec3} a new 3D vector
       */


      function fromValues(x, y, z) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
      }
      /**
       * Copy the values from one vec3 to another
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the source vector
       * @returns {vec3} out
       */


      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
      }
      /**
       * Set the components of a vec3 to the given values
       *
       * @param {vec3} out the receiving vector
       * @param {Number} x X component
       * @param {Number} y Y component
       * @param {Number} z Z component
       * @returns {vec3} out
       */


      function set(out, x, y, z) {
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
      }
      /**
       * Adds two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        return out;
      }
      /**
       * Subtracts vector b from vector a
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        return out;
      }
      /**
       * Multiplies two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function multiply(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        out[2] = a[2] * b[2];
        return out;
      }
      /**
       * Divides two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function divide(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        out[2] = a[2] / b[2];
        return out;
      }
      /**
       * Math.ceil the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to ceil
       * @returns {vec3} out
       */


      function ceil(out, a) {
        out[0] = Math.ceil(a[0]);
        out[1] = Math.ceil(a[1]);
        out[2] = Math.ceil(a[2]);
        return out;
      }
      /**
       * Math.floor the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to floor
       * @returns {vec3} out
       */


      function floor(out, a) {
        out[0] = Math.floor(a[0]);
        out[1] = Math.floor(a[1]);
        out[2] = Math.floor(a[2]);
        return out;
      }
      /**
       * Returns the minimum of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function min(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        out[2] = Math.min(a[2], b[2]);
        return out;
      }
      /**
       * Returns the maximum of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function max(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        out[2] = Math.max(a[2], b[2]);
        return out;
      }
      /**
       * Math.round the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to round
       * @returns {vec3} out
       */


      function round(out, a) {
        out[0] = Math.round(a[0]);
        out[1] = Math.round(a[1]);
        out[2] = Math.round(a[2]);
        return out;
      }
      /**
       * Scales a vec3 by a scalar number
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to scale
       * @param {Number} b amount to scale the vector by
       * @returns {vec3} out
       */


      function scale(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        return out;
      }
      /**
       * Adds two vec3's after scaling the second operand by a scalar value
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {Number} scale the amount to scale b by before adding
       * @returns {vec3} out
       */


      function scaleAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        out[2] = a[2] + b[2] * scale;
        return out;
      }
      /**
       * Calculates the euclidian distance between two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} distance between a and b
       */


      function distance(a, b) {
        var x = b[0] - a[0];
        var y = b[1] - a[1];
        var z = b[2] - a[2];
        return Math.sqrt(x * x + y * y + z * z);
      }
      /**
       * Calculates the squared euclidian distance between two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} squared distance between a and b
       */


      function squaredDistance(a, b) {
        var x = b[0] - a[0];
        var y = b[1] - a[1];
        var z = b[2] - a[2];
        return x * x + y * y + z * z;
      }
      /**
       * Calculates the squared length of a vec3
       *
       * @param {vec3} a vector to calculate squared length of
       * @returns {Number} squared length of a
       */


      function squaredLength(a) {
        var x = a[0];
        var y = a[1];
        var z = a[2];
        return x * x + y * y + z * z;
      }
      /**
       * Negates the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to negate
       * @returns {vec3} out
       */


      function negate(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        out[2] = -a[2];
        return out;
      }
      /**
       * Returns the inverse of the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to invert
       * @returns {vec3} out
       */


      function inverse(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        out[2] = 1.0 / a[2];
        return out;
      }
      /**
       * Normalize a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to normalize
       * @returns {vec3} out
       */


      function normalize(out, a) {
        var x = a[0];
        var y = a[1];
        var z = a[2];
        var len = x * x + y * y + z * z;

        if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
          out[2] = a[2] * len;
        }

        return out;
      }
      /**
       * Calculates the dot product of two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} dot product of a and b
       */


      function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      /**
       * Computes the cross product of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function cross(out, a, b) {
        var ax = a[0],
            ay = a[1],
            az = a[2];
        var bx = b[0],
            by = b[1],
            bz = b[2];
        out[0] = ay * bz - az * by;
        out[1] = az * bx - ax * bz;
        out[2] = ax * by - ay * bx;
        return out;
      }
      /**
       * Performs a linear interpolation between two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec3} out
       */


      function lerp(out, a, b, t) {
        var ax = a[0];
        var ay = a[1];
        var az = a[2];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        out[2] = az + t * (b[2] - az);
        return out;
      }
      /**
       * Performs a hermite interpolation with two control points
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {vec3} c the third operand
       * @param {vec3} d the fourth operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec3} out
       */


      function hermite(out, a, b, c, d, t) {
        var factorTimes2 = t * t;
        var factor1 = factorTimes2 * (2 * t - 3) + 1;
        var factor2 = factorTimes2 * (t - 2) + t;
        var factor3 = factorTimes2 * (t - 1);
        var factor4 = factorTimes2 * (3 - 2 * t);
        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
        return out;
      }
      /**
       * Performs a bezier interpolation with two control points
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {vec3} c the third operand
       * @param {vec3} d the fourth operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec3} out
       */


      function bezier(out, a, b, c, d, t) {
        var inverseFactor = 1 - t;
        var inverseFactorTimesTwo = inverseFactor * inverseFactor;
        var factorTimes2 = t * t;
        var factor1 = inverseFactorTimesTwo * inverseFactor;
        var factor2 = 3 * t * inverseFactorTimesTwo;
        var factor3 = 3 * factorTimes2 * inverseFactor;
        var factor4 = factorTimes2 * t;
        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
        return out;
      }
      /**
       * Generates a random vector with the given scale
       *
       * @param {vec3} out the receiving vector
       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
       * @returns {vec3} out
       */


      function random(out, scale) {
        scale = scale || 1.0;
        var r = glMatrix.RANDOM() * 2.0 * Math.PI;
        var z = glMatrix.RANDOM() * 2.0 - 1.0;
        var zScale = Math.sqrt(1.0 - z * z) * scale;
        out[0] = Math.cos(r) * zScale;
        out[1] = Math.sin(r) * zScale;
        out[2] = z * scale;
        return out;
      }
      /**
       * Transforms the vec3 with a mat4.
       * 4th vector component is implicitly '1'
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {mat4} m matrix to transform with
       * @returns {vec3} out
       */


      function transformMat4(out, a, m) {
        var x = a[0],
            y = a[1],
            z = a[2];
        var w = m[3] * x + m[7] * y + m[11] * z + m[15];
        w = w || 1.0;
        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return out;
      }
      /**
       * Transforms the vec3 with a mat3.
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {mat3} m the 3x3 matrix to transform with
       * @returns {vec3} out
       */


      function transformMat3(out, a, m) {
        var x = a[0],
            y = a[1],
            z = a[2];
        out[0] = x * m[0] + y * m[3] + z * m[6];
        out[1] = x * m[1] + y * m[4] + z * m[7];
        out[2] = x * m[2] + y * m[5] + z * m[8];
        return out;
      }
      /**
       * Transforms the vec3 with a quat
       * Can also be used for dual quaternions. (Multiply it with the real part)
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {quat} q quaternion to transform with
       * @returns {vec3} out
       */


      function transformQuat(out, a, q) {
        // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
        var qx = q[0],
            qy = q[1],
            qz = q[2],
            qw = q[3];
        var x = a[0],
            y = a[1],
            z = a[2]; // var qvec = [qx, qy, qz];
        // var uv = vec3.cross([], qvec, a);

        var uvx = qy * z - qz * y,
            uvy = qz * x - qx * z,
            uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

        var uuvx = qy * uvz - qz * uvy,
            uuvy = qz * uvx - qx * uvz,
            uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

        var w2 = qw * 2;
        uvx *= w2;
        uvy *= w2;
        uvz *= w2; // vec3.scale(uuv, uuv, 2);

        uuvx *= 2;
        uuvy *= 2;
        uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

        out[0] = x + uvx + uuvx;
        out[1] = y + uvy + uuvy;
        out[2] = z + uvz + uuvz;
        return out;
      }
      /**
       * Rotate a 3D vector around the x-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */


      function rotateX(out, a, b, c) {
        var p = [],
            r = []; //Translate point to the origin

        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2]; //perform rotation

        r[0] = p[0];
        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      /**
       * Rotate a 3D vector around the y-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */


      function rotateY(out, a, b, c) {
        var p = [],
            r = []; //Translate point to the origin

        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2]; //perform rotation

        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      /**
       * Rotate a 3D vector around the z-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */


      function rotateZ(out, a, b, c) {
        var p = [],
            r = []; //Translate point to the origin

        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2]; //perform rotation

        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
        r[2] = p[2]; //translate to correct position

        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      /**
       * Get the angle between two 3D vectors
       * @param {vec3} a The first operand
       * @param {vec3} b The second operand
       * @returns {Number} The angle in radians
       */


      function angle(a, b) {
        var tempA = fromValues(a[0], a[1], a[2]);
        var tempB = fromValues(b[0], b[1], b[2]);
        normalize(tempA, tempA);
        normalize(tempB, tempB);
        var cosine = dot(tempA, tempB);

        if (cosine > 1.0) {
          return 0;
        } else if (cosine < -1.0) {
          return Math.PI;
        } else {
          return Math.acos(cosine);
        }
      }
      /**
       * Returns a string representation of a vector
       *
       * @param {vec3} a vector to represent as a string
       * @returns {String} string representation of the vector
       */


      function str(a) {
        return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
      }
      /**
       * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
       *
       * @param {vec3} a The first vector.
       * @param {vec3} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
      }
      /**
       * Returns whether or not the vectors have approximately the same elements in the same position.
       *
       * @param {vec3} a The first vector.
       * @param {vec3} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0],
            a1 = a[1],
            a2 = a[2];
        var b0 = b[0],
            b1 = b[1],
            b2 = b[2];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
      }
      /**
       * Alias for {@link vec3.subtract}
       * @function
       */


      var sub = exports.sub = subtract;
      /**
       * Alias for {@link vec3.multiply}
       * @function
       */

      var mul = exports.mul = multiply;
      /**
       * Alias for {@link vec3.divide}
       * @function
       */

      var div = exports.div = divide;
      /**
       * Alias for {@link vec3.distance}
       * @function
       */

      var dist = exports.dist = distance;
      /**
       * Alias for {@link vec3.squaredDistance}
       * @function
       */

      var sqrDist = exports.sqrDist = squaredDistance;
      /**
       * Alias for {@link vec3.length}
       * @function
       */

      var len = exports.len = length;
      /**
       * Alias for {@link vec3.squaredLength}
       * @function
       */

      var sqrLen = exports.sqrLen = squaredLength;
      /**
       * Perform some operation over an array of vec3s.
       *
       * @param {Array} a the array of vectors to iterate over
       * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
       * @param {Number} offset Number of elements to skip at the beginning of the array
       * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
       * @param {Function} fn Function to call for each vector in the array
       * @param {Object} [arg] additional argument to pass to fn
       * @returns {Array} a
       * @function
       */

      var forEach = exports.forEach = function () {
        var vec = create();
        return function (a, stride, offset, count, fn, arg) {
          var i = void 0,
              l = void 0;

          if (!stride) {
            stride = 3;
          }

          if (!offset) {
            offset = 0;
          }

          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }

          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
          }

          return a;
        };
      }();
      /***/

    },
    /* 186 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      module.exports = {
        canFill: false,
        canStroke: false,
        initAttrs: function initAttrs(attrs) {
          this._attrs = {
            opacity: 1,
            fillOpacity: 1,
            strokeOpacity: 1,
            matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
          };
          this.attr(Util.assign(this.getDefaultAttrs(), attrs));
          return this;
        },
        getDefaultAttrs: function getDefaultAttrs() {
          return {};
        },

        /**
         * 设置或者设置属性，有以下 4 种情形：
         *   - name 不存在, 则返回属性集合
         *   - name 为字符串，value 为空，获取属性值
         *   - name 为字符串，value 不为空，设置属性值，返回 this
         *   - name 为键值对，value 为空，设置属性值
         *
         * @param  {String | Object} name  属性名
         * @param  {*} value 属性值
         * @return {*} 属性值
         */
        attr: function attr(name, value) {
          var self = this;

          if (arguments.length === 0) {
            return self._attrs;
          }

          if (Util.isObject(name)) {
            // self._attrs = Util.deepMix(self._attrs, name);
            for (var k in name) {
              this._setAttr(k, name[k]);
            }

            self.clearBBox();
            this._cfg.hasUpdate = true;
            return self;
          }

          if (arguments.length === 2) {
            this._setAttr(name, value);

            self.clearBBox();
            this._cfg.hasUpdate = true;
            return self;
          }

          return self._attrs[name];
        },
        _setAttr: function _setAttr(name, value) {
          var self = this;
          var attrs = this._attrs;
          attrs[name] = value;

          if (name === 'fill' || name === 'stroke') {
            attrs[name + 'Style'] = value;
            return;
          }

          if (name === 'opacity') {
            attrs.globalAlpha = value;
            return;
          }

          if (name === 'clip' && value) {
            self._setClip(value);

            return;
          }

          if (name === 'path' && self._afterSetAttrPath) {
            self._afterSetAttrPath(value);

            return;
          }

          if (name === 'transform') {
            self.transform(value);
            return;
          }

          if (name === 'rotate') {
            self.rotateAtStart(value);
          }
        },
        clearBBox: function clearBBox() {
          this.setSilent('box', null);
        },
        hasFill: function hasFill() {
          return this.canFill && this._attrs.fillStyle;
        },
        hasStroke: function hasStroke() {
          return this.canStroke && this._attrs.strokeStyle;
        },
        _setClip: function _setClip(item) {
          item._cfg.renderer = this._cfg.renderer;
          item._cfg.canvas = this._cfg.canvas;
          item._cfg.parent = this._cfg.parent;

          item.hasFill = function () {
            return true;
          };
        }
      };
      /***/
    },
    /* 187 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1); // 是否未改变


      function isUnchanged(m) {
        return m[0] === 1 && m[1] === 0 && m[3] === 0 && m[4] === 1 && m[6] === 0 && m[7] === 0;
      } // 是否仅仅是scale


      function isScale(m) {
        return m[1] === 0 && m[3] === 0 && m[6] === 0 && m[7] === 0;
      }

      function multiple(m1, m2) {
        if (!isUnchanged(m2)) {
          if (isScale(m2)) {
            m1[0] *= m2[0];
            m1[4] *= m2[4];
          } else {
            Util.mat3.multiply(m1, m1, m2);
          }
        }
      }

      module.exports = {
        initTransform: function initTransform() {},
        resetMatrix: function resetMatrix() {
          this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        },
        translate: function translate(tx, ty) {
          var matrix = this._attrs.matrix;
          Util.mat3.translate(matrix, matrix, [tx, ty]);
          this.clearTotalMatrix();
          this.attr('matrix', matrix);
          return this;
        },
        rotate: function rotate(radian) {
          var matrix = this._attrs.matrix;
          Util.mat3.rotate(matrix, matrix, radian);
          this.clearTotalMatrix();
          this.attr('matrix', matrix);
          return this;
        },
        scale: function scale(s1, s2) {
          var matrix = this._attrs.matrix;
          Util.mat3.scale(matrix, matrix, [s1, s2]);
          this.clearTotalMatrix();
          this.attr('matrix', matrix);
          return this;
        },
        rotateAtStart: function rotateAtStart(rotate) {
          var x = this._attrs.x || this._cfg.attrs.x;
          var y = this._attrs.y || this._cfg.attrs.y;

          if (Math.abs(rotate) > Math.PI * 2) {
            rotate = rotate / 180 * Math.PI;
          }

          return this.transform([['t', -x, -y], ['r', rotate], ['t', x, y]]);
        },
        move: function move(x, y) {
          var cx = this.get('x') || 0; // 当前的x

          var cy = this.get('y') || 0; // 当前的y

          this.translate(x - cx, y - cy);
          this.set('x', x);
          this.set('y', y);
          return this;
        },
        transform: function transform(ts) {
          var self = this;
          var matrix = this._attrs.matrix;
          Util.each(ts, function (t) {
            switch (t[0]) {
              case 't':
                self.translate(t[1], t[2]);
                break;

              case 's':
                self.scale(t[1], t[2]);
                break;

              case 'r':
                self.rotate(t[1]);
                break;

              case 'm':
                self.attr('matrix', Util.mat3.multiply([], matrix, t[1]));
                self.clearTotalMatrix();
                break;

              default:
                break;
            }
          });
          return self;
        },
        setTransform: function setTransform(ts) {
          this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);
          return this.transform(ts);
        },
        getMatrix: function getMatrix() {
          return this.attr('matrix');
        },
        setMatrix: function setMatrix(m) {
          this.attr('matrix', m);
          this.clearTotalMatrix();
          return this;
        },
        apply: function apply(v, root) {
          var m;

          if (root) {
            m = this._getMatrixByRoot(root);
          } else {
            m = this.attr('matrix');
          }

          Util.vec3.transformMat3(v, v, m);
          return this;
        },
        // 获取到达指定根节点的矩阵
        _getMatrixByRoot: function _getMatrixByRoot(root) {
          var self = this;
          root = root || self;
          var parent = self;
          var parents = [];

          while (parent !== root) {
            parents.unshift(parent);
            parent = parent.get('parent');
          }

          parents.unshift(parent);
          var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          Util.each(parents, function (child) {
            Util.mat3.multiply(m, child.attr('matrix'), m);
          });
          return m;
        },

        /**
         * 应用到当前元素上的总的矩阵
         * @return {Matrix} 矩阵
         */
        getTotalMatrix: function getTotalMatrix() {
          var m = this._cfg.totalMatrix;

          if (!m) {
            m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            var parent = this._cfg.parent;

            if (parent) {
              var pm = parent.getTotalMatrix();
              multiple(m, pm);
            }

            multiple(m, this.attr('matrix'));
            this._cfg.totalMatrix = m;
          }

          return m;
        },
        // 清除当前的矩阵
        clearTotalMatrix: function clearTotalMatrix() {// this._cfg.totalMatrix = null;
        },
        invert: function invert(v) {
          var m = this.getTotalMatrix(); // 单精屏幕下大多数矩阵没变化

          if (isScale(m)) {
            v[0] /= m[0];
            v[1] /= m[4];
          } else {
            var inm = Util.mat3.invert([], m);

            if (inm) {
              Util.vec3.transformMat3(v, v, inm);
            }
          }

          return this;
        },
        resetTransform: function resetTransform(context) {
          var mo = this.attr('matrix'); // 不改变时

          if (!isUnchanged(mo)) {
            context.transform(mo[0], mo[1], mo[3], mo[4], mo[6], mo[7]);
          }
        }
      };
      /***/
    },
    /* 188 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var ReservedProps = {
        delay: 'delay',
        rotate: 'rotate'
      };
      var colorRalaredProps = {
        fill: 'fill',
        stroke: 'stroke',
        fillStyle: 'fillStyle',
        strokeStyle: 'strokeStyle'
      };

      function getFromAttrs(toAttrs, shape) {
        var rst = {};
        var attrs = shape._attrs;

        for (var k in toAttrs.attrs) {
          rst[k] = attrs[k];
        }

        return rst;
      }

      function getFormatProps(props, shape) {
        var rst = {
          matrix: null,
          attrs: {}
        };
        var attrs = shape._attrs;

        for (var k in props) {
          if (k === 'transform') {
            rst.matrix = Util.transform(shape.getMatrix(), props[k]);
          } else if (k === 'rotate') {
            rst.matrix = Util.transform(shape.getMatrix(), [['r', props[k]]]);
          } else if (k === 'matrix') {
            rst.matrix = props[k];
          } else if (colorRalaredProps[k] && /^[r,R,L,l]{1}[\s]*\(/.test(props[k])) {
            // 渐变色不支持动画
            continue;
          } else if (!ReservedProps[k] && attrs[k] !== props[k]) {
            rst.attrs[k] = props[k];
          }
        }

        return rst;
      }

      function checkExistedAttrs(animators, animator) {
        var delay = animator.delay;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        Util.each(animator.toAttrs, function (v, k) {
          Util.each(animators, function (animator) {
            if (delay < animator.startTime + animator.duration) {
              if (hasOwnProperty.call(animator.toAttrs, k)) {
                delete animator.toAttrs[k];
                delete animator.fromAttrs[k];
              }
            }
          });
        });

        if (animator.toMatrix) {
          Util.each(animators, function (animator) {
            if (delay < animator.startTime + animator.duration && animator.toMatrix) {
              delete animator.toMatrix;
            }
          });
        }

        return animators;
      }

      module.exports = {
        /**
         * 执行动画
         * @param  {Object}   toProps  动画最终状态
         * @param  {Number}   duration 动画执行时间
         * @param  {String}   easing   动画缓动效果
         * @param  {Function} callback 动画执行后的回调
         * @param  {Number}   delay    动画延迟时间
         */
        animate: function animate(toProps, duration, easing, callback, delay) {
          if (delay === void 0) {
            delay = 0;
          }

          var self = this;
          self.set('animating', true);
          var timeline = self.get('timeline');

          if (!timeline) {
            timeline = self.get('canvas').get('timeline');
            self.setSilent('timeline', timeline);
          }

          var animators = self.get('animators') || []; // 初始化tick

          if (!timeline._timer) {
            timeline.initTimer();
          }

          if (Util.isNumber(callback)) {
            delay = callback;
            callback = null;
          }

          if (Util.isFunction(easing)) {
            callback = easing;
            easing = 'easeLinear';
          } else {
            easing = easing ? easing : 'easeLinear';
          }

          var formatProps = getFormatProps(toProps, self); // 记录动画属性

          var animator = {
            fromAttrs: getFromAttrs(formatProps, self),
            toAttrs: formatProps.attrs,
            fromMatrix: Util.clone(self.getMatrix()),
            toMatrix: formatProps.matrix,
            duration: duration,
            easing: easing,
            callback: callback,
            delay: delay,
            startTime: timeline.getTime(),
            id: Util.uniqueId()
          }; // 如果动画队列中已经有这个图形了

          if (animators.length > 0) {
            // 先检查是否需要合并属性。若有相同的动画，将该属性从前一个动画中删除,直接用后一个动画中
            animators = checkExistedAttrs(animators, animator);
          } else {
            // 否则将图形添加到队列
            timeline.addAnimator(self);
          }

          animators.push(animator);
          self.setSilent('animators', animators);
          self.setSilent('pause', {
            isPaused: false
          });
        },
        stopAnimate: function stopAnimate() {
          var _this = this;

          var animators = this.get('animators'); // 将动画执行到最后一帧，执行回调

          Util.each(animators, function (animator) {
            _this.attr(animator.toAttrs);

            if (animator.toMatrix) {
              _this.attr('matrix', animator.toMatrix);
            }

            if (animator.callback) {
              animator.callback();
            }
          });
          this.setSilent('animating', false);
          this.setSilent('animators', []);
        },
        pauseAnimate: function pauseAnimate() {
          var self = this;
          var timeline = self.get('timeline'); // 记录下是在什么时候暂停的

          self.setSilent('pause', {
            isPaused: true,
            pauseTime: timeline.getTime()
          });
          return self;
        },
        resumeAnimate: function resumeAnimate() {
          var self = this;
          var timeline = self.get('timeline');
          var current = timeline.getTime();
          var animators = self.get('animators');
          var pauseTime = self.get('pause').pauseTime; // 之后更新属性需要计算动画已经执行的时长，如果暂停了，就把初始时间调后

          Util.each(animators, function (animator) {
            animator.startTime = animator.startTime + (current - pauseTime);
            animator._paused = false;
            animator._pauseTime = null;
          });
          self.setSilent('pause', {
            isPaused: false
          });
          self.setSilent('animators', animators);
          return self;
        }
      };
      /***/
    },
    /* 189 */

    /***/
    function (module, exports, __webpack_require__) {
      var Shape = __webpack_require__(6);

      Shape.Arc = __webpack_require__(105);
      Shape.Circle = __webpack_require__(106);
      Shape.Dom = __webpack_require__(107);
      Shape.Ellipse = __webpack_require__(108);
      Shape.Fan = __webpack_require__(109);
      Shape.Image = __webpack_require__(110);
      Shape.Line = __webpack_require__(111);
      Shape.Marker = __webpack_require__(57);
      Shape.Path = __webpack_require__(112);
      Shape.Polygon = __webpack_require__(113);
      Shape.Polyline = __webpack_require__(114);
      Shape.Rect = __webpack_require__(115);
      Shape.Text = __webpack_require__(116);
      module.exports = Shape;
      /***/
    },
    /* 190 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var Inside = __webpack_require__(55);

      var mathUtl = {
        arc: __webpack_require__(37),
        ellipse: __webpack_require__(104),
        line: __webpack_require__(36)
      };
      var canvas = Util.createDom('<canvas width="500" height="500"></canvas>');
      var context = canvas.getContext('2d');

      function isPointInPathByContext(x, y, ctx) {
        ctx.createPath(context);
        return context.isPointInPath(x, y);
      }

      var arc = function arc(x, y) {
        var attrs = this._attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.r,
            startAngle = attrs.startAngle,
            endAngle = attrs.endAngle,
            clockwise = attrs.clockwise;
        var lineWidth = this.getHitLineWidth();

        if (this.hasStroke()) {
          return Inside.arcline(cx, cy, r, startAngle, endAngle, clockwise, lineWidth, x, y);
        }

        return false;
      };

      var circle = function circle(x, y) {
        var attrs = this._attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.r;
        var lineWidth = this.getHitLineWidth();
        var fill = this.hasFill();
        var stroke = this.hasStroke();

        if (fill && stroke) {
          return Inside.circle(cx, cy, r, x, y) || Inside.arcline(cx, cy, r, 0, Math.PI * 2, false, lineWidth, x, y);
        }

        if (fill) {
          return Inside.circle(cx, cy, r, x, y);
        }

        if (stroke) {
          return Inside.arcline(cx, cy, r, 0, Math.PI * 2, false, lineWidth, x, y);
        }

        return false;
      };

      var ellipse = function ellipse(x, y) {
        var attrs = this._attrs;
        var fill = this.hasFill();
        var stroke = this.hasStroke();
        var cx = attrs.x;
        var cy = attrs.y;
        var rx = attrs.rx;
        var ry = attrs.ry;
        var lineWidth = this.getHitLineWidth();
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var p = [x, y, 1];
        var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        Util.mat3.scale(m, m, [scaleX, scaleY]);
        Util.mat3.translate(m, m, [cx, cy]);
        var inm = Util.mat3.invert([], m);
        Util.vec3.transformMat3(p, p, inm);

        if (fill && stroke) {
          return Inside.circle(0, 0, r, p[0], p[1]) || Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]);
        }

        if (fill) {
          return Inside.circle(0, 0, r, p[0], p[1]);
        }

        if (stroke) {
          return Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]);
        }

        return false;
      };

      var fan = function fan(x, y) {
        var self = this;
        var fill = self.hasFill();
        var stroke = self.hasStroke();
        var attrs = self._attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var rs = attrs.rs;
        var re = attrs.re;
        var startAngle = attrs.startAngle;
        var endAngle = attrs.endAngle;
        var clockwise = attrs.clockwise;
        var v1 = [1, 0];
        var subv = [x - cx, y - cy];
        var angle = Util.vec2.angleTo(v1, subv);

        function _isPointInFill() {
          var angle1 = mathUtl.arc.nearAngle(angle, startAngle, endAngle, clockwise);

          if (Util.isNumberEqual(angle, angle1)) {
            var ls = Util.vec2.squaredLength(subv);

            if (rs * rs <= ls && ls <= re * re) {
              return true;
            }
          }

          return false;
        }

        function _isPointInStroke() {
          var lineWidth = self.getHitLineWidth();
          var ssp = {
            x: Math.cos(startAngle) * rs + cx,
            y: Math.sin(startAngle) * rs + cy
          };
          var sep = {
            x: Math.cos(startAngle) * re + cx,
            y: Math.sin(startAngle) * re + cy
          };
          var esp = {
            x: Math.cos(endAngle) * rs + cx,
            y: Math.sin(endAngle) * rs + cy
          };
          var eep = {
            x: Math.cos(endAngle) * re + cx,
            y: Math.sin(endAngle) * re + cy
          };

          if (Inside.line(ssp.x, ssp.y, sep.x, sep.y, lineWidth, x, y)) {
            return true;
          }

          if (Inside.line(esp.x, esp.y, eep.x, eep.y, lineWidth, x, y)) {
            return true;
          }

          if (Inside.arcline(cx, cy, rs, startAngle, endAngle, clockwise, lineWidth, x, y)) {
            return true;
          }

          if (Inside.arcline(cx, cy, re, startAngle, endAngle, clockwise, lineWidth, x, y)) {
            return true;
          }

          return false;
        }

        if (fill && stroke) {
          return _isPointInFill() || _isPointInStroke();
        }

        if (fill) {
          return _isPointInFill();
        }

        if (stroke) {
          return _isPointInStroke();
        }

        return false;
      };

      var image = function image(x, y) {
        var attrs = this._attrs;

        if (this.get('toDraw') || !attrs.img) {
          return false;
        }

        if (!this._cfg.attrs || this._cfg.attrs.img !== attrs.img) {
          this._setAttrImg();
        }

        var rx = attrs.x;
        var ry = attrs.y;
        var width = attrs.width;
        var height = attrs.height;
        return Inside.rect(rx, ry, width, height, x, y);
      };

      var line = function line(x, y) {
        var attrs = this._attrs;
        var x1 = attrs.x1,
            y1 = attrs.y1,
            x2 = attrs.x2,
            y2 = attrs.y2;
        var lineWidth = this.getHitLineWidth();

        if (this.hasStroke()) {
          return Inside.line(x1, y1, x2, y2, lineWidth, x, y);
        }

        return false;
      };

      var path = function path(x, y) {
        var self = this;
        var segments = self.get('segments');
        var fill = self.hasFill();
        var stroke = self.hasStroke();

        function _isPointInStroke() {
          if (!Util.isEmpty(segments)) {
            var lineWidth = self.getHitLineWidth();

            for (var i = 0, l = segments.length; i < l; i++) {
              if (segments[i].isInside(x, y, lineWidth)) {
                return true;
              }
            }

            return false;
          }
        }

        if (fill && stroke) {
          return isPointInPathByContext(x, y, self) || _isPointInStroke();
        }

        if (fill) {
          return isPointInPathByContext(x, y, self);
        }

        if (stroke) {
          return _isPointInStroke();
        }

        return false;
      };

      var polygon = function polygon(x, y) {
        var self = this;
        var fill = self.hasFill();
        var stroke = self.hasStroke();

        function _isPointInStroke() {
          var attrs = self._attrs;
          var points = attrs.points;

          if (points.length < 2) {
            return false;
          }

          var lineWidth = self.getHitLineWidth();
          var outPoints = points.slice(0);

          if (points.length >= 3) {
            outPoints.push(points[0]);
          }

          return Inside.polyline(outPoints, lineWidth, x, y);
        }

        if (fill && stroke) {
          return isPointInPathByContext(x, y, self) || _isPointInStroke();
        }

        if (fill) {
          return isPointInPathByContext(x, y, self);
        }

        if (stroke) {
          return _isPointInStroke();
        }

        return false;
      };

      var marker = function marker(x, y) {
        var attrs = this._attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.radius || attrs.r;
        var lineWidth = this.getHitLineWidth();
        return Inside.circle(cx, cy, r + lineWidth / 2, x, y);
      };

      var polyline = function polyline(x, y) {
        var self = this;
        var attrs = self._attrs;

        if (self.hasStroke()) {
          var points = attrs.points;

          if (points.length < 2) {
            return false;
          }

          var lineWidth = attrs.lineWidth;
          return Inside.polyline(points, lineWidth, x, y);
        }

        return false;
      };

      var rect = function rect(x, y) {
        var self = this;
        var fill = self.hasFill();
        var stroke = self.hasStroke();

        function _isPointInStroke() {
          var attrs = self._attrs;
          var rx = attrs.x;
          var ry = attrs.y;
          var width = attrs.width;
          var height = attrs.height;
          var radius = attrs.radius;
          var lineWidth = self.getHitLineWidth();

          if (radius === 0) {
            var halfWidth = lineWidth / 2;
            return Inside.line(rx - halfWidth, ry, rx + width + halfWidth, ry, lineWidth, x, y) || Inside.line(rx + width, ry - halfWidth, rx + width, ry + height + halfWidth, lineWidth, x, y) || Inside.line(rx + width + halfWidth, ry + height, rx - halfWidth, ry + height, lineWidth, x, y) || Inside.line(rx, ry + height + halfWidth, rx, ry - halfWidth, lineWidth, x, y);
          }

          return Inside.line(rx + radius, ry, rx + width - radius, ry, lineWidth, x, y) || Inside.line(rx + width, ry + radius, rx + width, ry + height - radius, lineWidth, x, y) || Inside.line(rx + width - radius, ry + height, rx + radius, ry + height, lineWidth, x, y) || Inside.line(rx, ry + height - radius, rx, ry + radius, lineWidth, x, y) || Inside.arcline(rx + width - radius, ry + radius, radius, 1.5 * Math.PI, 2 * Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + width - radius, ry + height - radius, radius, 0, 0.5 * Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + radius, ry + height - radius, radius, 0.5 * Math.PI, Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + radius, ry + radius, radius, Math.PI, 1.5 * Math.PI, false, lineWidth, x, y);
        }

        if (fill && stroke) {
          return isPointInPathByContext(x, y, self) || _isPointInStroke();
        }

        if (fill) {
          return isPointInPathByContext(x, y, self);
        }

        if (stroke) {
          return _isPointInStroke();
        }

        return false;
      };

      var text = function text(x, y) {
        var self = this;
        var box = self.getBBox();

        if (self.hasFill() || self.hasStroke()) {
          return Inside.box(box.minX, box.maxX, box.minY, box.maxY, x, y);
        }
      };

      var dom = function dom(x, y) {
        if (!this._cfg.el) {
          return false;
        }

        var box = this._cfg.el.getBBox();

        return Inside.box(box.x, box.x + box.width, box.y, box.y + box.height, x, y);
      };

      var shapes = {
        arc: arc,
        circle: circle,
        dom: dom,
        ellipse: ellipse,
        fan: fan,
        image: image,
        line: line,
        path: path,
        marker: marker,
        polygon: polygon,
        polyline: polyline,
        rect: rect,
        text: text
      };
      module.exports = {
        isPointInPath: function isPointInPath(x, y) {
          var shape = shapes[this.type];

          if (shape) {
            return shape.call(this, x, y);
          }

          return false;
        }
      };
      /***/
    },
    /* 191 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var PathUtil = __webpack_require__(58);

      var d3Timer = __webpack_require__(170);

      var d3Ease = __webpack_require__(173);

      var _require = __webpack_require__(204),
          interpolate = _require.interpolate,
          interpolateArray = _require.interpolateArray; // 目前整体动画只需要数值和数组的差值计算


      var Timeline = function Timeline(canvas) {
        // 待执行动画的队列
        this._animators = []; // 当前时间

        this._current = 0; // 计时器实例

        this._timer = null; // 画布

        this.canvas = canvas;
      };

      function _update(self, animator, ratio) {
        var cProps = {}; // 此刻属性

        var toAttrs = animator.toAttrs;
        var fromAttrs = animator.fromAttrs;
        var toMatrix = animator.toMatrix;

        if (self.get('destroyed')) {
          return;
        }

        var interf; //  差值函数

        for (var k in toAttrs) {
          if (!Util.isEqual(fromAttrs[k], toAttrs[k])) {
            if (k === 'path') {
              var toPath = toAttrs[k];
              var fromPath = fromAttrs[k];

              if (toPath.length > fromPath.length) {
                toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态

                fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态

                fromPath = PathUtil.fillPathByDiff(fromPath, toPath);
                fromPath = PathUtil.formatPath(fromPath, toPath);
                animator.fromAttrs.path = fromPath;
                animator.toAttrs.path = toPath;
              } else if (!animator.pathFormatted) {
                toPath = PathUtil.parsePathString(toAttrs[k]);
                fromPath = PathUtil.parsePathString(fromAttrs[k]);
                fromPath = PathUtil.formatPath(fromPath, toPath);
                animator.fromAttrs.path = fromPath;
                animator.toAttrs.path = toPath;
                animator.pathFormatted = true;
              }

              cProps[k] = [];

              for (var i = 0; i < toPath.length; i++) {
                var toPathPoint = toPath[i];
                var fromPathPoint = fromPath[i];
                var cPathPoint = [];

                for (var j = 0; j < toPathPoint.length; j++) {
                  if (Util.isNumber(toPathPoint[j]) && fromPathPoint && Util.isNumber(fromPathPoint[j])) {
                    interf = interpolate(fromPathPoint[j], toPathPoint[j]);
                    cPathPoint.push(interf(ratio));
                  } else {
                    cPathPoint.push(toPathPoint[j]);
                  }
                }

                cProps[k].push(cPathPoint);
              }
            } else {
              interf = interpolate(fromAttrs[k], toAttrs[k]);
              cProps[k] = interf(ratio);
            }
          }
        }

        if (toMatrix) {
          var mf = interpolateArray(animator.fromMatrix, toMatrix);
          var cM = mf(ratio);
          self.setMatrix(cM);
        }

        self.attr(cProps);
      }

      function update(shape, animator, elapsed) {
        var startTime = animator.startTime; // 如果还没有开始执行或暂停，先不更新

        if (elapsed < startTime + animator.delay || animator.isPaused) {
          return false;
        }

        var ratio;
        var duration = animator.duration;
        var easing = animator.easing; // 已执行时间

        elapsed = elapsed - startTime - animator.delay;

        if (animator.toAttrs.repeat) {
          ratio = elapsed % duration / duration;
          ratio = d3Ease[easing](ratio);
        } else {
          ratio = elapsed / duration;

          if (ratio < 1) {
            ratio = d3Ease[easing](ratio);
          } else {
            shape.attr(animator.toAttrs);

            if (animator.toMatrix) {
              shape.setMatrix(animator.toMatrix);
            }

            return true;
          }
        }

        _update(shape, animator, ratio);

        return false;
      }

      Util.augment(Timeline, {
        initTimer: function initTimer() {
          var _this = this;

          var self = this;
          var isFinished = false;
          var shape, animators, animator;
          self._timer = d3Timer.timer(function (elapsed) {
            self._current = elapsed;

            if (_this._animators.length > 0) {
              for (var i = _this._animators.length - 1; i >= 0; i--) {
                shape = _this._animators[i];

                if (shape.get('destroyed')) {
                  // 如果已经被销毁，直接移出队列
                  self.removeAnimator(i);
                  continue;
                }

                if (!shape.get('pause').isPaused) {
                  animators = shape.get('animators');

                  for (var j = animators.length - 1; j >= 0; j--) {
                    animator = animators[j];
                    isFinished = update(shape, animator, elapsed);

                    if (isFinished) {
                      animators.splice(j, 1);
                      isFinished = false;

                      if (animator.callback) {
                        animator.callback();
                      }
                    }
                  }
                }

                if (animators.length === 0) {
                  self.removeAnimator(i);
                }
              }

              _this.canvas.draw();
            }
          });
        },
        addAnimator: function addAnimator(shape) {
          this._animators.push(shape);
        },
        removeAnimator: function removeAnimator(index) {
          this._animators.splice(index, 1);
        },
        isAnimating: function isAnimating() {
          return !!this._animators.length;
        },
        stop: function stop() {
          if (this._timer) {
            this._timer.stop();
          }
        },
        stopAllAnimations: function stopAllAnimations() {
          this._animators.forEach(function (animator) {
            animator.stopAnimate();
          });

          this._animators = [];
          this.canvas.draw();
        },
        getTime: function getTime() {
          return this._current;
        }
      });
      module.exports = Timeline;
      /***/
    },
    /* 192 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__timer_js__ = __webpack_require__(59);
      /* harmony default export */


      __webpack_exports__["a"] = function (callback, delay, time) {
        var t = new __WEBPACK_IMPORTED_MODULE_0__timer_js__["a"
        /* Timer */
        ]();
        delay = delay == null ? 0 : +delay;
        t.restart(function (elapsed) {
          t.stop();
          callback(elapsed + delay);
        }, delay, time);
        return t;
      };
      /***/

    },
    /* 193 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__timer_js__ = __webpack_require__(59);
      /* harmony default export */


      __webpack_exports__["a"] = function (callback, delay, time) {
        var t = new __WEBPACK_IMPORTED_MODULE_0__timer_js__["a"
        /* Timer */
        ](),
            total = delay;
        if (delay == null) return t.restart(callback, delay, time), t;
        delay = +delay, time = time == null ? Object(__WEBPACK_IMPORTED_MODULE_0__timer_js__["b"
        /* now */
        ])() : +time;
        t.restart(function tick(elapsed) {
          elapsed += total;
          t.restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
        return t;
      };
      /***/

    },
    /* 194 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = linear;

      function linear(t) {
        return +t;
      }
      /***/

    },
    /* 195 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = quadIn;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = quadOut;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = quadInOut;

      function quadIn(t) {
        return t * t;
      }

      function quadOut(t) {
        return t * (2 - t);
      }

      function quadInOut(t) {
        return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
      }
      /***/

    },
    /* 196 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = cubicIn;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = cubicOut;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = cubicInOut;

      function cubicIn(t) {
        return t * t * t;
      }

      function cubicOut(t) {
        return --t * t * t + 1;
      }

      function cubicInOut(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
      }
      /***/

    },
    /* 197 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return polyIn;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "c", function () {
        return polyOut;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return polyInOut;
      });

      var exponent = 3;

      var polyIn = function custom(e) {
        e = +e;

        function polyIn(t) {
          return Math.pow(t, e);
        }

        polyIn.exponent = custom;
        return polyIn;
      }(exponent);

      var polyOut = function custom(e) {
        e = +e;

        function polyOut(t) {
          return 1 - Math.pow(1 - t, e);
        }

        polyOut.exponent = custom;
        return polyOut;
      }(exponent);

      var polyInOut = function custom(e) {
        e = +e;

        function polyInOut(t) {
          return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
        }

        polyInOut.exponent = custom;
        return polyInOut;
      }(exponent);
      /***/

    },
    /* 198 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = sinIn;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = sinOut;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = sinInOut;
      var pi = Math.PI,
          halfPi = pi / 2;

      function sinIn(t) {
        return 1 - Math.cos(t * halfPi);
      }

      function sinOut(t) {
        return Math.sin(t * halfPi);
      }

      function sinInOut(t) {
        return (1 - Math.cos(pi * t)) / 2;
      }
      /***/

    },
    /* 199 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = expIn;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = expOut;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = expInOut;

      function expIn(t) {
        return Math.pow(2, 10 * t - 10);
      }

      function expOut(t) {
        return 1 - Math.pow(2, -10 * t);
      }

      function expInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
      }
      /***/

    },
    /* 200 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = circleIn;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = circleOut;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = circleInOut;

      function circleIn(t) {
        return 1 - Math.sqrt(1 - t * t);
      }

      function circleOut(t) {
        return Math.sqrt(1 - --t * t);
      }

      function circleInOut(t) {
        return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
      }
      /***/

    },
    /* 201 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = bounceIn;
      /* harmony export (immutable) */

      __webpack_exports__["c"] = bounceOut;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = bounceInOut;
      var b1 = 4 / 11,
          b2 = 6 / 11,
          b3 = 8 / 11,
          b4 = 3 / 4,
          b5 = 9 / 11,
          b6 = 10 / 11,
          b7 = 15 / 16,
          b8 = 21 / 22,
          b9 = 63 / 64,
          b0 = 1 / b1 / b1;

      function bounceIn(t) {
        return 1 - bounceOut(1 - t);
      }

      function bounceOut(t) {
        return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
      }

      function bounceInOut(t) {
        return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
      }
      /***/

    },
    /* 202 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return backIn;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "c", function () {
        return backOut;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return backInOut;
      });

      var overshoot = 1.70158;

      var backIn = function custom(s) {
        s = +s;

        function backIn(t) {
          return t * t * ((s + 1) * t - s);
        }

        backIn.overshoot = custom;
        return backIn;
      }(overshoot);

      var backOut = function custom(s) {
        s = +s;

        function backOut(t) {
          return --t * t * ((s + 1) * t + s) + 1;
        }

        backOut.overshoot = custom;
        return backOut;
      }(overshoot);

      var backInOut = function custom(s) {
        s = +s;

        function backInOut(t) {
          return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
        }

        backInOut.overshoot = custom;
        return backInOut;
      }(overshoot);
      /***/

    },
    /* 203 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return elasticIn;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "c", function () {
        return elasticOut;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return elasticInOut;
      });

      var tau = 2 * Math.PI,
          amplitude = 1,
          period = 0.3;

      var elasticIn = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

        function elasticIn(t) {
          return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
        }

        elasticIn.amplitude = function (a) {
          return custom(a, p * tau);
        };

        elasticIn.period = function (p) {
          return custom(a, p);
        };

        return elasticIn;
      }(amplitude, period);

      var elasticOut = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

        function elasticOut(t) {
          return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
        }

        elasticOut.amplitude = function (a) {
          return custom(a, p * tau);
        };

        elasticOut.period = function (p) {
          return custom(a, p);
        };

        return elasticOut;
      }(amplitude, period);

      var elasticInOut = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

        function elasticInOut(t) {
          return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
        }

        elasticInOut.amplitude = function (a) {
          return custom(a, p * tau);
        };

        elasticInOut.period = function (p) {
          return custom(a, p);
        };

        return elasticInOut;
      }(amplitude, period);
      /***/

    },
    /* 204 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__src_value__ = __webpack_require__(60);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolate", function () {
        return __WEBPACK_IMPORTED_MODULE_0__src_value__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__src_array__ = __webpack_require__(121);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateArray", function () {
        return __WEBPACK_IMPORTED_MODULE_1__src_array__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__src_basis__ = __webpack_require__(63);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateBasis", function () {
        return __WEBPACK_IMPORTED_MODULE_2__src_basis__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__ = __webpack_require__(119);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function () {
        return __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__src_date__ = __webpack_require__(122);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateDate", function () {
        return __WEBPACK_IMPORTED_MODULE_4__src_date__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__src_number__ = __webpack_require__(40);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateNumber", function () {
        return __WEBPACK_IMPORTED_MODULE_5__src_number__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__src_object__ = __webpack_require__(123);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateObject", function () {
        return __WEBPACK_IMPORTED_MODULE_6__src_object__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__src_round__ = __webpack_require__(207);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateRound", function () {
        return __WEBPACK_IMPORTED_MODULE_7__src_round__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__src_string__ = __webpack_require__(124);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateString", function () {
        return __WEBPACK_IMPORTED_MODULE_8__src_string__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__src_transform_index__ = __webpack_require__(208);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function () {
        return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function () {
        return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_10__src_zoom__ = __webpack_require__(211);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateZoom", function () {
        return __WEBPACK_IMPORTED_MODULE_10__src_zoom__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_11__src_rgb__ = __webpack_require__(118);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateRgb", function () {
        return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function () {
        return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function () {
        return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["c"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_12__src_hsl__ = __webpack_require__(212);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateHsl", function () {
        return __WEBPACK_IMPORTED_MODULE_12__src_hsl__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function () {
        return __WEBPACK_IMPORTED_MODULE_12__src_hsl__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_13__src_lab__ = __webpack_require__(213);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateLab", function () {
        return __WEBPACK_IMPORTED_MODULE_13__src_lab__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_14__src_hcl__ = __webpack_require__(214);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateHcl", function () {
        return __WEBPACK_IMPORTED_MODULE_14__src_hcl__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function () {
        return __WEBPACK_IMPORTED_MODULE_14__src_hcl__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__ = __webpack_require__(215);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function () {
        return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function () {
        return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_16__src_quantize__ = __webpack_require__(216);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "quantize", function () {
        return __WEBPACK_IMPORTED_MODULE_16__src_quantize__["a"];
      });
      /***/

    },
    /* 205 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export gray */

      /* harmony export (immutable) */

      __webpack_exports__["a"] = lab;
      /* unused harmony export Lab */

      /* unused harmony export lch */

      /* harmony export (immutable) */

      __webpack_exports__["b"] = hcl;
      /* unused harmony export Hcl */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__define_js__ = __webpack_require__(62);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(61);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__math_js__ = __webpack_require__(117); // https://observablehq.com/@mbostock/lab-and-rgb


      var K = 18,
          Xn = 0.96422,
          Yn = 1,
          Zn = 0.82521,
          t0 = 4 / 29,
          t1 = 6 / 29,
          t2 = 3 * t1 * t1,
          t3 = t1 * t1 * t1;

      function labConvert(o) {
        if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl) return hcl2lab(o);
        if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color_js__["b"
        /* Rgb */
        ])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["h"
        /* rgbConvert */
        ])(o);
        var r = rgb2lrgb(o.r),
            g = rgb2lrgb(o.g),
            b = rgb2lrgb(o.b),
            y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
            x,
            z;
        if (r === g && g === b) x = z = y;else {
          x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
          z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
        }
        return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
      }

      function gray(l, opacity) {
        return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
      }

      function lab(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
      }

      function Lab(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
      }

      Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["a"
      /* default */
      ])(Lab, lab, Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["b"
      /* extend */
      ])(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
      /* Color */
      ], {
        brighter: function brighter(k) {
          return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function darker(k) {
          return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function rgb() {
          var y = (this.l + 16) / 116,
              x = isNaN(this.a) ? y : y + this.a / 500,
              z = isNaN(this.b) ? y : y - this.b / 200;
          x = Xn * lab2xyz(x);
          y = Yn * lab2xyz(y);
          z = Zn * lab2xyz(z);
          return new __WEBPACK_IMPORTED_MODULE_1__color_js__["b"
          /* Rgb */
          ](lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
        }
      }));

      function xyz2lab(t) {
        return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
      }

      function lab2xyz(t) {
        return t > t1 ? t * t * t : t2 * (t - t0);
      }

      function lrgb2rgb(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
      }

      function rgb2lrgb(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
      }

      function hclConvert(o) {
        if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab)) o = labConvert(o);
        if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);

        var h = Math.atan2(o.b, o.a) * __WEBPACK_IMPORTED_MODULE_2__math_js__["b"
        /* rad2deg */
        ];

        return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
      }

      function lch(l, c, h, opacity) {
        return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
      }

      function hcl(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
      }

      function Hcl(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
      }

      function hcl2lab(o) {
        if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
        var h = o.h * __WEBPACK_IMPORTED_MODULE_2__math_js__["a"
        /* deg2rad */
        ];
        return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
      }

      Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["a"
      /* default */
      ])(Hcl, hcl, Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["b"
      /* extend */
      ])(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
      /* Color */
      ], {
        brighter: function brighter(k) {
          return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
        },
        darker: function darker(k) {
          return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
        },
        rgb: function rgb() {
          return hcl2lab(this).rgb();
        }
      }));
      /***/
    },
    /* 206 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = cubehelix;
      /* unused harmony export Cubehelix */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__define_js__ = __webpack_require__(62);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(61);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__math_js__ = __webpack_require__(117);

      var A = -0.14861,
          B = +1.78277,
          C = -0.29227,
          D = -0.90649,
          E = +1.97294,
          ED = E * D,
          EB = E * B,
          BC_DA = B * C - D * A;

      function cubehelixConvert(o) {
        if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color_js__["b"
        /* Rgb */
        ])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["h"
        /* rgbConvert */
        ])(o);
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
            bl = b - l,
            k = (E * (g - l) - C * bl) / D,
            s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
            // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * __WEBPACK_IMPORTED_MODULE_2__math_js__["b"
        /* rad2deg */
        ] - 120 : NaN;
        return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
      }

      function cubehelix(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
      }

      function Cubehelix(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
      }

      Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["a"
      /* default */
      ])(Cubehelix, cubehelix, Object(__WEBPACK_IMPORTED_MODULE_0__define_js__["b"
      /* extend */
      ])(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
      /* Color */
      ], {
        brighter: function brighter(k) {
          k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color_js__["c"
          /* brighter */
          ] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color_js__["c"
          /* brighter */
          ], k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function darker(k) {
          k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color_js__["d"
          /* darker */
          ] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color_js__["d"
          /* darker */
          ], k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function rgb() {
          var h = isNaN(this.h) ? 0 : (this.h + 120) * __WEBPACK_IMPORTED_MODULE_2__math_js__["a"
          /* deg2rad */
          ],
              l = +this.l,
              a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
              cosh = Math.cos(h),
              sinh = Math.sin(h);
          return new __WEBPACK_IMPORTED_MODULE_1__color_js__["b"
          /* Rgb */
          ](255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
        }
      }));
      /***/
    },
    /* 207 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b) {
        return a = +a, b -= a, function (t) {
          return Math.round(a + b * t);
        };
      };
      /***/

    },
    /* 208 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return interpolateTransformCss;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return interpolateTransformSvg;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(40);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(209);

      function interpolateTransform(parse, pxComma, pxParen, degParen) {
        function pop(s) {
          return s.length ? s.pop() + " " : "";
        }

        function translate(xa, ya, xb, yb, s, q) {
          if (xa !== xb || ya !== yb) {
            var i = s.push("translate(", null, pxComma, null, pxParen);
            q.push({
              i: i - 4,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a"
              /* default */
              ])(xa, xb)
            }, {
              i: i - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a"
              /* default */
              ])(ya, yb)
            });
          } else if (xb || yb) {
            s.push("translate(" + xb + pxComma + yb + pxParen);
          }
        }

        function rotate(a, b, s, q) {
          if (a !== b) {
            if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

            q.push({
              i: s.push(pop(s) + "rotate(", null, degParen) - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a"
              /* default */
              ])(a, b)
            });
          } else if (b) {
            s.push(pop(s) + "rotate(" + b + degParen);
          }
        }

        function skewX(a, b, s, q) {
          if (a !== b) {
            q.push({
              i: s.push(pop(s) + "skewX(", null, degParen) - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a"
              /* default */
              ])(a, b)
            });
          } else if (b) {
            s.push(pop(s) + "skewX(" + b + degParen);
          }
        }

        function scale(xa, ya, xb, yb, s, q) {
          if (xa !== xb || ya !== yb) {
            var i = s.push(pop(s) + "scale(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a"
              /* default */
              ])(xa, xb)
            }, {
              i: i - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a"
              /* default */
              ])(ya, yb)
            });
          } else if (xb !== 1 || yb !== 1) {
            s.push(pop(s) + "scale(" + xb + "," + yb + ")");
          }
        }

        return function (a, b) {
          var s = [],
              // string constants and placeholders
          q = []; // number interpolators

          a = parse(a), b = parse(b);
          translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
          rotate(a.rotate, b.rotate, s, q);
          skewX(a.skewX, b.skewX, s, q);
          scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
          a = b = null; // gc

          return function (t) {
            var i = -1,
                n = q.length,
                o;

            while (++i < n) {
              s[(o = q[i]).i] = o.x(t);
            }

            return s.join("");
          };
        };
      }

      var interpolateTransformCss = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["a"
      /* parseCss */
      ], "px, ", "px)", "deg)");
      var interpolateTransformSvg = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["b"
      /* parseSvg */
      ], ", ", ")", ")");
      /***/
    },
    /* 209 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = parseCss;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = parseSvg;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__decompose__ = __webpack_require__(210);

      var cssNode, cssRoot, cssView, svgNode;

      function parseCss(value) {
        if (value === "none") return __WEBPACK_IMPORTED_MODULE_0__decompose__["b"
        /* identity */
        ];
        if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
        cssNode.style.transform = value;
        value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
        cssRoot.removeChild(cssNode);
        value = value.slice(7, -1).split(",");
        return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__["a"
        /* default */
        ])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
      }

      function parseSvg(value) {
        if (value == null) return __WEBPACK_IMPORTED_MODULE_0__decompose__["b"
        /* identity */
        ];
        if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode.setAttribute("transform", value);
        if (!(value = svgNode.transform.baseVal.consolidate())) return __WEBPACK_IMPORTED_MODULE_0__decompose__["b"
        /* identity */
        ];
        value = value.matrix;
        return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__["a"
        /* default */
        ])(value.a, value.b, value.c, value.d, value.e, value.f);
      }
      /***/

    },
    /* 210 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return identity;
      });

      var degrees = 180 / Math.PI;
      var identity = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
      };
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
        if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
          translateX: e,
          translateY: f,
          rotate: Math.atan2(b, a) * degrees,
          skewX: Math.atan(skewX) * degrees,
          scaleX: scaleX,
          scaleY: scaleY
        };
      };
      /***/

    },
    /* 211 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var rho = Math.SQRT2,
          rho2 = 2,
          rho4 = 4,
          epsilon2 = 1e-12;

      function cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }

      function sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }

      function tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      } // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]

      /* harmony default export */


      __webpack_exports__["a"] = function (p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S; // Special case for u0 ≅ u1.

        if (d2 < epsilon2) {
          S = Math.log(w1 / w0) / rho;

          i = function i(t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
          };
        } // General case.
        else {
            var d1 = Math.sqrt(d2),
                b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
                b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
                r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
                r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / rho;

            i = function i(t) {
              var s = t * S,
                  coshr0 = cosh(r0),
                  u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
              return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
            };
          }

        i.duration = S * 1000;
        return i;
      };
      /***/

    },
    /* 212 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return hslLong;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);

      function hsl(hue) {
        return function (start, end) {
          var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d"
          /* hsl */
          ])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d"
          /* hsl */
          ])(end)).h),
              s = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
          /* default */
          ])(start.s, end.s),
              l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
          /* default */
          ])(start.l, end.l),
              opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
          /* default */
          ])(start.opacity, end.opacity);
          return function (t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
          };
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = hsl(__WEBPACK_IMPORTED_MODULE_1__color__["c"
      /* hue */
      ]);
      var hslLong = hsl(__WEBPACK_IMPORTED_MODULE_1__color__["a"
      /* default */
      ]);
      /***/
    },
    /* 213 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = lab;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);

      function lab(start, end) {
        var l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
        /* default */
        ])((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e"
        /* lab */
        ])(start)).l, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e"
        /* lab */
        ])(end)).l),
            a = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
        /* default */
        ])(start.a, end.a),
            b = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
        /* default */
        ])(start.b, end.b),
            opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
        /* default */
        ])(start.opacity, end.opacity);
        return function (t) {
          start.l = l(t);
          start.a = a(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
      /***/

    },
    /* 214 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return hclLong;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);

      function hcl(hue) {
        return function (start, end) {
          var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c"
          /* hcl */
          ])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c"
          /* hcl */
          ])(end)).h),
              c = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
          /* default */
          ])(start.c, end.c),
              l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
          /* default */
          ])(start.l, end.l),
              opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
          /* default */
          ])(start.opacity, end.opacity);
          return function (t) {
            start.h = h(t);
            start.c = c(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
          };
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = hcl(__WEBPACK_IMPORTED_MODULE_1__color__["c"
      /* hue */
      ]);
      var hclLong = hcl(__WEBPACK_IMPORTED_MODULE_1__color__["a"
      /* default */
      ]);
      /***/
    },
    /* 215 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return cubehelixLong;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);

      function cubehelix(hue) {
        return function cubehelixGamma(y) {
          y = +y;

          function cubehelix(start, end) {
            var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b"
            /* cubehelix */
            ])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b"
            /* cubehelix */
            ])(end)).h),
                s = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
            /* default */
            ])(start.s, end.s),
                l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
            /* default */
            ])(start.l, end.l),
                opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a"
            /* default */
            ])(start.opacity, end.opacity);
            return function (t) {
              start.h = h(t);
              start.s = s(t);
              start.l = l(Math.pow(t, y));
              start.opacity = opacity(t);
              return start + "";
            };
          }

          cubehelix.gamma = cubehelixGamma;
          return cubehelix;
        }(1);
      }
      /* harmony default export */


      __webpack_exports__["b"] = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["c"
      /* hue */
      ]);
      var cubehelixLong = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["a"
      /* default */
      ]);
      /***/
    },
    /* 216 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (interpolator, n) {
        var samples = new Array(n);

        for (var i = 0; i < n; ++i) {
          samples[i] = interpolator(i / (n - 1));
        }

        return samples;
      };
      /***/

    },
    /* 217 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        canvas: __webpack_require__(218),
        svg: __webpack_require__(221)
      };
      /***/
    },
    /* 218 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        painter: __webpack_require__(219)
      };
      /***/
    },
    /* 219 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var renderUtil = __webpack_require__(220);

      var SHAPE_ATTRS = ['fillStyle', 'font', 'globalAlpha', 'lineCap', 'lineWidth', 'lineJoin', 'miterLimit', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY', 'strokeStyle', 'textAlign', 'textBaseline', 'lineDash', 'lineDashOffset'];

      var Painter = /*#__PURE__*/function () {
        function Painter(dom) {
          if (!dom) {
            return null;
          }

          var canvasId = Util.uniqueId('canvas_');
          var canvasDom = Util.createDom('<canvas id="' + canvasId + '"></canvas>');
          dom.appendChild(canvasDom);
          this.type = 'canvas';
          this.canvas = canvasDom;
          this.context = canvasDom.getContext('2d');
          this.toDraw = false;
          return this;
        }

        var _proto = Painter.prototype;

        _proto.beforeDraw = function beforeDraw() {
          var el = this.canvas;
          this.context && this.context.clearRect(0, 0, el.width, el.height);
        };

        _proto.draw = function draw(model) {
          var self = this;

          function drawInner() {
            self.animateHandler = Util.requestAnimationFrame(function () {
              self.animateHandler = undefined;

              if (self.toDraw) {
                drawInner();
              }
            });
            self.beforeDraw();

            try {
              self._drawGroup(model);
            } catch (ev) {
              // 绘制时异常，中断重绘
              console.warn('error in draw canvas, detail as:');
              console.warn(ev);
              self.toDraw = false;
            }

            self.toDraw = false;
          }

          if (self.animateHandler) {
            self.toDraw = true;
          } else {
            drawInner();
          }
        };

        _proto.drawSync = function drawSync(model) {
          this.beforeDraw();

          this._drawGroup(model);
        };

        _proto._drawGroup = function _drawGroup(group) {
          if (group._cfg.removed || group._cfg.destroyed || !group._cfg.visible) {
            return;
          }

          var self = this;
          var children = group._cfg.children;
          var child = null;
          this.setContext(group);

          for (var i = 0; i < children.length; i++) {
            child = children[i];

            if (children[i].isGroup) {
              self._drawGroup(child);
            } else {
              self._drawShape(child);
            }
          }

          this.restoreContext(group);
        };

        _proto._drawShape = function _drawShape(shape) {
          if (shape._cfg.removed || shape._cfg.destroyed || !shape._cfg.visible) {
            return;
          }

          this.setContext(shape);
          shape.drawInner(this.context);
          this.restoreContext(shape);
          shape._cfg.attrs = shape._attrs;
          shape._cfg.hasUpdate = false;
        };

        _proto.setContext = function setContext(shape) {
          var context = this.context;
          var clip = shape._attrs.clip;
          context.save();

          if (clip) {
            // context.save();
            clip.resetTransform(context);
            clip.createPath(context);
            context.clip(); // context.restore();
          }

          this.resetContext(shape);
          shape.resetTransform(context);
        };

        _proto.restoreContext = function restoreContext() {
          this.context.restore();
        };

        _proto.resetContext = function resetContext(shape) {
          var context = this.context;
          var elAttrs = shape._attrs; // var canvas = this.get('canvas');

          if (!shape.isGroup) {
            for (var k in elAttrs) {
              if (SHAPE_ATTRS.indexOf(k) > -1) {
                // 非canvas属性不附加
                var v = elAttrs[k];

                if (k === 'fillStyle') {
                  v = renderUtil.parseStyle(v, shape, context);
                }

                if (k === 'strokeStyle') {
                  v = renderUtil.parseStyle(v, shape, context);
                }

                if (k === 'lineDash' && context.setLineDash) {
                  if (Util.isArray(v)) {
                    context.setLineDash(v);
                  } else if (Util.isString(v)) {
                    context.setLineDash(v.split(' '));
                  }
                } else {
                  context[k] = v;
                }
              }
            }
          }
        };

        return Painter;
      }();

      module.exports = Painter;
      /***/
    },
    /* 220 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
      var regexDot = /[^\s\,]+/ig;
      var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
      var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/ig;
      var numColorCache = {};

      function addStop(steps, gradient) {
        var arr = steps.match(regexColorStop);
        Util.each(arr, function (item) {
          item = item.split(':');
          gradient.addColorStop(item[0], item[1]);
        });
      }

      function parseLineGradient(color, self, context) {
        var arr = regexLG.exec(color);
        var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);
        var steps = arr[2];
        var box = self.getBBox();
        var start;
        var end;

        if (angle >= 0 && angle < 0.5 * Math.PI) {
          start = {
            x: box.minX,
            y: box.minY
          };
          end = {
            x: box.maxX,
            y: box.maxY
          };
        } else if (0.5 * Math.PI <= angle && angle < Math.PI) {
          start = {
            x: box.maxX,
            y: box.minY
          };
          end = {
            x: box.minX,
            y: box.maxY
          };
        } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
          start = {
            x: box.maxX,
            y: box.maxY
          };
          end = {
            x: box.minX,
            y: box.minY
          };
        } else {
          start = {
            x: box.minX,
            y: box.maxY
          };
          end = {
            x: box.maxX,
            y: box.minY
          };
        }

        var tanTheta = Math.tan(angle);
        var tanTheta2 = tanTheta * tanTheta;
        var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
        var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
        var gradient = context.createLinearGradient(start.x, start.y, x, y);
        addStop(steps, gradient);
        return gradient;
      }

      function parseRadialGradient(color, self, context) {
        var arr = regexRG.exec(color);
        var fx = parseFloat(arr[1]);
        var fy = parseFloat(arr[2]);
        var fr = parseFloat(arr[3]);
        var steps = arr[4]; // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色

        if (fr === 0) {
          var colors = steps.match(regexColorStop);
          return colors[colors.length - 1].split(':')[1];
        }

        var box = self.getBBox();
        var width = box.maxX - box.minX;
        var height = box.maxY - box.minY;
        var r = Math.sqrt(width * width + height * height) / 2;
        var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, fr * r, box.minX + width / 2, box.minY + height / 2, r);
        addStop(steps, gradient);
        return gradient;
      }

      function parsePattern(color, self, context) {
        if (self.get('patternSource') && self.get('patternSource') === color) {
          return self.get('pattern');
        }

        var pattern;
        var img;
        var arr = regexPR.exec(color);
        var repeat = arr[1];
        var source = arr[2]; // Function to be called when pattern loads

        function onload() {
          // Create pattern
          pattern = context.createPattern(img, repeat);
          self.setSilent('pattern', pattern); // be a cache

          self.setSilent('patternSource', color);
        }

        switch (repeat) {
          case 'a':
            repeat = 'repeat';
            break;

          case 'x':
            repeat = 'repeat-x';
            break;

          case 'y':
            repeat = 'repeat-y';
            break;

          case 'n':
            repeat = 'no-repeat';
            break;

          default:
            repeat = 'no-repeat';
        }

        img = new Image(); // If source URL is not a data URL

        if (!source.match(/^data:/i)) {
          // Set crossOrigin for this image
          img.crossOrigin = 'Anonymous';
        }

        img.src = source;

        if (img.complete) {
          onload();
        } else {
          img.onload = onload; // Fix onload() bug in IE9

          img.src = img.src;
        }

        return pattern;
      }

      module.exports = {
        parsePath: function parsePath(path) {
          path = path || [];

          if (Util.isArray(path)) {
            return path;
          }

          if (Util.isString(path)) {
            path = path.match(regexTags);
            Util.each(path, function (item, index) {
              item = item.match(regexDot);

              if (item[0].length > 1) {
                var tag = item[0].charAt(0);
                item.splice(1, 0, item[0].substr(1));
                item[0] = tag;
              }

              Util.each(item, function (sub, i) {
                if (!isNaN(sub)) {
                  item[i] = +sub;
                }
              });
              path[index] = item;
            });
            return path;
          }
        },
        parseStyle: function parseStyle(color, self, context) {
          if (Util.isString(color)) {
            if (color[1] === '(' || color[2] === '(') {
              if (color[0] === 'l') {
                // regexLG.test(color)
                return parseLineGradient(color, self, context);
              } else if (color[0] === 'r') {
                // regexRG.test(color)
                return parseRadialGradient(color, self, context);
              } else if (color[0] === 'p') {
                // regexPR.test(color)
                return parsePattern(color, self, context);
              }
            }

            return color;
          }
        },
        numberToColor: function numberToColor(num) {
          // 增加缓存
          var color = numColorCache[num];

          if (!color) {
            var str = num.toString(16);

            for (var i = str.length; i < 6; i++) {
              str = '0' + str;
            }

            color = '#' + str;
            numColorCache[num] = color;
          }

          return color;
        }
      };
      /***/
    },
    /* 221 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        painter: __webpack_require__(222),
        getShape: __webpack_require__(229)
      };
      /***/
    },
    /* 222 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(1);

      var _require = __webpack_require__(27),
          parseRadius = _require.parseRadius;

      var Marker = __webpack_require__(57);

      var Defs = __webpack_require__(223);

      var SHAPE_TO_TAGS = {
        rect: 'path',
        circle: 'circle',
        line: 'line',
        path: 'path',
        marker: 'path',
        text: 'text',
        polygon: 'polygon',
        image: 'image',
        ellipse: 'ellipse',
        dom: 'foreignObject',
        fan: 'path',
        group: 'g'
      };
      var LETTER_SPACING = 0.3;
      var SVG_ATTR_MAP = {
        opacity: 'opacity',
        fillStyle: 'fill',
        strokeOpacity: 'stroke-opacity',
        fillOpacity: 'fill-opacity',
        strokeStyle: 'stroke',
        x: 'x',
        y: 'y',
        r: 'r',
        width: 'width',
        height: 'height',
        x1: 'x1',
        x2: 'x2',
        y1: 'y1',
        y2: 'y2',
        lineCap: 'stroke-linecap',
        lineJoin: 'stroke-linejoin',
        lineWidth: 'stroke-width',
        lineDash: 'stroke-dasharray',
        lineDashOffset: 'stroke-dashoffset',
        miterLimit: 'stroke-miterlimit',
        font: 'font',
        fontSize: 'font-size',
        fontStyle: 'font-style',
        fontVariant: 'font-variant',
        fontWeight: 'font-weight',
        fontFamily: 'font-family',
        startArrow: 'marker-start',
        endArrow: 'marker-end',
        path: 'd',
        "class": 'class',
        id: 'id',
        style: 'style',
        preserveAspectRatio: 'preserveAspectRatio'
      };
      var BASELINE_MAP = {
        top: 'before-edge',
        middle: 'central',
        bottom: 'after-edge',
        alphabetic: 'baseline',
        hanging: 'hanging'
      };
      var ANCHOR_MAP = {
        left: 'left',
        start: 'left',
        center: 'middle',
        right: 'end',
        end: 'end'
      };

      var Painter = /*#__PURE__*/function () {
        function Painter(dom) {
          if (!dom) {
            return null;
          }

          var svgId = Util.uniqueId('canvas_');
          var canvasDom = Util.createDom("<svg id=\"" + svgId + "\"></svg>");
          dom.appendChild(canvasDom);
          this.type = 'svg';
          this.canvas = canvasDom;
          this.context = new Defs(canvasDom);
          this.toDraw = false;
          return this;
        }

        var _proto = Painter.prototype;

        _proto.draw = function draw(model) {
          var self = this;

          function drawInner() {
            self.animateHandler = Util.requestAnimationFrame(function () {
              self.animateHandler = undefined;

              if (self.toDraw) {
                drawInner();
              }
            });

            try {
              model.resetMatrix();

              self._drawGroup(model, false);
            } catch (ev) {
              // 绘制时异常，中断重绘
              console.warn('error in draw canvas, detail as:');
              console.warn(ev);
              self.toDraw = false;
            }

            self.toDraw = false;
          }

          if (self.animateHandler) {
            self.toDraw = true;
          } else {
            drawInner();
          }
        };

        _proto.drawSync = function drawSync(model) {
          this._drawChildren(model, false);
        };

        _proto._drawGroup = function _drawGroup(model, redraw) {
          var cfg = model._cfg;

          if (cfg.removed || cfg.destroyed) {
            return;
          }
          /**
           * FIXME redraw: 为了使元素置顶的临时解决方案
           * 如果直接将dom元素重排可以解决部分问题。但是如果重排后的group中有新增的shape，置顶效果就没有了
           * 所以只能删除原有节点，新增节点以及所有子节点。这时候哪怕shape有el，也需要判断一下是否需要重绘
           */


          if (!cfg.el && cfg.attrs) {
            redraw = true;
          }

          if (cfg.tobeRemoved) {
            Util.each(cfg.tobeRemoved, function (item) {
              if (item.parentNode) {
                item.parentNode.removeChild(item);
              }
            });
            cfg.tobeRemoved = [];
          }

          this._drawShape(model, redraw);

          if (cfg.children && cfg.children.length > 0) {
            this._drawChildren(model, redraw);
          }
        };

        _proto._drawChildren = function _drawChildren(parent, redraw) {
          var self = this;
          var children = parent._cfg.children;
          var shape; // 防止在画children的时候，父group已经被destroy

          if (!children) {
            return;
          }

          if (parent._cfg.el && !redraw) {
            // FIXME 这边是为了解决一个group中有元素已经生成el，还有一些没生成el时，没生成el的置底效果不work
            var childLen = parent._cfg.el.childNodes.length + 1;

            if (childLen !== 0 && childLen !== children.length) {
              redraw = true;
            }
          }

          for (var i = 0; i < children.length; i++) {
            shape = children[i];

            if (shape.isGroup) {
              self._drawGroup(shape, redraw);
            } else {
              self._drawShape(shape, redraw);
            }
          }
        };

        _proto._drawShape = function _drawShape(model, redraw) {
          var self = this;
          var attrs = model._attrs;
          var cfg = model._cfg;
          var el = cfg.el; // 删除

          if (cfg.removed || cfg.destroyed) {
            if (el) {
              el.parentNode.removeChild(cfg.el);
            }

            return;
          } // 重绘节点


          if (redraw && el) {
            el.parentNode && el.parentNode.removeChild(el);
            el = null;
          } // 新增节点


          if (!el && cfg.parent) {
            self._createDom(model);

            self._updateShape(model);
          }

          el = cfg.el;

          if (cfg.visible === false) {
            el.setAttribute('visibility', 'hidden');
            return;
          }

          if (cfg.visible && el.hasAttribute('visibility')) {
            el.removeAttribute('visibility');
          } // 更新


          if (cfg.hasUpdate) {
            self._updateShape(model);
          }

          if (attrs.clip && attrs.clip._cfg.hasUpdate) {
            self._updateShape(attrs.clip);
          }
        };

        _proto._updateShape = function _updateShape(model) {
          var self = this;
          var attrs = model._attrs;
          var formerAttrs = model._cfg.attrs;

          if (!formerAttrs) {
            return;
          }

          if (!model._cfg.el) {
            self._createDom(model);
          }

          if ('clip' in attrs) {
            this._setClip(model, attrs.clip);
          }

          if ('shadowOffsetX' in attrs || 'shadowOffsetY' in attrs || 'shadowBlur' in attrs || 'shadowColor' in attrs) {
            this._setShadow(model);
          }

          if (model.type === 'text') {
            self._updateText(model);

            return;
          }

          if (model.type === 'fan') {
            self._updateFan(model);
          }

          if (model.type === 'marker') {
            model._cfg.el.setAttribute('d', self._assembleMarker(attrs));
          }

          if (model.type === 'rect') {
            model._cfg.el.setAttribute('d', self._assembleRect(attrs));
          }

          for (var key in attrs) {
            if (attrs[key] !== formerAttrs[key]) {
              self._setAttribute(model, key, attrs[key]);
            }
          }

          model._cfg.attrs = Util.deepMix({}, model._attrs);
          model._cfg.hasUpdate = false;
        };

        _proto._setAttribute = function _setAttribute(model, name, value) {
          var type = model.type;
          var attrs = model._attrs;
          var el = model._cfg.el;
          var defs = this.context; // 计算marker路径

          if ((type === 'marker' || type === 'rect') && ~['x', 'y', 'radius', 'r'].indexOf(name)) {
            return;
          } // 圆和椭圆不是x, y， 是cx, cy。 marker的x,y 用于计算marker的路径，不需要写到dom


          if (~['circle', 'ellipse'].indexOf(type) && ~['x', 'y'].indexOf(name)) {
            el.setAttribute('c' + name, parseInt(value, 10));
            return;
          } // 多边形


          if (type === 'polygon' && name === 'points') {
            if (!value || value.length === 0) {
              value = '';
            }

            if (Util.isArray(value)) {
              value = value.map(function (point) {
                return point[0] + ',' + point[1];
              });
              value = value.join(' ');
            }

            el.setAttribute('points', value);
            return;
          } // 设置path


          if (name === 'path' && Util.isArray(value)) {
            el.setAttribute('d', this._formatPath(value));
            return;
          } // 设置图片


          if (name === 'img') {
            this._setImage(model, value);

            return;
          }

          if (name === 'transform') {
            if (!value) {
              el.removeAttribute('transform');
              return;
            }

            this._setTransform(model);

            return;
          }

          if (name === 'rotate') {
            if (!value) {
              el.removeAttribute('transform');
              return;
            }

            this._setTransform(model);

            return;
          }

          if (name === 'matrix') {
            this._setTransform(model);

            return;
          }

          if (name === 'fillStyle' || name === 'strokeStyle') {
            this._setColor(model, name, value);

            return;
          }

          if (name === 'clip') {
            return;
          }

          if (~name.indexOf('Arrow')) {
            name = SVG_ATTR_MAP[name];

            if (!value) {
              model._cfg[name] = null;
              el.removeAttribute(name);
            } else {
              var id = null;

              if (typeof value === 'boolean') {
                id = defs.getDefaultArrow(attrs, name);
              } else {
                id = defs.addArrow(attrs, name);
              }

              el.setAttribute(name, "url(#" + id + ")");
              model._cfg[name] = id;
            }

            return;
          } // foreignObject


          if (name === 'html') {
            if (typeof value === 'string') {
              el.innerHTML = value;
            } else {
              el.innerHTML = '';
              el.appendChild(value);
            }
          }

          if (SVG_ATTR_MAP[name]) {
            el.setAttribute(SVG_ATTR_MAP[name], value);
          }
        };

        _proto._createDom = function _createDom(model) {
          var type = SHAPE_TO_TAGS[model.type];
          var attrs = model._attrs;

          if (!type) {
            throw new Error('the type' + model.type + 'is not supported by svg');
          }

          var shape = document.createElementNS('http://www.w3.org/2000/svg', type);
          model._cfg.el = shape;

          if (model._cfg.parent) {
            model._cfg.parent.get('el').appendChild(shape);
          }

          model._cfg.attrs = {};

          if (model.type === 'text') {
            shape.setAttribute('paint-order', 'stroke');
            shape.setAttribute('style', 'stroke-linecap:butt; stroke-linejoin:miter;');
          } else {
            if (!attrs.stroke && !attrs.strokeStyle) {
              shape.setAttribute('stroke', 'none');
            }

            if (!attrs.fill && !attrs.fillStyle) {
              shape.setAttribute('fill', 'none');
            }
          }

          return shape;
        };

        _proto._assembleMarker = function _assembleMarker(attrs) {
          var r = attrs.r;

          if (typeof attrs.r === 'undefined') {
            r = attrs.radius;
          }

          if (isNaN(Number(attrs.x)) || isNaN(Number(attrs.y)) || isNaN(Number(r))) {
            return '';
          }

          var d = '';

          if (typeof attrs.symbol === 'function') {
            d = attrs.symbol(attrs.x, attrs.y, r);
          } else {
            d = Marker.Symbols[attrs.symbol || 'circle'](attrs.x, attrs.y, r);
          }

          if (Util.isArray(d)) {
            d = d.map(function (path) {
              return path.join(' ');
            }).join('');
          }

          return d;
        };

        _proto._assembleRect = function _assembleRect(attrs) {
          var x = attrs.x;
          var y = attrs.y;
          var w = attrs.width;
          var h = attrs.height;
          var radius = attrs.radius;

          if (!radius) {
            return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
          }

          var r = parseRadius(radius);

          if (Util.isArray(radius)) {
            if (radius.length === 1) {
              r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
            } else if (radius.length === 2) {
              r.r1 = r.r3 = radius[0];
              r.r2 = r.r4 = radius[1];
            } else if (radius.length === 3) {
              r.r1 = radius[0];
              r.r2 = r.r4 = radius[1];
              r.r3 = radius[2];
            } else {
              r.r1 = radius[0];
              r.r2 = radius[1];
              r.r3 = radius[2];
              r.r4 = radius[3];
            }
          } else {
            r.r1 = r.r2 = r.r3 = r.r4 = radius;
          }

          var d = [["M " + (x + r.r1) + "," + y], ["l " + (w - r.r1 - r.r2) + ",0"], ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2], ["l 0," + (h - r.r2 - r.r3)], ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3], ["l " + (r.r3 + r.r4 - w) + ",0"], ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4], ["l 0," + (r.r4 + r.r1 - h)], ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1], ['z']];
          return d.join(' ');
        };

        _proto._formatPath = function _formatPath(value) {
          value = value.map(function (path) {
            return path.join(' ');
          }).join('');

          if (~value.indexOf('NaN')) {
            return '';
          }

          return value;
        };

        _proto._setTransform = function _setTransform(model) {
          var matrix = model._attrs.matrix;
          var el = model._cfg.el;
          var transform = [];

          for (var i = 0; i < 9; i += 3) {
            transform.push(matrix[i] + ',' + matrix[i + 1]);
          }

          transform = transform.join(',');

          if (transform.indexOf('NaN') === -1) {
            el.setAttribute('transform', "matrix(" + transform + ")");
          } else {
            console.warn('invalid matrix:', matrix);
          }
        };

        _proto._setImage = function _setImage(model, img) {
          var attrs = model._attrs;
          var el = model._cfg.el;

          if (Util.isString(img)) {
            el.setAttribute('href', img);
          } else if (img instanceof Image) {
            if (!attrs.width) {
              el.setAttribute('width', img.width);
              model._attrs.width = img.width;
            }

            if (!attrs.height) {
              el.setAttribute('height', img.height);
              model._attrs.height = img.height;
            }

            el.setAttribute('href', img.src);
          } else if (img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
            el.setAttribute('href', img.toDataURL());
          } else if (img instanceof ImageData) {
            var canvas = document.createElement('canvas');
            canvas.setAttribute('width', img.width);
            canvas.setAttribute('height', img.height);
            canvas.getContext('2d').putImageData(img, 0, 0);

            if (!attrs.width) {
              el.setAttribute('width', img.width);
              model._attrs.width = img.width;
            }

            if (!attrs.height) {
              el.setAttribute('height', img.height);
              model._attrs.height = img.height;
            }

            el.setAttribute('href', canvas.toDataURL());
          }
        };

        _proto._updateFan = function _updateFan(model) {
          function getPoint(angle, radius, center) {
            return {
              x: radius * Math.cos(angle) + center.x,
              y: radius * Math.sin(angle) + center.y
            };
          }

          var attrs = model._attrs;
          var cfg = model._cfg;
          var center = {
            x: attrs.x,
            y: attrs.y
          };
          var d = [];
          var startAngle = attrs.startAngle;
          var endAngle = attrs.endAngle;

          if (Util.isNumberEqual(endAngle - startAngle, Math.PI * 2)) {
            endAngle -= 0.00001;
          }

          var outerStart = getPoint(startAngle, attrs.re, center);
          var outerEnd = getPoint(endAngle, attrs.re, center);
          var fa = endAngle > startAngle ? 1 : 0;
          var fs = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
          var rs = attrs.rs;
          var re = attrs.re;
          var innerStart = getPoint(startAngle, attrs.rs, center);
          var innerEnd = getPoint(endAngle, attrs.rs, center);

          if (attrs.rs > 0) {
            d.push("M " + outerEnd.x + "," + outerEnd.y);
            d.push("L " + innerEnd.x + "," + innerEnd.y);
            d.push("A " + rs + "," + rs + ",0," + fs + "," + (fa === 1 ? 0 : 1) + "," + innerStart.x + "," + innerStart.y);
            d.push("L " + outerStart.x + " " + outerStart.y);
          } else {
            d.push("M " + center.x + "," + center.y);
            d.push("L " + outerStart.x + "," + outerStart.y);
          }

          d.push("A " + re + "," + re + ",0," + fs + "," + fa + "," + outerEnd.x + "," + outerEnd.y);

          if (attrs.rs > 0) {
            d.push("L " + innerEnd.x + "," + innerEnd.y);
          } else {
            d.push('Z');
          }

          cfg.el.setAttribute('d', d.join(' '));
        };

        _proto._updateText = function _updateText(model) {
          var self = this;
          var attrs = model._attrs;
          var formerAttrs = model._cfg.attrs;
          var el = model._cfg.el;

          this._setFont(model);

          for (var attr in attrs) {
            if (attrs[attr] !== formerAttrs[attr]) {
              if (attr === 'text') {
                self._setText(model, "" + attrs[attr]);

                continue;
              }

              if (attr === 'fillStyle' || attr === 'strokeStyle') {
                this._setColor(model, attr, attrs[attr]);

                continue;
              }

              if (attr === 'matrix') {
                this._setTransform(model);

                continue;
              }

              if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], attrs[attr]);
              }
            }
          }

          model._cfg.attrs = Object.assign({}, model._attrs);
          model._cfg.hasUpdate = false;
        };

        _proto._setFont = function _setFont(model) {
          var el = model.get('el');
          var attrs = model._attrs;
          var fontSize = attrs.fontSize;
          el.setAttribute('alignment-baseline', BASELINE_MAP[attrs.textBaseline] || 'baseline');
          el.setAttribute('text-anchor', ANCHOR_MAP[attrs.textAlign] || 'left');

          if (fontSize && +fontSize < 12) {
            // 小于 12 像素的文本进行 scale 处理
            attrs.matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            model.transform([['t', -attrs.x, -attrs.y], ['s', +fontSize / 12, +fontSize / 12], ['t', attrs.x, attrs.y]]);
          }
        };

        _proto._setText = function _setText(model, text) {
          var el = model._cfg.el;
          var baseline = model._attrs.textBaseline || 'bottom';

          if (!text) {
            el.innerHTML = '';
          } else if (~text.indexOf('\n')) {
            var x = model._attrs.x;
            var textArr = text.split('\n');
            var textLen = textArr.length - 1;
            var arr = '';
            Util.each(textArr, function (segment, i) {
              if (i === 0) {
                if (baseline === 'alphabetic') {
                  arr += "<tspan x=\"" + x + "\" dy=\"" + -textLen + "em\">" + segment + "</tspan>";
                } else if (baseline === 'top') {
                  arr += "<tspan x=\"" + x + "\" dy=\"0.9em\">" + segment + "</tspan>";
                } else if (baseline === 'middle') {
                  arr += "<tspan x=\"" + x + "\" dy=\"" + -(textLen - 1) / 2 + "em\">" + segment + "</tspan>";
                } else if (baseline === 'bottom') {
                  arr += "<tspan x=\"" + x + "\" dy=\"-" + (textLen + LETTER_SPACING) + "em\">" + segment + "</tspan>";
                } else if (baseline === 'hanging') {
                  arr += "<tspan x=\"" + x + "\" dy=\"" + (-(textLen - 1) - LETTER_SPACING) + "em\">" + segment + "</tspan>";
                }
              } else {
                arr += "<tspan x=\"" + x + "\" dy=\"1em\">" + segment + "</tspan>";
              }
            });
            el.innerHTML = arr;
          } else {
            el.innerHTML = text;
          }
        };

        _proto._setClip = function _setClip(model, value) {
          var el = model._cfg.el;

          if (!value) {
            el.removeAttribute('clip-path');
            return;
          }

          if (!el.hasAttribute('clip-path')) {
            this._createDom(value);

            this._updateShape(value);

            var id = this.context.addClip(value);
            el.setAttribute('clip-path', "url(#" + id + ")");
          } else if (value._cfg.hasUpdate) {
            this._updateShape(value);
          }
        };

        _proto._setColor = function _setColor(model, name, value) {
          var el = model._cfg.el;
          var defs = this.context;

          if (!value) {
            el.setAttribute(SVG_ATTR_MAP[name], 'none');
            return;
          }

          value = value.trim();

          if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
            var id = defs.find('gradient', value);

            if (!id) {
              id = defs.addGradient(value);
            }

            el.setAttribute(SVG_ATTR_MAP[name], "url(#" + id + ")");
          } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
            var _id = defs.find('pattern', value);

            if (!_id) {
              _id = defs.addPattern(value);
            }

            el.setAttribute(SVG_ATTR_MAP[name], "url(#" + _id + ")");
          } else {
            el.setAttribute(SVG_ATTR_MAP[name], value);
          }
        };

        _proto._setShadow = function _setShadow(model) {
          var el = model._cfg.el;
          var attrs = model._attrs;
          var cfg = {
            dx: attrs.shadowOffsetX,
            dy: attrs.shadowOffsetY,
            blur: attrs.shadowBlur,
            color: attrs.shadowColor
          };

          if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
            el.removeAttribute('filter');
          } else {
            var id = this.context.find('filter', cfg);

            if (!id) {
              id = this.context.addShadow(cfg, this);
            }

            el.setAttribute('filter', "url(#" + id + ")");
          }
        };

        return Painter;
      }();

      module.exports = Painter;
      /***/
    },
    /* 223 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * Created by Elaine on 2018/5/9.
       */
      var Util = __webpack_require__(1);

      var Gradient = __webpack_require__(224);

      var Shadow = __webpack_require__(225);

      var Arrow = __webpack_require__(226);

      var Clip = __webpack_require__(227);

      var Pattern = __webpack_require__(228);

      var Defs = /*#__PURE__*/function () {
        function Defs(canvas) {
          var el = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          var id = Util.uniqueId('defs_');
          el.id = id;
          canvas.appendChild(el);
          this.children = [];
          this.defaultArrow = {};
          this.el = el;
          this.canvas = canvas;
        }

        var _proto = Defs.prototype;

        _proto.find = function find(type, attr) {
          var children = this.children;
          var result = null;

          for (var i = 0; i < children.length; i++) {
            if (children[i].match(type, attr)) {
              result = children[i].id;
              break;
            }
          }

          return result;
        };

        _proto.findById = function findById(id) {
          var children = this.children;
          var flag = null;

          for (var i = 0; i < children.length; i++) {
            if (children[i].id === id) {
              flag = children[i];
              break;
            }
          }

          return flag;
        };

        _proto.add = function add(item) {
          this.children.push(item);
          item.canvas = this.canvas;
          item.parent = this;
        };

        _proto.getDefaultArrow = function getDefaultArrow(attrs, name) {
          var stroke = attrs.stroke || attrs.strokeStyle;

          if (this.defaultArrow[stroke]) {
            return this.defaultArrow[stroke].id;
          }

          var arrow = new Arrow(attrs, name);
          this.defaultArrow[stroke] = arrow;
          this.el.appendChild(arrow.el);
          return arrow.id;
        };

        _proto.addGradient = function addGradient(cfg) {
          var gradient = new Gradient(cfg);
          this.el.appendChild(gradient.el);
          this.add(gradient);
          return gradient.id;
        };

        _proto.addArrow = function addArrow(attrs, name) {
          var arrow = new Arrow(attrs, name);
          this.el.appendChild(arrow.el);
          return arrow.id;
        };

        _proto.addShadow = function addShadow(cfg) {
          var shadow = new Shadow(cfg);
          this.el.appendChild(shadow.el);
          this.add(shadow);
          return shadow.id;
        };

        _proto.addPattern = function addPattern(cfg) {
          var pattern = new Pattern(cfg);
          this.el.appendChild(pattern.el);
          this.add(pattern);
          return pattern.id;
        };

        _proto.addClip = function addClip(cfg) {
          var clip = new Clip(cfg);
          this.el.appendChild(clip.el);
          this.add(clip);
          return clip.id;
        };

        return Defs;
      }();

      module.exports = Defs;
      /***/
    },
    /* 224 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * Created by Elaine on 2018/5/9.
       */
      var Util = __webpack_require__(1);

      var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/ig;

      function addStop(steps) {
        var arr = steps.match(regexColorStop);

        if (!arr) {
          return '';
        }

        var stops = '';
        arr.sort(function (a, b) {
          a = a.split(':');
          b = b.split(':');
          return Number(a[0]) - Number(b[0]);
        });
        Util.each(arr, function (item) {
          item = item.split(':');
          stops += "<stop offset=\"" + item[0] + "\" stop-color=\"" + item[1] + "\"></stop>";
        });
        return stops;
      }

      function parseLineGradient(color, el) {
        var arr = regexLG.exec(color);
        var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);
        var steps = arr[2];
        var start;
        var end;

        if (angle >= 0 && angle < 0.5 * Math.PI) {
          start = {
            x: 0,
            y: 0
          };
          end = {
            x: 1,
            y: 1
          };
        } else if (0.5 * Math.PI <= angle && angle < Math.PI) {
          start = {
            x: 1,
            y: 0
          };
          end = {
            x: 0,
            y: 1
          };
        } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
          start = {
            x: 1,
            y: 1
          };
          end = {
            x: 0,
            y: 0
          };
        } else {
          start = {
            x: 0,
            y: 1
          };
          end = {
            x: 1,
            y: 0
          };
        }

        var tanTheta = Math.tan(angle);
        var tanTheta2 = tanTheta * tanTheta;
        var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
        var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
        el.setAttribute('x1', start.x);
        el.setAttribute('y1', start.y);
        el.setAttribute('x2', x);
        el.setAttribute('y2', y);
        el.innerHTML = addStop(steps);
      }

      function parseRadialGradient(color, self) {
        var arr = regexRG.exec(color);
        var cx = parseFloat(arr[1]);
        var cy = parseFloat(arr[2]);
        var r = parseFloat(arr[3]);
        var steps = arr[4];
        self.setAttribute('cx', cx);
        self.setAttribute('cy', cy);
        self.setAttribute('r', r);
        self.innerHTML = addStop(steps);
      }

      var Gradient = /*#__PURE__*/function () {
        function Gradient(cfg) {
          var el = null;
          var id = Util.uniqueId('gradient_');

          if (cfg.toLowerCase()[0] === 'l') {
            el = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            parseLineGradient(cfg, el);
          } else {
            el = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
            parseRadialGradient(cfg, el);
          }

          el.setAttribute('id', id);
          this.el = el;
          this.id = id;
          this.cfg = cfg;
          return this;
        }

        var _proto = Gradient.prototype;

        _proto.match = function match(type, attr) {
          return this.cfg === attr;
        };

        return Gradient;
      }();

      module.exports = Gradient;
      /***/
    },
    /* 225 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * Created by Elaine on 2018/5/10.
       */
      var Util = __webpack_require__(1);

      var ATTR_MAP = {
        shadowColor: 'color',
        shadowOpacity: 'opacity',
        shadowBlur: 'blur',
        shadowOffsetX: 'dx',
        shadowOffsetY: 'dy'
      };
      var SHADOW_DIMENSION = {
        x: '-40%',
        y: '-40%',
        width: '200%',
        height: '200%'
      };

      var Shadow = /*#__PURE__*/function () {
        function Shadow(cfg) {
          this.type = 'filter';
          var el = document.createElementNS('http://www.w3.org/2000/svg', 'filter'); // expand the filter region to fill in shadows

          Util.each(SHADOW_DIMENSION, function (v, k) {
            el.setAttribute(k, v);
          });
          this.el = el;
          this.id = Util.uniqueId('filter_');
          this.el.id = this.id;
          this.cfg = cfg;

          this._parseShadow(cfg, el);

          return this;
        }

        var _proto = Shadow.prototype;

        _proto.match = function match(type, cfg) {
          if (this.type !== type) {
            return false;
          }

          var flag = true;
          var config = this.cfg;
          Util.each(Object.keys(config), function (attr) {
            if (config[attr] !== cfg[attr]) {
              flag = false;
              return false;
            }
          });
          return flag;
        };

        _proto.update = function update(name, value) {
          var config = this.cfg;
          config[ATTR_MAP[name]] = value;

          this._parseShadow(config, this.el);

          return this;
        };

        _proto._parseShadow = function _parseShadow(config, el) {
          var child = "<feDropShadow \n      dx=\"" + (config.dx || 0) + "\" \n      dy=\"" + (config.dy || 0) + "\" \n      stdDeviation=\"" + (config.blur ? config.blur / 10 : 0) + "\"\n      flood-color=\"" + (config.color ? config.color : '#000') + "\"\n      flood-opacity=\"" + (config.opacity ? config.opacity : 1) + "\"\n      />";
          el.innerHTML = child;
        };

        return Shadow;
      }();

      module.exports = Shadow;
      /***/
    },
    /* 226 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * Created by Elaine on 2018/5/11.
       */
      var Util = __webpack_require__(1);

      var Arrow = /*#__PURE__*/function () {
        function Arrow(attrs, type) {
          var el = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
          var id = Util.uniqueId('marker_');
          el.setAttribute('id', id);
          var shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          shape.setAttribute('stroke', 'none');
          shape.setAttribute('fill', attrs.stroke || '#000');
          el.appendChild(shape);
          el.setAttribute('overflow', 'visible');
          el.setAttribute('orient', 'auto-start-reverse');
          this.el = el;
          this.child = shape;
          this.id = id;
          this.cfg = attrs[type === 'marker-start' ? 'startArrow' : 'endArrow'];
          this.stroke = attrs.stroke || '#000';

          if (this.cfg === true) {
            this._setDefaultPath(type, shape);
          } else {
            this._setMarker(attrs.lineWidth, shape);
          }

          return this;
        }

        var _proto = Arrow.prototype;

        _proto.match = function match() {
          return false;
        };

        _proto._setDefaultPath = function _setDefaultPath(type, el) {
          var parent = this.el;
          el.setAttribute('d', 'M0,0 L6,3 L0,6 L3,3Z');
          parent.setAttribute('refX', 3);
          parent.setAttribute('refY', 3);
        };

        _proto._setMarker = function _setMarker(r, el) {
          var parent = this.el;
          var path = this.cfg.path;
          var d = this.cfg.d;

          if (Util.isArray(path)) {
            path = path.map(function (segment) {
              return segment.join(' ');
            }).join('');
          }

          el.setAttribute('d', path);
          parent.appendChild(el);

          if (d) {
            parent.setAttribute('refX', d / r);
          }
        };

        _proto.update = function update(fill) {
          var child = this.child;

          if (child.attr) {
            child.attr('fill', fill);
          } else {
            child.setAttribute('fill', fill);
          }
        };

        return Arrow;
      }();

      module.exports = Arrow;
      /***/
    },
    /* 227 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * Created by Elaine on 2018/5/14.
       */
      var Util = __webpack_require__(1);

      var Clip = /*#__PURE__*/function () {
        function Clip(cfg) {
          this.type = 'clip';
          var el = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
          this.el = el;
          this.id = Util.uniqueId('clip_');
          el.id = this.id;
          var shapeEl = cfg._cfg.el; // just in case the clip shape is also a shape needs to be drawn

          el.appendChild(shapeEl.cloneNode(true));
          this.cfg = cfg;
          return this;
        }

        var _proto = Clip.prototype;

        _proto.match = function match() {
          return false;
        };

        _proto.remove = function remove() {
          var el = this.el;
          el.parentNode.removeChild(el);
        };

        return Clip;
      }();

      module.exports = Clip;
      /***/
    },
    /* 228 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * Created by Elaine on 2018/5/9.
       */
      var Util = __webpack_require__(1);

      var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;

      var Pattern = /*#__PURE__*/function () {
        function Pattern(cfg) {
          var el = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
          el.setAttribute('patternUnits', 'userSpaceOnUse');
          var child = document.createElementNS('http://www.w3.org/2000/svg', 'image');
          el.appendChild(child);
          var id = Util.uniqueId('pattern_');
          el.id = id;
          this.el = el;
          this.id = id;
          this.cfg = cfg;
          var arr = regexPR.exec(cfg);
          var source = arr[2];
          child.setAttribute('href', source);
          var img = new Image();

          if (!source.match(/^data:/i)) {
            img.crossOrigin = 'Anonymous';
          }

          img.src = source;

          function onload() {
            console.log(img.width, img.height);
            el.setAttribute('width', img.width);
            el.setAttribute('height', img.height);
          }

          if (img.complete) {
            onload();
          } else {
            img.onload = onload; // Fix onload() bug in IE9

            img.src = img.src;
          }

          return this;
        }

        var _proto = Pattern.prototype;

        _proto.match = function match(type, attr) {
          return this.cfg === attr;
        };

        return Pattern;
      }();

      module.exports = Pattern;
      /***/
    },
    /* 229 */

    /***/
    function (module, exports) {
      var TAG_MAP = {
        svg: 'svg',
        circle: 'circle',
        rect: 'rect',
        text: 'text',
        path: 'path',
        foreignObject: 'foreignObject',
        polygon: 'polygon',
        ellipse: 'ellipse',
        image: 'image'
      };

      module.exports = function getShape(x, y, e) {
        var target = e.target || e.srcElement;

        if (!TAG_MAP[target.tagName]) {
          var parent = target.parentNode;

          while (parent && !TAG_MAP[parent.tagName]) {
            parent = parent.parentNode;
          }

          target = parent;
        }

        if (this._cfg.el === target) {
          return this;
        }

        return this.find(function (item) {
          return item._cfg && item._cfg.el === target;
        });
      };
      /***/

    },
    /* 230 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        addEventListener: __webpack_require__(231),
        createDom: __webpack_require__(94),
        getBoundingClientRect: __webpack_require__(232),
        getHeight: __webpack_require__(233),
        getOuterHeight: __webpack_require__(234),
        getOuterWidth: __webpack_require__(235),
        getRatio: __webpack_require__(236),
        getStyle: __webpack_require__(237),
        getWidth: __webpack_require__(238),
        modifyCSS: __webpack_require__(95),
        requestAnimationFrame: __webpack_require__(96)
      };
      /***/
    },
    /* 231 */

    /***/
    function (module, exports) {
      /**
       * 添加事件监听器
       * @param  {Object} target DOM对象
       * @param  {String} eventType 事件名
       * @param  {Funtion} callback 回调函数
       * @return {Object} 返回对象
       */
      module.exports = function addEventListener(target, eventType, callback) {
        if (target) {
          if (target.addEventListener) {
            target.addEventListener(eventType, callback, false);
            return {
              remove: function remove() {
                target.removeEventListener(eventType, callback, false);
              }
            };
          } else if (target.attachEvent) {
            target.attachEvent('on' + eventType, callback);
            return {
              remove: function remove() {
                target.detachEvent('on' + eventType, callback);
              }
            };
          }
        }
      };
      /***/

    },
    /* 232 */

    /***/
    function (module, exports) {
      module.exports = function getBoundingClientRect(node, defaultValue) {
        if (node && node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          var top = document.documentElement.clientTop;
          var left = document.documentElement.clientLeft;
          return {
            top: rect.top - top,
            bottom: rect.bottom - top,
            left: rect.left - left,
            right: rect.right - left
          };
        }

        return defaultValue || null;
      };
      /***/

    },
    /* 233 */

    /***/
    function (module, exports) {
      /**
       * 获取高度
       * @param  {HTMLElement} el dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 高度
       */
      module.exports = function getHeight(el, defaultValue) {
        var height = this.getStyle(el, 'height', defaultValue);

        if (height === 'auto') {
          height = el.offsetHeight;
        }

        return parseFloat(height);
      };
      /***/

    },
    /* 234 */

    /***/
    function (module, exports) {
      /**
       * 获取外层高度
       * @param  {HTMLElement} el dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 高度
       */
      module.exports = function getOuterHeight(el, defaultValue) {
        var height = this.getHeight(el, defaultValue);
        var bTop = parseFloat(this.getStyle(el, 'borderTopWidth')) || 0;
        var pTop = parseFloat(this.getStyle(el, 'paddingTop')) || 0;
        var pBottom = parseFloat(this.getStyle(el, 'paddingBottom')) || 0;
        var bBottom = parseFloat(this.getStyle(el, 'borderBottomWidth')) || 0;
        return height + bTop + bBottom + pTop + pBottom;
      };
      /***/

    },
    /* 235 */

    /***/
    function (module, exports) {
      /**
       * 获取外层宽度
       * @param  {HTMLElement} el dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 宽度
       */
      module.exports = function getOuterWidth(el, defaultValue) {
        var width = this.getWidth(el, defaultValue);
        var bLeft = parseFloat(this.getStyle(el, 'borderLeftWidth')) || 0;
        var pLeft = parseFloat(this.getStyle(el, 'paddingLeft')) || 0;
        var pRight = parseFloat(this.getStyle(el, 'paddingRight')) || 0;
        var bRight = parseFloat(this.getStyle(el, 'borderRightWidth')) || 0;
        return width + bLeft + bRight + pLeft + pRight;
      };
      /***/

    },
    /* 236 */

    /***/
    function (module, exports) {
      module.exports = function getRatio() {
        return window.devicePixelRatio ? window.devicePixelRatio : 2;
      };
      /***/

    },
    /* 237 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);
      /**
       * 获取样式
       * @param  {Object} dom DOM节点
       * @param  {String} name 样式名
       * @param  {Any} defaultValue 默认值
       * @return {String} 属性值
       */


      module.exports = function getStyle(dom, name, defaultValue) {
        try {
          if (window.getComputedStyle) {
            return window.getComputedStyle(dom, null)[name];
          }

          return dom.currentStyle[name];
        } catch (e) {
          if (!isNil(defaultValue)) {
            return defaultValue;
          }

          return null;
        }
      };
      /***/

    },
    /* 238 */

    /***/
    function (module, exports) {
      /**
       * 获取宽度
       * @param  {HTMLElement} el  dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 宽度
       */
      module.exports = function getWidth(el, defaultValue) {
        var width = this.getStyle(el, 'width', defaultValue);

        if (width === 'auto') {
          width = el.offsetWidth;
        }

        return parseFloat(width);
      };
      /***/

    },
    /* 239 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        contains: __webpack_require__(41),
        difference: __webpack_require__(240),
        find: __webpack_require__(241),
        firstValue: __webpack_require__(242),
        flatten: __webpack_require__(243),
        flattenDeep: __webpack_require__(244),
        getRange: __webpack_require__(245),
        merge: __webpack_require__(42),
        pull: __webpack_require__(90),
        pullAt: __webpack_require__(129),
        reduce: __webpack_require__(246),
        remove: __webpack_require__(247),
        sortBy: __webpack_require__(248),
        union: __webpack_require__(249),
        uniq: __webpack_require__(130),
        valuesOfKey: __webpack_require__(65)
      };
      /***/
    },
    /* 240 */

    /***/
    function (module, exports, __webpack_require__) {
      var filter = __webpack_require__(64);

      var contains = __webpack_require__(41);
      /**
       * Flattens `array` a single level deep.
       *
       * @param {Array} arr The array to inspect.
       * @param {Array} values The values to exclude.
       * @return {Array} Returns the new array of filtered values.
       * @example
       * difference([2, 1], [2, 3]);  // => [1]
       */


      var difference = function difference(arr) {
        var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        return filter(arr, function (value) {
          return !contains(values, value);
        });
      };

      module.exports = difference;
      /***/
    },
    /* 241 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(11);

      var isPlainObject = __webpack_require__(26);

      var isMatch = __webpack_require__(127);

      function find(arr, predicate) {
        var _predicate = void 0;

        if (isFunction(predicate)) {
          _predicate = predicate;
        }

        if (isPlainObject(predicate)) {
          _predicate = function _predicate(a) {
            return isMatch(a, predicate);
          };
        }

        if (_predicate) {
          for (var i = 0; i < arr.length; i += 1) {
            if (_predicate(arr[i])) {
              return arr[i];
            }
          }
        }

        return null;
      }

      module.exports = find;
      /***/
    },
    /* 242 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      var isArray = __webpack_require__(4);

      var firstValue = function firstValue(data, name) {
        var rst = null;

        for (var i = 0; i < data.length; i++) {
          var obj = data[i];
          var value = obj[name];

          if (!isNil(value)) {
            if (isArray(value)) {
              rst = value[0];
            } else {
              rst = value;
            }

            break;
          }
        }

        return rst;
      };

      module.exports = firstValue;
      /***/
    },
    /* 243 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);

      var each = __webpack_require__(2);
      /**
       * Flattens `array` a single level deep.
       *
       * @param {Array} arr The array to flatten.
       * @return {Array} Returns the new flattened array.
       * @example
       *
       * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
       */


      var flatten = function flatten(arr) {
        if (!isArray(arr)) {
          return arr;
        }

        var result = [];
        each(arr, function (item) {
          if (isArray(item)) {
            each(item, function (subItem) {
              result.push(subItem);
            });
          } else {
            result.push(item);
          }
        });
        return result;
      };

      module.exports = flatten;
      /***/
    },
    /* 244 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);
      /**
       * Flattens `array` a single level deep.
       *
       * @param {Array} arr The array to flatten.
       * @param {Array} result The array to return.
       * @return {Array} Returns the new flattened array.
       * @example
       *
       * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]
       */


      var flattenDeep = function flattenDeep(arr) {
        var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (!isArray(arr)) {
          result.push(arr);
        } else {
          for (var i = 0; i < arr.length; i += 1) {
            flattenDeep(arr[i], result);
          }
        }

        return result;
      };

      module.exports = flattenDeep;
      /***/
    },
    /* 245 */

    /***/
    function (module, exports, __webpack_require__) {
      var filter = __webpack_require__(64);

      var isArray = __webpack_require__(4);

      var getRange = function getRange(values) {
        // 存在 NaN 时，min,max 判定会出问题
        values = filter(values, function (v) {
          return !isNaN(v);
        });

        if (!values.length) {
          // 如果没有数值则直接返回0
          return {
            min: 0,
            max: 0
          };
        }

        if (isArray(values[0])) {
          var tmp = [];

          for (var i = 0; i < values.length; i++) {
            tmp = tmp.concat(values[i]);
          }

          values = tmp;
        }

        var max = Math.max.apply(null, values);
        var min = Math.min.apply(null, values);
        return {
          min: min,
          max: max
        };
      };

      module.exports = getRange;
      /***/
    },
    /* 246 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);

      var isPlainObject = __webpack_require__(26);

      var each = __webpack_require__(2);

      var reduce = function reduce(arr, fn, init) {
        if (!isArray(arr) && !isPlainObject(arr)) {
          return arr;
        }

        var result = init;
        each(arr, function (data, i) {
          result = fn(result, data, i);
        });
        return result;
      };

      module.exports = reduce;
      /***/
    },
    /* 247 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(13);

      var pullAt = __webpack_require__(129);

      var remove = function remove(arr, predicate) {
        /**
         * const arr = [1, 2, 3, 4]
         * const evens = remove(arr, n => n % 2 == 0)
         * console.log(arr) // => [1, 3]
         * console.log(evens) // => [2, 4]
         */
        var result = [];

        if (!isArrayLike(arr)) {
          return result;
        }

        var i = -1;
        var indexes = [];
        var length = arr.length;

        while (++i < length) {
          var value = arr[i];

          if (predicate(value, i, arr)) {
            result.push(value);
            indexes.push(i);
          }
        }

        pullAt(arr, indexes);
        return result;
      };

      module.exports = remove;
      /***/
    },
    /* 248 */

    /***/
    function (module, exports, __webpack_require__) {
      var isString = __webpack_require__(10);

      var isFunction = __webpack_require__(11);

      var isArray = __webpack_require__(4);

      function sortBy(arr, key) {
        var comparer = void 0;

        if (isFunction(key)) {
          comparer = function comparer(a, b) {
            return key(a) - key(b);
          };
        } else {
          var keys = [];

          if (isString(key)) {
            keys.push(key);
          } else if (isArray(key)) {
            keys = key;
          }

          comparer = function comparer(a, b) {
            for (var i = 0; i < keys.length; i += 1) {
              var prop = keys[i];

              if (a[prop] > b[prop]) {
                return 1;
              }

              if (a[prop] < b[prop]) {
                return -1;
              }
            }

            return 0;
          };
        }

        arr.sort(comparer);
        return arr;
      }

      module.exports = sortBy;
      /***/
    },
    /* 249 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var toArray = __webpack_require__(34);

      var uniq = __webpack_require__(130);

      var union = function union() {
        var result = [];
        var sources = toArray(arguments);
        each(sources, function (arr) {
          result = result.concat(arr);
        });
        return uniq(result);
      };

      module.exports = union;
      /***/
    },
    /* 250 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        getWrapBehavior: __webpack_require__(251),
        wrapBehavior: __webpack_require__(252)
      };
      /***/
    },
    /* 251 */

    /***/
    function (module, exports) {
      /**
       * 获取封装的事件
       * @protected
       * @param  {Object} obj   对象
       * @param  {String} action 事件名称
       * @return {Function}        返回事件处理函数
       */
      function getWrapBehavior(obj, action) {
        return obj['_wrap_' + action];
      }

      module.exports = getWrapBehavior;
      /***/
    },
    /* 252 */

    /***/
    function (module, exports) {
      /**
       * 封装事件，便于使用上下文this,和便于解除事件时使用
       * @protected
       * @param  {Object} obj   对象
       * @param  {String} action 事件名称
       * @return {Function}        返回事件处理函数
       */
      function wrapBehavior(obj, action) {
        if (obj['_wrap_' + action]) {
          return obj['_wrap_' + action];
        }

        var method = function method(e) {
          obj[action](e);
        };

        obj['_wrap_' + action] = method;
        return method;
      }

      module.exports = wrapBehavior;
      /***/
    },
    /* 253 */

    /***/
    function (module, exports, __webpack_require__) {
      var number2color = __webpack_require__(254);

      module.exports = {
        number2color: number2color,
        numberToColor: number2color,
        parsePath: __webpack_require__(255),
        parseRadius: __webpack_require__(256)
      };
      /***/
    },
    /* 254 */

    /***/
    function (module, exports) {
      var numColorCache = {};

      module.exports = function numberToColor(num) {
        // 增加缓存
        var color = numColorCache[num];

        if (!color) {
          var str = num.toString(16);

          for (var i = str.length; i < 6; i++) {
            str = '0' + str;
          }

          color = '#' + str;
          numColorCache[num] = color;
        }

        return color;
      };
      /***/

    },
    /* 255 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);

      var isString = __webpack_require__(10);

      var each = __webpack_require__(2);

      var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
      var regexDot = /[^\s\,]+/ig;

      module.exports = function parsePath(path) {
        path = path || [];

        if (isArray(path)) {
          return path;
        }

        if (isString(path)) {
          path = path.match(regexTags);
          each(path, function (item, index) {
            item = item.match(regexDot);

            if (item[0].length > 1) {
              var tag = item[0].charAt(0);
              item.splice(1, 0, item[0].substr(1));
              item[0] = tag;
            }

            each(item, function (sub, i) {
              if (!isNaN(sub)) {
                item[i] = +sub;
              }
            });
            path[index] = item;
          });
          return path;
        }
      };
      /***/

    },
    /* 256 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);

      module.exports = function parseRadius(radius) {
        var r1 = 0,
            r2 = 0,
            r3 = 0,
            r4 = 0;

        if (isArray(radius)) {
          if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
          } else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
          } else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
          } else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
          }
        } else {
          r1 = r2 = r3 = r4 = radius;
        }

        return {
          r1: r1,
          r2: r2,
          r3: r3,
          r4: r4
        };
      };
      /***/

    },
    /* 257 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumberEqual = __webpack_require__(35);

      module.exports = {
        clamp: __webpack_require__(51),
        fixedBase: __webpack_require__(258),
        isDecimal: __webpack_require__(259),
        isEven: __webpack_require__(260),
        isInteger: __webpack_require__(261),
        isNegative: __webpack_require__(262),
        isNumberEqual: isNumberEqual,
        isOdd: __webpack_require__(263),
        isPositive: __webpack_require__(264),
        maxBy: __webpack_require__(131),
        minBy: __webpack_require__(265),
        mod: __webpack_require__(93),
        snapEqual: isNumberEqual,
        toDegree: __webpack_require__(92),
        toInt: __webpack_require__(132),
        toInteger: __webpack_require__(132),
        toRadian: __webpack_require__(91)
      };
      /***/
    },
    /* 258 */

    /***/
    function (module, exports) {
      var fixedBase = function fixedBase(v, base) {
        var str = base.toString();
        var index = str.indexOf('.');

        if (index === -1) {
          return Math.round(v);
        }

        var length = str.substr(index + 1).length;

        if (length > 20) {
          length = 20;
        }

        return parseFloat(v.toFixed(length));
      };

      module.exports = fixedBase;
      /***/
    },
    /* 259 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(9);

      var isDecimal = function isDecimal(num) {
        return isNumber(num) && num % 1 !== 0;
      };

      module.exports = isDecimal;
      /***/
    },
    /* 260 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(9);

      var isEven = function isEven(num) {
        return isNumber(num) && num % 2 === 0;
      };

      module.exports = isEven;
      /***/
    },
    /* 261 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(9);

      var isInteger = Number.isInteger ? Number.isInteger : function (num) {
        return isNumber(num) && num % 1 === 0;
      };
      module.exports = isInteger;
      /***/
    },
    /* 262 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(9);

      var isNagative = function isNagative(num) {
        return isNumber(num) && num < 0;
      };

      module.exports = isNagative;
      /***/
    },
    /* 263 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(9);

      var isOdd = function isOdd(num) {
        return isNumber(num) && num % 2 !== 0;
      };

      module.exports = isOdd;
      /***/
    },
    /* 264 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(9);

      var isPositive = function isPositive(num) {
        return isNumber(num) && num > 0;
      };

      module.exports = isPositive;
      /***/
    },
    /* 265 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);

      var isFunction = __webpack_require__(11);

      var each = __webpack_require__(2);
      /**
       * @param {Array} arr The array to iterate over.
       * @param {Function} [fn] The iteratee invoked per element.
       * @return {*} Returns the minimum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * minBy(objects, function(o) { return o.n; });
       * // => { 'n': 1 }
       *
       * minBy(objects, 'n');
       * // => { 'n': 1 }
       */


      var minBy = function minBy(arr, fn) {
        if (!isArray(arr)) {
          return undefined;
        }

        var min = arr[0];
        var minData = void 0;

        if (isFunction(fn)) {
          minData = fn(arr[0]);
        } else {
          minData = arr[0][fn];
        }

        var data = void 0;
        each(arr, function (val) {
          if (isFunction(fn)) {
            data = fn(val);
          } else {
            data = val[fn];
          }

          if (data < minData) {
            min = val;
            minData = data;
          }
        });
        return min;
      };

      module.exports = minBy;
      /***/
    },
    /* 266 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        forIn: __webpack_require__(267),
        has: __webpack_require__(133),
        hasKey: __webpack_require__(268),
        hasValue: __webpack_require__(269),
        keys: __webpack_require__(128),
        isMatch: __webpack_require__(127),
        values: __webpack_require__(134)
      };
      /***/
    },
    /* 267 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(2);
      /***/
    },
    /* 268 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(133);
      /***/
    },
    /* 269 */

    /***/
    function (module, exports, __webpack_require__) {
      var contains = __webpack_require__(41);

      var values = __webpack_require__(134);

      module.exports = function (obj, value) {
        return contains(values(obj), value);
      };
      /***/

    },
    /* 270 */

    /***/
    function (module, exports, __webpack_require__) {
      var pathIntersection = __webpack_require__(271);

      var path2absolute = __webpack_require__(138);

      var path2curve = __webpack_require__(137);

      var catmullRom2Bezier = __webpack_require__(140);

      module.exports = {
        catmullRom2Bezier: catmullRom2Bezier,
        catmullRomToBezier: catmullRom2Bezier,
        fillPath: __webpack_require__(272),
        fillPathByDiff: __webpack_require__(273),
        formatPath: __webpack_require__(275),
        intersection: pathIntersection,
        pathIntersection: pathIntersection,
        parsePathArray: __webpack_require__(136),
        parsePathString: __webpack_require__(139),
        pathToAbsolute: path2absolute,
        path2absolute: path2absolute,
        pathTocurve: path2curve,
        path2curve: path2curve,
        rectPath: __webpack_require__(135)
      };
      /***/
    },
    /* 271 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(4);

      var rectPath = __webpack_require__(135);

      var pathTocurve = __webpack_require__(137);

      var base3 = function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
        var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
      };

      var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z === null) {
          z = 1;
        }

        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2;
        var n = 12;
        var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
        var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
        var sum = 0;

        for (var i = 0; i < n; i++) {
          var ct = z2 * Tvalues[i] + z2;
          var xbase = base3(ct, x1, x2, x3, x4);
          var ybase = base3(ct, y1, y2, y3, y4);
          var comb = xbase * xbase + ybase * ybase;
          sum += Cvalues[i] * Math.sqrt(comb);
        }

        return z2 * sum;
      };

      var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
        var tvalues = [];
        var bounds = [[], []];
        var a = void 0;
        var b = void 0;
        var c = void 0;
        var t = void 0;

        for (var i = 0; i < 2; ++i) {
          if (i === 0) {
            b = 6 * x0 - 12 * x1 + 6 * x2;
            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
            c = 3 * x1 - 3 * x0;
          } else {
            b = 6 * y0 - 12 * y1 + 6 * y2;
            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c = 3 * y1 - 3 * y0;
          }

          if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) < 1e-12) {
              continue;
            }

            t = -c / b;

            if (t > 0 && t < 1) {
              tvalues.push(t);
            }

            continue;
          }

          var b2ac = b * b - 4 * c * a;
          var sqrtb2ac = Math.sqrt(b2ac);

          if (b2ac < 0) {
            continue;
          }

          var t1 = (-b + sqrtb2ac) / (2 * a);

          if (t1 > 0 && t1 < 1) {
            tvalues.push(t1);
          }

          var t2 = (-b - sqrtb2ac) / (2 * a);

          if (t2 > 0 && t2 < 1) {
            tvalues.push(t2);
          }
        }

        var j = tvalues.length;
        var jlen = j;
        var mt = void 0;

        while (j--) {
          t = tvalues[j];
          mt = 1 - t;
          bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
          bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        }

        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        bounds[0].length = bounds[1].length = jlen + 2;
        return {
          min: {
            x: Math.min.apply(0, bounds[0]),
            y: Math.min.apply(0, bounds[1])
          },
          max: {
            x: Math.max.apply(0, bounds[0]),
            y: Math.max.apply(0, bounds[1])
          }
        };
      };

      var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
          return;
        }

        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
        var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
        var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
          return;
        }

        var px = nx / denominator;
        var py = ny / denominator;
        var px2 = +px.toFixed(2);
        var py2 = +py.toFixed(2);

        if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
          return;
        }

        return {
          x: px,
          y: py
        };
      };

      var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
      };

      var box = function box(x, y, width, height) {
        if (x === null) {
          x = y = width = height = 0;
        }

        if (y === null) {
          y = x.y;
          width = x.width;
          height = x.height;
          x = x.x;
        }

        return {
          x: x,
          y: y,
          width: width,
          w: width,
          height: height,
          h: height,
          x2: x + width,
          y2: y + height,
          cx: x + width / 2,
          cy: y + height / 2,
          r1: Math.min(width, height) / 2,
          r2: Math.max(width, height) / 2,
          r0: Math.sqrt(width * width + height * height) / 2,
          path: rectPath(x, y, width, height),
          vb: [x, y, width, height].join(' ')
        };
      };

      var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
      };

      var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!isArray(p1x)) {
          p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }

        var bbox = curveDim.apply(null, p1x);
        return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
      };

      var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        var t13 = Math.pow(t1, 3);
        var t12 = Math.pow(t1, 2);
        var t2 = t * t;
        var t3 = t2 * t;
        var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
        var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
        var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
        var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
        var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
        var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
        var ax = t1 * p1x + t * c1x;
        var ay = t1 * p1y + t * c1y;
        var cx = t1 * c2x + t * p2x;
        var cy = t1 * c2y + t * p2y;
        var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);

        return {
          x: x,
          y: y,
          m: {
            x: mx,
            y: my
          },
          n: {
            x: nx,
            y: ny
          },
          start: {
            x: ax,
            y: ay
          },
          end: {
            x: cx,
            y: cy
          },
          alpha: alpha
        };
      };

      var interHelper = function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1);
        var bbox2 = bezierBBox(bez2);

        if (!isBBoxIntersect(bbox1, bbox2)) {
          return justCount ? 0 : [];
        }

        var l1 = bezlen.apply(0, bez1);
        var l2 = bezlen.apply(0, bez2);
        var n1 = ~~(l1 / 8);
        var n2 = ~~(l2 / 8);
        var dots1 = [];
        var dots2 = [];
        var xy = {};
        var res = justCount ? 0 : [];

        for (var i = 0; i < n1 + 1; i++) {
          var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
          dots1.push({
            x: d.x,
            y: d.y,
            t: i / n1
          });
        }

        for (var _i = 0; _i < n2 + 1; _i++) {
          var _d = findDotsAtSegment.apply(0, bez2.concat(_i / n2));

          dots2.push({
            x: _d.x,
            y: _d.y,
            t: _i / n2
          });
        }

        for (var _i2 = 0; _i2 < n1; _i2++) {
          for (var j = 0; j < n2; j++) {
            var di = dots1[_i2];
            var di1 = dots1[_i2 + 1];
            var dj = dots2[j];
            var dj1 = dots2[j + 1];
            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

            if (is) {
              if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
                continue;
              }

              xy[is.x.toFixed(4)] = is.y.toFixed(4);
              var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
              var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

              if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                if (justCount) {
                  res++;
                } else {
                  res.push({
                    x: is.x,
                    y: is.y,
                    t1: t1,
                    t2: t2
                  });
                }
              }
            }
          }
        }

        return res;
      };

      var interPathHelper = function interPathHelper(path1, path2, justCount) {
        path1 = pathTocurve(path1);
        path2 = pathTocurve(path2);
        var x1 = void 0;
        var y1 = void 0;
        var x2 = void 0;
        var y2 = void 0;
        var x1m = void 0;
        var y1m = void 0;
        var x2m = void 0;
        var y2m = void 0;
        var bez1 = void 0;
        var bez2 = void 0;
        var res = justCount ? 0 : [];

        for (var i = 0, ii = path1.length; i < ii; i++) {
          var pi = path1[i];

          if (pi[0] === 'M') {
            x1 = x1m = pi[1];
            y1 = y1m = pi[2];
          } else {
            if (pi[0] === 'C') {
              bez1 = [x1, y1].concat(pi.slice(1));
              x1 = bez1[6];
              y1 = bez1[7];
            } else {
              bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
              x1 = x1m;
              y1 = y1m;
            }

            for (var j = 0, jj = path2.length; j < jj; j++) {
              var pj = path2[j];

              if (pj[0] === 'M') {
                x2 = x2m = pj[1];
                y2 = y2m = pj[2];
              } else {
                if (pj[0] === 'C') {
                  bez2 = [x2, y2].concat(pj.slice(1));
                  x2 = bez2[6];
                  y2 = bez2[7];
                } else {
                  bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                  x2 = x2m;
                  y2 = y2m;
                }

                var intr = interHelper(bez1, bez2, justCount);

                if (justCount) {
                  res += intr;
                } else {
                  for (var k = 0, kk = intr.length; k < kk; k++) {
                    intr[k].segment1 = i;
                    intr[k].segment2 = j;
                    intr[k].bez1 = bez1;
                    intr[k].bez2 = bez2;
                  }

                  res = res.concat(intr);
                }
              }
            }
          }
        }

        return res;
      };

      module.exports = function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
      };
      /***/

    },
    /* 272 */

    /***/
    function (module, exports) {
      function decasteljau(points, t) {
        var left = [];
        var right = [];

        function recurse(points, t) {
          if (points.length === 1) {
            left.push(points[0]);
            right.push(points[0]);
          } else {
            var middlePoints = [];

            for (var i = 0; i < points.length - 1; i++) {
              if (i === 0) {
                left.push(points[0]);
              }

              if (i === points.length - 2) {
                right.push(points[i + 1]);
              }

              middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
            }

            recurse(middlePoints, t);
          }
        }

        if (points.length) {
          recurse(points, t);
        }

        return {
          left: left,
          right: right.reverse()
        };
      }

      function splitCurve(start, end, count) {
        var points = [[start[1], start[2]]];
        count = count || 2;
        var segments = [];

        if (end[0] === 'A') {
          points.push(end[6]);
          points.push(end[7]);
        } else if (end[0] === 'C') {
          points.push([end[1], end[2]]);
          points.push([end[3], end[4]]);
          points.push([end[5], end[6]]);
        } else if (end[0] === 'S' || end[0] === 'Q') {
          points.push([end[1], end[2]]);
          points.push([end[3], end[4]]);
        } else {
          points.push([end[1], end[2]]);
        }

        var leftSegments = points;
        var t = 1 / count;

        for (var i = 0; i < count - 1; i++) {
          var rt = t / (1 - t * i);
          var split = decasteljau(leftSegments, rt);
          segments.push(split.left);
          leftSegments = split.right;
        }

        segments.push(leftSegments);
        var result = segments.map(function (segment) {
          var cmd = [];

          if (segment.length === 4) {
            cmd.push('C');
            cmd = cmd.concat(segment[2]);
          }

          if (segment.length >= 3) {
            if (segment.length === 3) {
              cmd.push('Q');
            }

            cmd = cmd.concat(segment[1]);
          }

          if (segment.length === 2) {
            cmd.push('L');
          }

          cmd = cmd.concat(segment[segment.length - 1]);
          return cmd;
        });
        return result;
      }

      function splitSegment(start, end, count) {
        if (count === 1) {
          return [[].concat(start)];
        }

        var segments = [];

        if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
          segments = segments.concat(splitCurve(start, end, count));
        } else {
          var temp = [].concat(start);

          if (temp[0] === 'M') {
            temp[0] = 'L';
          }

          for (var i = 0; i <= count - 1; i++) {
            segments.push(temp);
          }
        }

        return segments;
      }

      module.exports = function fillPath(source, target) {
        if (source.length === 1) {
          return source;
        }

        var sourceLen = source.length - 1;
        var targetLen = target.length - 1;
        var ratio = sourceLen / targetLen;
        var segmentsToFill = [];

        if (source.length === 1 && source[0][0] === 'M') {
          for (var i = 0; i < targetLen - sourceLen; i++) {
            source.push(source[0]);
          }

          return source;
        }

        for (var _i = 0; _i < targetLen; _i++) {
          var index = Math.floor(ratio * _i);
          segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
        }

        var filled = segmentsToFill.reduce(function (filled, count, i) {
          if (i === sourceLen) {
            return filled.concat(source[sourceLen]);
          }

          return filled.concat(splitSegment(source[i], source[i + 1], count));
        }, []);
        filled.unshift(source[0]);

        if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
          filled.push('Z');
        }

        return filled;
      };
      /***/

    },
    /* 273 */

    /***/
    function (module, exports, __webpack_require__) {
      var isEqual = __webpack_require__(274);

      function getMinDiff(del, add, modify) {
        var type = null;
        var min = modify;

        if (add < min) {
          min = add;
          type = 'add';
        }

        if (del < min) {
          min = del;
          type = 'del';
        }

        return {
          type: type,
          min: min
        };
      }
      /*
       * https://en.wikipedia.org/wiki/Levenshtein_distance
       * 计算两条path的编辑距离
       */


      var levenshteinDistance = function levenshteinDistance(source, target) {
        var sourceLen = source.length;
        var targetLen = target.length;
        var sourceSegment = void 0,
            targetSegment = void 0;
        var temp = 0;

        if (sourceLen === 0 || targetLen === 0) {
          return null;
        }

        var dist = [];

        for (var i = 0; i <= sourceLen; i++) {
          dist[i] = [];
          dist[i][0] = {
            min: i
          };
        }

        for (var j = 0; j <= targetLen; j++) {
          dist[0][j] = {
            min: j
          };
        }

        for (var _i = 1; _i <= sourceLen; _i++) {
          sourceSegment = source[_i - 1];

          for (var _j = 1; _j <= targetLen; _j++) {
            targetSegment = target[_j - 1];

            if (isEqual(sourceSegment, targetSegment)) {
              temp = 0;
            } else {
              temp = 1;
            }

            var del = dist[_i - 1][_j].min + 1;
            var add = dist[_i][_j - 1].min + 1;
            var modify = dist[_i - 1][_j - 1].min + temp;
            dist[_i][_j] = getMinDiff(del, add, modify);
          }
        }

        return dist;
      };

      module.exports = function fillPathByDiff(source, target) {
        var diffMatrix = levenshteinDistance(source, target);
        var sourceLen = source.length;
        var targetLen = target.length;
        var changes = [];
        var index = 1;
        var minPos = 1; // 如果source和target不是完全不相等

        if (diffMatrix[sourceLen][targetLen] !== sourceLen) {
          // 获取从source到target所需改动
          for (var i = 1; i <= sourceLen; i++) {
            var min = diffMatrix[i][i].min;
            minPos = i;

            for (var j = index; j <= targetLen; j++) {
              if (diffMatrix[i][j].min < min) {
                min = diffMatrix[i][j].min;
                minPos = j;
              }
            }

            index = minPos;

            if (diffMatrix[i][index].type) {
              changes.push({
                index: i - 1,
                type: diffMatrix[i][index].type
              });
            }
          } // 对source进行增删path


          for (var _i2 = changes.length - 1; _i2 >= 0; _i2--) {
            index = changes[_i2].index;

            if (changes[_i2].type === 'add') {
              source.splice(index, 0, [].concat(source[index]));
            } else {
              source.splice(index, 1);
            }
          }
        } // source尾部补齐


        sourceLen = source.length;

        if (sourceLen < targetLen) {
          for (var _i3 = 0; _i3 < targetLen - sourceLen; _i3++) {
            if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
              source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
            } else {
              source.push(source[sourceLen - 1]);
            }
          }
        }

        return source;
      };
      /***/

    },
    /* 274 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      module.exports = function isEqual(obj1, obj2) {
        if (obj1.length !== obj2.length) {
          return false;
        }

        var result = true;
        each(obj1, function (item, i) {
          if (item !== obj2[i]) {
            result = false;
            return false;
          }
        });
        return result;
      };
      /***/

    },
    /* 275 */

    /***/
    function (module, exports) {
      /*
       * 抽取pathSegment中的关键点
       * M,L,A,Q,H,V一个端点
       * Q, S抽取一个端点，一个控制点
       * C抽取一个端点，两个控制点
       */
      function _getSegmentPoints(segment) {
        var points = [];

        switch (segment[0]) {
          case 'M':
            points.push([segment[1], segment[2]]);
            break;

          case 'L':
            points.push([segment[1], segment[2]]);
            break;

          case 'A':
            points.push([segment[6], segment[7]]);
            break;

          case 'Q':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;

          case 'T':
            points.push([segment[1], segment[2]]);
            break;

          case 'C':
            points.push([segment[5], segment[6]]);
            points.push([segment[1], segment[2]]);
            points.push([segment[3], segment[4]]);
            break;

          case 'S':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;

          case 'H':
            points.push([segment[1], segment[1]]);
            break;

          case 'V':
            points.push([segment[1], segment[1]]);
            break;

          default:
        }

        return points;
      } // 将两个点均分成count个点


      function _splitPoints(points, former, count) {
        var result = [].concat(points);
        var index = void 0;
        var t = 1 / (count + 1);

        var formerEnd = _getSegmentPoints(former)[0];

        for (var i = 1; i <= count; i++) {
          t *= i;
          index = Math.floor(points.length * t);

          if (index === 0) {
            result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
          } else {
            result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
          }
        }

        return result;
      }

      module.exports = function formatPath(fromPath, toPath) {
        if (fromPath.length <= 1) {
          return fromPath;
        }

        var points = void 0;

        for (var i = 0; i < toPath.length; i++) {
          if (fromPath[i][0] !== toPath[i][0]) {
            // 获取fromPath的pathSegment的端点，根据toPath的指令对其改造
            points = _getSegmentPoints(fromPath[i]);

            switch (toPath[i][0]) {
              case 'M':
                fromPath[i] = ['M'].concat(points[0]);
                break;

              case 'L':
                fromPath[i] = ['L'].concat(points[0]);
                break;

              case 'A':
                fromPath[i] = [].concat(toPath[i]);
                fromPath[i][6] = points[0][0];
                fromPath[i][7] = points[0][1];
                break;

              case 'Q':
                if (points.length < 2) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 1);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              case 'T':
                fromPath[i] = ['T'].concat(points[0]);
                break;

              case 'C':
                if (points.length < 3) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 2);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              case 'S':
                if (points.length < 2) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 1);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              default:
                fromPath[i] = toPath[i];
            }
          }
        }

        return fromPath;
      };
      /***/

    },
    /* 276 */

    /***/
    function (module, exports, __webpack_require__) {
      var strUtil = {
        lc: __webpack_require__(277),
        lowerCase: __webpack_require__(141),
        lowerFirst: __webpack_require__(75),
        substitute: __webpack_require__(278),
        uc: __webpack_require__(279),
        upperCase: __webpack_require__(142),
        upperFirst: __webpack_require__(87)
      };
      module.exports = strUtil;
      /***/
    },
    /* 277 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(141);
      /***/
    },
    /* 278 */

    /***/
    function (module, exports) {
      var substitute = function substitute(str, o) {
        if (!str || !o) {
          return str;
        }

        return str.replace(/\\?\{([^{}]+)\}/g, function (match, name) {
          if (match.charAt(0) === '\\') {
            return match.slice(1);
          }

          return o[name] === undefined ? '' : o[name];
        });
      };

      module.exports = substitute;
      /***/
    },
    /* 279 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(142);
      /***/
    },
    /* 280 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(12);

      var checkType = {
        getType: __webpack_require__(84),
        isArray: __webpack_require__(4),
        isArrayLike: __webpack_require__(13),
        isBoolean: __webpack_require__(82),
        isFunction: __webpack_require__(11),
        isNil: __webpack_require__(5),
        isNull: __webpack_require__(281),
        isNumber: __webpack_require__(9),
        isObject: __webpack_require__(25),
        isObjectLike: __webpack_require__(49),
        isPlainObject: __webpack_require__(26),
        isPrototype: __webpack_require__(85),
        isType: isType,
        isUndefined: __webpack_require__(282),
        isString: __webpack_require__(10),
        isRegExp: __webpack_require__(283),
        isDate: __webpack_require__(80),
        isArguments: __webpack_require__(284),
        isError: __webpack_require__(285)
      };
      module.exports = checkType;
      /***/
    },
    /* 281 */

    /***/
    function (module, exports) {
      var isNull = function isNull(value) {
        return value === null;
      };

      module.exports = isNull;
      /***/
    },
    /* 282 */

    /***/
    function (module, exports) {
      var isUndefined = function isUndefined(value) {
        return value === undefined;
      };

      module.exports = isUndefined;
      /***/
    },
    /* 283 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(12);

      var isRegExp = function isRegExp(str) {
        return isType(str, 'RegExp');
      };

      module.exports = isRegExp;
      /***/
    },
    /* 284 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 是否是参数类型
       *
       * @param {Object} value 测试的值
       * @return {Boolean}
       */
      var isType = __webpack_require__(12);

      var isArguments = function isArguments(value) {
        return isType(value, 'Arguments');
      };

      module.exports = isArguments;
      /***/
    },
    /* 285 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 是否是参数类型
       *
       * @param {Object} value 测试的值
       * @return {Boolean}
       */
      var isType = __webpack_require__(12);

      var isError = function isError(value) {
        return isType(value, 'Error');
      };

      module.exports = isError;
      /***/
    },
    /* 286 */

    /***/
    function (module, exports) {
      function debounce(func, wait, immediate) {
        var timeout = void 0;
        return function () {
          var context = this,
              args = arguments;

          var later = function later() {
            timeout = null;

            if (!immediate) {
              func.apply(context, args);
            }
          };

          var callNow = immediate && !timeout;
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);

          if (callNow) {
            func.apply(context, args);
          }
        };
      }

      module.exports = debounce;
      /***/
    },
    /* 287 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(13);

      var indexOf = function indexOf(arr, obj) {
        if (!isArrayLike(arr)) {
          return -1;
        }

        var m = Array.prototype.indexOf;

        if (m) {
          return m.call(arr, obj);
        }

        var index = -1;

        for (var i = 0; i < arr.length; i++) {
          if (arr[i] === obj) {
            index = i;
            break;
          }
        }

        return index;
      };

      module.exports = indexOf;
      /***/
    },
    /* 288 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(11);

      var isEqual = __webpack_require__(50);
      /**
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [fn] The function to customize comparisons.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, othValue) {
       *   if (isGreeting(objValue) && isGreeting(othValue)) {
       *     return true;
       *   }
       * }
       *
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * isEqualWith(array, other, customizer);  // => true
       */


      var isEqualWith = function isEqualWith(value, other, fn) {
        if (!isFunction(fn)) {
          return isEqual(value, other);
        }

        return !!fn(value, other);
      };

      module.exports = isEqualWith;
      /***/
    },
    /* 289 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var isArrayLike = __webpack_require__(13);

      var map = function map(arr, func) {
        if (!isArrayLike(arr)) {
          return arr;
        }

        var result = [];
        each(arr, function (value, index) {
          result.push(func(value, index));
        });
        return result;
      };

      module.exports = map;
      /***/
    },
    /* 290 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(2);

      var isPlaineObject = __webpack_require__(26);

      var hasOwnProperty = Object.prototype.hasOwnProperty;
      /**
       * Creates an object composed of the picked `object` properties.
       *
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       * pick(object, ['a', 'c']);  // => { 'a': 1, 'c': 3 }
       */

      var pick = function pick(object, keys) {
        if (object === null || !isPlaineObject(object)) {
          return {};
        }

        var result = {};
        each(keys, function (key) {
          if (hasOwnProperty.call(object, key)) {
            result[key] = object[key];
          }
        });
        return result;
      };

      module.exports = pick;
      /***/
    },
    /* 291 */

    /***/
    function (module, exports) {
      function throttle(func, wait, options) {
        var timeout = void 0,
            context = void 0,
            args = void 0,
            result = void 0;
        var previous = 0;
        if (!options) options = {};

        var later = function later() {
          previous = options.leading === false ? 0 : Date.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        };

        var throttled = function throttled() {
          var now = Date.now();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;

          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }

            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }

          return result;
        };

        throttled.cancel = function () {
          clearTimeout(timeout);
          previous = 0;
          timeout = context = args = null;
        };

        return throttled;
      }

      module.exports = throttle;
      /***/
    },
    /* 292 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview Default animation funciton
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var G = __webpack_require__(16);

      var PathUtil = Util.PathUtil;

      function getClip(coord) {
        var start = coord.start;
        var end = coord.end;
        var width = coord.getWidth();
        var height = coord.getHeight();
        var margin = 200;
        var startAngle;
        var endAngle;
        var center;
        var radius;
        var clip;

        if (coord.isPolar) {
          radius = coord.getRadius();
          center = coord.getCenter();
          startAngle = coord.startAngle;
          endAngle = coord.endAngle;
          clip = new G.Fan({
            attrs: {
              x: center.x,
              y: center.y,
              rs: 0,
              re: radius + margin,
              startAngle: startAngle,
              endAngle: startAngle
            }
          });
          clip.endState = {
            endAngle: endAngle
          };
        } else {
          clip = new G.Rect({
            attrs: {
              x: start.x - margin,
              y: end.y - margin,
              width: coord.isTransposed ? width + margin * 2 : 0,
              height: coord.isTransposed ? 0 : height + margin * 2
            }
          });

          if (coord.isTransposed) {
            clip.endState = {
              height: height + margin * 2
            };
          } else {
            clip.endState = {
              width: width + margin * 2
            };
          }
        }

        clip.isClip = true;
        return clip;
      } // 获取图形的包围盒


      function getPointsBox(points) {
        if (Util.isEmpty(points)) {
          return null;
        }

        var minX = points[0].x;
        var maxX = points[0].x;
        var minY = points[0].y;
        var maxY = points[0].y;
        Util.each(points, function (point) {
          minX = minX > point.x ? point.x : minX;
          maxX = maxX < point.x ? point.x : maxX;
          minY = minY > point.y ? point.y : minY;
          maxY = maxY < point.y ? point.y : maxY;
        });
        return {
          minX: minX,
          maxX: maxX,
          minY: minY,
          maxY: maxY,
          centerX: (minX + maxX) / 2,
          centerY: (minY + maxY) / 2
        };
      }

      function getAngle(shape, coord) {
        var points = shape.points || shape.get('origin').points;
        var box = getPointsBox(points);
        var endAngle;
        var startAngle;
        var coordStartAngle = coord.startAngle;
        var coordEndAngle = coord.endAngle;
        var diffAngle = coordEndAngle - coordStartAngle;

        if (coord.isTransposed) {
          endAngle = box.maxY * diffAngle;
          startAngle = box.minY * diffAngle;
        } else {
          endAngle = box.maxX * diffAngle;
          startAngle = box.minX * diffAngle;
        }

        endAngle += coordStartAngle;
        startAngle += coordStartAngle;
        return {
          startAngle: startAngle,
          endAngle: endAngle
        };
      }

      function getAnimateParam(animateCfg, index, id) {
        var result = {};

        if (animateCfg.delay) {
          result.delay = Util.isFunction(animateCfg.delay) ? animateCfg.delay(index, id) : animateCfg.delay;
        }

        result.easing = Util.isFunction(animateCfg.easing) ? animateCfg.easing(index, id) : animateCfg.easing;
        result.duration = Util.isFunction(animateCfg.duration) ? animateCfg.duration(index, id) : animateCfg.duration;
        result.callback = animateCfg.callback;
        return result;
      }

      function scaleInY(shape, animateCfg) {
        var id = shape._id;
        var index = shape.get('index');
        var box = shape.getBBox();
        var points = shape.get('origin').points;
        var x = (box.minX + box.maxX) / 2;
        var y;

        if (points[0].y - points[1].y <= 0) {
          // 当顶点在零点之下
          y = box.maxY;
        } else {
          y = box.minY;
        }

        var v = [x, y, 1];
        shape.apply(v);
        shape.attr('transform', [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]);
        var endState = {
          transform: [['t', -x, -y], ['s', 1, 100], ['t', x, y]]
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
      }

      function scaleInX(shape, animateCfg) {
        var id = shape._id;
        var index = shape.get('index');
        var box = shape.getBBox();
        var points = shape.get('origin').points;
        var x;
        var y = (box.minY + box.maxY) / 2;

        if (points[0].y - points[1].y > 0) {
          // 当顶点在零点之下
          x = box.maxX;
        } else {
          x = box.minX;
        }

        var v = [x, y, 1];
        shape.apply(v);
        shape.attr({
          transform: [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]
        });
        var endState = {
          transform: [['t', -x, -y], ['s', 100, 1], ['t', x, y]]
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
      }

      function lineWidthOut(shape, animateCfg) {
        var endState = {
          lineWidth: 0,
          opacity: 0
        };
        var id = shape._id;
        var index = shape.get('index');
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, function () {
          shape.remove();
        }, animateParam.delay);
      }

      function zoomIn(shape, animateCfg, coord) {
        var id = shape._id;
        var index = shape.get('index');
        var x;
        var y;

        if (coord.isPolar && shape.name !== 'point') {
          x = coord.getCenter().x;
          y = coord.getCenter().y;
        } else {
          var box = shape.getBBox();
          x = (box.minX + box.maxX) / 2;
          y = (box.minY + box.maxY) / 2;
        }

        var v = [x, y, 1];
        shape.apply(v);
        shape.attr({
          transform: [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]
        });
        var endState = {
          transform: [['t', -x, -y], ['s', 100, 100], ['t', x, y]]
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
      }

      function zoomOut(shape, animateCfg, coord) {
        var id = shape._id;
        var index = shape.get('index');
        var x;
        var y;

        if (coord.isPolar && shape.name !== 'point') {
          x = coord.getCenter().x;
          y = coord.getCenter().y;
        } else {
          var box = shape.getBBox();
          x = (box.minX + box.maxX) / 2;
          y = (box.minY + box.maxY) / 2;
        }

        var v = [x, y, 1];
        shape.apply(v);
        var endState = {
          transform: [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, function () {
          shape.remove();
        }, animateParam.delay);
      }

      function pathIn(shape, animateCfg) {
        if (shape.get('type') !== 'path') return;
        var id = shape._id;
        var index = shape.get('index');
        var path = PathUtil.pathToAbsolute(shape.attr('path'));
        shape.attr('path', [path[0]]);
        var endState = {
          path: path
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
      }

      function pathOut(shape, animateCfg) {
        if (shape.get('type') !== 'path') return;
        var id = shape._id;
        var index = shape.get('index');
        var path = PathUtil.pathToAbsolute(shape.attr('path'));
        var endState = {
          path: [path[0]]
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, function () {
          shape.remove();
        }, animateParam.delay);
      }

      function clipIn(shape, animateCfg, coord, startAngle, endAngle) {
        var clip = getClip(coord);
        var canvas = shape.get('canvas');
        var id = shape._id;
        var index = shape.get('index');
        var endState;

        if (startAngle) {
          clip.attr('startAngle', startAngle);
          clip.attr('endAngle', startAngle);
          endState = {
            endAngle: endAngle
          };
        } else {
          endState = clip.endState;
        }

        clip.set('canvas', canvas);
        shape.attr('clip', clip);
        shape.setSilent('animating', true);
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        clip.animate(endState, animateParam.duration, animateParam.easing, function () {
          if (shape && !shape.get('destroyed')) {
            shape.attr('clip', null);
            shape.setSilent('cacheShape', null);
            shape.setSilent('animating', false);
            clip.remove();
          }
        }, animateParam.delay);
      }

      function fadeIn(shape, animateCfg) {
        var id = shape._id;
        var index = shape.get('index');
        var fillOpacity = Util.isNil(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity');
        var strokeOpacity = Util.isNil(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity');
        shape.attr('fillOpacity', 0);
        shape.attr('strokeOpacity', 0);
        var endState = {
          fillOpacity: fillOpacity,
          strokeOpacity: strokeOpacity
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
      }

      function fadeOut(shape, animateCfg) {
        var id = shape._id;
        var index = shape.get('index');
        var endState = {
          fillOpacity: 0,
          strokeOpacity: 0
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, function () {
          shape.remove();
        }, animateParam.delay);
      }

      function fanIn(shape, animateCfg, coord) {
        var angle = getAngle(shape, coord);
        var endAngle = angle.endAngle;
        var startAngle = angle.startAngle;
        clipIn(shape, animateCfg, coord, startAngle, endAngle);
      }

      function lineSlideLeft(shape, animateCfg, coord) {
        if (shape.name !== 'line') {
          return;
        }

        var canvas = shape.get('canvas');
        var cache = shape.get('cacheShape');
        var id = shape._id;
        var index = shape.get('index');
        var clip = new G.Rect({
          attrs: {
            x: coord.start.x,
            y: coord.end.y,
            width: coord.getWidth(),
            height: coord.getHeight()
          }
        });
        clip.isClip = true;
        clip.set('canvas', canvas);
        var lastPath = PathUtil.pathToAbsolute(cache.attrs.path);
        var updatePath = PathUtil.pathToAbsolute(shape.attr('path'));
        var gap = lastPath[1][1] - lastPath[0][1]; // 生成过渡Path

        var pathPatchPosX = lastPath[lastPath.length - 1][1] + gap;
        var pathPatchPosY = updatePath[updatePath.length - 1][2];
        var transitionPath = lastPath.concat([['L', pathPatchPosX, pathPatchPosY]]);
        var v = [0, 0, 1];
        shape.apply(v);
        shape.attr('clip', clip);
        shape.attr('path', transitionPath);
        var endState = {
          transform: [['t', -gap, 0]]
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, function () {
          if (shape && !shape.get('destroyed')) {
            shape.attr('path', updatePath);
            shape.attr({
              transform: [['t', gap, 0]]
            });
            shape.attr('clip', null);
            shape.setSilent('cacheShape', null);
            clip.remove();
          }
        }, animateParam.delay);
      }

      function areaSlideLeft(shape, animateCfg, coord) {
        if (shape.name !== 'area') {
          return;
        }

        var canvas = shape.get('canvas');
        var cache = shape.get('cacheShape');
        var id = shape._id;
        var index = shape.get('index');
        var clip = new G.Rect({
          attrs: {
            x: coord.start.x,
            y: coord.end.y,
            width: coord.getWidth(),
            height: coord.getHeight()
          }
        });
        clip.isClip = true;
        clip.set('canvas', canvas);
        var lastPath = PathUtil.pathToAbsolute(cache.attrs.path);
        var updatePath = PathUtil.pathToAbsolute(shape.attr('path'));
        var gap = lastPath[1][1] - lastPath[0][1]; // 生成过渡Path

        var middleIndex = Math.floor(lastPath.length / 2);
        var pathPatchPosX = lastPath[middleIndex - 1][1] + gap;
        var pathPatchPosY = updatePath[middleIndex - 1][2];
        var transitionPath = [].concat(lastPath.slice(0, middleIndex), [['L', pathPatchPosX, pathPatchPosY], ['L', pathPatchPosX, updatePath[middleIndex][2]]], lastPath.slice(middleIndex));
        var v = [0, 0, 1];
        shape.apply(v);
        shape.attr('clip', clip);
        shape.attr('path', transitionPath);
        var endState = {
          transform: [['t', -gap, 0]]
        };
        var animateParam = getAnimateParam(animateCfg, index, id, endState);
        shape.animate(endState, animateParam.duration, animateParam.easing, function () {
          if (shape && !shape.get('destroyed')) {
            shape.attr('path', updatePath);
            shape.attr({
              transform: [['t', gap, 0]]
            });
            shape.attr('clip', null);
            shape.setSilent('cacheShape', null);
            clip.remove();
          }
        }, animateParam.delay);
      } // 默认动画库


      module.exports = {
        enter: {
          clipIn: clipIn,
          zoomIn: zoomIn,
          pathIn: pathIn,
          scaleInY: scaleInY,
          scaleInX: scaleInX,
          fanIn: fanIn,
          fadeIn: fadeIn
        },
        leave: {
          lineWidthOut: lineWidthOut,
          zoomOut: zoomOut,
          pathOut: pathOut,
          fadeOut: fadeOut
        },
        appear: {
          clipIn: clipIn,
          zoomIn: zoomIn,
          pathIn: pathIn,
          scaleInY: scaleInY,
          scaleInX: scaleInX,
          fanIn: fanIn,
          fadeIn: fadeIn
        },
        update: {
          fadeIn: fadeIn,
          fanIn: fanIn,
          lineSlideLeft: lineSlideLeft,
          areaSlideLeft: areaSlideLeft
        }
      };
      /***/
    },
    /* 293 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview view
       * @author dxq613@gmail.com
       */


      var Base = __webpack_require__(147);

      var Geom = __webpack_require__(21);

      var Util = __webpack_require__(0);

      var Controller = __webpack_require__(165);

      var Global = __webpack_require__(7);

      var Theme = __webpack_require__(150);

      var FIELD_ORIGIN = '_origin';

      var Animate = __webpack_require__(357);

      function isFullCircle(coord) {
        var startAngle = coord.startAngle;
        var endAngle = coord.endAngle;

        if (!Util.isNil(startAngle) && !Util.isNil(endAngle) && endAngle - startAngle < Math.PI * 2) {
          return false;
        }

        return true;
      }

      function isBetween(value, start, end) {
        var tmp = (value - start) / (end - start);
        return tmp >= 0 && tmp <= 1;
      }

      function isPointInCoord(coord, point) {
        var result = false;

        if (coord) {
          var type = coord.type;

          if (type === 'theta') {
            var start = coord.start;
            var end = coord.end;
            result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);
          } else {
            var invertPoint = coord.invert(point);
            result = invertPoint.x >= 0 && invertPoint.y >= 0 && invertPoint.x <= 1 && invertPoint.y <= 1;
          }
        }

        return result;
      }

      var ViewGeoms = {};
      Util.each(Geom, function (geomConstructor, className) {
        var methodName = Util.lowerFirst(className);

        ViewGeoms[methodName] = function (cfg) {
          var geom = new geomConstructor(cfg);
          this.addGeom(geom);
          return geom;
        };
      });
      /**
       * 图表中的视图
       * @class View
       */

      var View = /*#__PURE__*/function (_Base) {
        _inheritsLoose(View, _Base);

        var _proto = View.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {
            viewContainer: null,
            coord: null,
            start: {
              x: 0,
              y: 0
            },
            end: {
              x: 1,
              y: 1
            },
            geoms: [],
            scales: {},
            options: {},
            scaleController: null,
            padding: 0,
            theme: null,
            parent: null,
            tooltipEnable: true,
            // 是否展示 tooltip
            animate: Global.animate,
            visible: true
          };
        };

        function View(cfg) {
          var _this;

          _this = _Base.call(this, cfg) || this;

          var self = _assertThisInitialized(_this);

          self._setTheme();

          Util.each(Geom, function (GeomConstructor, className) {
            var methodName = Util.lowerFirst(className);

            self[methodName] = function (cfg) {
              if (cfg === void 0) {
                cfg = {};
              }

              cfg.viewTheme = self.get('viewTheme');
              var geom = new GeomConstructor(cfg);
              self.addGeom(geom);
              return geom;
            };
          }); // Util.mix(this, ViewGeoms);

          self.init();
          return _this;
        }

        _proto._setTheme = function _setTheme() {
          var self = this;
          var theme = self.get('theme');
          var viewTheme = {};
          var newTheme = {};

          if (Util.isObject(theme)) {
            newTheme = theme;
          } else if (Util.indexOf(Object.keys(Theme), theme) !== -1) {
            newTheme = Theme[theme];
          }

          Util.deepMix(viewTheme, Global, newTheme);
          self.set('viewTheme', viewTheme);
        }
        /**
         * @protected
         * 初始化
         */
        ;

        _proto.init = function init() {
          this._initViewPlot(); // 先创建容器


          if (this.get('data')) {
            this._initData(this.get('data'));
          }

          this._initOptions();

          this._initControllers();

          this._bindEvents();
        } // 初始化配置项
        ;

        _proto._initOptions = function _initOptions() {
          var self = this;
          var options = Util.mix({}, self.get('options')); // 防止修改原始值

          if (!options.scales) {
            options.scales = {};
          }

          if (!options.coord) {
            options.coord = {};
          }

          if (options.animate === false) {
            this.set('animate', false);
          }

          if (options.tooltip === false || Util.isNull(options.tooltip)) {
            // 配置项方式关闭 tooltip
            this.set('tooltipEnable', false);
          }

          if (options.geoms && options.geoms.length) {
            Util.each(options.geoms, function (geomOption) {
              self._createGeom(geomOption);
            });
          }

          var scaleController = self.get('scaleController');

          if (scaleController) {
            scaleController.defs = options.scales;
          }

          var coordController = self.get('coordController');

          if (coordController) {
            coordController.reset(options.coord);
          }

          this.set('options', options);
        };

        _proto._createGeom = function _createGeom(cfg) {
          var type = cfg.type;
          var geom;

          if (this[type]) {
            geom = this[type]();
            Util.each(cfg, function (v, k) {
              if (geom[k]) {
                if (Util.isObject(v) && v.field) {
                  // 配置项传入
                  if (v === 'label') {
                    geom[k](v.field, v.callback, v.cfg);
                  } else {
                    var _cfg;

                    Util.each(v, function (value, key) {
                      if (key !== 'field') {
                        _cfg = value;
                      }
                    });
                    geom[k](v.field, _cfg);
                  }
                } else {
                  geom[k](v);
                }
              }
            });
          }
        } // 初始化所有的控制器
        ;

        _proto._initControllers = function _initControllers() {
          var self = this;
          var options = self.get('options');
          var viewTheme = self.get('viewTheme');
          var canvas = self.get('canvas');
          var scaleController = new Controller.Scale({
            viewTheme: viewTheme,
            defs: options.scales
          });
          var coordController = new Controller.Coord(options.coord);
          this.set('scaleController', scaleController);
          this.set('coordController', coordController);
          var axisController = new Controller.Axis({
            canvas: canvas,
            viewTheme: viewTheme
          });
          this.set('axisController', axisController);
          var guideController = new Controller.Guide({
            viewTheme: viewTheme,
            options: options.guides || []
          });
          this.set('guideController', guideController);
        };

        _proto._initViewPlot = function _initViewPlot() {
          if (!this.get('viewContainer')) {
            // 用于 geom 的绘制
            this.set('viewContainer', this.get('middlePlot'));
          }
        };

        _proto._initGeoms = function _initGeoms() {
          var geoms = this.get('geoms');
          var filteredData = this.get('filteredData');
          var coord = this.get('coord');
          var viewId = this.get('_id');

          for (var i = 0; i < geoms.length; i++) {
            var geom = geoms[i];
            geom.set('data', filteredData);
            geom.set('coord', coord);
            geom.set('_id', viewId + '-geom' + i);
            geom.set('keyFields', this.get('keyFields'));
            geom.init();
          }
        };

        _proto._clearGeoms = function _clearGeoms() {
          var self = this;
          var geoms = self.get('geoms');

          for (var i = 0; i < geoms.length; i++) {
            var geom = geoms[i];
            geom.clear();
          }
        };

        _proto._removeGeoms = function _removeGeoms() {
          var self = this;
          var geoms = self.get('geoms');

          while (geoms.length > 0) {
            var geom = geoms.shift();
            geom.destroy();
          }
        };

        _proto._drawGeoms = function _drawGeoms() {
          this.emit('beforedrawgeoms');
          var geoms = this.get('geoms');
          var coord = this.get('coord');

          for (var i = 0; i < geoms.length; i++) {
            var geom = geoms[i];
            geom.setCoord(coord);
            geom.paint();
          }

          this.emit('afterdrawgeoms');
        };

        _proto.isShapeInView = function isShapeInView(shape) {
          var id = this.get('_id');
          var shapeId = shape._id;

          if (shapeId) {
            return shapeId.split('-')[0] === id;
          }

          var parent = shape;

          while (parent) {
            if (parent.get('viewId') === id) {
              return true;
            }

            parent = parent.get('parent');
          }

          return false;
        }
        /**
         * View 所在的范围
         * @protected
         * @return {Object} View 所在的范围
         */
        ;

        _proto.getViewRegion = function getViewRegion() {
          var self = this;
          var parent = self.get('parent');
          var start;
          var end;

          if (parent) {
            var region = parent.getViewRegion();

            var viewRegion = self._getViewRegion(region.start, region.end);

            start = viewRegion.start;
            end = viewRegion.end;
          } else {
            start = self.get('start');
            end = self.get('end');
          }

          return {
            start: start,
            end: end
          };
        } // 获取 range 所在的范围
        ;

        _proto._getViewRegion = function _getViewRegion(plotStart, plotEnd) {
          var start = this.get('start');
          var end = this.get('end');
          var startX = start.x;
          var startY = 1 - end.y;
          var endX = end.x;
          var endY = 1 - start.y;
          var padding = this.get('padding'); // 转换成 上、右、下、左的模式

          var allPadding = Util.toAllPadding(padding);
          var top = allPadding[0];
          var right = allPadding[1];
          var bottom = allPadding[2];
          var left = allPadding[3];
          var startPoint = {
            x: startX * (plotEnd.x - plotStart.x) + plotStart.x + left,
            y: startY * (plotEnd.y - plotStart.y) + plotStart.y - bottom
          };
          var endPoint = {
            x: endX * (plotEnd.x - plotStart.x) + plotStart.x - right,
            y: endY * (plotEnd.y - plotStart.y) + plotStart.y + top
          };
          return {
            start: startPoint,
            end: endPoint
          };
        };

        _proto._createCoord = function _createCoord() {
          var coordController = this.get('coordController');
          var region = this.getViewRegion();
          var coord = coordController.createCoord(region.start, region.end);
          this.set('coord', coord);
        };

        _proto._renderAxes = function _renderAxes() {
          var options = this.get('options');
          var axesOptions = options.axes;

          if (axesOptions === false) {
            // 不渲染坐标轴
            return;
          }

          var axisController = this.get('axisController');
          axisController.container = this.get('backPlot');
          axisController.coord = this.get('coord');
          axisController.options = axesOptions || {};
          var xScale = this.getXScale();
          var yScales = this.getYScales();
          var viewId = this.get('_id');
          axisController.createAxis(xScale, yScales, viewId);
        };

        _proto._renderGuides = function _renderGuides() {
          var guideController = this.get('guideController');

          if (!Util.isEmpty(guideController.options)) {
            var coord = this.get('coord');
            guideController.view = this;
            guideController.backContainer = this.get('backPlot');
            guideController.frontContainer = this.get('frontPlot');
            guideController.xScales = this._getScales('x');
            guideController.yScales = this._getScales('y');
            guideController.render(coord);
          }
        } // 注册事件
        ;

        _proto._bindEvents = function _bindEvents() {
          var eventController = new Controller.Event({
            view: this,
            canvas: this.get('canvas')
          });
          eventController.bindEvents();
          this.set('eventController', eventController);
        } // 清理时间
        ;

        _proto._clearEvents = function _clearEvents() {
          var eventController = this.get('eventController');
          eventController && eventController.clearEvents();
        };

        _proto._getScales = function _getScales(dimType) {
          var geoms = this.get('geoms');
          var result = {};

          for (var i = 0; i < geoms.length; i++) {
            var geom = geoms[i];
            var scale = dimType === 'x' ? geom.getXScale() : geom.getYScale();

            if (scale && !result[scale.field]) {
              result[scale.field] = scale;
            }
          }

          return result;
        };

        _proto._adjustScale = function _adjustScale() {
          this._setCatScalesRange();

          var geoms = this.get('geoms');
          var scaleController = this.get('scaleController');
          var colDefs = scaleController.defs;

          for (var i = 0; i < geoms.length; i++) {
            var geom = geoms[i];

            if (geom.get('type') === 'interval') {
              var yScale = geom.getYScale();
              var field = yScale.field,
                  min = yScale.min,
                  max = yScale.max,
                  type = yScale.type;

              if (!(colDefs[field] && colDefs[field].min) && type !== 'time') {
                if (min > 0) {
                  yScale.change({
                    min: 0
                  });
                } else if (max <= 0) {
                  // 当柱状图全为负值时也需要从 0 开始生长
                  yScale.change({
                    max: 0
                  });
                }
              }
            }
          }
        };

        _proto._setCatScalesRange = function _setCatScalesRange() {
          var self = this;
          var coord = self.get('coord');
          var viewTheme = self.get('viewTheme');
          var xScale = self.getXScale();
          var yScales = self.getYScales();
          var scales = [];
          xScale && scales.push(xScale);
          scales = scales.concat(yScales);
          var inFullCircle = coord.isPolar && isFullCircle(coord);
          var scaleController = self.get('scaleController');
          var colDefs = scaleController.defs;
          Util.each(scales, function (scale) {
            if ((scale.isCategory || scale.isIdentity) && scale.values && !(colDefs[scale.field] && colDefs[scale.field].range)) {
              var count = scale.values.length;
              var range;

              if (count === 1) {
                range = [0.5, 1]; // 只有一个分类时,防止计算出现 [0.5,0.5]的状态
              } else {
                var widthRatio = 1;
                var offset = 0;

                if (inFullCircle) {
                  if (!coord.isTransposed) {
                    range = [0, 1 - 1 / count];
                  } else {
                    widthRatio = viewTheme.widthRatio.multiplePie;
                    offset = 1 / count * widthRatio;
                    range = [offset / 2, 1 - offset / 2];
                  }
                } else {
                  offset = 1 / count * 1 / 2; // 两边留下分类空间的一半

                  range = [offset, 1 - offset]; // 坐标轴最前面和最后面留下空白防止绘制柱状图时
                }
              }

              scale.range = range;
            }
          });
        };

        _proto.getXScale = function getXScale() {
          var geoms = this.get('geoms'); // 如果进行过滤，那么 geom 默认隐藏时会出现不一致
          // 默认隐藏时坐标轴不绘制，但是调用了 geom.show() 后，则图形显示了，坐标轴依然不见

          /* .filter(function(geom) {
            return geom.get('visible');
          }); */

          var xScale = null;

          if (!Util.isEmpty(geoms)) {
            xScale = geoms[0].getXScale();
          }

          return xScale;
        };

        _proto.getYScales = function getYScales() {
          var geoms = this.get('geoms');
          /* .filter(function(geom) {
            return geom.get('visible');
          }); */

          var rst = [];

          for (var i = 0; i < geoms.length; i++) {
            var geom = geoms[i];
            var yScale = geom.getYScale();

            if (yScale && Util.indexOf(rst, yScale) === -1) {
              rst.push(yScale);
            }
          }

          return rst;
        }
        /**
         * 获取数据对应在画布空间的坐标
         * @param  {Object} item 原始数据
         * @return {Object}      返回对应的画布上的坐标点
         */
        ;

        _proto.getXY = function getXY(item) {
          var self = this;
          var coord = self.get('coord');

          var xScales = self._getScales('x');

          var yScales = self._getScales('y');

          var x;
          var y;

          for (var field in item) {
            if (xScales[field]) {
              x = xScales[field].scale(item[field]);
            }

            if (yScales[field]) {
              y = yScales[field].scale(item[field]);
            }
          }

          if (!Util.isNil(x) && !Util.isNil(y)) {
            return coord.convert({
              x: x,
              y: y
            });
          }

          return null;
        }
        /**
         * 获取逼近的点的数据集合
         * @param  {Object} point 画布上的像素点
         * @return {Array} 数据
         */
        ;

        _proto.getSnapRecords = function getSnapRecords(point) {
          var self = this;
          var geoms = self.get('geoms');
          var rst = [];
          Util.each(geoms, function (geom) {
            var dataArray = geom.get('dataArray');
            var record;
            Util.each(dataArray, function (data) {
              record = geom.findPoint(point, data);
              record && rst.push(record);
            });
          });
          return rst;
        }
        /**
         * @protected
         * 添加几何标记
         * @param {Geom} geom 几何标记
         */
        ;

        _proto.addGeom = function addGeom(geom) {
          var self = this;
          var geoms = self.get('geoms');
          geoms.push(geom);
          geom.set('view', self);
          var container = self.get('viewContainer');
          geom.set('container', container);
          geom.set('animate', self.get('animate'));
          geom.bindEvents();
        }
        /**
         * @protected
         * 移除几何标记
         * @param {Geom} geom 几何标记
         */
        ;

        _proto.removeGeom = function removeGeom(geom) {
          var geoms = this.get('geoms');
          Util.Array.remove(geoms, geom);
          geom.destroy();
        };

        _proto.createScale = function createScale(field, data) {
          var scales = this.get('scales');
          var parent = this.get('parent');
          var scale = scales[field]; // const filters = this._getFilters();

          if (!data) {
            var filteredData = this.get('filteredData');

            var legendFields = this._getFieldsForLegend(); // 过滤导致数据为空时，需要使用全局数据
            // 参与过滤的字段的度量也根据全局数据来生成


            if (filteredData.length && !legendFields.includes(field)) {
              data = filteredData;
            } else {
              data = this.get('data');
            }
          }

          var scaleController = this.get('scaleController');

          if (!scale) {
            scale = scaleController.createScale(field, data);

            if (scale.sync && parent) {
              var parentScale = parent.createScale(field, data);
              scale = this._getSyncScale(parentScale, scale);
            }

            scales[field] = scale;
          } else if (scale.sync) {
            // 防止 view 内部创建的scale，Chart 上的scale 范围更大
            var newScale = scaleController.createScale(field, data);

            this._syncScale(scale, newScale);
          }

          return scale;
        };

        _proto._getFieldsForLegend = function _getFieldsForLegend() {
          var fields = [];
          var geoms = this.get('geoms');
          Util.each(geoms, function (geom) {
            var geomFields = geom.getFieldsForLegend();
            fields = fields.concat(geomFields);
          });
          return Util.uniq(fields);
        } // 如果需要同步度量，则使得 values,min,max的范围最大
        ;

        _proto._getSyncScale = function _getSyncScale(parentScale, scale) {
          if (parentScale.type !== scale.type) {
            return scale;
          }

          this._syncScale(parentScale, scale);

          return parentScale;
        };

        _proto._syncScale = function _syncScale(distScale, sourceScale) {
          var mergeValues = Util.union(distScale.values, sourceScale.values);

          if (sourceScale.isLinear) {
            var max = Math.max(distScale.max, sourceScale.max);
            var min = Math.min(distScale.min, sourceScale.min);

            if (distScale.max !== max || distScale.min !== min) {
              distScale.change({
                min: min,
                max: max,
                values: mergeValues
              });
            }
          }

          if (mergeValues.length !== distScale.values.length) {
            distScale.change({
              values: mergeValues
            });
          }
        }
        /**
         * @protected
         * 获取过滤后的值（需要显示的值）
         * @param {String} field 度量
         * @return {Array.<String>} 滤后的值
         */
        ;

        _proto.getFilteredValues = function getFilteredValues(field) {
          var scale = this.get('scales')[field];
          var values = scale.values;

          var filters = this._getFilters();

          var rst;

          if (filters && filters[field]) {
            rst = values.filter(filters[field]);
          } else {
            rst = values.slice(0);
          }

          return rst;
        }
        /**
         * @protected
         * 获取被过滤的值（不需显示的值）
         * @param {String} field 度量
         * @return {Array.<String>} 滤出的值
         */
        ;

        _proto.getFilteredOutValues = function getFilteredOutValues(field) {
          var scale = this.get('scales')[field];
          var values = scale.values;

          var filters = this._getFilters();

          var rst;

          if (filters && filters[field]) {
            rst = values.filter(function () {
              return !filters[field].apply(filters, arguments);
            });
          } else {
            rst = [];
          }

          return rst;
        };

        _proto.filter = function filter(field, condition) {
          var options = this.get('options');

          if (!options.filters) {
            options.filters = {};
          }

          options.filters[field] = condition;
          this.get('scaleController').filters = options.filters;
        } // 获取 filters
        ;

        _proto._getFilters = function _getFilters() {
          var options = this.get('options');
          return options.filters;
        } // 执行 filter 数据
        ;

        _proto.execFilter = function execFilter(data) {
          var self = this;

          var filters = self._getFilters();

          if (filters) {
            data = data.filter(function (obj) {
              var rst = true;
              Util.each(filters, function (fn, k) {
                if (fn) {
                  rst = fn(obj[k], obj);

                  if (!rst) {
                    return false;
                  }
                }
              });
              return rst;
            });
          }

          return data;
        };

        _proto.axis = function axis(field, cfg) {
          var options = this.get('options');

          if (field === false) {
            options.axes = false;
          } else {
            if (!options.axes) {
              options.axes = {};
            }

            var axisOptions = options.axes;
            axisOptions[field] = cfg;
          }

          return this;
        };

        _proto.guide = function guide() {
          return this.get('guideController');
        };

        _proto._getKeyFields = function _getKeyFields(scaleDefs) {
          var keyFields = [];
          Util.each(scaleDefs, function (def, field) {
            if (def.key) {
              keyFields.push(field);
            }
          });
          this.set('keyFields', keyFields);
        };

        _proto.scale = function scale(field, cfg) {
          var options = this.get('options');
          var scaleDefs = options.scales;

          if (Util.isObject(field)) {
            Util.mix(scaleDefs, field);
          } else {
            scaleDefs[field] = cfg;
          }

          this._getKeyFields(scaleDefs);

          return this;
        };

        _proto.tooltip = function tooltip(visible) {
          this.set('tooltipEnable', visible);
          return this;
        };

        _proto.animate = function animate(enable) {
          var options = this.get('options');
          options.animate = enable;
          this.set('animate', enable);
          return this;
        };

        _proto.changeOptions = function changeOptions(options) {
          this.set('options', options);

          this._initOptions(options);

          return this;
        }
        /**
         * @internal 查找包含指定点的视图
         * @param  {Object} point 点的位置
         * @return {Array} 多个视图
         */
        ;

        _proto.getViewsByPoint = function getViewsByPoint(point) {
          var rst = [];
          var views = this.get('views');

          if (isPointInCoord(this.get('coord'), point)) {
            rst.push(this);
          }

          Util.each(views, function (view) {
            if (view.get('visible') && isPointInCoord(view.get('coord'), point)) {
              rst.push(view);
            }
          });
          return rst;
        }
        /**
         * 遍历所有的 shape ，用户更改 shape 后进行刷新
         * @param  {Function} fn 回调函数包含参数：record,shape,geom,view
         * @return {View} 当前视图
         */
        ;

        _proto.eachShape = function eachShape(fn) {
          var self = this;
          var views = self.get('views');
          var canvas = self.get('canvas');
          Util.each(views, function (view) {
            view.eachShape(fn);
          });
          var geoms = this.get('geoms');
          Util.each(geoms, function (geom) {
            var shapes = geom.getShapes();
            Util.each(shapes, function (shape) {
              var origin = shape.get('origin');

              if (Util.isArray(origin)) {
                var arr = origin.map(function (subOrigin) {
                  return subOrigin[FIELD_ORIGIN];
                });
                fn(arr, shape, geom, self);
              } else {
                var obj = origin[FIELD_ORIGIN];
                fn(obj, shape, geom, self);
              }
            });
          });
          canvas.draw();
          return this;
        }
        /**
         * 遍历所有的 shape ，回调函数中 true / false 控制图形是否显示
         * @param  {Function} fn 回调函数包含参数：record,shape,geom,view
         * @return {View} 当前视图
         */
        ;

        _proto.filterShape = function filterShape(fn) {
          var callback = function callback(record, shape, geom, view) {
            if (!fn(record, shape, geom, view)) {
              shape.hide();
            } else {
              shape.show();
            }
          };

          this.eachShape(callback);
          return this;
        };

        _proto.clearInner = function clearInner() {
          this.set('scales', {});
          this.emit('beforeclearinner');
          var options = this.get('options');
          options.geoms = null;

          this._clearGeoms(); // reset guide


          this.get('guideController') && this.get('guideController').reset(); // clear axis

          this.get('axisController') && this.get('axisController').clear();
          this.emit('afterclearinner');
        }
        /**
         * 清除视图内容，包括 geoms
         * @return {View} 当前视图
         */
        ;

        _proto.clear = function clear() {
          var options = this.get('options');
          options.filters = null;

          this._removeGeoms(); // const container = this.get('viewContainer');
          // container.clear();


          this.clearInner();
          this.get('guideController') && this.get('guideController').clear();
          this.set('isUpdate', false);
          this.set('keyFields', []);
          return this;
        }
        /**
         * 设置坐标系信息
         * @param  {String} type 类型
         * @param  {Object} cfg  配置项
         * @return {Object} coordController 坐标系的管理器
         */
        ;

        _proto.coord = function coord(type, cfg) {
          var coordController = this.get('coordController');
          coordController.reset({
            type: type,
            cfg: cfg
          });
          return coordController;
        }
        /**
         * 当父元素边框发生改变时坐标系需要重新调整
         * @protected
         */
        ;

        _proto.resetCoord = function resetCoord() {
          this._createCoord();
        };

        _proto.source = function source(data, scales) {
          this._initData(data);

          if (scales) {
            this.scale(scales);
          }

          this.emit('setdata');
          return this;
        };

        _proto.changeData = function changeData(data) {
          this.emit('beforechangedata');

          this._initData(data);

          this.emit('afterchangedata');
          this.repaint();
          return this;
        };

        _proto._initData = function _initData(data) {
          var dataView = this.get('dataView');

          if (dataView) {
            dataView.off('change', Util.getWrapBehavior(this, '_onViewChange'));
            this.set('dataView', null);
          }

          if (data && data.isDataView) {
            data.on('change', Util.wrapBehavior(this, '_onViewChange'));
            this.set('dataView', data);
            data = data.rows;
          }

          this.set('data', data);
        };

        _proto._onViewChange = function _onViewChange() {
          this.emit('beforechangedata');
          var dataView = this.get('dataView');
          var rows = dataView.rows;
          this.set('data', rows);
          this.emit('afterchangedata');
          this.repaint();
        } // 初始化各个 view 和绘制辅助元素
        ;

        _proto.beforeRender = function beforeRender() {
          var views = this.get('views'); // 如果存在 views 则初始化子 view 的方法

          Util.each(views, function (view) {
            view.beforeRender();
          });
          this.initView();
        } // 绘制坐标轴、图例、辅助元素等图表组件
        ;

        _proto.drawComponents = function drawComponents() {
          var views = this.get('views'); // 如果存在 views 则初始化子 view 的方法

          Util.each(views, function (view) {
            view.drawComponents();
          });

          this._renderAxes();

          this._renderGuides();
        } // 绘制图形
        ;

        _proto.drawCanvas = function drawCanvas(stopDraw) {
          if (!stopDraw) {
            var views = this.get('views');
            var backPlot = this.get('backPlot');
            backPlot.sort();
            var canvas = this.get('canvas');
            var animate = this.get('animate');

            if (animate) {
              var isUpdate = this.get('isUpdate');
              Util.each(views, function (view) {
                Animate.execAnimation(view, isUpdate);
              });
              Animate.execAnimation(this, isUpdate);
            } else {
              canvas.draw();
            }
          }
        };

        _proto.render = function render(stopDraw) {
          this.clearInner();
          this.emit('beforerender');
          this.beforeRender();
          this.emit('beforepaint');
          this.drawComponents();
          this.paint();
          this.emit('afterpaint');
          this.drawCanvas(stopDraw);
          this.emit('afterrender');
          this.set('rendered', true);
          return this;
        };

        _proto.initView = function initView() {
          var data = this.get('data') || [];
          var filteredData = this.execFilter(data);
          this.set('filteredData', filteredData); // if (!Util.isEmpty(data)) {

          this._createCoord(); // draw geometry 前绘制区域可能会发生改变


          this.emit('beforeinitgeoms');

          this._initGeoms();

          this._adjustScale(); // }

        };

        _proto.paint = function paint() {
          var views = this.get('views'); // 绘制

          Util.each(views, function (view) {
            view.paint();
          });
          var data = this.get('data');

          if (!Util.isEmpty(data)) {
            this._drawGeoms();
          } // 如果 view 隐藏了，隐藏所有的图形和坐标轴


          if (!this.get('visible')) {
            this.changeVisible(false, true); // 隐藏所有的图形，但是不绘制
          }
        };

        _proto.changeVisible = function changeVisible(visible, stopDraw) {
          var geoms = this.get('geoms');
          Util.each(geoms, function (geom) {
            // if (geom.get('visible')) { // geom 隐藏时不受
            geom.changeVisible(visible, true); // }
          });
          this.get('axisController') && this.get('axisController').changeVisible(visible);
          this.get('guideController') && this.get('guideController').changeVisible(visible);

          if (!stopDraw) {
            var canvas = this.get('canvas');
            canvas.draw();
          }
        };

        _proto.repaint = function repaint() {
          this.set('isUpdate', true);
          this.clearInner();
          this.render();
        };

        _proto.destroy = function destroy() {
          this._clearEvents();

          var dataView = this.get('dataView');
          dataView && dataView.off('change', Util.getWrapBehavior(this, '_onViewChange'));
          this.clear();

          _Base.prototype.destroy.call(this);
        };

        return View;
      }(Base);

      module.exports = View;
      /***/
    },
    /* 294 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var isNil = __webpack_require__(5);

      var isArray = __webpack_require__(4);

      var each = __webpack_require__(2);

      var Base = __webpack_require__(29);

      var Position = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Position, _Base);

        function Position(cfg) {
          var _this;

          _this = _Base.call(this, cfg) || this;
          _this.names = ['x', 'y'];
          _this.type = 'position';
          return _this;
        }

        var _proto = Position.prototype;

        _proto.mapping = function mapping(x, y) {
          var scales = this.scales;
          var coord = this.coord;
          var scaleX = scales[0];
          var scaleY = scales[1];
          var rstX;
          var rstY;
          var obj;

          if (isNil(x) || isNil(y)) {
            return [];
          }

          if (isArray(y) && isArray(x)) {
            rstX = [];
            rstY = [];

            for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i++, j++) {
              obj = coord.convertPoint({
                x: scaleX.scale(x[i]),
                y: scaleY.scale(y[j])
              });
              rstX.push(obj.x);
              rstY.push(obj.y);
            }
          } else if (isArray(y)) {
            x = scaleX.scale(x);
            rstY = [];
            each(y, function (yVal) {
              yVal = scaleY.scale(yVal);
              obj = coord.convertPoint({
                x: x,
                y: yVal
              });

              if (rstX && rstX !== obj.x) {
                if (!isArray(rstX)) {
                  rstX = [rstX];
                }

                rstX.push(obj.x);
              } else {
                rstX = obj.x;
              }

              rstY.push(obj.y);
            });
          } else if (isArray(x)) {
            y = scaleY.scale(y);
            rstX = [];
            each(x, function (xVal) {
              xVal = scaleX.scale(xVal);
              obj = coord.convertPoint({
                x: xVal,
                y: y
              });

              if (rstY && rstY !== obj.y) {
                if (!isArray(rstY)) {
                  rstY = [rstY];
                }

                rstY.push(obj.y);
              } else {
                rstY = obj.y;
              }

              rstX.push(obj.x);
            });
          } else {
            x = scaleX.scale(x);
            y = scaleY.scale(y);
            var point = coord.convertPoint({
              x: x,
              y: y
            });
            rstX = point.x;
            rstY = point.y;
          }

          return [rstX, rstY];
        };

        return Position;
      }(Base);

      module.exports = Position;
      /***/
    },
    /* 295 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var isString = __webpack_require__(10);

      var ColorUtil = __webpack_require__(148);

      var Base = __webpack_require__(29);

      var Color = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Color, _Base);

        function Color(cfg) {
          var _this;

          _this = _Base.call(this, cfg) || this;
          _this.names = ['color'];
          _this.type = 'color';
          _this.gradient = null;

          if (isString(_this.values)) {
            _this.linear = true;
          }

          return _this;
        }
        /**
         * @override
         */


        var _proto = Color.prototype;

        _proto.getLinearValue = function getLinearValue(percent) {
          var gradient = this.gradient;

          if (!gradient) {
            var values = this.values;
            gradient = ColorUtil.gradient(values);
            this.gradient = gradient;
          }

          return gradient(percent);
        };

        return Color;
      }(Base);

      module.exports = Color;
      /***/
    },
    /* 296 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Base = __webpack_require__(29);

      var Shape = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Shape, _Base);

        function Shape(cfg) {
          var _this;

          _this = _Base.call(this, cfg) || this;
          _this.names = ['shape'];
          _this.type = 'shape';
          _this.gradient = null;
          return _this;
        }
        /**
         * @override
         */


        var _proto = Shape.prototype;

        _proto.getLinearValue = function getLinearValue(percent) {
          var values = this.values;
          var index = Math.round((values.length - 1) * percent);
          return values[index];
        };

        return Shape;
      }(Base);

      module.exports = Shape;
      /***/
    },
    /* 297 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Base = __webpack_require__(29);

      var Size = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Size, _Base);

        function Size(cfg) {
          var _this;

          _this = _Base.call(this, cfg) || this;
          _this.names = ['size'];
          _this.type = 'size';
          _this.gradient = null;
          return _this;
        }

        return Size;
      }(Base);

      module.exports = Size;
      /***/
    },
    /* 298 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Base = __webpack_require__(29);

      var Opacity = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Opacity, _Base);

        function Opacity(cfg) {
          var _this;

          _this = _Base.call(this, cfg) || this;
          _this.names = ['opacity'];
          _this.type = 'opacity';
          _this.gradient = null;
          return _this;
        }

        return Opacity;
      }(Base);

      module.exports = Opacity;
      /***/
    },
    /* 299 */

    /***/
    function (module, exports, __webpack_require__) {
      // 完整版下使用支持按照某个字段进行分组的 dodge
      var mix = __webpack_require__(8);

      var Adjust = __webpack_require__(30);

      var Dodge = __webpack_require__(300);

      var Stack = __webpack_require__(301);

      var AdjustMixin = __webpack_require__(149);

      var DodgeMixin = __webpack_require__(302);

      var StackMixin = __webpack_require__(303);

      mix(Adjust.prototype, AdjustMixin);
      mix(Dodge.prototype, AdjustMixin, DodgeMixin);
      mix(Stack.prototype, StackMixin);
      Adjust.Jitter = __webpack_require__(304);
      Adjust.Symmetric = __webpack_require__(305);
      Adjust.Dodge = Dodge;
      Adjust.Stack = Stack;
      module.exports = Adjust;
      /***/
    },
    /* 300 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Adjust = __webpack_require__(30);

      var each = __webpack_require__(2);

      var MARGIN_RATIO = 1 / 2;
      var DODGE_RATIO = 1 / 2;

      var Dodge = /*#__PURE__*/function (_Adjust) {
        _inheritsLoose(Dodge, _Adjust);

        function Dodge() {
          return _Adjust.apply(this, arguments) || this;
        }

        var _proto = Dodge.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          /**
           * 调整过程中,2个数据的间距
           * @type {Number}
           */
          this.marginRatio = MARGIN_RATIO;
          /**
           * 调整占单位宽度的比例,例如：占2个分类间距的 1/2
           * @type {Number}
           */

          this.dodgeRatio = DODGE_RATIO;
          this.adjustNames = ['x', 'y']; // 调整的维度，默认,x,y都做调整
        };

        _proto.getDodgeOffset = function getDodgeOffset(range, index, count) {
          var self = this;
          var pre = range.pre;
          var next = range.next;
          var tickLength = next - pre;
          var width = tickLength * self.dodgeRatio / count;
          var margin = self.marginRatio * width;
          var offset = 1 / 2 * (tickLength - count * width - (count - 1) * margin) + ((index + 1) * width + index * margin) - 1 / 2 * width - 1 / 2 * tickLength;
          return (pre + next) / 2 + offset;
        };

        _proto.processAdjust = function processAdjust(dataArray) {
          var self = this;
          var count = dataArray.length;
          var xField = self.xField;
          each(dataArray, function (data, index) {
            for (var i = 0, len = data.length; i < len; i++) {
              var obj = data[i];
              var value = obj[xField];
              var range = {
                pre: len === 1 ? value - 1 : value - 0.5,
                next: len === 1 ? value + 1 : value + 0.5
              };
              var dodgeValue = self.getDodgeOffset(range, index, count);
              obj[xField] = dodgeValue;
            }
          });
        };

        return Dodge;
      }(Adjust);

      Adjust.Dodge = Dodge;
      module.exports = Dodge;
      /***/
    },
    /* 301 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var isArray = __webpack_require__(4);

      var isNil = __webpack_require__(5);

      var Adjust = __webpack_require__(30);

      var Stack = /*#__PURE__*/function (_Adjust) {
        _inheritsLoose(Stack, _Adjust);

        function Stack() {
          return _Adjust.apply(this, arguments) || this;
        }

        var _proto = Stack.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          this.xField = null; // 调整对应的 x 方向对应的字段名称

          this.yField = null; // 调整对应的 y 方向对应的字段名称
        };

        _proto.processAdjust = function processAdjust(dataArray) {
          this.processStack(dataArray);
        };

        _proto.processStack = function processStack(dataArray) {
          var self = this;
          var xField = self.xField;
          var yField = self.yField;
          var count = dataArray.length;
          var stackCache = {
            positive: {},
            negative: {}
          }; // 层叠顺序翻转

          if (self.reverseOrder) {
            dataArray = dataArray.slice(0).reverse();
          }

          for (var i = 0; i < count; i++) {
            var data = dataArray[i];

            for (var j = 0, len = data.length; j < len; j++) {
              var item = data[j];
              var x = item[xField] || 0;
              var y = item[yField];
              var xkey = x.toString();
              y = isArray(y) ? y[1] : y;

              if (!isNil(y)) {
                var direction = y >= 0 ? 'positive' : 'negative';

                if (!stackCache[direction][xkey]) {
                  stackCache[direction][xkey] = 0;
                }

                item[yField] = [stackCache[direction][xkey], y + stackCache[direction][xkey]];
                stackCache[direction][xkey] += y;
              }
            }
          }
        };

        return Stack;
      }(Adjust);

      Adjust.Stack = Stack;
      module.exports = Stack;
      /***/
    },
    /* 302 */

    /***/
    function (module, exports, __webpack_require__) {
      var ArrayUtil = {
        merge: __webpack_require__(42),
        values: __webpack_require__(65)
      };

      var group = __webpack_require__(143);

      var each = __webpack_require__(2);

      module.exports = {
        /**
         * @protected
         * @override
         */
        processAdjust: function processAdjust(dataArray) {
          var self = this;
          var mergeData = ArrayUtil.merge(dataArray);
          var dodgeDim = self.dodgeBy;
          var adjDataArray = dataArray;

          if (dodgeDim) {
            // 如果指定了分组dim的字段
            adjDataArray = group(mergeData, dodgeDim);
          }

          self.cacheMap = {};
          self.adjDataArray = adjDataArray;
          self.mergeData = mergeData;
          self.adjustData(adjDataArray, mergeData);
          self.adjDataArray = null;
          self.mergeData = null;
        },
        getDistribution: function getDistribution(dim) {
          var self = this;
          var dataArray = self.adjDataArray;
          var cacheMap = self.cacheMap;
          var map = cacheMap[dim];

          if (!map) {
            map = {};
            each(dataArray, function (data, index) {
              var values = ArrayUtil.values(data, dim);

              if (!values.length) {
                values.push(0);
              }

              each(values, function (val) {
                if (!map[val]) {
                  map[val] = [];
                }

                map[val].push(index);
              });
            });
            cacheMap[dim] = map;
          }

          return map;
        },
        adjustDim: function adjustDim(dim, values, data, frameCount, frameIndex) {
          var self = this;
          var map = self.getDistribution(dim);
          var groupData = self.groupData(data, dim); // 根据值分组

          each(groupData, function (group, key) {
            key = parseFloat(key);
            var range;

            if (values.length === 1) {
              range = {
                pre: values[0] - 1,
                next: values[0] + 1
              };
            } else {
              range = self.getAdjustRange(dim, key, values);
            }

            each(group, function (record) {
              var value = record[dim];
              var valueArr = map[value];
              var valIndex = valueArr.indexOf(frameIndex);
              record[dim] = self.getDodgeOffset(range, valIndex, valueArr.length);
            });
          });
        }
      };
      /***/
    },
    /* 303 */

    /***/
    function (module, exports) {
      module.exports = {
        _initDefaultCfg: function _initDefaultCfg() {
          this.xField = null; // 调整对应的 x 方向对应的字段名称

          this.yField = null; // 调整对应的 y 方向对应的字段名称

          this.height = null; // 仅有一个维度调整时，总的高度

          this.size = 10; // 单个点的大小

          this.reverseOrder = false; // 是否反序进行层叠

          this.adjustNames = ['y']; // Only support stack y
        },
        processOneDimStack: function processOneDimStack(dataArray) {
          var self = this;
          var xField = self.xField;
          var yField = self.yField || 'y';
          var height = self.height;
          var stackY = {}; // 如果层叠的顺序翻转

          if (self.reverseOrder) {
            dataArray = dataArray.slice(0).reverse();
          }

          for (var i = 0, len = dataArray.length; i < len; i++) {
            var data = dataArray[i]; // cates

            for (var j = 0, dataLen = data.length; j < dataLen; j++) {
              var item = data[j];
              var size = item.size || self.size;
              var stackHeight = size * 2 / height;
              var x = item[xField];

              if (!stackY[x]) {
                stackY[x] = stackHeight / 2;
              }

              item[yField] = stackY[x];
              stackY[x] += stackHeight;
            }
          }
        },
        processAdjust: function processAdjust(dataArray) {
          if (this.yField) {
            this.processStack(dataArray);
          } else {
            this.processOneDimStack(dataArray);
          }
        }
      };
      /***/
    },
    /* 304 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var each = __webpack_require__(2);

      var mix = __webpack_require__(8);

      var ArrayUtil = {
        merge: __webpack_require__(42)
      };

      var Adjust = __webpack_require__(30);

      var AdjustMixin = __webpack_require__(149);

      var Jitter = /*#__PURE__*/function (_Adjust) {
        _inheritsLoose(Jitter, _Adjust);

        function Jitter() {
          return _Adjust.apply(this, arguments) || this;
        }

        var _proto = Jitter.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          this.xField = null; // 调整对应的 x 方向对应的字段名称

          this.yField = null; // 调整对应的 y 方向对应的字段名称

          this.adjustNames = ['x', 'y']; // 指x,y

          this.groupFields = null; // 参与分组的数据维度
        };

        _proto.processAdjust = function processAdjust(dataArray) {
          var self = this;
          var mergeData = ArrayUtil.merge(dataArray);
          self.adjDataArray = dataArray;
          self.mergeData = mergeData;
          self.adjustData(dataArray, mergeData);
          self.adjFrames = null;
          self.mergeData = null;
        };

        _proto.getAdjustOffset = function getAdjustOffset(pre, next) {
          var r = Math.random(); // 随机位置，均匀分布

          var avg = next - pre; // * length

          var append = avg * 0.05;
          return pre + append + avg * 0.9 * r;
        }; // adjust group data


        _proto._adjustGroup = function _adjustGroup(group, dim, key, values) {
          var self = this;
          var range = self.getAdjustRange(dim, key, values);
          each(group, function (record) {
            record[dim] = self.getAdjustOffset(range.pre, range.next); // 获取调整的位置
          });
        };

        _proto.adjustDim = function adjustDim(dim, values, data) {
          var self = this;
          var groupData = self.groupData(data, dim);
          each(groupData, function (group, key) {
            key = parseFloat(key);

            self._adjustGroup(group, dim, key, values);
          });
        };

        return Jitter;
      }(Adjust);

      mix(Jitter.prototype, AdjustMixin);
      Adjust.Jitter = Jitter;
      module.exports = Jitter;
      /***/
    },
    /* 305 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var each = __webpack_require__(2);

      var maxBy = __webpack_require__(131);

      var isArray = __webpack_require__(4);

      var ArrayUtil = {
        merge: __webpack_require__(42)
      };

      var Adjust = __webpack_require__(30);

      var Symmetric = /*#__PURE__*/function (_Adjust) {
        _inheritsLoose(Symmetric, _Adjust);

        function Symmetric() {
          return _Adjust.apply(this, arguments) || this;
        }

        var _proto = Symmetric.prototype;

        _proto._initDefaultCfg = function _initDefaultCfg() {
          this.xField = null; // 调整对应的 x 方向对应的字段名称

          this.yField = null; // 调整对应的 y 方向对应的字段名称

          this.cacheMax = null; // 缓存的最大值

          this.adjustNames = ['y']; // Only support stack y

          this.groupFields = null; // 参与分组的数据维度
        }; // 获取最大的y值


        _proto._getMax = function _getMax(dim) {
          var self = this;
          var mergeData = self.mergeData;
          var maxRecord = maxBy(mergeData, function (obj) {
            var value = obj[dim];

            if (isArray(value)) {
              return Math.max.apply(null, value);
            }

            return value;
          });
          var maxValue = maxRecord[dim];
          var max = isArray(maxValue) ? Math.max.apply(null, maxValue) : maxValue;
          return max;
        }; // 获取每个字段最大的值


        _proto._getXValuesMax = function _getXValuesMax() {
          var self = this;
          var yField = self.yField;
          var xField = self.xField;
          var cache = {};
          var mergeData = self.mergeData;
          each(mergeData, function (obj) {
            var xValue = obj[xField];
            var yValue = obj[yField];
            var max = isArray(yValue) ? Math.max.apply(null, yValue) : yValue;
            cache[xValue] = cache[xValue] || 0;

            if (cache[xValue] < max) {
              cache[xValue] = max;
            }
          });
          return cache;
        }; // 入口函数


        _proto.processAdjust = function processAdjust(dataArray) {
          var self = this;
          var mergeData = ArrayUtil.merge(dataArray);
          self.mergeData = mergeData;

          self._processSymmetric(dataArray);

          self.mergeData = null;
        }; // 处理对称


        _proto._processSymmetric = function _processSymmetric(dataArray) {
          var self = this;
          var xField = self.xField;
          var yField = self.yField;

          var max = self._getMax(yField);

          var first = dataArray[0][0];
          var cache;

          if (first && isArray(first[yField])) {
            cache = self._getXValuesMax();
          }

          each(dataArray, function (data) {
            each(data, function (obj) {
              var value = obj[yField];
              var offset;

              if (isArray(value)) {
                var xValue = obj[xField];
                var valueMax = cache[xValue];
                offset = (max - valueMax) / 2;
                var tmp = [];
                /* eslint-disable no-loop-func */

                each(value, function (subVal) {
                  // 多个字段
                  tmp.push(offset + subVal);
                });
                /* eslint-enable no-loop-func */

                obj[yField] = tmp;
              } else {
                offset = (max - value) / 2;
                obj[yField] = [offset, value + offset];
              }
            });
          });
        };

        return Symmetric;
      }(Adjust);

      Adjust.Symmetric = Symmetric;
      module.exports = Symmetric;
      /***/
    },
    /* 306 */

    /***/
    function (module, exports, __webpack_require__) {
      var _html, _tooltip;
      /**
       * @fileOverview G2 3.0 dark theme
       * @author sima.zhang
       */


      var Util = __webpack_require__(0);

      var BasicTheme = __webpack_require__(151); // tooltip 相关 dom 的 css 类名


      var TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';
      var LEGEND_CONTAINER_CLASS = 'g2-legend';
      var DarkTheme = Util.deepMix({}, BasicTheme, {
        background: {
          fill: '#1F1F1F',
          radius: 2
        },
        // 容器区域
        plotBackground: {
          fill: '#1F1F1F'
        },
        // 绘图区域
        axis: {
          top: {
            label: {
              textStyle: {
                fill: '#A6A6A6'
              }
            },
            line: {
              stroke: '#737373'
            },
            tickLine: {
              stroke: '#737373'
            }
          },
          bottom: {
            label: {
              textStyle: {
                fill: '#A6A6A6'
              }
            },
            line: {
              stroke: '#737373'
            },
            tickLine: {
              stroke: '#737373'
            }
          },
          left: {
            label: {
              textStyle: {
                fill: '#A6A6A6'
              }
            },
            grid: {
              lineStyle: {
                stroke: '#404040'
              }
            }
          },
          right: {
            label: {
              textStyle: {
                fill: '#A6A6A6'
              }
            },
            grid: {
              lineStyle: {
                stroke: '#404040'
              }
            }
          },
          circle: {
            label: {
              textStyle: {
                fill: '#A6A6A6'
              }
            },
            line: {
              stroke: '#737373'
            },
            tickLine: {
              stroke: '#737373'
            },
            grid: {
              lineStyle: {
                stroke: '#404040'
              }
            }
          },
          radius: {
            label: {
              textStyle: {
                fill: '#A6A6A6'
              }
            },
            line: {
              stroke: '#737373'
            },
            tickLine: {
              stroke: '#737373'
            },
            grid: {
              lineStyle: {
                stroke: '#404040'
              }
            }
          },
          helix: {
            line: {
              stroke: '#737373'
            },
            tickLine: {
              stroke: '#737373'
            }
          }
        },
        label: {
          textStyle: {
            fill: '#A6A6A6'
          }
        },
        legend: {
          right: {
            textStyle: {
              fill: '#737373'
            },
            unCheckColor: '#bfbfbf'
          },
          left: {
            textStyle: {
              fill: '#737373'
            },
            // 图例项文本的样式
            unCheckColor: '#bfbfbf'
          },
          top: {
            textStyle: {
              fill: '#737373'
            },
            // 图例项文本的样式
            unCheckColor: '#bfbfbf'
          },
          bottom: {
            textStyle: {
              fill: '#737373'
            },
            // 图例项文本的样式
            unCheckColor: '#bfbfbf'
          },
          html: (_html = {}, _html["" + LEGEND_CONTAINER_CLASS] = {
            color: '#D9D9D9'
          }, _html),
          gradient: {
            textStyle: {
              fill: '#D9D9D9'
            },
            lineStyle: {
              stroke: '#404040'
            }
          }
        },
        tooltip: (_tooltip = {}, _tooltip["" + TOOLTIP_CONTAINER_CLASS] = {
          color: '#D9D9D9',
          backgroundColor: 'rgba(0, 0, 0, 0.5)',
          boxShadow: '0px 0px 2px #000'
        }, _tooltip),
        tooltipCrosshairsRect: {
          type: 'rect',
          rectStyle: {
            fill: '#fff',
            opacity: 0.1
          }
        },
        // tooltip 辅助背景框样式
        tooltipCrosshairsLine: {
          lineStyle: {
            stroke: 'rgba(255, 255, 255, 0.45)'
          }
        },
        guide: {
          line: {
            text: {
              style: {
                fill: '#A6A6A6'
              }
            }
          },
          text: {
            style: {
              fill: '#A6A6A6'
            }
          },
          region: {
            // TODO
            style: {
              lineWidth: 0,
              // 辅助框的边框宽度
              fill: '#000',
              // 辅助框填充的颜色
              fillOpacity: 0.04 // 辅助框的背景透明度

            } // 辅助框的图形样式属性

          }
        }
      });
      module.exports = DarkTheme;
      /***/
    },
    /* 307 */

    /***/
    function (module, exports, __webpack_require__) {
      var GeomLabels = __webpack_require__(66);

      var PolarLabels = __webpack_require__(163);

      var PieLabels = __webpack_require__(337);

      var IntervalLabels = __webpack_require__(338);

      var Labels = {
        getLabelsClass: function getLabelsClass(coordType, type) {
          var rst = GeomLabels;

          if (coordType === 'polar') {
            rst = PolarLabels;
          } else if (coordType === 'theta') {
            // pie chart
            rst = PieLabels;
          } else if (type === 'interval' || type === 'polygon') {
            // bar
            rst = IntervalLabels;
          }

          return rst;
        }
      };
      module.exports = Labels;
      /***/
    },
    /* 308 */

    /***/
    function (module, exports, __webpack_require__) {
      var Axis = __webpack_require__(31);

      Axis.Base = Axis;
      Axis.Circle = __webpack_require__(312);
      Axis.Grid = __webpack_require__(152);
      Axis.Helix = __webpack_require__(313);
      Axis.Line = __webpack_require__(314);
      Axis.Polyline = __webpack_require__(315);
      module.exports = Axis;
      /***/
    },
    /* 309 */

    /***/
    function (module, exports, __webpack_require__) {
      var Greedy = __webpack_require__(154);
      /*
         *  根据如下规则尝试放置label
         *                5
         *        ------------------
         *        |    1   |   0   |
         *    8   —————————4————————   7
         *        |    2   |   3   |
         *        ——————————————————
         *                 6
         */


      function adjustLabelPosition(label, x, y, index) {
        var bbox = label.getBBox();
        var width = bbox.width;
        var height = bbox.height;
        var attrs = {
          x: x,
          y: y,
          textAlign: 'center'
        };

        switch (index) {
          case 0:
            attrs.y -= height / 2;
            attrs.textAlign = 'left';
            break;

          case 1:
            attrs.y -= height / 2;
            attrs.textAlign = 'right';
            break;

          case 2:
            attrs.y += height / 2;
            attrs.textAlign = 'right';
            break;

          case 3:
            attrs.y += height / 2;
            attrs.textAlign = 'left';
            break;

          case 5:
            attrs.y -= height / 2;
            break;

          case 6:
            attrs.y += height / 2;
            break;

          case 7:
            attrs.x += width / 2;
            attrs.textAlign = 'left';
            break;

          case 8:
            attrs.x -= width / 2;
            attrs.textAlign = 'right';
            break;

          default:
            break;
        }

        label.attr(attrs);
        return label.getBBox();
      }

      module.exports = function (labels) {
        var greedy = new Greedy();
        var toBeRemoved = [];
        var bbox, label, x, y, canFill;

        for (var i = 0; i < labels.length; i++) {
          label = labels[i];
          x = label.attr('x');
          y = label.attr('y');
          canFill = false;

          for (var _i = 0; _i < 8; _i++) {
            bbox = adjustLabelPosition(label, x, y, _i);

            if (greedy.hasGap(bbox)) {
              greedy.fillGap(bbox);
              canFill = true;
              break;
            }
          }

          if (!canFill) {
            toBeRemoved.push(label);
          }
        }

        for (var _i2 = 0; _i2 < toBeRemoved.length; _i2++) {
          toBeRemoved[_i2].remove();
        }

        return canFill;
      };
      /***/

    },
    /* 310 */

    /***/
    function (module, exports, __webpack_require__) {
      var Greedy = __webpack_require__(154);

      var MAX_TIMES = 20;

      function spiralFill(label, greedy) {
        var dt = -1;
        var x = label.attr('x'),
            y = label.attr('y');
        var bbox = label.getBBox();
        var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
        var dxdy,
            t = -dt,
            dx = 0,
            dy = 0;

        var f = function f(t) {
          return [(t *= 0.1) * Math.cos(t), t * Math.sin(t)];
        };

        if (greedy.hasGap(bbox)) {
          greedy.fillGap(bbox);
          return true;
        }

        var canFill = false,
            times = 0;

        while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < MAX_TIMES) {
          dxdy = f(t += dt);
          dx = ~~dxdy[0];
          dy = ~~dxdy[1];
          label.attr({
            x: x + dx,
            y: y + dy
          });
          times++;

          if (greedy.hasGap(label.getBBox())) {
            greedy.fillGap(bbox);
            canFill = true;
            break;
          }
        }

        return canFill;
      }

      module.exports = function (labels) {
        var label;
        var greedy = new Greedy();
        var toBeRemoved = [];

        for (var i = 0; i < labels.length; i++) {
          label = labels[i];

          if (!spiralFill(label, greedy)) {
            toBeRemoved.push(label);
          }
        }

        for (var _i = 0; _i < toBeRemoved.length; _i++) {
          toBeRemoved[_i].remove();
        }
      };
      /***/

    },
    /* 311 */

    /***/
    function (module, exports) {
      module.exports = function bboxAdjust(labels, shapes) {
        var labelBBox, shapeBBox;
        var toBeRemoved = [];

        for (var i = 0; i < labels.length; i++) {
          labelBBox = labels[i].getBBox();
          shapeBBox = shapes[i].getBBox();

          if (labelBBox.width > shapeBBox.width || labelBBox.height > shapeBBox.height) {
            toBeRemoved.push(labels[i]);
          } else if (labelBBox.width * labelBBox.height > shapeBBox.width * shapeBBox.height) {
            toBeRemoved.push(labels[i]);
          }
        }

        for (var _i = 0; _i < toBeRemoved.length; _i++) {
          toBeRemoved[_i].remove();
        }
      };
      /***/

    },
    /* 312 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Base = __webpack_require__(31);

      var vec2 = Util.MatrixUtil.vec2;

      var Circle = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Circle, _Base);

        function Circle() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Circle.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 坐标轴的类型
             * @type {String}
             */
            type: 'circle',

            /**
             * 指定刻度之间的间距
             * @type {Number}
             */
            tickInterval: null,

            /**
             * 开始弧度
             * @type {Number}
             */
            startAngle: -Math.PI / 2,

            /**
             * 结束弧度
             * @type {Number}
             */
            endAngle: Math.PI * 3 / 2,
            line: {
              // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线
              lineWidth: 1,
              stroke: '#C0D0E0'
            },
            tickLine: {
              // @type {Attrs} 标注坐标线的图形属性
              lineWidth: 1,
              stroke: '#C0D0E0',
              length: 5
            },

            /**
             * 默认文本距离轴线的距离
             * @type {Number}
             */
            _labelOffset: 5
          });
        };

        _proto.parseTick = function parseTick(tick, index, length) {
          return {
            text: tick,
            value: index / length
          };
        };

        _proto._getCirclePoint = function _getCirclePoint(angle, radius) {
          var self = this;
          var center = self.get('center');
          radius = radius || self.get('radius');
          return {
            x: center.x + Math.cos(angle) * radius,
            y: center.y + Math.sin(angle) * radius
          };
        };

        _proto.getTickPoint = function getTickPoint(value) {
          var self = this;
          var startAngle = self.get('startAngle');
          var endAngle = self.get('endAngle');
          var angle = startAngle + (endAngle - startAngle) * value;
          return self._getCirclePoint(angle);
        };

        _proto.getSideVector = function getSideVector(offset, point) {
          var self = this;
          var center = self.get('center');
          var vector = [point.x - center.x, point.y - center.y];

          if (!Util.isNil(offset)) {
            var vecLen = vec2.length(vector);
            vec2.scale(vector, vector, offset / vecLen);
          }

          return vector;
        };

        _proto.getSidePoint = function getSidePoint(point, offset) {
          var self = this;
          var vector = self.getSideVector(offset, point);
          return {
            x: point.x + vector[0],
            y: point.y + vector[1]
          };
        };

        _proto.getTickEnd = function getTickEnd(start, length) {
          var self = this;
          var tickLine = self.get('tickLine');
          length = length ? length : tickLine.length;
          return self.getSidePoint(start, length);
        };

        _proto.getTextAnchor = function getTextAnchor(vector) {
          var align;

          if (Util.snapEqual(vector[0], 0)) {
            align = 'center';
          } else if (vector[0] > 0) {
            align = 'left';
          } else if (vector[0] < 0) {
            align = 'right';
          }

          return align;
        };

        _proto.getLinePath = function getLinePath() {
          var self = this;
          var center = self.get('center');
          var x = center.x;
          var y = center.y;
          var rx = self.get('radius');
          var ry = rx;
          var startAngle = self.get('startAngle');
          var endAngle = self.get('endAngle');
          var inner = self.get('inner');
          var path = [];

          if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
            path = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
          } else {
            var startPoint = self._getCirclePoint(startAngle);

            var endPoint = self._getCirclePoint(endAngle);

            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
            var sweep = startAngle > endAngle ? 0 : 1;

            if (!inner) {
              path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];
            } else {
              var innerStartVector = self.getSideVector(inner * rx, startPoint);
              var innerEndVector = self.getSideVector(inner * rx, endPoint);
              var innerStartPoint = {
                x: innerStartVector[0] + x,
                y: innerStartVector[1] + y
              };
              var innerEndPoint = {
                x: innerEndVector[0] + x,
                y: innerEndVector[1] + y
              };
              path = [['M', innerStartPoint.x, innerStartPoint.y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', innerEndPoint.x, innerEndPoint.y], ['A', rx * inner, ry * inner, 0, large, Math.abs(sweep - 1), innerStartPoint.x, innerStartPoint.y]];
            }
          }

          return path;
        };

        _proto.addLabel = function addLabel(tick, point, index) {
          var self = this;
          var offset = self.get('label').offset || self.get('_labelOffset') || 0.001;
          point = self.getSidePoint(point, offset);

          _Base.prototype.addLabel.call(this, tick, point, index);
        };

        _proto.autoRotateLabels = function autoRotateLabels() {
          var self = this;
          var ticks = self.get('ticks');
          var labelRenderer = self.get('labelRenderer');

          if (labelRenderer && ticks.length > 12) {
            // 小于12个文本时文本不旋转
            var radius = self.get('radius');
            var startAngle = self.get('startAngle');
            var endAngle = self.get('endAngle');
            var totalAngle = endAngle - startAngle;
            var avgAngle = totalAngle / (ticks.length - 1);
            var avgWidth = Math.sin(avgAngle / 2) * radius * 2;
            var maxLength = self.getMaxLabelWidth(labelRenderer);
            Util.each(labelRenderer.get('group').get('children'), function (label, index) {
              var tick = ticks[index];
              var angle = tick.value * totalAngle + startAngle;
              var mode = angle % (Math.PI * 2);

              if (maxLength < avgWidth) {
                // 文本的最大宽度大于
                if (mode <= 0) {
                  angle = angle + Math.PI;
                }

                if (mode > Math.PI) {
                  angle = angle - Math.PI;
                }

                angle = angle - Math.PI / 2;
                label.attr('textAlign', 'center');
              } else {
                if (mode > Math.PI / 2) {
                  angle = angle - Math.PI;
                } else if (mode < Math.PI / 2 * -1) {
                  angle = angle + Math.PI;
                }
              }

              label.rotateAtStart(angle);
            });
          }
        };

        return Circle;
      }(Base);

      module.exports = Circle;
      /***/
    },
    /* 313 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Base = __webpack_require__(31);

      var MatrixUtil = Util.MatrixUtil,
          PathUtil = Util.PathUtil;
      var vec2 = MatrixUtil.vec2;

      var Helix = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Helix, _Base);

        function Helix() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Helix.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            inner: 0,
            type: 'helix',
            line: {
              // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线
              lineWidth: 1,
              stroke: '#C0D0E0'
            },
            tickLine: {
              // @type {Attrs} 标注坐标线的图形属性
              lineWidth: 1,
              stroke: '#C0D0E0',
              length: 5
            },
            startAngle: 1.25 * Math.PI,
            endAngle: 7.25 * Math.PI,
            // 螺旋系数
            a: 0,
            // 画布中心坐标
            center: null,
            // 坐标轴绘制起点
            axisStart: null,
            // 坐标轴的n个坐标点
            crp: []
          });
        };

        _proto.getLinePath = function getLinePath() {
          var self = this;
          var crp = self.get('crp');
          var axisStart = self.get('axisStart');
          var path = PathUtil.catmullRomToBezier(crp);
          path.unshift(['M', axisStart.x, axisStart.y]);
          return path;
        };

        _proto.getTickPoint = function getTickPoint(value) {
          var self = this;
          var startAngle = self.get('startAngle');
          var endAngle = self.get('endAngle');
          var angle = startAngle + (endAngle - startAngle) * value;
          return self._getHelixPoint(angle);
        };

        _proto._getHelixPoint = function _getHelixPoint(angle) {
          var self = this;
          var center = self.get('center');
          var a = self.get('a'); // 螺线系数

          var radius = a * angle + self.get('inner'); // 螺线方程

          return {
            x: center.x + Math.cos(angle) * radius,
            y: center.y + Math.sin(angle) * radius
          };
        };

        _proto.getSideVector = function getSideVector(offset, point) {
          var self = this;
          var center = self.get('center');
          var vector = [point.x - center.x, point.y - center.y];

          if (offset) {
            var vecLen = vec2.length(vector);
            vec2.scale(vector, vector, offset / vecLen);
          }

          return vector;
        };

        _proto.getSidePoint = function getSidePoint(point, offset) {
          var self = this;
          var vector = self.getSideVector(offset, point);
          return {
            x: point.x + vector[0],
            y: point.y + vector[1]
          };
        };

        _proto.getTickEnd = function getTickEnd(start, length) {
          var self = this;
          var tickLine = self.get('tickLine');
          length = length ? length : tickLine.length;
          return self.getSidePoint(start, length);
        };

        return Helix;
      }(Base);

      module.exports = Helix;
      /***/
    },
    /* 314 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Base = __webpack_require__(31);

      var Util = __webpack_require__(3);

      var MatrixUtil = Util.MatrixUtil;
      var vec2 = MatrixUtil.vec2;

      var Line = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Line, _Base);

        function Line() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Line.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            x: null,
            // @type {Number} 距离初始位置的x轴偏移量,仅对于左侧、右侧的纵向坐标有效
            y: null,
            // @type {Number} 距离初始位置的y轴偏移量，仅对顶部、底部的横向坐标轴有效
            line: {
              // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线
              lineWidth: 1,
              stroke: '#C0D0E0'
            },
            tickLine: {
              // @type {Attrs} 标注坐标线的图形属性
              lineWidth: 1,
              stroke: '#C0D0E0',
              length: 5
            },
            isVertical: false,
            start: null,
            // @type {Object} 起点
            end: null // @type {Object} 终点

          });
        };

        _proto._getAvgLabelLength = function _getAvgLabelLength(labelRenderer) {
          var labels = labelRenderer.get('group').get('children');
          return labels[1].attr('x') - labels[0].attr('x');
        };

        _proto._getAvgLabelHeightSpace = function _getAvgLabelHeightSpace(labelRenderer) {
          var labels = labelRenderer.get('group').get('children');
          return labels[1].attr('y') - labels[0].attr('y');
        }
        /**
         * 获取距离坐标轴的向量
         * @override
         * @param  {Number} offset 偏移值
         * @return {Array}        返回二维向量
         */
        ;

        _proto.getSideVector = function getSideVector(offset) {
          var self = this;
          var isVertical = self.get('isVertical');
          var factor = self.get('factor'); // if (Util.isArray(offset)) {
          //   return offset.map(value => value * factor);
          // }

          if (!Util.isNumber(offset)) {
            return [0, 0];
          }

          var start = self.get('start');
          var end = self.get('end');
          var axisVector = self.getAxisVector();
          var normal = vec2.normalize([], axisVector);
          var direction = false;

          if (isVertical && start.y < end.y || !isVertical && start.x > end.x) {
            direction = true;
          }

          var verticalVector = vec2.vertical([], normal, direction);
          return vec2.scale([], verticalVector, offset * factor);
        };

        _proto.getAxisVector = function getAxisVector() {
          var start = this.get('start');
          var end = this.get('end');
          return [end.x - start.x, end.y - start.y];
        };

        _proto.getLinePath = function getLinePath() {
          var self = this;
          var start = self.get('start');
          var end = self.get('end');
          var path = [];
          path.push(['M', start.x, start.y]);
          path.push(['L', end.x, end.y]);
          return path;
        };

        _proto.getTickEnd = function getTickEnd(start, value) {
          var self = this;
          var offsetVector = self.getSideVector(value);
          return {
            x: start.x + offsetVector[0],
            y: start.y + offsetVector[1]
          };
        };

        _proto.getTickPoint = function getTickPoint(tickValue) {
          var self = this;
          var start = self.get('start');
          var end = self.get('end');
          var rangeX = end.x - start.x;
          var rangeY = end.y - start.y;
          return {
            x: start.x + rangeX * tickValue,
            y: start.y + rangeY * tickValue
          };
        };

        _proto.renderTitle = function renderTitle() {
          var self = this;
          var title = self.get('title');
          var offsetPoint = self.getTickPoint(0.5);
          var titleOffset = title.offset;

          if (Util.isNil(titleOffset)) {
            // 没有指定 offset 则自动计算
            titleOffset = 20;
            var labelsGroup = self.get('labelsGroup');

            if (labelsGroup) {
              var labelLength = self.getMaxLabelWidth(labelsGroup);
              var labelOffset = self.get('label').offset || self.get('_labelOffset');
              titleOffset += labelLength + labelOffset;
            }
          }

          var textStyle = title.textStyle;
          var cfg = Util.mix({}, textStyle);

          if (title.text) {
            var vector = self.getAxisVector(); // 坐标轴方向的向量

            if (title.autoRotate && Util.isNil(textStyle.rotate)) {
              // 自动旋转并且用户没有指定标题的旋转角度
              var angle = 0;

              if (!Util.snapEqual(vector[1], 0)) {
                // 所有水平坐标轴，文本不转置
                var v1 = [1, 0];
                var v2 = [vector[0], vector[1]];
                angle = vec2.angleTo(v2, v1, true);
              }

              cfg.rotate = angle * (180 / Math.PI);
            } else if (!Util.isNil(textStyle.rotate)) {
              // 用户设置了旋转角度就以用户设置的为准
              cfg.rotate = textStyle.rotate / 180 * Math.PI; // 将角度转换为弧度
            }

            var sideVector = self.getSideVector(titleOffset);
            var point;
            var position = title.position;

            if (position === 'start') {
              point = {
                x: this.get('start').x + sideVector[0],
                y: this.get('start').y + sideVector[1]
              };
            } else if (position === 'end') {
              point = {
                x: this.get('end').x + sideVector[0],
                y: this.get('end').y + sideVector[1]
              };
            } else {
              point = {
                x: offsetPoint.x + sideVector[0],
                y: offsetPoint.y + sideVector[1]
              };
            }

            cfg.x = point.x;
            cfg.y = point.y;
            cfg.text = title.text;
            var group = self.get('group');
            var titleShape = group.addShape('Text', {
              zIndex: 2,
              attrs: cfg
            });
            titleShape.name = 'axis-title';
            self.get('appendInfo') && titleShape.setSilent('appendInfo', self.get('appendInfo'));
          }
        };

        _proto.autoRotateLabels = function autoRotateLabels() {
          var self = this;
          var labelRenderer = self.get('labelRenderer');
          var title = self.get('title');

          if (labelRenderer) {
            var labelGroup = labelRenderer.get('group');
            var labels = labelGroup.get('children');
            var offset = self.get('label').offset;
            var append = 12;
            var titleOffset = title ? title.offset : 48;

            if (titleOffset < 0) {
              // 如果是负的的话就不旋转
              return;
            }

            var vector = self.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景

            var angle;
            var maxWidth;

            if (Util.snapEqual(vector[0], 0) && title && title.text) {
              // 坐标轴垂直，由于不知道边距，只能防止跟title重合，如果title不存在，则不自动旋转
              maxWidth = self.getMaxLabelWidth(labelRenderer);

              if (maxWidth > titleOffset - offset - append) {
                angle = Math.acos((titleOffset - offset - append) / maxWidth) * -1;
              }
            } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {
              // 坐标轴水平，不考虑边距，根据最长的和平均值进行翻转
              var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));
              maxWidth = self.getMaxLabelWidth(labelRenderer);

              if (maxWidth > avgWidth) {
                angle = Math.asin((titleOffset - offset - append) * 1.25 / maxWidth);
              }
            }

            if (angle) {
              var factor = self.get('factor');
              Util.each(labels, function (label) {
                label.rotateAtStart(angle);

                if (Util.snapEqual(vector[1], 0)) {
                  if (factor > 0) {
                    label.attr('textAlign', 'left');
                  } else {
                    label.attr('textAlign', 'right');
                  }
                }
              });
            }
          }
        };

        _proto.autoHideLabels = function autoHideLabels() {
          var self = this;
          var labelRenderer = self.get('labelRenderer');
          var labelSpace;
          var tickStep;
          var append = 8;

          if (labelRenderer) {
            var labelGroup = labelRenderer.get('group');
            var labels = labelGroup.get('children');
            var vector = self.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景

            if (labels.length < 2) {
              return;
            }

            if (Util.snapEqual(vector[0], 0)) {
              // 坐标轴垂直
              var maxHeight = self.getMaxLabelHeight(labelRenderer) + append;
              var avgHeight = Math.abs(self._getAvgLabelHeightSpace(labelRenderer));

              if (maxHeight > avgHeight) {
                labelSpace = maxHeight;
                tickStep = avgHeight;
              }
            } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {
              // 坐标轴水平
              var maxWidth = self.getMaxLabelWidth(labelRenderer) + append;
              var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));

              if (maxWidth > avgWidth) {
                labelSpace = maxWidth;
                tickStep = avgWidth;
              }
            }

            if (labelSpace && tickStep) {
              var ratio = Math.ceil(labelSpace / tickStep);
              Util.each(labels, function (label, i) {
                if (i % ratio !== 0) {
                  label.attr('text', '');
                }
              });
            }
          }
        };

        return Line;
      }(Base);

      module.exports = Line;
      /***/
    },
    /* 315 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Base = __webpack_require__(31);

      var MatrixUtil = Util.MatrixUtil,
          PathUtil = Util.PathUtil;
      var vec2 = MatrixUtil.vec2;

      var Polyline = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Polyline, _Base);

        function Polyline() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Polyline.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            type: 'polyline'
          });
        };

        _proto.getLinePath = function getLinePath() {
          var self = this;
          var tickPoints = self.get('tickPoints');
          var start = self.get('start');
          var end = self.get('end');
          var points = [];
          points.push(start.x);
          points.push(start.y);
          Util.each(tickPoints, function (tick) {
            points.push(tick.x);
            points.push(tick.y);
          });
          points.push(end.x);
          points.push(end.y);
          var path = PathUtil.catmullRomToBezier(points);
          path.unshift(['M', start.x, start.y]);
          return path;
        };

        _proto.getTickPoint = function getTickPoint(value, index) {
          var tickPoints = this.get('tickPoints');
          return tickPoints[index];
        };

        _proto.getTickEnd = function getTickEnd(start, value, index) {
          var self = this;
          var lineAttrs = self.get('tickLine');
          var tickLength = value ? value : lineAttrs.length;
          var offsetVector = self.getSideVector(tickLength, start, index);
          return {
            x: start.x + offsetVector[0],
            y: start.y + offsetVector[1]
          };
        };

        _proto.getSideVector = function getSideVector(offset, point, index) {
          var self = this;
          var preTickPoint;

          if (index === 0) {
            preTickPoint = self.get('start');

            if (preTickPoint.x === point.x && preTickPoint.y === point.y) {
              return [0, 0];
            }
          } else {
            var tickPoints = self.get('tickPoints');
            preTickPoint = tickPoints[index - 1];
          }

          var vector = [point.x - preTickPoint.x, point.y - preTickPoint.y];
          var normal = vec2.normalize([], vector);
          var verticalVector = vec2.vertical([], normal, false);
          return vec2.scale([], verticalVector, offset);
        };

        return Polyline;
      }(Base);

      module.exports = Polyline;
      /***/
    },
    /* 316 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        Guide: __webpack_require__(15),
        Arc: __webpack_require__(317),
        DataMarker: __webpack_require__(318),
        DataRegion: __webpack_require__(319),
        Html: __webpack_require__(320),
        Image: __webpack_require__(321),
        Line: __webpack_require__(322),
        Region: __webpack_require__(323),
        Text: __webpack_require__(324)
      };
      /***/
    },
    /* 317 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Guide = __webpack_require__(15);

      var PI = Math.PI;
      var atan = Math.atan;

      function calculateAngle(point, center) {
        var x = point.x - center.x;
        var y = point.y - center.y;
        var deg;

        if (y === 0) {
          if (x < 0) {
            deg = PI / 2;
          } else {
            deg = 270 * PI / 180;
          }
        } else if (x >= 0 && y > 0) {
          deg = PI * 2 - atan(x / y);
        } else if (x <= 0 && y < 0) {
          deg = PI - atan(x / y);
        } else if (x > 0 && y < 0) {
          deg = PI + atan(-x / y);
        } else if (x < 0 && y > 0) {
          deg = atan(x / -y);
        }

        return deg;
      }

      var Arc = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(Arc, _Guide);

        function Arc() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = Arc.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 辅助元素类型
             * @type {String}
             */
            name: 'arc',

            /**
             * 辅助弧线的起始点
             * @type {Object | Function | Array}
             */
            start: null,

            /**
             * 辅助弧线的终止点
             * @type {Object | Function | Array}
             */
            end: null,

            /**
             * 辅助文本的样式配置
             * @type {Object}
             */
            style: {
              stroke: '#999',
              lineWidth: 1
            }
          });
        };

        _proto.render = function render(coord, group) {
          var self = this;
          var start = self.parsePoint(coord, self.get('start'));
          var end = self.parsePoint(coord, self.get('end')); // 只要有一个点无意义，则不绘制

          if (!start || !end) {
            return;
          }

          var coordCenter = coord.getCenter();
          var radius = Math.sqrt((start.x - coordCenter.x) * (start.x - coordCenter.x) + (start.y - coordCenter.y) * (start.y - coordCenter.y));
          var path; // 处理整圆的情况

          var startAngle = calculateAngle(start, coordCenter);
          var endAngle = calculateAngle(end, coordCenter);

          if (endAngle < startAngle) {
            endAngle += PI * 2;
          }

          if (Util.isNumberEqual(start.x, end.x) && Util.isNumberEqual(start.y, end.y) && (self.get('start')[0] !== self.get('end')[0] || self.get('start')[1] !== self.get('end')[1])) {
            path = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, 2 * coordCenter.x - start.x, 2 * coordCenter.y - start.y], ['A', radius, radius, 0, 1, 1, start.x, start.y]];
          } else {
            var dAngle = (endAngle - startAngle) % (PI * 2);
            var largeArc = dAngle > PI ? 1 : 0;
            path = [['M', start.x, start.y], ['A', radius, radius, 0, largeArc, 1, end.x, end.y]];
          }

          var arcShape = group.addShape('path', {
            zIndex: self.get('zIndex'),
            attrs: Util.mix({
              path: path
            }, self.get('style'))
          });
          arcShape.name = 'guide-arc';
          self.get('appendInfo') && arcShape.setSilent('appendInfo', self.get('appendInfo'));
          self.set('el', arcShape);
        };

        return Arc;
      }(Guide);

      module.exports = Arc;
      /***/
    },
    /* 318 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Guide = __webpack_require__(15);

      var DataMarker = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(DataMarker, _Guide);

        function DataMarker() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = DataMarker.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            name: 'dataMarker',
            zIndex: 1,
            top: true,
            position: null,
            style: {
              point: {
                r: 3,
                fill: '#FFFFFF',
                stroke: '#1890FF',
                lineWidth: 2
              },
              line: {
                stroke: '#A3B1BF',
                lineWidth: 1
              },
              text: {
                fill: '#000000',
                opacity: 0.65,
                fontSize: 12,
                textAlign: 'start'
              }
            },
            // end of style
            display: {
              point: true,
              line: true,
              text: true
            },
            lineLength: 20,
            direction: 'upward',
            autoAdjust: true
          });
        };

        _proto.render = function render(coord, group) {
          var self = this;
          var point = self.parsePoint(coord, self.get('position'));

          if (!point) {
            return;
          } // container


          var markerGroup = group.addGroup();
          markerGroup.name = 'guide-data-marker'; // markerGroup.translate(point.x, point.y);

          var positions = self._getElementPosition(point);

          var display = self.get('display');
          var lineShape;
          var textShape; // add line

          if (display.line) {
            var lineData = positions.line;
            lineShape = self._drawLine(lineData, markerGroup);
          } // add text


          if (display.text && self.get('content')) {
            var textPosition = positions.text;
            textShape = self._drawText(textPosition, markerGroup);
          } // add circle


          if (display.point) {
            var pointPoisition = positions.point;

            self._drawPoint(pointPoisition, markerGroup);
          }

          if (self.get('autoAdjust')) {
            var bbox = markerGroup.getBBox();
            var minX = bbox.minX,
                minY = bbox.minY,
                maxX = bbox.maxX,
                maxY = bbox.maxY;
            var start = coord.start,
                end = coord.end;

            if (textShape) {
              if (minX <= start.x) {
                // 左侧超出
                textShape.attr('textAlign', 'start');
              }

              if (maxX >= end.x) {
                // 右侧超出
                textShape.attr('textAlign', 'end');
              }

              var direction = self.get('direction');

              if (direction === 'upward' && minY <= end.y || direction !== 'upward' && maxY >= start.y) {
                // 上方或者下方超出
                var textBaseline;
                var dir;

                if (direction === 'upward' && minY <= end.y) {
                  textBaseline = 'top';
                  dir = 1;
                } else {
                  textBaseline = 'bottom';
                  dir = -1;
                }

                textShape.attr('textBaseline', textBaseline);
                var lineLength = 0;

                if (self.get('display').line) {
                  lineLength = self.get('lineLength');
                  var linePath = [['M', point.x, point.y], ['L', point.x, point.y + lineLength * dir]];
                  lineShape.attr('path', linePath);
                }

                var newY = point.y + (lineLength + 2) * dir;
                textShape.attr('y', newY);
              }
            }
          }

          self.get('appendInfo') && markerGroup.setSilent('appendInfo', self.get('appendInfo'));
          self.set('el', markerGroup);
        };

        _proto._getElementPosition = function _getElementPosition(position) {
          var self = this;
          var x = position.x,
              y = position.y;
          var lineLength = self.get('display').line ? self.get('lineLength') : 0;
          var direction = self.get('direction');
          var textStyle = self.get('style').text;
          textStyle.textBaseline = direction === 'upward' ? 'bottom' : 'top';
          var dir = direction === 'upward' ? -1 : 1;
          var pointPoisition = {
            x: x,
            y: y
          };
          var lineStart = {
            x: x,
            y: y
          };
          var lineEnd = {
            x: x,
            y: lineLength * dir + y
          };
          var textPosition = {
            x: x,
            y: (lineLength + 2) * dir + y
          };
          return {
            point: pointPoisition,
            line: [lineStart, lineEnd],
            text: textPosition
          };
        };

        _proto._drawLine = function _drawLine(lineData, g) {
          var self = this;
          var lineStyle = self.get('style').line;
          var linePath = [['M', lineData[0].x, lineData[0].y], ['L', lineData[1].x, lineData[1].y]];
          var lineShape = g.addShape('path', {
            attrs: Util.mix({
              path: linePath
            }, lineStyle)
          });
          return lineShape;
        };

        _proto._drawText = function _drawText(position, g) {
          var self = this;
          var textStyle = this.get('style').text;
          var textShape = g.addShape('text', {
            attrs: Util.mix({
              text: self.get('content')
            }, textStyle, position)
          });
          return textShape;
        };

        _proto._drawPoint = function _drawPoint(position, g) {
          var self = this;
          var pointStyle = self.get('style').point;
          var pointShape = g.addShape('circle', {
            attrs: Util.mix({}, pointStyle, position)
          });
          return pointShape;
        };

        return DataMarker;
      }(Guide);

      module.exports = DataMarker;
      /***/
    },
    /* 319 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Helper = __webpack_require__(155);

      var Guide = __webpack_require__(15);

      var DataRegion = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(DataRegion, _Guide);

        function DataRegion() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = DataRegion.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            name: 'dataRegion',
            start: null,
            // 只支持数值
            end: null,
            // 只支持数值
            content: '',
            // 文本内容
            style: {
              region: {
                lineWidth: 0,
                fill: '#000000',
                opacity: 0.04
              },
              text: {
                textAlign: 'center',
                textBaseline: 'bottom',
                fontSize: 12,
                fill: 'rgba(0, 0, 0, .65)'
              }
            }
          });
        };

        _proto.render = function render(coord, group, data) {
          var self = this; // draw region

          var lineLength = self.get('lineLength') || 0; // TODO: 如何命名

          var regionData = self._getRegionData(coord, data);

          if (!regionData.length) return;

          var regionBBox = self._getBBox(regionData);

          var path = [];
          path.push(['M', regionData[0].x, regionBBox.yMin - lineLength]);

          for (var i = 0, len = regionData.length; i < len; i++) {
            var p = ['L', regionData[i].x, regionData[i].y];
            path.push(p);
          }

          path.push(['L', regionData[regionData.length - 1].x, regionBBox.yMin - lineLength]); // draw

          var style = self.get('style');
          var regionStyle = style.region; // 兼容之前的写法

          var textStyle = style.text;
          var regionGroup = group.addGroup();
          regionGroup.name = 'guide-data-region';
          regionGroup.addShape('path', {
            attrs: Util.mix({
              path: path
            }, regionStyle)
          });
          var content = self.get('content');

          if (content) {
            regionGroup.addShape('Text', {
              attrs: Util.mix({
                x: (regionBBox.xMin + regionBBox.xMax) / 2,
                y: regionBBox.yMin - lineLength,
                text: content
              }, textStyle)
            });
          }

          self.get('appendInfo') && regionGroup.setSilent('appendInfo', self.get('appendInfo'));
          self.set('el', regionGroup);
        };

        _proto._getRegionData = function _getRegionData(coord, data) {
          var self = this;
          var start = self.get('start');
          var end = self.get('end');
          var xField = Helper.getFirstScale(self.get('xScales')).field;
          var yField = Helper.getFirstScale(self.get('yScales')).field;
          var startXValue = Util.isArray(start) ? start[0] : start[xField];
          var endXValue = Util.isArray(end) ? end[0] : end[xField];
          var startIndex;
          var arr = [];

          for (var i = 0, len = data.length; i < len; i++) {
            var item = data[i];

            if (item[xField] === startXValue) {
              startIndex = i;
            }

            if (i >= startIndex) {
              var point = self.parsePoint(coord, [item[xField], item[yField]]); // 判断是否是有效点

              point && arr.push(point);
            }

            if (item[xField] === endXValue) {
              break;
            }
          }

          return arr;
        };

        _proto._getBBox = function _getBBox(data) {
          var xs = [];
          var ys = [];

          for (var i = 0; i < data.length; i++) {
            xs.push(data[i].x);
            ys.push(data[i].y);
          }

          var xRange = Util.arrayUtil.getRange(xs);
          var yRange = Util.arrayUtil.getRange(ys);
          return {
            xMin: xRange.min,
            xMax: xRange.max,
            yMin: yRange.min,
            yMax: yRange.max
          };
        };

        return DataRegion;
      }(Guide);

      module.exports = DataRegion;
      /***/
    },
    /* 320 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var DomUtil = Util.DomUtil;

      var Guide = __webpack_require__(15);

      var Html = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(Html, _Guide);

        function Html() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = Html.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            name: 'html',
            zIndex: 7,
            position: null,

            /**
             * Horizontal alignment, can be 'left'、'middle'、'right'
             * @type {String}
             */
            alignX: 'middle',

            /**
             * vertical alignment, can be 'top'、'middle'、'bottom'
             * @type {String}
             */
            alignY: 'middle',

            /**
             * Horizontal offset
             * @type {Number}
             */
            offsetX: null,

            /**
             * Vertical offset
             * @type {Number}
             */
            offsetY: null,

            /**
            * html content
            *@type {String | Function}
            */
            html: null
          });
        }
        /**
         * render Html Guide
         * @override
         * @param {Coordinate} coord the instance of Coordinate class
         * @param {Container} container the container which contain the guide component
         */
        ;

        _proto.render = function render(coord, container) {
          var self = this;
          var position = self.parsePoint(coord, self.get('position'));

          if (!position) {
            return;
          }

          var parentNode = container.get('canvas').get('el').parentNode;
          var wrapperNode = DomUtil.createDom('<div class="g-guide"></div>');
          parentNode.appendChild(wrapperNode);
          var html = self.get('htmlContent') || self.get('html');

          if (Util.isFunction(html)) {
            var xScales = self.get('xScales');
            var yScales = self.get('yScales');
            html = html(xScales, yScales);
          }

          var htmlNode = DomUtil.createDom(html);
          wrapperNode.appendChild(htmlNode);
          DomUtil.modifyCSS(wrapperNode, {
            position: 'absolute' // to fix dom in the document stream to get the true width

          });

          self._setDomPosition(wrapperNode, htmlNode, position);

          self.set('el', wrapperNode);
        };

        _proto._setDomPosition = function _setDomPosition(parentDom, childDom, point) {
          var self = this;
          var alignX = self.get('alignX');
          var alignY = self.get('alignY');
          var domWidth = DomUtil.getOuterWidth(childDom);
          var domHeight = DomUtil.getOuterHeight(childDom);
          var position = {
            x: point.x,
            y: point.y
          };

          if (alignX === 'middle' && alignY === 'top') {
            position.x -= Math.round(domWidth / 2);
          } else if (alignX === 'middle' && alignY === 'bottom') {
            position.x -= Math.round(domWidth / 2);
            position.y -= Math.round(domHeight);
          } else if (alignX === 'left' && alignY === 'bottom') {
            position.y -= Math.round(domHeight);
          } else if (alignX === 'left' && alignY === 'middle') {
            position.y -= Math.round(domHeight / 2);
          } else if (alignX === 'left' && alignY === 'top') {
            position.x = point.x;
            position.y = point.y;
          } else if (alignX === 'right' && alignY === 'bottom') {
            position.x -= Math.round(domWidth);
            position.y -= Math.round(domHeight);
          } else if (alignX === 'right' && alignY === 'middle') {
            position.x -= Math.round(domWidth);
            position.y -= Math.round(domHeight / 2);
          } else if (alignX === 'right' && alignY === 'top') {
            position.x -= Math.round(domWidth);
          } else {
            // 默认位于中心点
            position.x -= Math.round(domWidth / 2);
            position.y -= Math.round(domHeight / 2);
          }

          var offsetX = self.get('offsetX');

          if (offsetX) {
            position.x += offsetX;
          }

          var offsetY = self.get('offsetY');

          if (offsetY) {
            position.y += offsetY;
          }

          DomUtil.modifyCSS(parentDom, {
            top: Math.round(position.y) + 'px',
            left: Math.round(position.x) + 'px',
            visibility: 'visible',
            zIndex: self.get('zIndex')
          });
        }
        /**
         * clear html guide
         * @override
         */
        ;

        _proto.clear = function clear() {
          var self = this;
          var el = self.get('el');
          el && el.parentNode && el.parentNode.removeChild(el);
        };

        return Html;
      }(Guide);

      module.exports = Html;
      /***/
    },
    /* 321 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Guide = __webpack_require__(15);

      var Image = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(Image, _Guide);

        function Image() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = Image.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            type: 'image',

            /**
             * the start of image
             * @type {Object | Function | Array}
             */
            start: null,

            /**
             * the end of image
             * @type {Object | Function | Array}
             */
            end: null,

            /**
             * image url
             * @type {String}
             */
            src: null,

            /**
             * Horizontal offset
             * @type {Number}
             */
            offsetX: null,

            /**
             * Vertical offset
             * @type {Number}
             */
            offsetY: null
          });
        };

        _proto.render = function render(coord, group) {
          var self = this;
          var start = self.parsePoint(coord, self.get('start'));

          if (!start) {
            return;
          }

          var cfg = {
            x: start.x,
            y: start.y
          };
          cfg.img = self.get('src');

          if (!self.get('end')) {
            // 如果咩有指定结束点，则 start 为图片的左上角坐标
            cfg.width = self.get('width') || 32;
            cfg.height = self.get('height') || 32;
          } else {
            var end = self.parsePoint(coord, self.get('end'));

            if (!end) {
              return;
            } // cfg.width = Math.abs(end.x - start.x);
            // cfg.height = Math.abs(end.y - start.y);


            cfg.width = end.x - start.x;
            cfg.height = end.y - start.y;
          }

          if (self.get('offsetX')) {
            cfg.x += self.get('offsetX');
          }

          if (self.get('offsetY')) {
            cfg.y += self.get('offsetY');
          }

          var imgGuide = group.addShape('Image', {
            zIndex: 1,
            attrs: cfg
          });
          imgGuide.name = 'guide-image';
          self.get('appendInfo') && imgGuide.setSilent('appendInfo', self.get('appendInfo'));
          self.set('el', imgGuide);
        };

        return Image;
      }(Guide);

      module.exports = Image;
      /***/
    },
    /* 322 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Guide = __webpack_require__(15);

      var vec2 = Util.MatrixUtil.vec2;

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var Line = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(Line, _Guide);

        function Line() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = Line.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 辅助元素类型
             * @type {String}
             */
            name: 'line',

            /**
             * 辅助线的起点位置
             * @type {Object | Function | Array}
             */
            start: null,

            /**
             * 辅助线的终点位置
             * @type {Object | Function | Array}
             */
            end: null,

            /**
             * 辅助线的图形样式
             * @type {Object}
             */
            lineStyle: {
              stroke: '#000',
              lineWidth: 1
            },

            /**
             * 辅助文本配置
             * @type {Object}
             */
            text: {
              position: 'end',
              // 文本的显示位置： start / center / end / 百分比
              autoRotate: true,
              // 文本是否沿着辅助线的方向自动旋转
              style: {
                fill: '#999',
                fontSize: 12,
                fontWeight: 500,
                fontFamily: FONT_FAMILY
              },
              // 辅助文本的样式
              content: null // 辅助文本的文字

            }
          });
        };

        _proto.render = function render(coord, group) {
          var self = this;
          var start = self.parsePoint(coord, self.get('start'));
          var end = self.parsePoint(coord, self.get('end'));

          if (!start || !end) {
            return;
          }

          var guideLineGroup = group.addGroup({
            viewId: group.get('viewId')
          });

          self._drawLines(start, end, guideLineGroup);

          var text = self.get('text');

          if (text && text.content) {
            self._drawText(start, end, guideLineGroup);
          }

          self.set('el', guideLineGroup);
        };

        _proto._drawLines = function _drawLines(start, end, group) {
          var path = [['M', start.x, start.y], ['L', end.x, end.y]];
          var guideLine = group.addShape('Path', {
            attrs: Util.mix({
              path: path
            }, this.get('lineStyle'))
          });
          guideLine.name = 'guide-line';
          this.get('appendInfo') && guideLine.setSilent('appendInfo', this.get('appendInfo'));
        };

        _proto._drawText = function _drawText(start, end, group) {
          var textCfg = this.get('text');
          var position = textCfg.position;
          var textStyle = textCfg.style || {};
          var percent;

          if (position === 'start') {
            percent = 0;
          } else if (position === 'center') {
            percent = 0.5;
          } else if (Util.isString(position) && position.indexOf('%') !== -1) {
            percent = parseInt(position, 10) / 100;
          } else if (Util.isNumber(position)) {
            percent = position;
          } else {
            percent = 1;
          }

          if (percent > 1 || percent < 0) {
            percent = 1;
          }

          var cfg = {
            x: start.x + (end.x - start.x) * percent,
            y: start.y + (end.y - start.y) * percent
          };

          if (textCfg.offsetX) {
            // 设置了偏移量
            cfg.x += textCfg.offsetX;
          }

          if (textCfg.offsetY) {
            // 设置了偏移量
            cfg.y += textCfg.offsetY;
          }

          cfg.text = textCfg.content;
          cfg = Util.mix({}, cfg, textStyle);

          if (textCfg.autoRotate && Util.isNil(textStyle.rotate)) {
            // 自动旋转且用户没有设置旋转角度
            var angle = vec2.angleTo([end.x - start.x, end.y - start.y], [1, 0], 1);
            cfg.rotate = angle;
          } else if (!Util.isNil(textStyle.rotate)) {
            // 用户设置了旋转角度
            cfg.rotate = textStyle.rotate * Math.PI / 180;
          }

          var shape = group.addShape('Text', {
            attrs: cfg
          });
          shape.name = 'guide-line-text';
          this.get('appendInfo') && shape.setSilent('appendInfo', this.get('appendInfo'));
        };

        return Line;
      }(Guide);

      module.exports = Line;
      /***/
    },
    /* 323 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Guide = __webpack_require__(15);

      var Region = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(Region, _Guide);

        function Region() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = Region.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            name: 'region',
            zIndex: 1,
            start: null,
            end: null,
            style: {
              lineWidth: 0,
              fill: '#CCD7EB',
              opacity: 0.4
            }
          });
        };

        _proto.render = function render(coord, group) {
          var self = this;
          var rectStyle = self.get('style');

          var path = self._getPath(coord);

          if (!path.length) {
            // path 为空时不绘制
            return;
          }

          var regionGroup = group.addShape('path', {
            zIndex: self.get('zIndex'),
            attrs: Util.mix({
              path: path
            }, rectStyle)
          });
          regionGroup.name = 'guide-region';
          self.get('appendInfo') && regionGroup.setSilent('appendInfo', self.get('appendInfo'));
          self.set('el', regionGroup);
        };

        _proto._getPath = function _getPath(coord) {
          var self = this;
          var start = self.parsePoint(coord, self.get('start'));
          var end = self.parsePoint(coord, self.get('end'));

          if (!start || !end) {
            return [];
          }

          var path = [['M', start.x, start.y], ['L', end.x, start.y], ['L', end.x, end.y], ['L', start.x, end.y], ['z']];
          return path;
        };

        return Region;
      }(Guide);

      module.exports = Region;
      /***/
    },
    /* 324 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var Guide = __webpack_require__(15);

      var Text = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(Text, _Guide);

        function Text() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = Text.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 辅助元素类型
             * @type {String}
             */
            name: 'text',

            /**
             * 辅助文本的位置
             * @type {Object | Function | Array}
             */
            position: null,

            /**
             * 辅助文本的显示文字
             * @type {String}
             */
            content: null,

            /**
             * 辅助文本的样式配置
             * @type {Object}
             */
            style: {
              fill: '#999',
              fontSize: 12,
              fontWeight: 500,
              textAlign: 'center'
            },

            /**
             * x 方向的偏移量
             * @type {Number}
             */
            offsetX: null,

            /**
             * y 方向的偏移量
             * @type {Number}
             */
            offsetY: null,
            top: true
          });
        };

        _proto.render = function render(coord, group) {
          var self = this;
          var point = self.parsePoint(coord, self.get('position'));

          if (!point) {
            return;
          }

          var textStyle = Util.mix({}, self.get('style'));
          var offsetX = self.get('offsetX');
          var offsetY = self.get('offsetY');

          if (offsetX) {
            point.x += offsetX;
          }

          if (offsetY) {
            point.y += offsetY;
          }

          if (textStyle.rotate) {
            textStyle.rotate = textStyle.rotate * Math.PI / 180; // 将角度转换为弧度
          }

          var guideText = group.addShape('Text', {
            zIndex: self.get('zIndex'),
            attrs: Util.mix({
              text: self.get('content')
            }, textStyle, point)
          });
          guideText.name = 'guide-text';
          self.get('appendInfo') && guideText.setSilent('appendInfo', self.get('appendInfo'));
          self.set('el', guideText);
        };

        return Text;
      }(Guide);

      module.exports = Text;
      /***/
    },
    /* 325 */

    /***/
    function (module, exports, __webpack_require__) {
      var Label = __webpack_require__(153);

      module.exports = Label;
      /***/
    },
    /* 326 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The entry of legend
       * @author sima.zhang
       */
      module.exports = {
        Category: __webpack_require__(156),
        // 分类图例
        CatHtml: __webpack_require__(158),
        // 分类图例
        CatPageHtml: __webpack_require__(327),
        // 分类图例
        // Tail: require('./tail'), // 尾部跟随图例
        Color: __webpack_require__(328),
        // 颜色图例
        Size: __webpack_require__(330),
        // 大小图例（适用于除映射点大小以外的其他大小）
        CircleSize: __webpack_require__(331) // 点大小图例

      };
      /***/
    },
    /* 327 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var CatHtml = __webpack_require__(158);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var DomUtil = Util.DomUtil;
      var LIST_CLASS = 'g2-legend-list';
      var SLIP_CLASS = 'g2-slip';
      var CARET_UP_CLASS = 'g2-caret-up';
      var CARET_DOWN_CLASS = 'g2-caret-down';
      var ENABLED_CARET_COLOR = 'rgba(0,0,0,0.65)';
      var DISABLED_CARET_COLOR = 'rgba(0,0,0,0.25)';

      function findNodeByClass(node, className) {
        return node.getElementsByClassName(className)[0];
      }

      var CatPageHtml = /*#__PURE__*/function (_CatHtml) {
        _inheritsLoose(CatPageHtml, _CatHtml);

        function CatPageHtml() {
          return _CatHtml.apply(this, arguments) || this;
        }

        var _proto = CatPageHtml.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _CatHtml.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * type标识
             * @type {String}
             */
            type: 'category-page-legend',

            /**
             * html 容器
             * @type {DOM}
             */
            container: null,

            /**
             * 向上 / 下翻页图标的样式
             * @type {ATTRS}
             */
            caretStyle: {
              fill: 'rgba(0,0,0,0.65)'
            },

            /**
             * 页码文字的样式
             * @type {ATTRS}
             */
            pageNumStyle: {
              display: 'inline-block',
              fontSize: '12px',
              fontFamily: FONT_FAMILY,
              cursor: 'default'
            },

            /**
             * 翻页块 DOM 的样式
             * @type {ATTRS}
             */
            slipDomStyle: {
              width: 'auto',
              height: 'auto',
              position: 'absolute'
            },

            /**
             * 翻页块 DOM
             * @type {String}
             */
            slipTpl: '<div class="' + SLIP_CLASS + '" >' + '<svg viewBox="64 64 896 896" class="g2-caret-up" data-icon="left" style = "display:inline-block;vertical-align:middle;" width="1em" height="1em" aria-hidden="true">' + '<path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path>' + '</svg>' + '<p class="cur-pagenum" style = "display:inline-block;vertical-align:middle;">1</p>' + '<p class="next-pagenum" style = "display:inline-block;vertical-align:middle;"">/2</p>' + '<svg viewBox="64 64 896 896" class="g2-caret-down" data-icon="right" style = "display:inline-block;vertical-align:middle;" width="1em" height="1em" aria-hidden="true">' + '<path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path>' + '</svg>' + '</div>',

            /**
             * 翻页块的宽度，用于设置翻页块相对于 legend 的位置
             * @type {Number}
             */
            slipWidth: 65,

            /**
             * legend 内容超出容器的处理方式
             * @type {String}
             */
            legendOverflow: 'unset'
          });
        };

        _proto.render = function render() {
          _CatHtml.prototype._renderHTML.call(this);

          this._renderFlipPage();
        };

        _proto._renderFlipPage = function _renderFlipPage() {
          var legendWrapper = this.get('legendWrapper'); // ul

          var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
          var position = this.get('position');
          var layout = this.get('layout');
          var isVertical = position === 'right' || position === 'left' || layout === 'vertical';
          var itemDisplay = isVertical ? 'block' : 'inline-block';
          var legengWrapperHeight = legendWrapper.offsetHeight; // 翻页

          if (legendWrapper.scrollHeight > legengWrapperHeight) {
            // append a slip div
            var slipTpl = this.get('slipTpl');
            var slipDom = DomUtil.createDom(slipTpl);
            var caretUpDom = findNodeByClass(slipDom, CARET_UP_CLASS);
            var caretDownDom = findNodeByClass(slipDom, CARET_DOWN_CLASS);
            DomUtil.modifyCSS(caretUpDom, this.get('caretStyle'));
            DomUtil.modifyCSS(caretUpDom, {
              fill: 'rgba(0,0,0,0.25)'
            });
            DomUtil.modifyCSS(caretDownDom, this.get('caretStyle'));
            var curPageNumDom = findNodeByClass(slipDom, 'cur-pagenum');
            var totalPageNumDom = findNodeByClass(slipDom, 'next-pagenum');
            var pageNumStyle = this.get('pageNumStyle');
            DomUtil.modifyCSS(curPageNumDom, Util.mix({}, pageNumStyle, {
              paddingLeft: '10px'
            }));
            DomUtil.modifyCSS(totalPageNumDom, Util.mix({}, pageNumStyle, {
              opacity: 0.3,
              paddingRight: '10px'
            })); // layout at the center-bottom of the legendWrapper

            DomUtil.modifyCSS(slipDom, Util.mix({}, this.get('slipDomStyle'), isVertical ? {
              top: legengWrapperHeight + 'px'
            } : {
              right: 0,
              top: '50%',
              // 横向布局的时候，分页在右侧居中对齐
              transform: 'translate(0, -50%)'
            }));
            legendWrapper.style.overflow = this.get('legendOverflow');
            legendWrapper.appendChild(slipDom);

            if (!isVertical) {
              var legendListMaxWidth = Math.max(legendWrapper.offsetWidth - 10 - slipDom.offsetWidth, 0); // 横向布局的时候更新list的宽度

              DomUtil.modifyCSS(itemListDom, {
                maxWidth: legendListMaxWidth + "px"
              });
            }

            var li = itemListDom.childNodes;
            var curHeight = 0; // find the total page number

            var pages = 1;
            var blockLi = [];

            for (var i = 0; i < li.length; i++) {
              li[i].style.display = itemDisplay;
              curHeight = li[i].offsetTop + li[i].offsetHeight;

              if (curHeight > legengWrapperHeight) {
                pages++;
                blockLi.forEach(function (bl) {
                  bl.style.display = 'none';
                });
                blockLi = [];
              }

              blockLi.push(li[i]);
            }

            totalPageNumDom.innerText = '/' + pages; // initialize the page

            li.forEach(function (l) {
              l.style.display = itemDisplay;
              curHeight = l.offsetTop + l.offsetHeight;

              if (curHeight > legengWrapperHeight) {
                l.style.display = 'none';
              }
            }); // 上翻事件

            caretUpDom.addEventListener('click', function () {
              // it is the 1st page
              if (li[0].style.display === itemDisplay) return; // otherwise

              var firstDisplayItemIdx = -1;
              li.forEach(function (l, i) {
                if (l.style.display === itemDisplay) {
                  firstDisplayItemIdx = firstDisplayItemIdx === -1 ? i : firstDisplayItemIdx;
                  l.style.display = 'none';
                }
              });

              for (var _i = firstDisplayItemIdx - 1; _i >= 0; _i--) {
                li[_i].style.display = itemDisplay;
                curHeight = li[firstDisplayItemIdx - 1].offsetTop + li[firstDisplayItemIdx - 1].offsetHeight;
                li[_i].style.display = 'none';

                if (curHeight <= legengWrapperHeight) {
                  li[_i].style.display = itemDisplay;
                } else break;
              } // change the page number


              var currentPage = Number.parseInt(curPageNumDom.innerText, 10) - 1;

              if (currentPage === 1) {
                caretUpDom.style.fill = DISABLED_CARET_COLOR;
              } else {
                caretUpDom.style.fill = ENABLED_CARET_COLOR;
              }

              caretDownDom.style.fill = ENABLED_CARET_COLOR;
              curPageNumDom.innerText = currentPage;
            }); // 下翻事件

            caretDownDom.addEventListener('click', function () {
              // it is the last page
              if (li[li.length - 1].style.display === itemDisplay) return; // otherwise

              var lastDisplayItemIdx = -1;
              li.forEach(function (l, i) {
                if (l.style.display === itemDisplay) {
                  lastDisplayItemIdx = i;
                  l.style.display = 'none';
                }
              });

              for (var _i2 = lastDisplayItemIdx + 1; _i2 < li.length; _i2++) {
                li[_i2].style.display = itemDisplay;
                curHeight = li[_i2].offsetTop + li[_i2].offsetHeight;
                li[_i2].style.display = 'none';
                if (curHeight <= legengWrapperHeight) li[_i2].style.display = itemDisplay;else break;
              } // change the page number


              var currentPage = Number.parseInt(curPageNumDom.innerText, 10) + 1;

              if (currentPage === pages) {
                caretDownDom.style.fill = DISABLED_CARET_COLOR;
              } else {
                caretDownDom.style.fill = ENABLED_CARET_COLOR;
              }

              caretUpDom.style.fill = ENABLED_CARET_COLOR;
              curPageNumDom.innerText = currentPage;
            });
            this.set('slipDom', slipDom);
          }
        };

        _proto.destroy = function destroy() {
          var slipDom = this.get('slipDom');

          if (slipDom && slipDom.parentNode) {
            slipDom.parentNode.removeChild(slipDom);
          }

          _CatHtml.prototype.destroy.call(this);
        };

        return CatPageHtml;
      }(CatHtml);

      module.exports = CatPageHtml;
      /***/
    },
    /* 328 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The class of the gradient color legend
       * @author sima.zhang
       */


      var _require = __webpack_require__(73),
          ColorUtil = _require.ColorUtil; // TODO：ColorUtil 包需要从 attr 包中抽离


      var Util = __webpack_require__(3);

      var Continuous = __webpack_require__(68);

      var Color = /*#__PURE__*/function (_Continuous) {
        _inheritsLoose(Color, _Continuous);

        function Color() {
          return _Continuous.apply(this, arguments) || this;
        }

        var _proto = Color.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Continuous.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 类型
             * @type {String}
             */
            type: 'color-legend',

            /**
             * 布局方式
             * horizontal 水平
             * vertical 垂直
             * @type {String}
             */
            layout: 'vertical',

            /**
             * 两头滑块的样式
             * @type {object}
             */
            triggerAttr: {
              fill: '#fff',
              shadowOffsetX: -2,
              shadowOffsetY: 2,
              shadowBlur: 10,
              shadowColor: '#ccc',
              radius: 3
            },

            /**
             * 同一分段是否使用相同颜色而不使用渐变色，在 slidable = false 时生效
             * @type {boolean}
             */
            isSegment: false
          });
        };

        _proto._setPercentage = function _setPercentage() {
          var items = this.get('items');
          if (items[0].percentage) return;
          var min = items[0].value;
          var max = items[items.length - 1].value;
          Util.each(items, function (it) {
            it.percentage = (it.value - min) / (max - min);
          });
          return;
        } // render the slider while slidable === true
        ;

        _proto._renderSliderShape = function _renderSliderShape() {
          this._setPercentage();

          var slider = this.get('slider');
          var backgroundElement = slider.get('backgroundElement');
          var width = this.get('width');
          var height = this.get('height');
          var layout = this.get('layout');
          var items = this.get('items');
          var fill = '';
          var rgbColor; // gradient color distributed according to the percentage

          if (layout === 'vertical') {
            fill += 'l (90) ';
            Util.each(items, function (v) {
              rgbColor = ColorUtil.toRGB(v.color);
              fill += 1 - v.percentage + ':' + rgbColor + ' ';
            });
          } else {
            fill += 'l (0) ';
            Util.each(items, function (v) {
              rgbColor = ColorUtil.toRGB(v.color);
              fill += v.percentage + ':' + rgbColor + ' ';
            });
          }

          return this._addMiddleBar(backgroundElement, 'Rect', {
            x: 0,
            y: 0,
            width: width,
            height: height,
            fill: fill,
            strokeOpacity: 0
          });
        } // render the silder while slidable === false
        ;

        _proto._renderUnslidable = function _renderUnslidable() {
          this._setPercentage();

          var titleShape = this.get('titleShape');
          var titleGap = this.get('titleGap');
          titleGap = titleShape ? titleShape.getBBox().height + titleGap : titleGap;
          var width = this.get('width');
          var height = this.get('height');
          var layout = this.get('layout');
          var items = this.get('items');
          var fill = '';
          var rgbColor;
          var path = [];
          var group = this.get('group');
          var bgGroup = group.addGroup();
          var isize = items.length; // gradient color distributed according to the percentage

          if (layout === 'vertical') {
            fill += 'l (90) ';

            for (var i = 0; i < isize; i += 1) {
              if (i !== 0 && i !== isize - 1) {
                path.push(['M', 0, height - items[i].percentage * height]);
                path.push(['L', width, height - items[i].percentage * height]);
              }

              rgbColor = ColorUtil.toRGB(items[i].color);
              fill += 1 - items[i].percentage + ':' + rgbColor + ' ';

              if (this.get('isSegment') && i > 0) {
                // one color instead of gradient color for a block while isSegment === true
                var preRgbColor = ColorUtil.toRGB(items[i - 1].color);
                fill += 1 - items[i].percentage + ':' + preRgbColor + ' ';
              }

              bgGroup.addShape('text', {
                attrs: Util.mix({}, {
                  x: width + this.get('textOffset') / 2,
                  y: height - items[i].percentage * height,
                  text: this._formatItemValue(items[i].value) + '' // 以字符串格式展示

                }, this.get('textStyle'), {
                  textAlign: 'start'
                })
              });
            }
          } else {
            // horizontal
            fill += 'l (0) ';

            for (var _i = 0; _i < isize; _i += 1) {
              if (_i !== 0 && _i !== isize - 1) {
                path.push(['M', items[_i].percentage * width, 0]);
                path.push(['L', items[_i].percentage * width, height]);
              }

              rgbColor = ColorUtil.toRGB(items[_i].color);

              if (this.get('isSegment') && _i > 0) {
                var _preRgbColor = ColorUtil.toRGB(items[_i - 1].color);

                fill += items[_i].percentage + ':' + _preRgbColor + ' ';
              }

              fill += items[_i].percentage + ':' + rgbColor + ' ';
              bgGroup.addShape('text', {
                attrs: Util.mix({}, {
                  x: items[_i].percentage * width,
                  y: height + 5 + this.get('textOffset'),
                  text: this._formatItemValue(items[_i].value) + '' // 以字符串格式展示

                }, this.get('textStyle'))
              });
            }
          }

          bgGroup.addShape('rect', {
            attrs: {
              x: 0,
              y: 0,
              width: width,
              height: height,
              fill: fill,
              strokeOpacity: 0
            }
          }); // the white line segment to seperate color blocks

          bgGroup.addShape('path', {
            attrs: Util.mix({
              path: path
            }, this.get('lineStyle'))
          });
          bgGroup.move(0, titleGap);
        };

        return Color;
      }(Continuous);

      module.exports = Color;
      /***/
    },
    /* 329 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The class of slider
       * @author sima.zhang
       */


      var Util = __webpack_require__(3);

      var DomUtil = Util.DomUtil;
      var Group = Util.Group;

      var Slider = /*#__PURE__*/function (_Group) {
        _inheritsLoose(Slider, _Group);

        function Slider() {
          return _Group.apply(this, arguments) || this;
        }

        var _proto = Slider.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {
            /**
             * 范围
             * @type {Array}
             */
            range: null,

            /**
             * 中滑块属性
             * 透明的，用于用户交互
             * @type {ATTRS}
             */
            middleAttr: {
              fill: '#fff',
              fillOpacity: 0
            },

            /**
             * 背景
             * @type {G-Element}
             */
            backgroundElement: null,

            /**
             * 下滑块
             * @type {G-Element}
             */
            minHandleElement: null,

            /**
             * 上滑块
             * @type {G-Element}
             */
            maxHandleElement: null,

            /**
             * 中块，
             * 透明的，用于用户交互
             * @type {G-Element}
             */
            middleHandleElement: null,

            /**
             * 当前的激活的元素
             * @type {G-Element}
             */
            currentTarget: null,

            /**
             * 布局方式： horizontal，vertical
             * @type {String}
             */
            layout: 'vertical',

            /**
             * 宽
             * @type {Number}
             */
            width: null,

            /**
             * 高
             * @type {Number}
             */
            height: null,

            /**
             * 当前的PageX
             * @type {Number}
             */
            pageX: null,

            /**
             * 当前的PageY
             * @type {Number}
             */
            pageY: null
          };
        } // arrange the zindex and cursors of each element
        ;

        _proto._beforeRenderUI = function _beforeRenderUI() {
          var layout = this.get('layout');
          var backgroundElement = this.get('backgroundElement');
          var minHandleElement = this.get('minHandleElement');
          var maxHandleElement = this.get('maxHandleElement');
          var middleHandleElement = this.addShape('rect', {
            attrs: this.get('middleAttr')
          });
          var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
          this.add([backgroundElement, minHandleElement, maxHandleElement]);
          this.set('middleHandleElement', middleHandleElement);
          backgroundElement.set('zIndex', 0);
          middleHandleElement.set('zIndex', 1);
          minHandleElement.set('zIndex', 2);
          maxHandleElement.set('zIndex', 2);
          middleHandleElement.attr('cursor', 'move');
          minHandleElement.attr('cursor', trigerCursor);
          maxHandleElement.attr('cursor', trigerCursor);
          this.sort();
        } // rendering
        ;

        _proto._renderUI = function _renderUI() {
          if (this.get('layout') === 'horizontal') {
            this._renderHorizontal();
          } else {
            this._renderVertical();
          }
        };

        _proto._transform = function _transform(layout) {
          var range = this.get('range');
          var minRatio = range[0] / 100;
          var maxRatio = range[1] / 100;
          var width = this.get('width');
          var height = this.get('height');
          var minHandleElement = this.get('minHandleElement');
          var maxHandleElement = this.get('maxHandleElement');
          var middleHandleElement = this.get('middleHandleElement');
          minHandleElement.resetMatrix();
          maxHandleElement.resetMatrix();

          if (layout === 'horizontal') {
            middleHandleElement.attr({
              x: width * minRatio,
              y: 0,
              width: (maxRatio - minRatio) * width,
              height: height
            });
            minHandleElement.translate(minRatio * width, height);
            maxHandleElement.translate(maxRatio * width, height);
          } else {
            middleHandleElement.attr({
              x: 0,
              y: height * (1 - maxRatio),
              width: width,
              height: (maxRatio - minRatio) * height
            });
            minHandleElement.translate(1, (1 - minRatio) * height);
            maxHandleElement.translate(1, (1 - maxRatio) * height);
          }
        };

        _proto._renderHorizontal = function _renderHorizontal() {
          this._transform('horizontal');
        };

        _proto._renderVertical = function _renderVertical() {
          this._transform('vertical');
        };

        _proto._bindUI = function _bindUI() {
          this.on('mousedown', Util.wrapBehavior(this, '_onMouseDown'));
        } // if the target matches name
        ;

        _proto._isElement = function _isElement(target, name) {
          var element = this.get(name);

          if (target === element) {
            return true;
          }

          if (element.isGroup) {
            var elementChildren = element.get('children');
            return elementChildren.indexOf(target) > -1;
          }

          return false;
        } // get the result range after adding diff to range
        // insure that the result out of the interval [0, 100]
        ;

        _proto._getRange = function _getRange(diff, range) {
          var rst = diff + range;
          rst = rst > 100 ? 100 : rst;
          rst = rst < 0 ? 0 : rst;
          return rst;
        };

        _proto._updateStatus = function _updateStatus(dim, ev) {
          var totalLength = dim === 'x' ? this.get('width') : this.get('height');
          dim = Util.upperFirst(dim);
          var range = this.get('range');
          var page = this.get('page' + dim);
          var currentTarget = this.get('currentTarget');
          var rangeStash = this.get('rangeStash');
          var layout = this.get('layout');
          var sign = layout === 'vertical' ? -1 : 1;
          var currentPage = ev['page' + dim]; // the distance of the mouse dragging

          var diffPage = currentPage - page;
          var diffRange = diffPage / totalLength * 100 * sign;
          var diffStashRange; // the min and max trigger overlap, range[0] and range[1] change together

          if (range[1] <= range[0]) {
            if (this._isElement(currentTarget, 'minHandleElement') || this._isElement(currentTarget, 'maxHandleElement')) {
              range[0] = this._getRange(diffRange, range[0]);
              range[1] = this._getRange(diffRange, range[0]);
            }
          } else {
            // user drags the min trigger
            if (this._isElement(currentTarget, 'minHandleElement')) {
              range[0] = this._getRange(diffRange, range[0]);
            } // user drags the max trigger


            if (this._isElement(currentTarget, 'maxHandleElement')) {
              range[1] = this._getRange(diffRange, range[1]);
            }
          } // the user drags the middle bar


          if (this._isElement(currentTarget, 'middleHandleElement')) {
            // the diffrence between min and max trigger while mouse down
            diffStashRange = rangeStash[1] - rangeStash[0];
            range[0] = this._getRange(diffRange, range[0]); // keep the diffStashRange

            range[1] = range[0] + diffStashRange;

            if (range[1] > 100) {
              range[1] = 100;
              range[0] = range[1] - diffStashRange;
            }
          }

          this.emit('sliderchange', {
            range: range
          });
          this.set('page' + dim, currentPage);

          this._renderUI();

          this.get('canvas').draw(); // need delete

          return;
        } // the listener of mouse down
        ;

        _proto._onMouseDown = function _onMouseDown(ev) {
          var currentTarget = ev.currentTarget;
          var originEvent = ev.event;
          var range = this.get('range');
          originEvent.stopPropagation();
          originEvent.preventDefault();
          this.set('pageX', originEvent.pageX);
          this.set('pageY', originEvent.pageY);
          this.set('currentTarget', currentTarget); // stash the range

          this.set('rangeStash', [range[0], range[1]]);

          this._bindCanvasEvents();
        };

        _proto._bindCanvasEvents = function _bindCanvasEvents() {
          var containerDOM = this.get('canvas').get('containerDOM'); // this.on('mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));

          this.onMouseMoveListener = DomUtil.addEventListener(containerDOM, 'mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));
          this.onMouseUpListener = DomUtil.addEventListener(containerDOM, 'mouseup', Util.wrapBehavior(this, '_onCanvasMouseUp'));
          this.onMouseLeaveListener = DomUtil.addEventListener(containerDOM, 'mouseleave', Util.wrapBehavior(this, '_onCanvasMouseUp'));
        } // listener of mouse click and move = drag
        ;

        _proto._onCanvasMouseMove = function _onCanvasMouseMove(ev) {
          if (!this._mouseOutArea(ev)) {
            var layout = this.get('layout');

            if (layout === 'horizontal') {
              this._updateStatus('x', ev);
            } else {
              this._updateStatus('y', ev);
            }
          }
        } // listener of mouse up
        ;

        _proto._onCanvasMouseUp = function _onCanvasMouseUp() {
          this._removeDocumentEvents();
        } // remove listeners
        ;

        _proto._removeDocumentEvents = function _removeDocumentEvents() {
          this.onMouseMoveListener.remove();
          this.onMouseUpListener.remove();
        } // if the mouse is out of the area
        ;

        _proto._mouseOutArea = function _mouseOutArea(ev) {
          var el = this.get('canvas').get('el');
          var el_bbox = el.getBoundingClientRect();
          var parent = this.get('parent');
          var bbox = parent.getBBox();
          var left = parent.attr('matrix')[6];
          var top = parent.attr('matrix')[7];
          var right = left + bbox.width;
          var bottom = top + bbox.height;
          var mouseX = ev.clientX - el_bbox.x;
          var mouseY = ev.clientY - el_bbox.y;

          if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {
            return true;
          }

          return false;
        };

        return Slider;
      }(Group);

      module.exports = Slider;
      /***/
    },
    /* 330 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The class of the gradient color legend
       * @author sima.zhang
       */


      var Util = __webpack_require__(3);

      var Continuous = __webpack_require__(68);

      var Size = /*#__PURE__*/function (_Continuous) {
        _inheritsLoose(Size, _Continuous);

        function Size() {
          return _Continuous.apply(this, arguments) || this;
        }

        var _proto = Size.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Continuous.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 类型
             * @type {String}
             */
            type: 'size-legend',
            width: 100,
            height: 200,

            /**
             * 不能滑动时圈的样式
             * @type {ATTRS}
             */
            _unslidableElementStyle: {
              fill: '#4E7CCC',
              fillOpacity: 1
            },

            /**
             * 中间 bar 的前景颜色
             * @type {ATTRS}
             */
            frontMiddleBarStyle: {
              fill: 'rgb(64, 141, 251)'
            }
          });
        } // render the slider shape
        ;

        _proto._renderSliderShape = function _renderSliderShape() {
          var slider = this.get('slider');
          var backgroundElement = slider.get('backgroundElement');
          var layout = this.get('layout');
          var width = this.get('width');
          var height = this.get('height'); // const x = minRadius;

          var y = this.get('height') / 2;
          var frontMiddleBarStyle = this.get('frontMiddleBarStyle'); // background of middle bar

          var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [width - 4, height]] : [[0, y + height / 2], [0, y + height / 2 - 4], [width, y - height / 2], [width, y + height / 2]];
          return this._addMiddleBar(backgroundElement, 'Polygon', Util.mix({
            points: points
          }, frontMiddleBarStyle));
        } // render the middle bar while slidable === false,
        // there are no triggers for this situation
        ;

        _proto._renderUnslidable = function _renderUnslidable() {
          var layout = this.get('layout');
          var width = this.get('width');
          var height = this.get('height');
          var frontMiddleBarStyle = this.get('frontMiddleBarStyle');
          var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [width - 4, height]] : [[0, height], [0, height - 4], [width, 0], [width, height]];
          var group = this.get('group');
          var bgGroup = group.addGroup();
          bgGroup.addShape('Polygon', {
            attrs: Util.mix({
              points: points
            }, frontMiddleBarStyle)
          });

          var minText = this._formatItemValue(this.get('firstItem').value);

          var maxText = this._formatItemValue(this.get('lastItem').value);

          if (this.get('layout') === 'vertical') {
            this._addText(width + 10, height - 3, minText); // min


            this._addText(width + 10, 3, maxText); // max

          } else {
            this._addText(0, height, minText); // min


            this._addText(width, height, maxText); // max

          }
        } // add min and max text while slidable === false
        ;

        _proto._addText = function _addText(x, y, text) {
          var group = this.get('group');
          var textGroup = group.addGroup();
          var textStyle = this.get('textStyle');
          var titleShape = this.get('titleShape');
          var titleGap = this.get('titleGap');

          if (titleShape) {
            titleGap += titleShape.getBBox().height;
          }

          if (this.get('layout') === 'vertical') {
            textGroup.addShape('text', {
              attrs: Util.mix({
                x: x + this.get('textOffset'),
                y: y,
                text: text === 0 ? '0' : text
              }, textStyle)
            });
          } else {
            y += titleGap + this.get('textOffset') - 20;
            if (!titleShape) y += 10;
            textGroup.addShape('text', {
              attrs: Util.mix({
                x: x,
                y: y,
                text: text === 0 ? '0' : text
              }, textStyle)
            });
          }
        };

        return Size;
      }(Continuous);

      module.exports = Size;
      /***/
    },
    /* 331 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The class of the size legend
       * @author sima.zhang
       * @author ye liu
       */


      var Util = __webpack_require__(3); // const Global = require('../../global');


      var Continuous = __webpack_require__(68);

      var SLIDER_HEIGHT = 2;
      var CIRCLE_GAP = 16;
      var MAX_SIZE = 16;
      var MIN_SIZE = 5;

      var CircleSize = /*#__PURE__*/function (_Continuous) {
        _inheritsLoose(CircleSize, _Continuous);

        function CircleSize() {
          return _Continuous.apply(this, arguments) || this;
        }

        var _proto = CircleSize.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Continuous.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 类型
             * @type {String}
             */
            type: 'size-circle-legend',
            width: 100,
            height: 200,

            /**
             * 不能滑动时圈的样式
             * @type {ATTRS}
             */
            _unslidableCircleStyle: {
              stroke: 'rgb(99, 161, 248)',
              fill: 'rgb(99, 161, 248)',
              fillOpacity: 0.3,
              lineWidth: 1.5
            },

            /**
             * 滑块的样式
             * @type {ATTRS}
             */
            triggerAttr: {
              fill: 'white',
              shadowOffsetX: -2,
              shadowOffsetY: 2,
              shadowBlur: 10,
              shadowColor: '#ccc'
            },

            /**
             * 中间 bar 的前景颜色
             * @type {ATTRS}
             */
            frontMiddleBarStyle: {
              fill: 'rgb(64, 141, 251)'
            }
          });
        } // render the slider shape
        ;

        _proto._renderSliderShape = function _renderSliderShape() {
          var minRadius = MIN_SIZE;
          var slider = this.get('slider');
          var backgroundElement = slider.get('backgroundElement');
          var layout = this.get('layout');
          var width = layout === 'vertical' ? SLIDER_HEIGHT : this.get('width');
          var height = layout === 'vertical' ? this.get('height') : SLIDER_HEIGHT;
          var x = minRadius;
          var y = this.get('height') / 2;
          var frontMiddleBarStyle = this.get('frontMiddleBarStyle'); // background of middle bar

          var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [0, height]] : [[0, y + height], [0, y - height], [x + width - 4, y - height], [x + width - 4, y + height]];
          return this._addMiddleBar(backgroundElement, 'Polygon', Util.mix({
            points: points
          }, frontMiddleBarStyle));
        } // triggers while layout === horizontal
        ;

        _proto._addHorizontalTrigger = function _addHorizontalTrigger(type, blockAttr, textAttr, radius) {
          var slider = this.get('slider');
          var trigger = slider.get(type + 'HandleElement');
          var y = -this.get('height') / 2;
          var button = trigger.addShape('circle', {
            attrs: Util.mix({
              x: 0,
              y: y,
              r: radius
            }, blockAttr)
          });
          var text = trigger.addShape('text', {
            attrs: Util.mix(textAttr, {
              x: 0,
              y: y + radius + 10,
              textAlign: 'center',
              textBaseline: 'middle'
            })
          });
          var layout = this.get('layout');
          var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
          button.attr('cursor', trigerCursor);
          text.attr('cursor', trigerCursor);
          this.set(type + 'ButtonElement', button);
          this.set(type + 'TextElement', text);
        } // triggers while layout === vertical
        ;

        _proto._addVerticalTrigger = function _addVerticalTrigger(type, blockAttr, textAttr, radius) {
          var slider = this.get('slider');
          var trigger = slider.get(type + 'HandleElement');
          var button = trigger.addShape('circle', {
            attrs: Util.mix({
              x: 0,
              y: 0,
              r: radius
            }, blockAttr)
          });
          var text = trigger.addShape('text', {
            attrs: Util.mix(textAttr, {
              x: radius + 10,
              y: 0,
              textAlign: 'start',
              textBaseline: 'middle'
            })
          });
          var layout = this.get('layout');
          var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
          button.attr('cursor', trigerCursor);
          text.attr('cursor', trigerCursor);
          this.set(type + 'ButtonElement', button);
          this.set(type + 'TextElement', text);
        } // render the triggers
        ;

        _proto._renderTrigger = function _renderTrigger() {
          var min = this.get('firstItem');
          var max = this.get('lastItem');
          var layout = this.get('layout');
          var textStyle = this.get('textStyle');
          var triggerAttr = this.get('triggerAttr');
          var minBlockAttr = Util.mix({}, triggerAttr);
          var maxBlockAttr = Util.mix({}, triggerAttr);
          var minRadius = MIN_SIZE;
          var maxRadius = MAX_SIZE;
          var minTextAttr = Util.mix({
            text: this._formatItemValue(min.value) + ''
          }, textStyle);
          var maxTextAttr = Util.mix({
            text: this._formatItemValue(max.value) + ''
          }, textStyle);

          if (layout === 'vertical') {
            this._addVerticalTrigger('min', minBlockAttr, minTextAttr, minRadius);

            this._addVerticalTrigger('max', maxBlockAttr, maxTextAttr, maxRadius);
          } else {
            this._addHorizontalTrigger('min', minBlockAttr, minTextAttr, minRadius);

            this._addHorizontalTrigger('max', maxBlockAttr, maxTextAttr, maxRadius);
          }
        } // user interactions
        ;

        _proto._bindEvents = function _bindEvents() {
          var _this = this;

          if (this.get('slidable')) {
            var slider = this.get('slider');
            slider.on('sliderchange', function (ev) {
              var range = ev.range;

              var firstItemValue = _this.get('firstItem').value;

              var lastItemValue = _this.get('lastItem').value;

              var minValue = firstItemValue + range[0] / 100 * (lastItemValue - firstItemValue);
              var maxValue = firstItemValue + range[1] / 100 * (lastItemValue - firstItemValue);
              var minRadius = MIN_SIZE + range[0] / 100 * (MAX_SIZE - MIN_SIZE);
              var maxRadius = MIN_SIZE + range[1] / 100 * (MAX_SIZE - MIN_SIZE);

              _this._updateElement(minValue, maxValue, minRadius, maxRadius);

              var itemFiltered = new Event('itemfilter', ev, true, true);
              itemFiltered.range = [minValue, maxValue];

              _this.emit('itemfilter', itemFiltered);
            });
          }
        } // update the triggers
        ;

        _proto._updateElement = function _updateElement(min, max, minR, maxR) {
          // update the text of the triggers
          _Continuous.prototype._updateElement.call(this, min, max);

          var minTextElement = this.get('minTextElement');
          var maxTextElement = this.get('maxTextElement');
          var minCircleElement = this.get('minButtonElement');
          var maxCircleElement = this.get('maxButtonElement'); // update the radius of the triggers

          minCircleElement.attr('r', minR);
          maxCircleElement.attr('r', maxR); // update the text position of the triggers

          var layout = this.get('layout');

          if (layout === 'vertical') {
            minTextElement.attr('x', minR + 10);
            maxTextElement.attr('x', maxR + 10);
          } else {
            var y = -this.get('height') / 2;
            minTextElement.attr('y', y + minR + 10);
            maxTextElement.attr('y', y + maxR + 10);
          }
        } // add a circle for slidable === false
        ;

        _proto._addCircle = function _addCircle(x, y, r, text, maxWidth) {
          var group = this.get('group');
          var circleGroup = group.addGroup();
          var circleStyle = this.get('_unslidableCircleStyle');
          var textStyle = this.get('textStyle');
          var titleShape = this.get('titleShape');
          var titleGap = this.get('titleGap');

          if (titleShape) {
            titleGap += titleShape.getBBox().height;
          }

          circleGroup.addShape('circle', {
            attrs: Util.mix({
              x: x,
              y: y + titleGap,
              r: r === 0 ? 1 : r
            }, circleStyle)
          });

          if (this.get('layout') === 'vertical') {
            circleGroup.addShape('text', {
              attrs: Util.mix({
                x: maxWidth + 20 + this.get('textOffset'),
                y: y + titleGap,
                text: text === 0 ? '0' : text
              }, textStyle)
            });
          } else {
            circleGroup.addShape('text', {
              attrs: Util.mix({
                x: x,
                y: y + titleGap + maxWidth + 13 + this.get('textOffset'),
                text: text === 0 ? '0' : text
              }, textStyle)
            });
          }
        } // the circles while slidable === false
        ;

        _proto._renderUnslidable = function _renderUnslidable() {
          var firstItemValue = this.get('firstItem').value;
          var lastItemValue = this.get('lastItem').value;

          if (firstItemValue > lastItemValue) {
            var tmp = lastItemValue;
            lastItemValue = firstItemValue;
            firstItemValue = tmp;
          }

          var minText = this._formatItemValue(firstItemValue);

          var maxText = this._formatItemValue(lastItemValue);

          var minRadius = firstItemValue < MIN_SIZE ? MIN_SIZE : firstItemValue;
          var maxRadius = lastItemValue > MAX_SIZE ? MAX_SIZE : lastItemValue;

          if (minRadius > maxRadius) {
            minRadius = MIN_SIZE;
            maxRadius = MAX_SIZE;
          }

          if (this.get('layout') === 'vertical') {
            this._addCircle(maxRadius, maxRadius, minRadius, minText, 2 * maxRadius); // min


            this._addCircle(maxRadius, maxRadius * 2 + CIRCLE_GAP + minRadius, maxRadius, maxText, 2 * maxRadius); // max

          } else {
            this._addCircle(maxRadius, maxRadius, minRadius, minText, 2 * maxRadius); // min


            this._addCircle(maxRadius * 2 + CIRCLE_GAP + minRadius, maxRadius, maxRadius, maxText, 2 * maxRadius); // max

          }
        };

        _proto.activate = function activate(value) {
          if (!this.get('slidable')) {
            return;
          }

          _Continuous.prototype.activate.call(this, value);
        };

        return CircleSize;
      }(Continuous);

      module.exports = CircleSize;
      /***/
    },
    /* 332 */

    /***/
    function (module, exports, __webpack_require__) {
      var Tooltip = __webpack_require__(69);

      Tooltip.Html = __webpack_require__(333);
      Tooltip.Canvas = __webpack_require__(162);
      Tooltip.Mini = __webpack_require__(335);
      module.exports = Tooltip;
      /***/
    },
    /* 333 */

    /***/
    function (module, exports, __webpack_require__) {
      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var G = __webpack_require__(20);

      var Tooltip = __webpack_require__(69);

      var Util = __webpack_require__(3);

      var DomUtil = Util.DomUtil;

      var TooltipTheme = __webpack_require__(334);

      var Crosshair = __webpack_require__(159);

      var PositionMixin = __webpack_require__(160);

      var MarkerGroupMixin = __webpack_require__(161);

      var CONTAINER_CLASS = 'g2-tooltip';
      var TITLE_CLASS = 'g2-tooltip-title';
      var LIST_CLASS = 'g2-tooltip-list';
      var MARKER_CLASS = 'g2-tooltip-marker';
      var VALUE_CLASS = 'g2-tooltip-value';
      var LIST_ITEM_CLASS = 'g2-tooltip-list-item';
      var MARKER_SIZE = 5;
      var Marker = G.Marker;

      function find(dom, cls) {
        return dom.getElementsByClassName(cls)[0];
      }

      function mergeStyles(styles, cfg) {
        Object.keys(styles).forEach(function (k) {
          if (cfg[k]) {
            styles[k] = Util.mix(styles[k], cfg[k]);
          }
        });
        return styles;
      }

      var HtmlTooltip = /*#__PURE__*/function (_Tooltip) {
        _inheritsLoose(HtmlTooltip, _Tooltip);

        var _proto = HtmlTooltip.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Tooltip.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
               * tooltip 容器模板
               * @type {String}
            */
            containerTpl: ' <div class="' + CONTAINER_CLASS + '"> ' + '<div class="' + TITLE_CLASS + '"></div>' + '<ul class="' + LIST_CLASS + '"></ul>' + '</div>',

            /**
             * tooltip 列表项模板
             * @type {String}
             */
            itemTpl: "<li data-index={index}>\n      <svg viewBox=\"0 0 " + MARKER_SIZE + " " + MARKER_SIZE + "\" class=\"" + MARKER_CLASS + "\"></svg>\n      {name}<span class=\"" + VALUE_CLASS + "\">{value}</span></li>",

            /**
             * tooltip html内容
             * @type {String}
             */
            htmlContent: null,

            /**
             * tooltip 内容跟随鼠标移动
             * @type {Boolean}
             */
            follow: true,

            /**
             * 是否允许鼠标停留在 tooltip 上，默认不允许
             * @type {Boolean}
             */
            enterable: false
          });
        };

        function HtmlTooltip(cfg) {
          var _this;

          _this = _Tooltip.call(this, cfg) || this;
          Util.assign(_assertThisInitialized(_this), PositionMixin);
          Util.assign(_assertThisInitialized(_this), MarkerGroupMixin);
          var style = TooltipTheme;
          _this.style = mergeStyles(style, cfg);

          _this._init_();

          if (_this.get('items')) {
            _this.render();
          } // crosshair


          var crosshair = _this.get('crosshairs');

          if (crosshair) {
            var plot = crosshair.type === 'rect' ? _this.get('backPlot') : _this.get('frontPlot');
            var crosshairGroup = new Crosshair(Util.mix({
              plot: plot,
              plotRange: _this.get('plotRange'),
              canvas: _this.get('canvas')
            }, _this.get('crosshairs')));
            crosshairGroup.hide();

            _this.set('crosshairGroup', crosshairGroup);
          }

          return _this;
        }

        _proto._init_ = function _init_() {
          var self = this;
          var containerTpl = self.get('containerTpl');
          var outterNode = self.get('canvas').get('el').parentNode;
          var container;

          if (!this.get('htmlContent')) {
            if (/^\#/.test(containerTpl)) {
              // 如果传入 dom 节点的 id
              var id = containerTpl.replace('#', '');
              container = document.getElementById(id);
            } else {
              container = DomUtil.createDom(containerTpl);
              DomUtil.modifyCSS(container, self.style[CONTAINER_CLASS]);
              outterNode.appendChild(container);
              outterNode.style.position = 'relative';
            }

            self.set('container', container);
          }
        };

        _proto.render = function render() {
          var self = this;
          self.clear();

          if (self.get('htmlContent')) {
            var outterNode = self.get('canvas').get('el').parentNode;

            var container = self._getHtmlContent();

            outterNode.appendChild(container);
            self.set('container', container);
          } else {
            self._renderTpl();
          }
        };

        _proto._renderTpl = function _renderTpl() {
          var self = this;
          var showTitle = self.get('showTitle');
          var titleContent = self.get('titleContent');
          var container = self.get('container');
          var titleDom = find(container, TITLE_CLASS);
          var listDom = find(container, LIST_CLASS);
          var items = self.get('items');

          if (titleDom && showTitle) {
            DomUtil.modifyCSS(titleDom, self.style[TITLE_CLASS]);
            titleDom.innerHTML = titleContent;
          }

          if (listDom) {
            DomUtil.modifyCSS(listDom, self.style[LIST_CLASS]);
            Util.each(items, function (item, index) {
              listDom.appendChild(self._addItem(item, index));
            });
          }
        };

        _proto.clear = function clear() {
          var container = this.get('container');

          if (this.get('htmlContent')) {
            container && container.remove();
          } else {
            var titleDom = find(container, TITLE_CLASS);
            var listDom = find(container, LIST_CLASS);

            if (titleDom) {
              titleDom.innerHTML = '';
            }

            if (listDom) {
              listDom.innerHTML = '';
            }
          }
        };

        _proto.show = function show() {
          var container = this.get('container');

          if (!container || this.destroyed) {
            // 防止容器不存在或者被销毁时报错
            return;
          }

          container.style.visibility = 'visible';
          container.style.display = 'block';
          var crosshairGroup = this.get('crosshairGroup');
          crosshairGroup && crosshairGroup.show();
          var markerGroup = this.get('markerGroup');
          markerGroup && markerGroup.show();

          _Tooltip.prototype.show.call(this);

          this.get('canvas').draw();
        };

        _proto.hide = function hide() {
          var container = this.get('container'); // relative: https://github.com/antvis/g2/issues/1221

          if (!container || this.destroyed) {
            return;
          }

          container.style.visibility = 'hidden';
          container.style.display = 'none';
          var crosshairGroup = this.get('crosshairGroup');
          crosshairGroup && crosshairGroup.hide();
          var markerGroup = this.get('markerGroup');
          markerGroup && markerGroup.hide();

          _Tooltip.prototype.hide.call(this);

          this.get('canvas').draw();
        };

        _proto.destroy = function destroy() {
          var self = this;
          var container = self.get('container');
          var containerTpl = self.get('containerTpl');

          if (container && !/^\#/.test(containerTpl)) {
            container.parentNode.removeChild(container);
          }

          var crosshairGroup = this.get('crosshairGroup');
          crosshairGroup && crosshairGroup.destroy();
          var markerGroup = this.get('markerGroup');
          markerGroup && markerGroup.remove();

          _Tooltip.prototype.destroy.call(this);
        };

        _proto._getMarkerSvg = function _getMarkerSvg(item) {
          var marker = item.marker || {};
          var symbol = marker.activeSymbol || marker.symbol;
          var method;

          if (Util.isFunction(symbol)) {
            method = symbol;
          } else if (Util.isString(symbol)) {
            method = Marker.Symbols[symbol];
          }

          method = Util.isFunction(method) ? method : Marker.Symbols.circle;
          var pathArr = method(MARKER_SIZE / 2, MARKER_SIZE / 2, MARKER_SIZE / 2);
          var path = pathArr.reduce(function (res, arr) {
            return "" + res + arr[0] + arr.slice(1).join(',');
          }, '');
          return "<path d=\"" + path + "\" fill=\"" + (marker.fill || 'none') + "\" stroke=\"" + (marker.stroke || 'none') + "\" />";
        };

        _proto._addItem = function _addItem(item, index) {
          var itemTpl = this.get('itemTpl'); // TODO: 有可能是个回调函数

          var itemDiv = Util.substitute(itemTpl, Util.mix({
            index: index
          }, item));
          var itemDOM = DomUtil.createDom(itemDiv);
          DomUtil.modifyCSS(itemDOM, this.style[LIST_ITEM_CLASS]);
          var markerDom = find(itemDOM, MARKER_CLASS);

          if (markerDom) {
            DomUtil.modifyCSS(markerDom, _extends({}, this.style[MARKER_CLASS], {
              borderRadius: 'unset'
            }));

            var markerPath = this._getMarkerSvg(item);

            markerDom.innerHTML = markerPath;
          }

          var valueDom = find(itemDOM, VALUE_CLASS);

          if (valueDom) {
            DomUtil.modifyCSS(valueDom, this.style[VALUE_CLASS]);
          }

          return itemDOM;
        };

        _proto._getHtmlContent = function _getHtmlContent() {
          var htmlContent = this.get('htmlContent');
          var title = this.get('titleContent');
          var items = this.get('items');
          var htmlString = htmlContent(title, items);
          var ele = DomUtil.createDom(htmlString);
          return ele;
        };

        _proto.setPosition = function setPosition(x, y, target) {
          var container = this.get('container');
          var outterNode = this.get('canvas').get('el');
          var viewWidth = DomUtil.getWidth(outterNode);
          var viewHeight = DomUtil.getHeight(outterNode);
          var containerWidth = container.clientWidth;
          var containerHeight = container.clientHeight;
          var endx = x;
          var endy = y;
          var position;
          var prePosition = this.get('prePosition') || {
            x: 0,
            y: 0
          }; // @2019-01-30 by blue.lb 由于display:none的元素获取clientWidth和clientHeight的值为0，这里强制显隐一下，其实直接在show和hide中去掉display设置最好，猜测为了更好的兼容浏览器

          if (!containerWidth) {
            container.style.display = 'block';
            containerWidth = container.clientWidth;
            containerHeight = container.clientHeight;
            container.style.display = 'none';
          }

          if (this.get('enterable')) {
            y = y - container.clientHeight / 2;
            position = [x, y];

            if (prePosition && x - prePosition.x > 0) {
              // 留 1px 防止鼠标点击事件无法在画布上触发
              x -= container.clientWidth + 1;
            } else {
              x += 1;
            }
          } else if (this.get('position')) {
            // @2019-01-30 by blue.lb 这里应该是多余代码
            // const containerWidth = container.clientWidth;
            // const containerHeight = container.clientHeight;
            position = this._calcTooltipPosition(x, y, this.get('position'), containerWidth, containerHeight, target);
            x = position[0];
            y = position[1];
          } else {
            position = this._constraintPositionInBoundary(x, y, containerWidth, containerHeight, viewWidth, viewHeight);
            x = position[0];
            y = position[1];
          }

          if (this.get('inPlot')) {
            // tooltip 必须限制在绘图区域内
            var plotRange = this.get('plotRange');
            position = this._constraintPositionInPlot(x, y, containerWidth, containerHeight, plotRange, this.get('enterable'));
            x = position[0];
            y = position[1];
          }

          var markerItems = this.get('markerItems');

          if (!Util.isEmpty(markerItems)) {
            endx = markerItems[0].x;
            endy = markerItems[0].y;
          }

          this.set('prePosition', position); // 记录上次的位置

          var follow = this.get('follow');

          if (follow) {
            container.style.left = x + 'px';
            container.style.top = y + 'px';
          }

          var crosshairGroup = this.get('crosshairGroup');

          if (crosshairGroup) {
            var items = this.get('items');
            crosshairGroup.setPosition(endx, endy, items);
          }

          _Tooltip.prototype.setPosition.call(this, x, y);
        };

        return HtmlTooltip;
      }(Tooltip);

      module.exports = HtmlTooltip;
      /***/
    },
    /* 334 */

    /***/
    function (module, exports, __webpack_require__) {
      var _TooltipTheme;

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY; // tooltip 相关 dom 的 css 类名


      var TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';
      var TOOLTIP_TITLE_CLASS = 'g2-tooltip-title';
      var TOOLTIP_LIST_CLASS = 'g2-tooltip-list';
      var TOOLTIP_LIST_ITEM_CLASS = 'g2-tooltip-list-item';
      var TOOLTIP_MARKER_CLASS = 'g2-tooltip-marker';
      var TOOLTIP_VALUE_CLASS = 'g2-tooltip-value';
      var TooltipTheme = (_TooltipTheme = {
        crosshairs: false,
        offset: 15
      }, _TooltipTheme["" + TOOLTIP_CONTAINER_CLASS] = {
        position: 'absolute',
        visibility: 'hidden',
        // @2018-07-25 by blue.lb 这里去掉浮动，火狐上存在样式错位
        // whiteSpace: 'nowrap',
        zIndex: 8,
        transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
        backgroundColor: 'rgba(255, 255, 255, 0.9)',
        boxShadow: '0px 0px 10px #aeaeae',
        borderRadius: '3px',
        color: 'rgb(87, 87, 87)',
        fontSize: '12px',
        fontFamily: FONT_FAMILY,
        lineHeight: '20px',
        padding: '10px 10px 6px 10px'
      }, _TooltipTheme["" + TOOLTIP_TITLE_CLASS] = {
        marginBottom: '4px'
      }, _TooltipTheme["" + TOOLTIP_LIST_CLASS] = {
        margin: 0,
        listStyleType: 'none',
        padding: 0
      }, _TooltipTheme["" + TOOLTIP_LIST_ITEM_CLASS] = {
        marginBottom: '4px'
      }, _TooltipTheme["" + TOOLTIP_MARKER_CLASS] = {
        width: '5px',
        height: '5px',
        borderRadius: '50%',
        display: 'inline-block',
        marginRight: '8px'
      }, _TooltipTheme["" + TOOLTIP_VALUE_CLASS] = {
        display: 'inline-block',
        "float": 'right',
        marginLeft: '30px'
      }, _TooltipTheme);
      module.exports = TooltipTheme;
      /***/
    },
    /* 335 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(3);

      var CanvasTooltip = __webpack_require__(162);

      var _require = __webpack_require__(14),
          FONT_FAMILY = _require.FONT_FAMILY;

      var DomUtil = Util.DomUtil;
      var MatrixUtil = Util.MatrixUtil;

      var MiniTooltip = /*#__PURE__*/function (_CanvasTooltip) {
        _inheritsLoose(MiniTooltip, _CanvasTooltip);

        function MiniTooltip() {
          return _CanvasTooltip.apply(this, arguments) || this;
        }

        var _proto = MiniTooltip.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _CanvasTooltip.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * 默认背景板样式
             * @type {Object}
             */
            boardStyle: {
              x: 0,
              y: 0,
              width: 0,
              height: 0,
              // fill: 'rgba(50, 50, 50, 1)',
              radius: 3
            },

            /**
             * 默认value样式
             * @type {Object}
             * */
            valueStyle: {
              x: 0,
              y: 0,
              text: '',
              fontFamily: FONT_FAMILY,
              fontSize: 12,
              stroke: '#fff',
              lineWidth: 2,
              fill: 'black',
              textBaseline: 'top',
              textAlign: 'start'
            },

            /**
             * 默认padding值
             * @type {Object}
             */
            padding: {
              top: 5,
              right: 5,
              bottom: 0,
              left: 5
            },
            triangleWidth: 10,
            triangleHeight: 4
          });
        };

        _proto._init_ = function _init_() {
          var self = this;
          var padding = self.get('padding');
          var parent = self.get('frontPlot'); // container

          var container = parent.addGroup();
          self.set('container', container); // board

          var board = container.addShape('rect', {
            attrs: Util.mix({}, self.get('boardStyle'))
          });
          self.set('board', board); // triangleShpe

          var triangleShape = container.addShape('path', {
            attrs: {
              fill: self.get('boardStyle').fill
            }
          });
          self.set('triangleShape', triangleShape); // itemGroup

          var itemGroup = container.addGroup();
          itemGroup.move(padding.left, padding.top); // value

          var valueShape = itemGroup.addShape('text', {
            attrs: Util.mix({}, self.get('valueStyle'))
          });
          self.set('valueShape', valueShape);
        };

        _proto.render = function render() {
          var self = this;
          self.clear();
          var board = self.get('board');
          var valueShape = self.get('valueShape');
          var padding = self.get('padding');
          var item = self.get('items')[0];

          if (valueShape) {
            valueShape.attr('text', item.value);
          } // update board based on bbox


          var bbox = valueShape ? valueShape.getBBox() : {
            width: 80,
            height: 30
          };
          var width = padding.left + bbox.width + padding.right;
          var height = padding.top + bbox.height + padding.bottom;
          board.attr('width', width);
          board.attr('height', height); // update triangle shape

          self._centerTriangleShape();
        };

        _proto.clear = function clear() {
          var valueShape = this.get('valueShape');
          valueShape.attr('text', '');
        };

        _proto.setPosition = function setPosition(x, y, target) {
          var self = this;
          var container = self.get('container');
          var plotRange = self.get('plotRange');
          var bbox = container.getBBox();
          var width = bbox.width;
          var height = bbox.height;
          x -= width / 2;

          if (target && (target.name === 'point' || target.name === 'interval')) {
            var targetY = target.getBBox().y;
            y = targetY;
          }

          y -= height;

          if (this.get('inPlot')) {
            // constrain in plot
            if (x < plotRange.tl.x) {
              x = plotRange.tl.x;

              self._leftTriangleShape();
            } else if (x + width / 2 > plotRange.tr.x) {
              x = plotRange.tr.x - width;

              self._rightTriangleShape();
            } else {
              self._centerTriangleShape();
            }

            if (y < plotRange.tl.y) {
              y = plotRange.tl.y;
            } else if (y + height > plotRange.bl.y) {
              y = plotRange.bl.y - height;
            }
          } else {
            // constrain in dom
            var outterNode = this.get('canvas').get('el');
            var viewWidth = DomUtil.getWidth(outterNode);
            var viewHeight = DomUtil.getHeight(outterNode);

            if (x < 0) {
              x = 0;

              self._leftTriangleShape();
            } else if (x + width / 2 > viewWidth) {
              x = viewWidth - width;

              self._rightTriangleShape();
            } else {
              self._centerTriangleShape();
            }

            if (y < 0) {
              y = 0;
            } else if (y + height > viewHeight) {
              y = viewHeight - height;
            }
          }

          var ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          var mat = MatrixUtil.transform(ulMatrix, [['t', x, y]]);
          container.stopAnimate();
          container.animate({
            matrix: mat
          }, this.get('animationDuration'));
        };

        _proto._centerTriangleShape = function _centerTriangleShape() {
          var triangle = this.get('triangleShape');
          var width = this.get('triangleWidth');
          var height = this.get('triangleHeight');
          var boardBBox = this.get('board').getBBox();
          var boardWidth = boardBBox.width;
          var boardHeight = boardBBox.height;
          var pathArray = [['M', 0, 0], ['L', width, 0], ['L', width / 2, height], ['L', 0, 0], ['Z']];
          triangle.attr('path', pathArray);
          triangle.move(boardWidth / 2 - width / 2, boardHeight - 1);
        };

        _proto._leftTriangleShape = function _leftTriangleShape() {
          var triangle = this.get('triangleShape');
          var width = this.get('triangleWidth');
          var height = this.get('triangleHeight');
          var boardBBox = this.get('board').getBBox();
          var boardHeight = boardBBox.height;
          var pathArray = [['M', 0, 0], ['L', width, 0], ['L', 0, height + 3], ['L', 0, 0], ['Z']];
          triangle.attr('path', pathArray);
          triangle.move(0, boardHeight - 3);
        };

        _proto._rightTriangleShape = function _rightTriangleShape() {
          var triangle = this.get('triangleShape');
          var width = this.get('triangleWidth');
          var height = this.get('triangleHeight');
          var boardBBox = this.get('board').getBBox();
          var boardWidth = boardBBox.width;
          var boardHeight = boardBBox.height;
          var pathArray = [['M', 0, 0], ['L', width, 0], ['L', width, height + 4], ['L', 0, 0], ['Z']];
          triangle.attr('path', pathArray);
          triangle.move(boardWidth - width - 1, boardHeight - 4);
        };

        return MiniTooltip;
      }(CanvasTooltip);

      module.exports = MiniTooltip;
      /***/
    },
    /* 336 */

    /***/
    function (module, exports, __webpack_require__) {
      var MatrixUtil = __webpack_require__(0).MatrixUtil;

      var Vector2 = MatrixUtil.vec2;

      function smoothBezier(points, smooth, isLoop, constraint) {
        var cps = [];
        var prevPoint;
        var nextPoint;
        var hasConstraint = !!constraint;
        var min, max;

        if (hasConstraint) {
          min = [Infinity, Infinity];
          max = [-Infinity, -Infinity];

          for (var i = 0, l = points.length; i < l; i++) {
            var point = points[i];
            min = Vector2.min([], min, point);
            max = Vector2.max([], max, point);
          }

          min = Vector2.min([], min, constraint[0]);
          max = Vector2.max([], max, constraint[1]);
        }

        for (var _i = 0, len = points.length; _i < len; _i++) {
          var _point = points[_i];

          if (isLoop) {
            prevPoint = points[_i ? _i - 1 : len - 1];
            nextPoint = points[(_i + 1) % len];
          } else {
            if (_i === 0 || _i === len - 1) {
              cps.push(_point);
              continue;
            } else {
              prevPoint = points[_i - 1];
              nextPoint = points[_i + 1];
            }
          }

          var v = [];
          v = Vector2.sub(v, nextPoint, prevPoint);
          v = Vector2.scale(v, v, smooth);
          var d0 = Vector2.distance(_point, prevPoint);
          var d1 = Vector2.distance(_point, nextPoint);
          var sum = d0 + d1;

          if (sum !== 0) {
            d0 /= sum;
            d1 /= sum;
          }

          var v1 = Vector2.scale([], v, -d0);
          var v2 = Vector2.scale([], v, d1);
          var cp0 = Vector2.add([], _point, v1);
          var cp1 = Vector2.add([], _point, v2);

          if (hasConstraint) {
            cp0 = Vector2.max([], cp0, min);
            cp0 = Vector2.min([], cp0, max);
            cp1 = Vector2.max([], cp1, min);
            cp1 = Vector2.min([], cp1, max);
          }

          cps.push(cp0);
          cps.push(cp1);
        }

        if (isLoop) {
          cps.push(cps.shift());
        }

        return cps;
      }

      function catmullRom2bezier(crp, z, constraint) {
        var isLoop = !!z;
        var pointList = [];

        for (var i = 0, l = crp.length; i < l; i += 2) {
          pointList.push([crp[i], crp[i + 1]]);
        }

        var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
        var len = pointList.length;
        var d1 = [];
        var cp1;
        var cp2;
        var p;

        for (var _i2 = 0; _i2 < len - 1; _i2++) {
          cp1 = controlPointList[_i2 * 2];
          cp2 = controlPointList[_i2 * 2 + 1];
          p = pointList[_i2 + 1];
          d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
        }

        if (isLoop) {
          cp1 = controlPointList[len];
          cp2 = controlPointList[len + 1];
          p = pointList[0];
          d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
        }

        return d1;
      }

      module.exports = {
        catmullRom2bezier: catmullRom2bezier
      };
      /***/
    },
    /* 337 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      var PolarLabels = __webpack_require__(163);

      var PathUtil = __webpack_require__(23);

      var Global = __webpack_require__(7);

      var MARGIN = 5;

      function getEndPoint(center, angle, r) {
        return {
          x: center.x + r * Math.cos(angle),
          y: center.y + r * Math.sin(angle)
        };
      }

      function antiCollision(labels, lineHeight, plotRange, center, isRight) {
        // adjust y position of labels to avoid overlapping
        var overlapping = true;
        var start = plotRange.start;
        var end = plotRange.end;
        var startY = Math.min(start.y, end.y);
        var totalHeight = Math.abs(start.y - end.y);
        var i;
        var maxY = 0;
        var minY = Number.MIN_VALUE;
        var boxes = labels.map(function (label) {
          if (label.y > maxY) {
            maxY = label.y;
          }

          if (label.y < minY) {
            minY = label.y;
          }

          return {
            size: lineHeight,
            targets: [label.y - startY]
          };
        });
        minY -= startY;

        if (maxY - startY > totalHeight) {
          totalHeight = maxY - startY;
        }

        while (overlapping) {
          /* eslint no-loop-func: 0 */
          boxes.forEach(function (box) {
            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size); // box.pos = Math.max(0, target - box.size / 2);
          }); // detect overlapping and join boxes

          overlapping = false;
          i = boxes.length;

          while (i--) {
            if (i > 0) {
              var previousBox = boxes[i - 1];
              var box = boxes[i];

              if (previousBox.pos + previousBox.size > box.pos) {
                // overlapping
                previousBox.size += box.size;
                previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up

                if (previousBox.pos + previousBox.size > totalHeight) {
                  previousBox.pos = totalHeight - previousBox.size;
                }

                boxes.splice(i, 1); // removing box

                overlapping = true;
              }
            }
          }
        }

        i = 0; // step 4: normalize y and adjust x

        boxes.forEach(function (b) {
          var posInCompositeBox = startY + lineHeight / 2; // middle of the label

          b.targets.forEach(function () {
            labels[i].y = b.pos + posInCompositeBox;
            posInCompositeBox += lineHeight;
            i++;
          });
        }); // (x - cx)^2 + (y - cy)^2 = totalR^2

        labels.forEach(function (label) {
          var rPow2 = label.r * label.r;
          var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);

          if (rPow2 < dyPow2) {
            label.x = center.x;
          } else {
            var dx = Math.sqrt(rPow2 - dyPow2);

            if (!isRight) {
              // left
              label.x = center.x - dx;
            } else {
              // right
              label.x = center.x + dx;
            }
          }
        });
      }

      var PieLabels = function PieLabels(cfg) {
        PieLabels.superclass.constructor.call(this, cfg);
      };

      Util.extend(PieLabels, PolarLabels);
      Util.augment(PieLabels, {
        getDefaultCfg: function getDefaultCfg() {
          return {
            label: Global.thetaLabels
          };
        },
        getDefaultOffset: function getDefaultOffset(point) {
          return point.offset || 0;
        },

        /**
         * @protected
         * to avoid overlapping
         * @param {Array} items labels to be placed
         * @return {Array} items
         */
        adjustItems: function adjustItems(items) {
          var self = this;
          var offset = items[0] ? items[0].offset : 0;

          if (offset > 0) {
            items = self._distribute(items, offset);
          }

          return PieLabels.superclass.adjustItems.call(this, items);
        },

        /**
         * @private
         * distribute labels
         * @param {Array} labels labels
         * @param {Number} offset offset
         * @return {Array} labels
         */
        _distribute: function _distribute(labels, offset) {
          var self = this;
          var coord = self.get('coord');
          var radius = coord.getRadius();
          var lineHeight = self.get('label').labelHeight;
          var center = coord.getCenter();
          var totalR = radius + offset;
          var totalHeight = totalR * 2 + lineHeight * 2;
          var plotRange = {
            start: coord.start,
            end: coord.end
          };
          var geom = self.get('geom');

          if (geom) {
            var view = geom.get('view');
            plotRange = view.getViewRegion();
          } // step 1: separate labels


          var halves = [[], // left
          [] // right
          ];
          labels.forEach(function (label) {
            if (!label) {
              return;
            }

            if (label.textAlign === 'right') {
              // left
              halves[0].push(label);
            } else {
              // right or center will be put on the right side
              halves[1].push(label);
            }
          });
          halves.forEach(function (half, index) {
            // step 2: reduce labels
            var maxLabelsCountForOneSide = parseInt(totalHeight / lineHeight, 10);

            if (half.length > maxLabelsCountForOneSide) {
              half.sort(function (a, b) {
                // sort by percentage DESC
                return b['..percent'] - a['..percent'];
              });
              half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
            } // step 3: distribute position (x and y)


            half.sort(function (a, b) {
              // sort by y ASC
              return a.y - b.y;
            });
            antiCollision(half, lineHeight, plotRange, center, index);
          });
          return halves[0].concat(halves[1]);
        },
        // 连接线
        lineToLabel: function lineToLabel(label) {
          var self = this;
          var coord = self.get('coord');
          var r = coord.getRadius();
          var distance = label.offset;
          var angle = label.orignAngle || label.angle;
          var center = coord.getCenter();
          var start = getEndPoint(center, angle, r + MARGIN / 2);
          var inner = getEndPoint(center, angle, r + distance / 2);

          if (!label.labelLine) {
            label.labelLine = self.get('label').labelLine || {};
          }

          label.labelLine.path = ['M' + start.x, start.y + ' Q' + inner.x, inner.y + ' ' + label.x, label.y].join(',');
        },

        /**
         * @protected
         * get rotation for label
         * @param {Number} angle angle
         * @param {Number} offset offset
         * @return {Number} rotate
         */
        getLabelRotate: function getLabelRotate(angle, offset) {
          var rotate;

          if (offset < 0) {
            rotate = angle * 180 / Math.PI;

            if (rotate > 90) {
              rotate = rotate - 180;
            }

            if (rotate < -90) {
              rotate = rotate + 180;
            }
          }

          return rotate / 180 * Math.PI;
        },

        /**
         * @protected
         * get text align for label
         * @param {Object} point point
         * @return {String} align
         */
        getLabelAlign: function getLabelAlign(point) {
          var self = this;
          var coord = self.get('coord');
          var center = coord.getCenter();
          var align;

          if (point.angle <= Math.PI / 2 && point.x >= center.x) {
            align = 'left';
          } else {
            align = 'right';
          }

          var offset = self.getDefaultOffset(point);

          if (offset <= 0) {
            if (align === 'right') {
              align = 'left';
            } else {
              align = 'right';
            }
          }

          return align;
        },
        getArcPoint: function getArcPoint(point) {
          return point;
        },
        getPointAngle: function getPointAngle(point) {
          var self = this;
          var coord = self.get('coord');
          var startPoint = {
            x: Util.isArray(point.x) ? point.x[0] : point.x,
            y: point.y[0]
          };
          self.transLabelPoint(startPoint); // 转换到画布坐标，如果坐标系发生改变

          var endPoint = {
            x: Util.isArray(point.x) ? point.x[1] : point.x,
            y: point.y[1]
          };
          self.transLabelPoint(endPoint); // 转换到画布坐标，如果坐标系发生改变

          var angle;
          var startAngle = PathUtil.getPointAngle(coord, startPoint);

          if (point.points && point.points[0].y === point.points[1].y) {
            angle = startAngle;
          } else {
            var endAngle = PathUtil.getPointAngle(coord, endPoint);

            if (startAngle >= endAngle) {
              // 100% pie slice
              endAngle = endAngle + Math.PI * 2;
            }

            angle = startAngle + (endAngle - startAngle) / 2;
          }

          return angle;
        },
        getCirclePoint: function getCirclePoint(angle, offset) {
          var self = this;
          var coord = self.get('coord');
          var center = coord.getCenter();
          var r = coord.getRadius() + offset;
          var point = getEndPoint(center, angle, r);
          point.angle = angle;
          point.r = r;
          return point;
        }
      });
      module.exports = PieLabels;
      /***/
    },
    /* 338 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      var GeomLabels = __webpack_require__(66);

      var IntervalLabels = function IntervalLabels(cfg) {
        IntervalLabels.superclass.constructor.call(this, cfg);
      };

      Util.extend(IntervalLabels, GeomLabels);
      Util.augment(IntervalLabels, {
        setLabelPosition: function setLabelPosition(point, originPoint, index, position) {
          if (Util.isFunction(position)) {
            position = position(point.text, originPoint._origin, index);
          }

          var coord = this.get('coord');
          var transposed = coord.isTransposed;
          var point0 = coord.convertPoint(originPoint.points[0]);
          var point1 = coord.convertPoint(originPoint.points[2]);
          var width = (point0.x - point1.x) / 2 * (transposed ? -1 : 1);
          var height = (point0.y - point1.y) / 2 * (transposed ? -1 : 1);

          switch (position) {
            case 'right':
              if (transposed) {
                point.x -= width;
                point.y += height;
                point.textAlign = point.textAlign || 'center';
              } else {
                point.x -= width;
                point.y += height;
                point.textAlign = point.textAlign || 'left';
              }

              break;

            case 'left':
              if (transposed) {
                point.x -= width;
                point.y -= height;
                point.textAlign = point.textAlign || 'center';
              } else {
                point.x += width;
                point.y += height;
                point.textAlign = point.textAlign || 'right';
              }

              break;

            case 'bottom':
              if (transposed) {
                point.x -= width * 2;
                point.textAlign = point.textAlign || 'left';
              } else {
                point.y += height * 2;
                point.textAlign = point.textAlign || 'center';
              }

              break;

            case 'middle':
              if (transposed) {
                point.x -= width;
              } else {
                point.y += height;
              }

              point.textAlign = point.textAlign || 'center';
              break;

            case 'top':
              if (transposed) {
                point.textAlign = point.textAlign || 'left';
              } else {
                point.textAlign = point.textAlign || 'center';
              }

              break;

            default:
              break;
          }
        }
      });
      module.exports = IntervalLabels;
      /***/
    },
    /* 339 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The tooltip handler
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var _require = __webpack_require__(7),
          defaultColor = _require.defaultColor;

      var FIELD_ORIGIN = '_origin';

      function getScaleName(scale) {
        return scale.alias || scale.field;
      }

      var TooltipMixin = {
        _getIntervalSize: function _getIntervalSize(obj) {
          var size = null;
          var type = this.get('type');
          var coord = this.get('coord');

          if (coord.isRect && (type === 'interval' || type === 'schema')) {
            size = this.getSize(obj[FIELD_ORIGIN]); // 如果字段发生了映射，宽度计算就会报错

            var dim = coord.isTransposed ? 'y' : 'x';

            if (Util.isArray(obj[dim])) {
              var width = Math.abs(obj[dim][1] - obj[dim][0]);
              size = size < width ? null : size; // 直方图计算错误
            }
          }

          return size;
        },
        _snapEqual: function _snapEqual(v1, v2, scale) {
          var equals;
          v1 = scale.translate(v1);
          v2 = scale.translate(v2);

          if (scale.isCategory) {
            equals = v1 === v2;
          } else {
            equals = Util.snapEqual(v1, v2);
          }

          return equals;
        },
        _getScaleValueByPoint: function _getScaleValueByPoint(point) {
          var result = 0;
          var coord = this.get('coord');
          var xScale = this.getXScale();
          var invertPoint = coord.invert(point);
          var xValue = invertPoint.x;

          if (this.isInCircle() && xValue > (1 + xScale.rangeMax()) / 2) {
            xValue = xScale.rangeMin(); // 极坐标下，scale 的 range 被做过特殊处理 see view.js#L88
          }

          result = xScale.invert(xValue);

          if (xScale.isCategory) {
            result = xScale.translate(result); // 防止分类类型
          }

          return result;
        },
        _getOriginByPoint: function _getOriginByPoint(point) {
          var xScale = this.getXScale();
          var yScale = this.getYScale();
          var xField = xScale.field;
          var yField = yScale.field;
          var coord = this.get('coord');
          var invertPoint = coord.invert(point);
          var xValue = xScale.invert(invertPoint.x);
          var yValue = yScale.invert(invertPoint.y);
          var result = {};
          result[xField] = xValue;
          result[yField] = yValue;
          return result;
        },
        _getScale: function _getScale(field) {
          var self = this;
          var scales = self.get('scales');
          var rst = null;
          Util.each(scales, function (scale) {
            if (scale.field === field) {
              rst = scale;
              return false;
            }
          });
          return rst;
        },
        // 获取值对应的度量
        _getTipValueScale: function _getTipValueScale() {
          var attrs = this.getAttrsForLegend();
          var scale;
          Util.each(attrs, function (attr) {
            var tmpScale = attr.getScale(attr.type);

            if (tmpScale.isLinear) {
              // 如果指定字段是非position的，同时是连续的
              scale = tmpScale;
              return false;
            }
          });
          var xScale = this.getXScale();
          var yScale = this.getYScale();

          if (!scale && yScale && yScale.field === '..y') {
            return xScale;
          }

          return scale || yScale || xScale;
        },
        _getTipTitleScale: function _getTipTitleScale(titleField) {
          var self = this;

          if (titleField) {
            return self._getScale(titleField);
          }

          var position = self.getAttr('position');
          var fields = position.getFields();
          var tmpField;
          Util.each(fields, function (field) {
            if (!field.includes('..')) {
              tmpField = field;
              return false;
            }
          });
          return self._getScale(tmpField);
        },
        _filterValue: function _filterValue(arr, point) {
          var coord = this.get('coord');
          var yScale = this.getYScale();
          var yField = yScale.field;
          var invertPoint = coord.invert(point);
          var yValue = invertPoint.y;
          yValue = yScale.invert(yValue);
          var rst = arr[arr.length - 1];
          Util.each(arr, function (obj) {
            var origin = obj[FIELD_ORIGIN];

            if (origin[yField][0] <= yValue && origin[yField][1] >= yValue) {
              rst = obj;
              return false;
            }
          });
          return rst;
        },
        getXDistance: function getXDistance() {
          var self = this;
          var distance = self.get('xDistance');

          if (!distance) {
            var xScale = self.getXScale();

            if (xScale.isCategory) {
              distance = 1;
            } else {
              var values = xScale.values; // values 是无序的

              var min = xScale.translate(values[0]);
              var max = min;
              Util.each(values, function (value) {
                // 时间类型需要 translate
                value = xScale.translate(value);

                if (value < min) {
                  min = value;
                }

                if (value > max) {
                  max = value;
                }
              });
              var length = values.length; // 应该是除以 length - 1

              distance = (max - min) / (length - 1);
            }

            self.set('xDistance', distance);
          }

          return distance;
        },
        findPoint: function findPoint(point, dataArray) {
          var self = this;
          var type = self.get('type');
          var xScale = self.getXScale();
          var yScale = self.getYScale();
          var xField = xScale.field;
          var yField = yScale.field;
          var rst = null;

          if (Util.indexOf(['heatmap', 'point'], type) > -1) {
            var coord = self.get('coord');
            var invertPoint = coord.invert(point);
            var xValue = xScale.invert(invertPoint.x);
            var yValue = yScale.invert(invertPoint.y);
            var min = Infinity;
            Util.each(dataArray, function (obj) {
              var distance = Math.pow(obj[FIELD_ORIGIN][xField] - xValue, 2) + Math.pow(obj[FIELD_ORIGIN][yField] - yValue, 2);

              if (distance < min) {
                min = distance;
                rst = obj;
              }
            });
            return rst;
          }

          var first = dataArray[0];
          var last = dataArray[dataArray.length - 1];

          if (!first) {
            return rst;
          }

          var value = self._getScaleValueByPoint(point); // 根据该点获得对应度量后数据的值


          var firstXValue = first[FIELD_ORIGIN][xField];
          var firstYValue = first[FIELD_ORIGIN][yField];
          var lastXValue = last[FIELD_ORIGIN][xField];
          var isYRange = yScale.isLinear && Util.isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况
          // 如果x的值是数组

          if (Util.isArray(firstXValue)) {
            Util.each(dataArray, function (record) {
              var origin = record[FIELD_ORIGIN];

              if (xScale.translate(origin[xField][0]) <= value && xScale.translate(origin[xField][1]) >= value) {
                if (isYRange) {
                  if (!Util.isArray(rst)) {
                    rst = [];
                  }

                  rst.push(record);
                } else {
                  rst = record;
                  return false;
                }
              }
            });

            if (Util.isArray(rst)) {
              rst = this._filterValue(rst, point);
            }
          } else {
            var next;

            if (!xScale.isLinear && xScale.type !== 'timeCat') {
              Util.each(dataArray, function (record, index) {
                var origin = record[FIELD_ORIGIN];

                if (self._snapEqual(origin[xField], value, xScale)) {
                  if (isYRange) {
                    if (!Util.isArray(rst)) {
                      rst = [];
                    }

                    rst.push(record);
                  } else {
                    rst = record;
                    return false;
                  }
                } else if (xScale.translate(origin[xField]) <= value) {
                  last = record;
                  next = dataArray[index + 1];
                }
              });

              if (Util.isArray(rst)) {
                rst = this._filterValue(rst, point);
              }
            } else {
              if ((value > xScale.translate(lastXValue) || value < xScale.translate(firstXValue)) && (value > xScale.max || value < xScale.min)) {
                return null;
              }

              var firstIdx = 0;
              var lastIdx = dataArray.length - 1;
              var middleIdx;

              while (firstIdx <= lastIdx) {
                middleIdx = Math.floor((firstIdx + lastIdx) / 2);
                var item = dataArray[middleIdx][FIELD_ORIGIN][xField];

                if (self._snapEqual(item, value, xScale)) {
                  return dataArray[middleIdx];
                }

                if (xScale.translate(item) <= xScale.translate(value)) {
                  firstIdx = middleIdx + 1;
                  last = dataArray[middleIdx];
                  next = dataArray[middleIdx + 1];
                } else {
                  if (lastIdx === 0) {
                    last = dataArray[0];
                  }

                  lastIdx = middleIdx - 1;
                }
              }
            }

            if (last && next) {
              // 计算最逼近的
              if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - value) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - value)) {
                last = next;
              }
            }
          }

          var distance = self.getXDistance(); // 每个分类间的平均间距

          if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - value) <= distance / 2) {
            rst = last;
          }

          return rst;
        },

        /**
         * @protected
         * 获取tooltip的标题
         * @param  {Object} origin 点的原始信息
         * @param  {String} titleField 标题的字段
         * @return {String} 提示信息的标题
         */
        getTipTitle: function getTipTitle(origin, titleField) {
          var tipTitle = '';

          var titleScale = this._getTipTitleScale(titleField);

          if (titleScale) {
            var value = origin[titleScale.field];
            tipTitle = titleScale.getText(value);
          } else if (this.get('type') === 'heatmap') {
            // 热力图在不存在 title 的时候特殊处理
            var xScale = this.getXScale();
            var yScale = this.getYScale();
            var xValue = xScale.getText(origin[xScale.field]);
            var yValue = yScale.getText(origin[yScale.field]);
            tipTitle = '( ' + xValue + ', ' + yValue + ' )';
          }

          return tipTitle;
        },
        getTipValue: function getTipValue(origin, valueScale) {
          var value;
          var field = valueScale.field;
          var key = origin.key;
          value = origin[field];

          if (Util.isArray(value)) {
            var tmp = [];
            Util.each(value, function (sub) {
              tmp.push(valueScale.getText(sub));
            });
            value = tmp.join('-');
          } else {
            value = valueScale.getText(value, key);
          }

          return value;
        },

        /**
         * @protected
         * 获取tooltip的名称
         * @param  {Object} origin 点的原始信息
         * @return {String} 提示信息的名称
         */
        getTipName: function getTipName(origin) {
          var name;
          var nameScale;

          var groupScales = this._getGroupScales();

          if (groupScales.length) {
            // 如果存在分组类型，取第一个分组类型
            Util.each(groupScales, function (scale) {
              nameScale = scale;
              return false;
            });
          }

          if (nameScale) {
            var field = nameScale.field;
            name = nameScale.getText(origin[field]);
          } else {
            var valueScale = this._getTipValueScale();

            name = getScaleName(valueScale);
          }

          return name;
        },

        /**
         * 获取点对应tooltip的信息
         * @protected
         * @param  {Object} point 原始的数据记录
         * @param  {String} titleField tooltipTitle 配置信息
         * @return {Array}  一条或者多条记录
         */
        getTipItems: function getTipItems(point, titleField) {
          var self = this;
          var origin = point[FIELD_ORIGIN];
          var tipTitle = self.getTipTitle(origin, titleField);
          var tooltipCfg = self.get('tooltipCfg');
          var items = [];
          var name;
          var value;

          function addItem(itemName, itemValue, cfg) {
            if (!Util.isNil(itemValue) && itemValue !== '') {
              // 值为null的时候，忽视
              var item = {
                title: tipTitle,
                point: point,
                name: itemName || tipTitle,
                value: itemValue,
                color: point.color || defaultColor,
                marker: true
              };
              item.size = self._getIntervalSize(point);
              items.push(Util.mix({}, item, cfg));
            }
          }

          if (tooltipCfg) {
            var fields = tooltipCfg.fields;
            var cfg = tooltipCfg.cfg;
            var callbackParams = [];
            Util.each(fields, function (field) {
              callbackParams.push(origin[field]);
            });

            if (cfg) {
              // 存在回调函数
              if (Util.isFunction(cfg)) {
                cfg = cfg.apply(null, callbackParams);
              }

              var itemCfg = Util.mix({}, {
                point: point,
                title: tipTitle,
                color: point.color || defaultColor,
                marker: true // 默认展示 marker

              }, cfg);
              itemCfg.size = self._getIntervalSize(point);
              items.push(itemCfg);
            } else {
              Util.each(fields, function (field) {
                if (!Util.isNil(origin[field])) {
                  // 字段数据为null ,undefined时不显示
                  var scale = self._getScale(field);

                  name = getScaleName(scale);
                  value = scale.getText(origin[field]);
                  addItem(name, value);
                }
              });
            }
          } else {
            var valueScale = self._getTipValueScale();

            if (!Util.isNil(origin[valueScale.field])) {
              // 字段数据为null ,undefined时不显示
              value = self.getTipValue(origin, valueScale);
              name = self.getTipName(origin);
              addItem(name, value);
            }
          }

          return items;
        },
        isShareTooltip: function isShareTooltip() {
          var shareTooltip = this.get('shareTooltip');
          var type = this.get('type');
          var view = this.get('view');
          var options;

          if (view.get('parent')) {
            options = view.get('parent').get('options');
          } else {
            options = view.get('options');
          }

          if (type === 'interval') {
            var coord = this.get('coord');
            var coordType = coord.type;

            if (coordType === 'theta' || coordType === 'polar' && coord.isTransposed) {
              shareTooltip = false;
            }
          } else if (!this.getYScale() || Util.inArray(['contour', 'point', 'polygon', 'edge'], type)) {
            shareTooltip = false;
          }

          if (options.tooltip && Util.isBoolean(options.tooltip.shared)) {
            // 以用户设置的为准
            shareTooltip = options.tooltip.shared;
          }

          return shareTooltip;
        }
      };
      module.exports = TooltipMixin;
      /***/
    },
    /* 340 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview the interaction when geom was actived
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var FIELD_ORIGIN = '_origin';

      var ZIndexUtil = __webpack_require__(164);

      var ATTRS_ORIGIN_ACTIVE = '_originActiveAttrs';

      function isSameShape(shape1, shape2) {
        if (Util.isNil(shape1) || Util.isNil(shape2)) {
          return false;
        }

        var shape1Origin = shape1.get('origin');
        var shape2Origin = shape2.get('origin');
        return Util.isEqual(shape1Origin, shape2Origin);
      }

      function isChange(preShapes, shapes) {
        if (!preShapes) {
          return true;
        }

        if (preShapes.length !== shapes.length) {
          return true;
        }

        var rst = false;
        Util.each(shapes, function (shape, index) {
          if (!isSameShape(shape, preShapes[index])) {
            rst = true;
            return false;
          }
        });
        return rst;
      }

      function getOriginAttrs(activeCfg, shape) {
        var originAttrs = {};
        Util.each(activeCfg, function (v, k) {
          var originValue = shape.attr(k);

          if (Util.isArray(originValue)) {
            originValue = Util.cloneDeep(originValue); // 缓存原来的属性，由于 .attr('matrix') 是数组，所以此处需要深度复制
          }

          originAttrs[k] = originValue;
        });
        return originAttrs;
      }

      var ActiveMixin = {
        _isAllowActive: function _isAllowActive() {
          var allowActive = this.get('allowActive');

          if (Util.isNil(allowActive)) {
            // 用户未设置，使用默认的策略
            var view = this.get('view');
            var isShareTooltip = this.isShareTooltip();
            var options = view.get('options'); // 默认情况下，tooltip 关闭或者 tooltip 模式为 shared === false 的时候允许 active

            if (options.tooltip === false || !isShareTooltip) {
              return true;
            }
          } else {
            return allowActive;
          }

          return false;
        },
        _onMouseenter: function _onMouseenter(ev) {
          var self = this;
          var shape = ev.shape;
          var shapeContainer = self.get('shapeContainer');

          if (shape && shapeContainer.contain(shape) && self._isAllowActive()) {
            // shape.get('animating')
            self.setShapesActived(shape);
          }
        },
        _onMouseleave: function _onMouseleave() {
          var self = this;
          var view = self.get('view');
          var canvas = view.get('canvas');

          if (self.get('activeShapes')) {
            self.clearActivedShapes();
            canvas.draw();
          }
        },
        _bindActiveAction: function _bindActiveAction() {
          var self = this;
          var view = self.get('view');
          var type = self.get('type');
          view.on(type + ':mouseenter', Util.wrapBehavior(self, '_onMouseenter'));
          view.on(type + ':mouseleave', Util.wrapBehavior(self, '_onMouseleave'));
        },
        _offActiveAction: function _offActiveAction() {
          var self = this;
          var view = self.get('view');
          var type = self.get('type');
          view.off(type + ':mouseenter', Util.getWrapBehavior(self, '_onMouseenter'));
          view.off(type + ':mouseleave', Util.getWrapBehavior(self, '_onMouseleave'));
        },
        _setActiveShape: function _setActiveShape(shape) {
          var self = this;
          var activedOptions = self.get('activedOptions') || {};
          var shapeData = shape.get('origin');
          var shapeName = shapeData.shape || self.getDefaultValue('shape');

          if (Util.isArray(shapeName)) {
            shapeName = shapeName[0];
          }

          var shapeFactory = self.get('shapeFactory');
          var shapeCfg = Util.mix({}, shape.attr(), {
            origin: shapeData
          });
          var activeCfg = shapeFactory.getActiveCfg(shapeName, shapeCfg);

          if (activedOptions.style) {
            Util.mix(activeCfg, activedOptions.style);
          }

          var originAttrs = getOriginAttrs(activeCfg, shape);
          shape.setSilent(ATTRS_ORIGIN_ACTIVE, originAttrs);

          if (activedOptions.animate) {
            shape.animate(activeCfg, 300);
          } else {
            shape.attr(activeCfg);
          }

          ZIndexUtil.toFront(shape); // 提前
        },
        setShapesActived: function setShapesActived(shapes) {
          var self = this;

          if (!Util.isArray(shapes)) {
            shapes = [shapes];
          }

          var preShapes = self.get('activeShapes'); // 获取上次被激活的 shapes

          if (!isChange(preShapes, shapes)) {
            return;
          }

          var view = self.get('view');
          var canvas = view.get('canvas');
          var activedOptions = self.get('activedOptions');

          if (activedOptions && activedOptions.highlight) {
            // 上次的动画未完成，所以要停止掉动画
            Util.each(shapes, function (shape) {
              if (shape.get('animating')) {
                shape.stopAnimate();
              }
            });
            self.highlightShapes(shapes);
          } else {
            if (preShapes) {
              self.clearActivedShapes(); // 先清除激活元素
            }

            Util.each(shapes, function (shape) {
              if (shape.get('animating')) {
                shape.stopAnimate();
              }

              if (shape.get('visible')) {
                // && !shape.get('selected')
                self._setActiveShape(shape);
              }
            });
          }

          self.set('activeShapes', shapes); // shapeContainer.sort(); // toFront, resetZIndex 不需要再排序

          canvas.draw();
        },
        clearActivedShapes: function clearActivedShapes() {
          var self = this;
          var shapeContainer = self.get('shapeContainer');
          var activedOptions = self.get('activedOptions');
          var activeAnimate = activedOptions && activedOptions.animate;

          if (shapeContainer && !shapeContainer.get('destroyed')) {
            var activeShapes = self.get('activeShapes');
            Util.each(activeShapes, function (activeShape) {
              // if (!activeShape.get('selected')) {
              var originAttrs = activeShape.get(ATTRS_ORIGIN_ACTIVE);

              if (activeAnimate) {
                activeShape.stopAnimate();
                activeShape.animate(originAttrs, 300);
              } else {
                activeShape.attr(originAttrs);
              }

              ZIndexUtil.resetZIndex(activeShape);
              activeShape.setSilent(ATTRS_ORIGIN_ACTIVE, null); // }
            });
            var preHighlightShapes = self.get('preHighlightShapes');

            if (preHighlightShapes) {
              var shapes = shapeContainer.get('children');
              Util.each(shapes, function (shape) {
                // if (!shape.get('selected')) {
                var originAttrs = shape.get(ATTRS_ORIGIN_ACTIVE);

                if (originAttrs) {
                  if (activeAnimate) {
                    shape.stopAnimate();
                    shape.animate(originAttrs, 300);
                  } else {
                    shape.attr(originAttrs);
                  }

                  ZIndexUtil.resetZIndex(shape);
                  shape.setSilent(ATTRS_ORIGIN_ACTIVE, null);
                } // }

              });
            } // 恢复原来排序
            // const children = shapeContainer.get('children');
            // children.sort((obj1, obj2) => {
            //   return obj1._INDEX - obj2._INDEX;
            // });


            self.set('activeShapes', null);
            self.set('preHighlightShapes', null);
          }
        },
        getGroupShapesByPoint: function getGroupShapesByPoint(point) {
          var self = this;
          var shapeContainer = self.get('shapeContainer');
          var activeShapes = [];

          if (shapeContainer) {
            var xField = self.getXScale().field;
            var shapes = self.getShapes();

            var originObj = self._getOriginByPoint(point);

            Util.each(shapes, function (shape) {
              var origin = shape.get('origin');

              if (shape.get('visible') && origin) {
                // 有可能不是图形，而是label文本，所以判断一下
                var shapeXValue = origin[FIELD_ORIGIN][xField];

                if (shapeXValue === originObj[xField]) {
                  activeShapes.push(shape);
                }
              }
            });
          }

          return activeShapes;
        },
        getSingleShapeByPoint: function getSingleShapeByPoint(point) {
          var self = this;
          var shapeContainer = self.get('shapeContainer');
          var canvas = shapeContainer.get('canvas');
          var pixelRatio = canvas.get('pixelRatio');
          var result;

          if (shapeContainer) {
            result = shapeContainer.getShape(point.x * pixelRatio, point.y * pixelRatio);
          }

          if (result && result.get('origin')) {
            return result;
          }
        },
        highlightShapes: function highlightShapes(_highlightShapes, highlightCfg) {
          var self = this;

          if (!Util.isArray(_highlightShapes)) {
            _highlightShapes = [_highlightShapes];
          }

          var preHighlightShapes = self.get('activeShapes'); // 获取上次被激活的 shapes

          if (!isChange(preHighlightShapes, _highlightShapes)) {
            return;
          }

          if (preHighlightShapes) {
            self.clearActivedShapes();
          }

          var shapes = self.getShapes();
          var activedOptions = self.get('activedOptions');
          var activeAnimate = activedOptions && activedOptions.animate;
          var activeStyle = activedOptions && activedOptions.style;
          Util.each(shapes, function (shape) {
            var changeAttrs = {};
            shape.stopAnimate();

            if (Util.indexOf(_highlightShapes, shape) !== -1) {
              Util.mix(changeAttrs, activeStyle, highlightCfg); // shape.setZIndex(1); // 提前

              ZIndexUtil.toFront(shape);
            } else {
              Util.mix(changeAttrs, {
                fillOpacity: 0.3,
                // @2018-07-11 by blue.lb 由于线图只有stoke，fillOpacity不生效，最好还是直接改成整个图形透明度opacity
                opacity: 0.3
              });
              ZIndexUtil.resetZIndex(shape);
            }

            var originAttrs = getOriginAttrs(changeAttrs, shape);
            shape.setSilent(ATTRS_ORIGIN_ACTIVE, originAttrs);

            if (activeAnimate) {
              shape.animate(changeAttrs, 300);
            } else {
              shape.attr(changeAttrs);
            }
          });
          self.set('preHighlightShapes', _highlightShapes);
          self.set('activeShapes', _highlightShapes);
        }
      };
      module.exports = ActiveMixin;
      /***/
    },
    /* 341 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview the interaction when geom was selected
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var FIELD_ORIGIN = '_origin';

      var ZIndexUtil = __webpack_require__(164);

      function isSameShape(shape1, shape2) {
        if (Util.isNil(shape1) || Util.isNil(shape2)) {
          return false;
        }

        var shape1Origin = shape1.get('origin');
        var shape2Origin = shape2.get('origin');
        return Util.isEqual(shape1Origin, shape2Origin);
      }

      function getOriginAttrs(selectedCfg, shape) {
        var originAttrs = {};
        Util.each(selectedCfg, function (v, k) {
          if (k === 'transform') {
            k = 'matrix';
          }

          var originValue = shape.attr(k);

          if (Util.isArray(originValue)) {
            originValue = Util.cloneDeep(originValue); // 缓存原来的属性，由于 .attr('matrix') 是数组，所以此处需要深度复制
          }

          originAttrs[k] = originValue;
        });
        return originAttrs;
      }

      var SelectMixin = {
        _isAllowSelect: function _isAllowSelect() {
          var isAllowSelect = this.get('allowSelect');

          if (Util.isNil(isAllowSelect)) {
            var type = this.get('type');
            var coord = this.get('coord');
            var coordType = coord && coord.type;

            if (type === 'interval' && coordType === 'theta') {
              // 饼图默认可以进行选中
              return true;
            }
          } else {
            // 用户设置了 select 配置
            return isAllowSelect;
          }

          return false;
        },
        _onClick: function _onClick(ev) {
          var self = this;

          if (self._isAllowSelect()) {
            // 允许选中下才执行
            // self.clearActivedShapes(); // 不需要清除hover效果
            var shape = ev.shape;
            var shapeContainer = self.get('shapeContainer');

            if (shape && shapeContainer.contain(shape)) {
              // 去除 !shape.get('animating') 的判定，点击反馈更加及时
              self.setShapeSelected(shape);
            }
          }
        },
        _bindSelectedAction: function _bindSelectedAction() {
          var self = this;
          var view = self.get('view');
          var type = self.get('type');
          view.on(type + ':click', Util.wrapBehavior(self, '_onClick'));
        },
        _offSelectedAction: function _offSelectedAction() {
          var self = this;
          var view = self.get('view');
          var type = self.get('type');
          view.off(type + ':click', Util.getWrapBehavior(self, '_onClick'));
        },
        _setShapeStatus: function _setShapeStatus(shape, status) {
          var self = this;
          var view = self.get('view');
          var selectedOptions = self.get('selectedOptions') || {};
          var animate = selectedOptions.animate !== false; // 默认允许动画

          var canvas = view.get('canvas');
          shape.set('selected', status);
          var shapeData = shape.get('origin');

          if (status) {
            // 选中状态
            var shapeName = shapeData.shape || self.getDefaultValue('shape');

            if (Util.isArray(shapeName)) {
              shapeName = shapeName[0];
            }

            var shapeFactory = self.get('shapeFactory');
            var cfg = Util.mix({
              geom: self,
              point: shapeData
            }, selectedOptions);
            var selectedStyle = shapeFactory.getSelectedCfg(shapeName, cfg);
            Util.mix(selectedStyle, cfg.style); // 用户设置的优先级更高

            if (!shape.get('_originAttrs')) {
              // 缓存原有属性
              if (shape.get('animating')) {
                // 停止动画
                shape.stopAnimate();
              }

              shape.set('_originAttrs', getOriginAttrs(selectedStyle, shape));
            } // 选中时图形要到最上面


            if (selectedOptions.toFront) {
              ZIndexUtil.toFront(shape);
            }

            if (animate) {
              shape.animate(selectedStyle, 300);
            } else {
              shape.attr(selectedStyle);
              canvas.draw();
            }
          } else {
            var originAttrs = shape.get('_originAttrs'); // 取消选中时，要恢复到原先的位置

            if (selectedOptions.toFront) {
              ZIndexUtil.resetZIndex(shape);
            }

            shape.set('_originAttrs', null);

            if (animate) {
              shape.animate(originAttrs, 300);
            } else {
              shape.attr(originAttrs);
              canvas.draw();
            }
          }
        },
        setShapeSelected: function setShapeSelected(shape) {
          var self = this;

          var selectedShapes = self._getSelectedShapes();

          var selectedOptions = self.get('selectedOptions') || {};
          var cancelable = selectedOptions.cancelable !== false; // 选中状态是否允许取消，默认允许

          if (selectedOptions.mode === 'multiple') {
            // 支持多选
            if (Util.indexOf(selectedShapes, shape) === -1) {
              selectedShapes.push(shape);

              self._setShapeStatus(shape, true);
            } else if (cancelable) {
              // 图形已经被选中并且选中状态允许取消选中
              Util.Array.remove(selectedShapes, shape);

              self._setShapeStatus(shape, false);
            }
          } else {
            var selectedShape = selectedShapes[0];

            if (cancelable) {
              // 如果允许取消，则选中null
              shape = isSameShape(selectedShape, shape) ? null : shape;
            }

            if (!isSameShape(selectedShape, shape)) {
              if (selectedShape) {
                self._setShapeStatus(selectedShape, false);
              }

              if (shape) {
                self._setShapeStatus(shape, true);
              }
            }
          }
        },
        clearSelected: function clearSelected() {
          var self = this;
          var shapeContainer = self.get('shapeContainer');

          if (shapeContainer && !shapeContainer.get('destroyed')) {
            var selectedShapes = self._getSelectedShapes();

            Util.each(selectedShapes, function (shape) {
              self._setShapeStatus(shape, false);

              shape.set('_originAttrs', null);
            });
          }
        },

        /**
         * 设置记录对应的图形选中
         * @param {Object} record 选中的记录
         * @chainable
         * @return {Geom} 返回当前的 Geometry
         */
        setSelected: function setSelected(record) {
          var self = this;
          var shapes = self.getShapes();
          Util.each(shapes, function (shape) {
            var origin = shape.get('origin');

            if (origin && origin[FIELD_ORIGIN] === record) {
              self.setShapeSelected(shape);
            }
          });
          return this;
        },
        _getSelectedShapes: function _getSelectedShapes() {
          var self = this;
          var shapes = self.getShapes();
          var selectedShapes = [];
          Util.each(shapes, function (shape) {
            if (shape.get('selected')) {
              selectedShapes.push(shape);
            }
          });
          self.set('selectedShapes', selectedShapes);
          return selectedShapes;
        }
      };
      module.exports = SelectMixin;
      /***/
    },
    /* 342 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      module.exports = function (field) {
        if (Util.isArray(field)) {
          return field;
        }

        if (Util.isString(field)) {
          return field.split('*');
        }

        return [field];
      };
      /***/

    },
    /* 343 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 度量的控制器
       * @author dxq613@gmail.com
       */
      var Scale = __webpack_require__(74);

      var Util = __webpack_require__(0);

      var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
      var TYPES = {
        LINEAR: 'linear',
        CAT: 'cat',
        TIME: 'time'
      };

      var ScaleController = /*#__PURE__*/function () {
        function ScaleController(cfg) {
          // defs 列定义
          this.defs = {};
          this.viewTheme = {
            scales: {}
          }; // filtered fields

          this.filters = {};
          Util.assign(this, cfg);
        }

        var _proto = ScaleController.prototype;

        _proto._getDef = function _getDef(field) {
          var defs = this.defs;
          var viewTheme = this.viewTheme;
          var def = null;

          if (viewTheme.scales[field] || defs[field]) {
            def = Util.mix({}, viewTheme.scales[field]); // 处理覆盖属性的问题

            Util.each(defs[field], function (v, k) {
              if (Util.isNil(v)) {
                delete def[k];
              } else {
                def[k] = v;
              }
            });

            if (this.filters[field]) {
              delete def.min;
              delete def.max;
            }
          }

          return def;
        };

        _proto._getDefaultType = function _getDefaultType(field, data) {
          var type = TYPES.LINEAR;
          var value = Util.Array.firstValue(data, field);

          if (Util.isArray(value)) {
            value = value[0];
          }

          if (dateRegex.test(value)) {
            type = TYPES.TIME;
          } else if (Util.isString(value)) {
            type = TYPES.CAT;
          }

          return type;
        };

        _proto._getScaleCfg = function _getScaleCfg(type, field, data) {
          var cfg = {
            field: field
          };
          var values = Util.Array.values(data, field);
          cfg.values = values;

          if (!Scale.isCategory(type) && type !== 'time') {
            var range = Util.Array.getRange(values);
            cfg.min = range.min;
            cfg.max = range.max;
            cfg.nice = true;
          }

          if (type === 'time') {
            cfg.nice = false;
          }

          return cfg;
        };

        _proto.createScale = function createScale(field, data) {
          var self = this;

          var def = self._getDef(field);

          var scale;
          var validData = data || [];
          var firstValue = Util.Array.firstValue(validData, field);

          if (Util.isNumber(field) || Util.isNil(firstValue) && !def) {
            scale = Scale.identity({
              value: field,
              field: field.toString(),
              values: [field]
            });
          } else {
            // 如果已经定义过这个度量
            var type;

            if (def) {
              type = def.type;
            }

            type = type || self._getDefaultType(field, validData);

            var cfg = self._getScaleCfg(type, field, validData);

            if (def) {
              Util.mix(cfg, def);
            }

            scale = Scale[type](cfg);
          }

          return scale;
        };

        return ScaleController;
      }();

      module.exports = ScaleController;
      /***/
    },
    /* 344 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The controller of coordinate
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var Coord = __webpack_require__(345);

      var CoordController = /*#__PURE__*/function () {
        function CoordController(option) {
          this.type = 'rect';
          this.actions = [];
          this.cfg = {};
          Util.mix(this, option);
          this.option = option || {};
        }

        var _proto = CoordController.prototype;

        _proto.reset = function reset(coordOption) {
          this.actions = coordOption.actions || [];
          this.type = coordOption.type;
          this.cfg = coordOption.cfg;
          this.option.actions = this.actions;
          this.option.type = this.type;
          this.option.cfg = this.cfg;
          return this;
        };

        _proto._execActions = function _execActions(coord) {
          var actions = this.actions;
          Util.each(actions, function (action) {
            var m = action[0];
            coord[m](action[1], action[2]);
          });
        };

        _proto.hasAction = function hasAction(actionName) {
          var actions = this.actions;
          var rst = false;
          Util.each(actions, function (action) {
            if (actionName === action[0]) {
              rst = true;
              return false;
            }
          });
          return rst;
        }
        /**
         * 创建坐标系对象
         * @param  {Object} start 坐标系起始点
         * @param  {Object} end   坐标系结束点
         * @return {Function} 坐标系的构造函数
         */
        ;

        _proto.createCoord = function createCoord(start, end) {
          var self = this;
          var type = self.type;
          var cfg = self.cfg;
          var C; // 构造函数

          var coord;
          var coordCfg = Util.mix({
            start: start,
            end: end
          }, cfg);

          if (type === 'theta') {
            // definition of theta coord
            C = Coord.Polar;

            if (!self.hasAction('transpose')) {
              self.transpose(); // 极坐标，同时transpose
            }

            coord = new C(coordCfg);
            coord.type = type;
          } else {
            C = Coord[Util.upperFirst(type || '')] || Coord.Rect;
            coord = new C(coordCfg);
          }

          self._execActions(coord);

          return coord;
        };

        _proto.rotate = function rotate(angle) {
          angle = angle * Math.PI / 180;
          this.actions.push(['rotate', angle]);
          return this;
        };

        _proto.reflect = function reflect(dim) {
          this.actions.push(['reflect', dim]);
          return this;
        };

        _proto.scale = function scale(sx, sy) {
          this.actions.push(['scale', sx, sy]);
          return this;
        };

        _proto.transpose = function transpose() {
          this.actions.push(['transpose']);
          return this;
        };

        return CoordController;
      }();

      module.exports = CoordController;
      /***/
    },
    /* 345 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";
      /**
       * @fileOverview the entry of coordinate
       * @author sima.zhang1990@gmail.com
       */

      var Coord = __webpack_require__(44);

      Coord.Cartesian = __webpack_require__(346);
      Coord.Rect = Coord.Cartesian;
      Coord.Polar = __webpack_require__(347);
      Coord.Helix = __webpack_require__(348);
      module.exports = Coord;
      /***/
    },
    /* 346 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /**
       * @fileOverview the class of Cartesian Coordinate
       * @author sima.zhang
       */


      var mix = __webpack_require__(8);

      var Base = __webpack_require__(44);

      var Cartesian = /*#__PURE__*/function (_Base) {
        _inherits(Cartesian, _Base);

        _createClass(Cartesian, [{
          key: "getDefaultCfg",

          /**
           * @override
           */
          value: function getDefaultCfg() {
            var cfg = _get(_getPrototypeOf(Cartesian.prototype), "getDefaultCfg", this).call(this);

            return mix({}, cfg, {
              start: {
                x: 0,
                y: 0
              },
              end: {
                x: 0,
                y: 0
              },
              type: 'cartesian',
              isRect: true
            });
          }
        }]);

        function Cartesian(cfg) {
          var _this;

          _classCallCheck(this, Cartesian);

          _this = _possibleConstructorReturn(this, _getPrototypeOf(Cartesian).call(this, cfg));

          _this._init();

          return _this;
        }

        _createClass(Cartesian, [{
          key: "_init",
          value: function _init() {
            var start = this.start,
                end = this.end;
            var x = {
              start: start.x,
              end: end.x
            };
            var y = {
              start: start.y,
              end: end.y
            };
            this.x = x;
            this.y = y;
          }
        }, {
          key: "convertPoint",
          value: function convertPoint(point) {
            var x;
            var y;

            if (this.isTransposed) {
              x = point.y;
              y = point.x;
            } else {
              x = point.x;
              y = point.y;
            }

            return {
              x: this.convertDim(x, 'x'),
              y: this.convertDim(y, 'y')
            };
          }
        }, {
          key: "invertPoint",
          value: function invertPoint(point) {
            var x = this.invertDim(point.x, 'x');
            var y = this.invertDim(point.y, 'y');

            if (this.isTransposed) {
              return {
                x: y,
                y: x
              };
            }

            return {
              x: x,
              y: y
            };
          }
        }]);

        return Cartesian;
      }(Base);

      module.exports = Cartesian;
      /***/
    },
    /* 347 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /**
       * @fileOverview the class of Polar Coordinate
       * @author sima.zhang
       */


      var MatrixUtil = __webpack_require__(43);

      var isNumberEqual = __webpack_require__(35);

      var mix = __webpack_require__(8);

      var Base = __webpack_require__(44);

      var mat3 = MatrixUtil.mat3;
      var vec2 = MatrixUtil.vec2;
      var vec3 = MatrixUtil.vec3;

      var Polar = /*#__PURE__*/function (_Base) {
        _inherits(Polar, _Base);

        _createClass(Polar, [{
          key: "getDefaultCfg",
          value: function getDefaultCfg() {
            var cfg = _get(_getPrototypeOf(Polar.prototype), "getDefaultCfg", this).call(this);

            return mix({}, cfg, {
              startAngle: -Math.PI / 2,
              endAngle: Math.PI * 3 / 2,
              innerRadius: 0,
              type: 'polar',
              isPolar: true
            });
          }
        }]);

        function Polar(cfg) {
          var _this;

          _classCallCheck(this, Polar);

          _this = _possibleConstructorReturn(this, _getPrototypeOf(Polar).call(this, cfg));

          _this._init();

          return _this;
        }

        _createClass(Polar, [{
          key: "_init",
          value: function _init() {
            var radius = this.radius;
            var innerRadius = this.innerRadius;
            var center = this.center;
            var startAngle = this.startAngle;
            var endAngle = this.endAngle;

            while (endAngle < startAngle) {
              endAngle += Math.PI * 2;
            }

            this.endAngle = endAngle;
            var oneBox = this.getOneBox();
            var oneWidth = oneBox.maxX - oneBox.minX;
            var oneHeight = oneBox.maxY - oneBox.minY;
            var left = Math.abs(oneBox.minX) / oneWidth;
            var top = Math.abs(oneBox.minY) / oneHeight;
            var width = this.width;
            var height = this.height;
            var maxRadius;
            var circleCentre;

            if (height / oneHeight > width / oneWidth) {
              // width为主
              maxRadius = width / oneWidth;
              circleCentre = {
                x: center.x - (0.5 - left) * width,
                y: center.y - (0.5 - top) * maxRadius * oneHeight
              };
            } else {
              // height为主
              maxRadius = height / oneHeight;
              circleCentre = {
                x: center.x - (0.5 - left) * maxRadius * oneWidth,
                y: center.y - (0.5 - top) * height
              };
            }

            if (!radius) {
              radius = maxRadius;
            } else if (radius > 0 && radius <= 1) {
              radius = maxRadius * radius;
            } else if (radius <= 0 || radius > maxRadius) {
              radius = maxRadius;
            }

            var x = {
              start: startAngle,
              end: endAngle
            };
            var y = {
              start: innerRadius * radius,
              end: radius
            };
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.circleCentre = circleCentre;
            this.center = circleCentre;
          }
        }, {
          key: "getCenter",
          value: function getCenter() {
            return this.circleCentre;
          }
        }, {
          key: "getOneBox",
          value: function getOneBox() {
            var startAngle = this.startAngle;
            var endAngle = this.endAngle;

            if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
              return {
                minX: -1,
                maxX: 1,
                minY: -1,
                maxY: 1
              };
            }

            var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
            var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];

            for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
              xs.push(Math.cos(i));
              ys.push(Math.sin(i));
            }

            return {
              minX: Math.min.apply(Math, xs),
              maxX: Math.max.apply(Math, xs),
              minY: Math.min.apply(Math, ys),
              maxY: Math.max.apply(Math, ys)
            };
          }
        }, {
          key: "getRadius",
          value: function getRadius() {
            return this.radius;
          }
        }, {
          key: "convertPoint",
          value: function convertPoint(point) {
            var center = this.getCenter();
            var x = this.isTransposed ? point.y : point.x;
            var y = this.isTransposed ? point.x : point.y;
            x = this.convertDim(x, 'x');
            y = this.convertDim(y, 'y');
            return {
              x: center.x + Math.cos(x) * y,
              y: center.y + Math.sin(x) * y
            };
          }
        }, {
          key: "invertPoint",
          value: function invertPoint(point) {
            var center = this.getCenter();
            var vPoint = [point.x - center.x, point.y - center.y];
            var x = this.x;
            var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            mat3.rotate(m, m, x.start);
            var vStart = [1, 0, 0];
            vec3.transformMat3(vStart, vStart, m);
            vStart = [vStart[0], vStart[1]];
            var angle = vec2.angleTo(vStart, vPoint, x.end < x.start);

            if (isNumberEqual(angle, Math.PI * 2)) {
              angle = 0;
            }

            var radius = vec2.length(vPoint);
            var xPercent = angle / (x.end - x.start);
            xPercent = x.end - x.start > 0 ? xPercent : -xPercent;
            var yPercent = this.invertDim(radius, 'y');
            var rst = {};
            rst.x = this.isTransposed ? yPercent : xPercent;
            rst.y = this.isTransposed ? xPercent : yPercent;
            return rst;
          }
        }]);

        return Polar;
      }(Base);

      module.exports = Polar;
      /***/
    },
    /* 348 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /**
       * @fileOverview the class of Helix Coordinate
       * @author sima.zhang
       */


      var MatrixUtil = __webpack_require__(43);

      var isNumberEqual = __webpack_require__(35);

      var mix = __webpack_require__(8);

      var Base = __webpack_require__(44);

      var vec2 = MatrixUtil.vec2;

      var Helix = /*#__PURE__*/function (_Base) {
        _inherits(Helix, _Base);

        _createClass(Helix, [{
          key: "getDefaultCfg",
          value: function getDefaultCfg() {
            var cfg = _get(_getPrototypeOf(Helix.prototype), "getDefaultCfg", this).call(this);

            return mix({}, cfg, {
              startAngle: 1.25 * Math.PI,
              endAngle: 7.25 * Math.PI,
              innerRadius: 0,
              type: 'helix',
              isHelix: true
            });
          }
        }]);

        function Helix(cfg) {
          var _this;

          _classCallCheck(this, Helix);

          _this = _possibleConstructorReturn(this, _getPrototypeOf(Helix).call(this, cfg));

          _this._init();

          return _this;
        }

        _createClass(Helix, [{
          key: "_init",
          value: function _init() {
            var width = this.width;
            var height = this.height;
            var radius = this.radius;
            var innerRadius = this.innerRadius;
            var startAngle = this.startAngle;
            var endAngle = this.endAngle;
            var index = (endAngle - startAngle) / (2 * Math.PI) + 1; // 螺线圈数

            var maxRadius = Math.min(width, height) / 2;

            if (radius && radius >= 0 && radius <= 1) {
              maxRadius = maxRadius * radius;
            }

            var d = Math.floor(maxRadius * (1 - innerRadius) / index);
            var a = d / (Math.PI * 2); // 螺线系数

            var x = {
              start: startAngle,
              end: endAngle
            };
            var y = {
              start: innerRadius * maxRadius,
              end: innerRadius * maxRadius + d * 0.99
            };
            this.a = a;
            this.d = d;
            this.x = x;
            this.y = y;
          }
        }, {
          key: "getCenter",
          value: function getCenter() {
            return this.center;
          }
          /**
           * 将百分比数据变成屏幕坐标
           * @param  {Object} point 归一化的点坐标
           * @return {Object}       返回对应的屏幕坐标
           */

        }, {
          key: "convertPoint",
          value: function convertPoint(point) {
            var a = this.a;
            var center = this.center;
            var x;
            var y;

            if (this.isTransposed) {
              x = point.y;
              y = point.x;
            } else {
              x = point.x;
              y = point.y;
            }

            var thi = this.convertDim(x, 'x');
            var r = a * thi;
            var newY = this.convertDim(y, 'y');
            return {
              x: center.x + Math.cos(thi) * (r + newY),
              y: center.y + Math.sin(thi) * (r + newY)
            };
          }
          /**
           * 将屏幕坐标点还原成百分比数据
           * @param  {Object} point 屏幕坐标
           * @return {Object}       返回对应的归一化后的数据
           */

        }, {
          key: "invertPoint",
          value: function invertPoint(point) {
            var center = this.center;
            var a = this.a;
            var d = this.d + this.y.start;
            var v = vec2.subtract([], [point.x, point.y], [center.x, center.y]);
            var thi = vec2.angleTo(v, [1, 0], true);
            var rMin = thi * a; // 坐标与原点的连线在第一圈上的交点，最小r值

            if (vec2.length(v) < rMin) {
              // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况
              rMin = vec2.length(v);
            }

            var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈

            thi = 2 * index * Math.PI + thi;
            var r = a * thi;
            var newY = vec2.length(v) - r;
            newY = isNumberEqual(newY, 0) ? 0 : newY;
            var x = this.invertDim(thi, 'x');
            var y = this.invertDim(newY, 'y');
            x = isNumberEqual(x, 0) ? 0 : x;
            y = isNumberEqual(y, 0) ? 0 : y;
            var rst = {};
            rst.x = this.isTransposed ? y : x;
            rst.y = this.isTransposed ? x : y;
            return rst;
          }
        }]);

        return Helix;
      }(Base);

      module.exports = Helix;
      /***/
    },
    /* 349 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The controller of axis
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var _require = __webpack_require__(22),
          Axis = _require.Axis;

      var vec2 = Util.MatrixUtil.vec2;

      function formatTicks(ticks) {
        var tmp = [];

        if (ticks.length > 0) {
          tmp = ticks.slice(0);
          var first = tmp[0];
          var last = tmp[tmp.length - 1];

          if (first.value !== 0) {
            tmp.unshift({
              value: 0
            });
          }

          if (last.value !== 1) {
            tmp.push({
              value: 1
            });
          }
        }

        return tmp;
      }

      function fillAxisTicks(ticks, isLinear, gridCentering) {
        var result = [];
        if (ticks.length < 1) return result;

        if (ticks.length >= 2 && isLinear && gridCentering) {
          result.push({
            text: '',
            tickValue: '',
            value: 0
          });
        }

        if (ticks[0].value !== 0) {
          result.push({
            text: '',
            tickValue: '',
            value: 0
          });
        }

        result = result.concat(ticks);

        if (result[result.length - 1].value !== 1) {
          result.push({
            text: '',
            tickValue: '',
            value: 1
          });
        }

        return result;
      }

      function getDefaultValueFromPosition(position, val) {
        if (val === void 0) {
          val = 0;
        }

        if (position === 'middle') {
          val = 0.5;
        }

        if (position.includes('%')) {
          val = parseInt(position, 10) / 100;
        }

        return val;
      }

      var AxisController = /*#__PURE__*/function () {
        function AxisController(cfg) {
          this.visible = true;
          this.canvas = null;
          this.container = null;
          this.coord = null;
          this.options = null;
          this.axes = [];
          Util.mix(this, cfg);
        }

        var _proto = AxisController.prototype;

        _proto._isHide = function _isHide(field) {
          // 对应的坐标轴是否隐藏
          var options = this.options;

          if (options && options[field] === false) {
            return true;
          }

          return false;
        };

        _proto._getMiddleValue = function _getMiddleValue(curValue, ticks, index, isLinear) {
          if (curValue === 0 && !isLinear) {
            return 0;
          }

          if (curValue === 1) {
            return 1;
          }

          var nextValue = ticks[index + 1].value;

          if (!isLinear && nextValue === 1) {
            return 1;
          }

          return (curValue + nextValue) / 2;
        };

        _proto._getLineRange = function _getLineRange(coord, scale, dimType, index) {
          var start;
          var end;
          var isVertical;
          var field = scale.field;
          var options = this.options;
          var position = '';

          if (options[field] && options[field].position) {
            position = options[field].position;
          } // TODO middle & percentage for position


          if (dimType === 'x') {
            // x轴的坐标轴,底部的横坐标
            var y = position === 'top' ? 1 : 0;
            y = getDefaultValueFromPosition(position, y);
            start = {
              x: 0,
              y: y
            };
            end = {
              x: 1,
              y: y
            };
            isVertical = false;
          } else {
            // y轴坐标轴
            if (index) {
              // 多轴的情况
              var x = position === 'left' ? 0 : 1;
              x = getDefaultValueFromPosition(position, x);
              start = {
                x: x,
                y: 0
              };
              end = {
                x: x,
                y: 1
              };
            } else {
              // 单个y轴，或者第一个y轴
              var _x = position === 'right' ? 1 : 0;

              _x = getDefaultValueFromPosition(position, _x);
              start = {
                x: _x,
                y: 0
              };
              end = {
                x: _x,
                y: 1
              };
            }

            isVertical = true;
          }

          start = coord.convert(start);
          end = coord.convert(end);
          return {
            start: start,
            end: end,
            isVertical: isVertical
          };
        };

        _proto._getLineCfg = function _getLineCfg(coord, scale, dimType, index) {
          var factor;

          var range = this._getLineRange(coord, scale, dimType, index);

          var isVertical = range.isVertical; // 标识该坐标轴是否是纵坐标

          var start = range.start;
          var end = range.end;
          var center = coord.center;

          if (coord.isTransposed) {
            isVertical = !isVertical;
          }

          if (isVertical && start.x > center.x || !isVertical && start.y > center.y) {
            factor = 1;
          } else {
            factor = -1;
          }

          return {
            isVertical: isVertical,
            factor: factor,
            start: start,
            end: end
          };
        } // 获取圆弧坐标轴配置项信息
        ;

        _proto._getCircleCfg = function _getCircleCfg(coord) {
          var circleCfg = {};
          var rangeX = coord.x;
          var rangeY = coord.y;
          var isReflectY = rangeY.start > rangeY.end;
          var start;

          if (coord.isTransposed) {
            start = {
              x: isReflectY ? 0 : 1,
              y: 0
            };
          } else {
            start = {
              x: 0,
              y: isReflectY ? 0 : 1
            };
          }

          start = coord.convert(start);
          var center = coord.circleCentre;
          var startVector = [start.x - center.x, start.y - center.y];
          var normalVector = [1, 0];
          var startAngle;

          if (start.y > center.y) {
            startAngle = vec2.angle(startVector, normalVector);
          } else {
            startAngle = vec2.angle(startVector, normalVector) * -1;
          }

          var endAngle = startAngle + (rangeX.end - rangeX.start);
          circleCfg.startAngle = startAngle;
          circleCfg.endAngle = endAngle;
          circleCfg.center = center;
          circleCfg.radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));
          circleCfg.inner = coord.innerRadius || 0;
          return circleCfg;
        };

        _proto._getRadiusCfg = function _getRadiusCfg(coord) {
          var startAngle = coord.x.start;
          var factor = startAngle < 0 ? -1 : 1;
          var start;
          var end;

          if (coord.isTransposed) {
            start = {
              x: 0,
              y: 0
            };
            end = {
              x: 1,
              y: 0
            };
          } else {
            start = {
              x: 0,
              y: 0
            };
            end = {
              x: 0,
              y: 1
            };
          }

          return {
            factor: factor,
            start: coord.convert(start),
            end: coord.convert(end)
          };
        } // 确定坐标轴的位置
        ;

        _proto._getAxisPosition = function _getAxisPosition(coord, dimType, index, field) {
          var position = ''; // 用户自己定义了 position

          var options = this.options; // const VALID_POSITIONS = [
          //   'top',
          //   'left',
          //   'right',
          //   'bottom'
          // ];

          if (options[field] && options[field].position) {
            position = options[field].position; // if (VALID_POSITIONS.indexOf(position) > -1) {
            //   return position;
            // }
          } else {
            var coordType = coord.type;

            if (coord.isRect) {
              if (dimType === 'x') {
                position = 'bottom';
              } else if (dimType === 'y') {
                if (index) {
                  position = 'right';
                } else {
                  position = 'left';
                }
              }
            } else if (coordType === 'helix') {
              position = 'helix';
            } else if (dimType === 'x') {
              position = coord.isTransposed ? 'radius' : 'circle';
            } else {
              position = coord.isTransposed ? 'circle' : 'radius';
            }
          }

          return position;
        } // 获取坐标轴构成的配置信息
        ;

        _proto._getAxisDefaultCfg = function _getAxisDefaultCfg(coord, scale, type, position) {
          var self = this;
          var viewTheme = self.viewTheme;
          var cfg = {};
          var options = self.options;
          var field = scale.field;
          cfg = Util.deepMix({}, viewTheme.axis[position], cfg, options[field]);
          cfg.viewTheme = viewTheme;

          if (cfg.title) {
            var title = Util.isPlainObject(cfg.title) ? cfg.title : {};
            title.text = title.text || scale.alias || field;
            Util.deepMix(cfg, {
              title: title
            });
          }

          cfg.ticks = scale.getTicks();

          if (coord.isPolar && !scale.isCategory) {
            if (type === 'x' && Math.abs(coord.endAngle - coord.startAngle) === Math.PI * 2) {
              cfg.ticks.pop();
            }
          }

          cfg.coord = coord;

          if (cfg.label && Util.isNil(cfg.label.autoRotate)) {
            cfg.label.autoRotate = true; // 允许自动旋转，避免重叠
          }

          if (options.hasOwnProperty('xField') && options.xField.hasOwnProperty('grid')) {
            if (cfg.position === 'left') {
              Util.deepMix(cfg, options.xField);
            }
          }

          return cfg;
        } // 确定坐标轴的配置信息
        ;

        _proto._getAxisCfg = function _getAxisCfg(coord, scale, verticalScale, dimType, index, viewId) {
          if (index === void 0) {
            index = '';
          }

          var self = this;

          var position = self._getAxisPosition(coord, dimType, index, scale.field);

          var cfg = self._getAxisDefaultCfg(coord, scale, dimType, position);

          if (!Util.isEmpty(cfg.grid) && verticalScale) {
            // 生成 gridPoints
            var gridPoints = [];
            var tickValues = [];
            var verticalTicks = formatTicks(verticalScale.getTicks()); // 没有垂直的坐标点时不会只栅格

            if (verticalTicks.length) {
              var ticks = fillAxisTicks(cfg.ticks, scale.isLinear, cfg.grid.align === 'center');
              Util.each(ticks, function (tick, idx) {
                tickValues.push(tick.tickValue);
                var subPoints = [];
                var value = tick.value;

                if (cfg.grid.align === 'center') {
                  value = self._getMiddleValue(value, ticks, idx, scale.isLinear);
                }

                if (!Util.isNil(value)) {
                  var rangeX = coord.x;
                  var rangeY = coord.y;
                  Util.each(verticalTicks, function (verticalTick) {
                    var x = dimType === 'x' ? value : verticalTick.value;
                    var y = dimType === 'x' ? verticalTick.value : value;
                    var point = coord.convert({
                      x: x,
                      y: y
                    });

                    if (coord.isPolar) {
                      var center = coord.circleCentre;

                      if (rangeY.start > rangeY.end) {
                        y = 1 - y;
                      }

                      point.flag = rangeX.start > rangeX.end ? 0 : 1;
                      point.radius = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
                    }

                    subPoints.push(point);
                  });
                  gridPoints.push({
                    _id: viewId + '-' + dimType + index + '-grid-' + tick.tickValue,
                    points: subPoints
                  });
                }
              });
            }

            cfg.grid.items = gridPoints;
            cfg.grid.tickValues = tickValues;
          }

          cfg.type = scale.type;
          return cfg;
        };

        _proto._getHelixCfg = function _getHelixCfg(coord) {
          var helixCfg = {};
          var a = coord.a;
          var startAngle = coord.startAngle;
          var endAngle = coord.endAngle;
          var index = 100;
          var crp = [];

          for (var i = 0; i <= index; i++) {
            var point = coord.convert({
              x: i / 100,
              y: 0
            });
            crp.push(point.x);
            crp.push(point.y);
          }

          var axisStart = coord.convert({
            x: 0,
            y: 0
          });
          helixCfg.a = a;
          helixCfg.startAngle = startAngle;
          helixCfg.endAngle = endAngle;
          helixCfg.crp = crp;
          helixCfg.axisStart = axisStart;
          helixCfg.center = coord.center;
          helixCfg.inner = coord.y.start; // 内半径

          return helixCfg;
        };

        _proto._drawAxis = function _drawAxis(coord, scale, verticalScale, dimType, viewId, xAxis, index) {
          var container = this.container;
          var canvas = this.canvas;
          var C; // 坐标轴类

          var appendCfg; // 每个坐标轴 start end 等绘制边界的信息

          if (coord.type === 'cartesian') {
            C = Axis.Line;
            appendCfg = this._getLineCfg(coord, scale, dimType, index);
          } else if (coord.type === 'helix' && dimType === 'x') {
            C = Axis.Helix;
            appendCfg = this._getHelixCfg(coord);
          } else if (dimType === 'x') {
            C = Axis.Circle;
            appendCfg = this._getCircleCfg(coord);
          } else {
            C = Axis.Line;
            appendCfg = this._getRadiusCfg(coord);
          }

          var cfg = this._getAxisCfg(coord, scale, verticalScale, dimType, index, viewId);

          cfg = Util.mix({}, cfg, appendCfg);

          if (dimType === 'y' && xAxis && xAxis.get('type') === 'circle') {
            cfg.circle = xAxis;
          }

          cfg._id = viewId + '-' + dimType;

          if (!Util.isNil(index)) {
            cfg._id = viewId + '-' + dimType + index;
          }

          Util.mix(cfg, {
            canvas: canvas,
            // 每个 axis 需要单独的 group，
            // 否则所有的 aixs 的文本都混在一起了
            // 同时无法知道是哪个坐标轴的事件
            group: container.addGroup({
              viewId: viewId
            })
          });
          var axis = new C(cfg);
          axis.render();
          this.axes.push(axis);
          return axis;
        };

        _proto.createAxis = function createAxis(xScale, yScales, viewId) {
          var self = this;
          var coord = this.coord;
          var coordType = coord.type; // theta坐标系默认不绘制坐标轴

          if (coordType !== 'theta' && !(coordType === 'polar' && coord.isTransposed)) {
            var xAxis;

            if (xScale && !self._isHide(xScale.field)) {
              xAxis = self._drawAxis(coord, xScale, yScales[0], 'x', viewId); // 绘制 x 轴
            }

            if (!Util.isEmpty(yScales) && coordType !== 'helix') {
              Util.each(yScales, function (yScale, index) {
                if (!self._isHide(yScale.field)) {
                  self._drawAxis(coord, yScale, xScale, 'y', viewId, xAxis, index);
                }
              });
            }
          }
        };

        _proto.changeVisible = function changeVisible(visible) {
          var axes = this.axes;
          Util.each(axes, function (axis) {
            axis.set('visible', visible);
          });
        };

        _proto.clear = function clear() {
          var self = this;
          var axes = self.axes;
          Util.each(axes, function (axis) {
            axis.destroy();
          });
          self.axes = [];
        };

        return AxisController;
      }();

      module.exports = AxisController;
      /***/
    },
    /* 350 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      var Guide = __webpack_require__(351);

      var GuideController = /*#__PURE__*/function () {
        function GuideController(cfg) {
          this.guides = [];
          this.options = [];
          this.xScales = null;
          this.yScales = null;
          this.view = null;
          this.viewTheme = null;
          this.frontGroup = null;
          this.backGroup = null;
          Util.mix(this, cfg);
        }

        var _proto = GuideController.prototype;

        _proto._creatGuides = function _creatGuides() {
          var self = this;
          var options = this.options;
          var xScales = this.xScales;
          var yScales = this.yScales;
          var view = this.view;
          var viewTheme = this.viewTheme; // @2019-01-18 by blue.lb 这里如果给 backContainer 添加 group 的话，会直接导致 BBoxOfBackPlot 函数中计算 element.getBBox() 出错

          if (this.backContainer && view) {
            this.backGroup = this.backContainer.addGroup({
              viewId: view.get('_id')
            });
          }

          if (this.frontContainer && view) {
            this.frontGroup = this.frontContainer.addGroup({
              viewId: view.get('_id')
            });
          }

          options.forEach(function (option) {
            var type = option.type;
            var config = Util.deepMix({
              xScales: xScales,
              yScales: yScales,
              viewTheme: viewTheme
            }, viewTheme ? viewTheme.guide[type] : {}, option);
            type = Util.upperFirst(type);
            var guide = new Guide[type](config);
            self.guides.push(guide);
          });
          return self.guides;
        };

        _proto.line = function line(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'line'
          }, cfg));
          return this;
        };

        _proto.arc = function arc(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'arc'
          }, cfg));
          return this;
        };

        _proto.text = function text(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'text'
          }, cfg));
          return this;
        };

        _proto.image = function image(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'image'
          }, cfg));
          return this;
        };

        _proto.region = function region(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'region'
          }, cfg));
          return this;
        };

        _proto.regionFilter = function regionFilter(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'regionFilter'
          }, cfg));
          return this;
        };

        _proto.dataMarker = function dataMarker(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'dataMarker'
          }, cfg));
          return this;
        };

        _proto.dataRegion = function dataRegion(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'dataRegion'
          }, cfg));
          return this;
        };

        _proto.html = function html(cfg) {
          if (cfg === void 0) {
            cfg = {};
          }

          this.options.push(Util.mix({
            type: 'html'
          }, cfg));
          return this;
        };

        _proto.render = function render(coord) {
          var self = this;
          var view = self.view;
          var viewData = view && view.get('data');

          var guides = self._creatGuides();

          Util.each(guides, function (guide) {
            var container;

            if (guide.get('top')) {
              // 默认 guide 绘制到 backPlot，用户也可以声明 top: true，显示在最上层
              // @2019-01-18 by blue.lb 直接用传入的就行
              container = self.frontGroup || self.frontContainer; // container = self.frontContainer;
            } else {
              // @2019-01-18 by blue.lb 直接用传入的就行
              container = self.backGroup || self.backContainer; // container = self.backContainer;
            }

            guide.render(coord, container, viewData, view);
          });
        };

        _proto.clear = function clear() {
          this.options = [];
          this.reset();
        };

        _proto.changeVisible = function changeVisible(visible) {
          var guides = this.guides;
          Util.each(guides, function (guide) {
            guide.changeVisible(visible);
          });
        };

        _proto.reset = function reset() {
          var guides = this.guides;
          Util.each(guides, function (guide) {
            guide.clear();
          });
          this.guides = []; // @2019-01-18 by blue.lb 删除这部分

          this.backGroup && this.backGroup.remove();
          this.frontGroup && this.frontGroup.remove();
        };

        return GuideController;
      }();

      module.exports = GuideController;
      /***/
    },
    /* 351 */

    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(22),
          Guide = _require.Guide;

      var RegionFilter = __webpack_require__(352);

      Guide.RegionFilter = RegionFilter;
      module.exports = Guide;
      /***/
    },
    /* 352 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(0);

      var Guide = __webpack_require__(15);

      var _require = __webpack_require__(20),
          Path = _require.Path;

      var RegionFilter = /*#__PURE__*/function (_Guide) {
        _inheritsLoose(RegionFilter, _Guide);

        function RegionFilter() {
          return _Guide.apply(this, arguments) || this;
        }

        var _proto = RegionFilter.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Guide.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            name: 'regionFilter',
            zIndex: 1,
            top: true,
            start: null,
            end: null,
            color: null,
            apply: null,
            style: {
              opacity: 1
            }
          });
        };

        _proto.render = function render(coord, group, viewData, view) {
          var self = this;
          var layer = group.addGroup();
          layer.name = 'guide-region-filter';
          view.once('afterpaint', function () {
            // 2018-08-08 by blue.lb padding为auto时，会导致重新绘制一次，这时候layer已经被销毁了
            if (layer.get('destroyed')) return;

            self._drawShapes(view, layer);

            var clip = self._drawClip(coord);

            layer.attr({
              clip: clip
            });
            self.set('clip', clip);
            self.get('appendInfo') && layer.setSilent('appendInfo', self.get('appendInfo'));
            self.set('el', layer);
          });
        };

        _proto._drawShapes = function _drawShapes(view, layer) {
          var self = this;
          var output = [];
          var geoms = view.getAllGeoms();
          geoms.map(function (geom) {
            var shapes = geom.getShapes();
            var geomType = geom.get('type');

            var filter = self._geomFilter(geomType);

            if (filter) {
              shapes.map(function (shape) {
                var shapeType = shape.type; // const shapeAttr = Util.mix({}, shape.attr());

                var shapeAttr = Util.cloneDeep(shape.attr());

                self._adjustDisplay(shapeAttr);

                var s = layer.addShape(shapeType, {
                  attrs: shapeAttr
                });
                output.push(s);
                return shape;
              });
            }

            return geom;
          });
          return output;
        };

        _proto._drawClip = function _drawClip(coord) {
          var self = this;
          var start = self.parsePoint(coord, self.get('start'));
          var end = self.parsePoint(coord, self.get('end'));
          var path = [['M', start.x, start.y], ['L', end.x, start.y], ['L', end.x, end.y], ['L', start.x, end.y], ['z']];
          var clip = new Path({
            attrs: {
              path: path,
              opacity: 1
            }
          });
          return clip;
        };

        _proto._adjustDisplay = function _adjustDisplay(attr) {
          var self = this;
          var color = self.get('color');

          if (attr.fill) {
            attr.fill = attr.fillStyle = color;
          }

          attr.stroke = attr.strokeStyle = color;
        };

        _proto._geomFilter = function _geomFilter(geomType) {
          var self = this;
          var apply = self.get('apply');

          if (apply) {
            return Util.contains(apply, geomType);
          }

          return true;
        };

        _proto.clear = function clear() {
          _Guide.prototype.clear.call(this);

          var clip = this.get('clip');
          clip && clip.remove();
        };

        return RegionFilter;
      }(Guide);

      module.exports = RegionFilter;
      /***/
    },
    /* 353 */

    /***/
    function (module, exports, __webpack_require__) {
      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      var Util = __webpack_require__(0);

      var _require = __webpack_require__(22),
          Legend = _require.Legend;

      var Tail = __webpack_require__(354);

      var Shape = __webpack_require__(19);

      var bboxOfBackPlot = __webpack_require__(166);

      var plotRange2BBox = __webpack_require__(168);

      var Global = __webpack_require__(7);

      var FIELD_ORIGIN = '_origin';
      var MARKER_SIZE = 4.5;
      var requireAnimationFrameFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
      var STROKE_MARKERS = ['cross', 'tick', 'plus', 'hyphen', 'line', 'hollowCircle', 'hollowSquare', 'hollowDiamond', 'hollowTriangle', 'hollowTriangleDown', 'hollowHexagon', 'hollowBowtie'];

      function _snapEqual(v1, v2, scale) {
        var isEqual;

        if (Util.isNil(scale)) {
          return false;
        }

        v1 = scale.translate(v1);
        v2 = scale.translate(v2);

        if (scale.isCategory) {
          isEqual = v1 === v2;
        } else {
          isEqual = Math.abs(v1 - v2) <= 1;
        }

        return isEqual;
      }

      function findGeom(geoms, value) {
        var rst;
        Util.each(geoms, function (geom) {
          if (geom.get('visible')) {
            var yScale = geom.getYScale();

            if (yScale.field === value) {
              rst = geom;
              return;
            }
          }
        });
        return rst;
      }

      var LegendController = /*#__PURE__*/function () {
        function LegendController(cfg) {
          var self = this;
          self.options = {};
          Util.mix(self, cfg);
          self.clear();
          var chart = self.chart;
          self.container = chart.get('frontPlot');
          self.plotRange = chart.get('plotRange');
        }

        var _proto = LegendController.prototype;

        _proto.clear = function clear() {
          var legends = this.legends;
          this.backRange = null;
          Util.each(legends, function (legendItems) {
            Util.each(legendItems, function (legend) {
              legend.destroy();
            });
          });
          this.legends = {};
        } // 获取坐标轴等背景元素占的范围，防止遮挡坐标轴
        ;

        _proto.getBackRange = function getBackRange() {
          var backRange = this.backRange;

          if (!backRange) {
            var backPlot = this.chart.get('backPlot');
            backRange = bboxOfBackPlot(backPlot, plotRange2BBox(this.chart.get('plotRange')));
            var plotRange = this.plotRange;

            if (backRange.maxX - backRange.minX < plotRange.br.x - plotRange.tl.x && backRange.maxY - backRange.minY < plotRange.br.y - plotRange.tl.y) {
              // 如果背景小于则直接使用 plotRange
              backRange = {
                minX: plotRange.tl.x,
                minY: plotRange.tl.y,
                maxX: plotRange.br.x,
                maxY: plotRange.br.y
              };
            }

            this.backRange = backRange;
          }

          return backRange;
        };

        _proto._isFieldInView = function _isFieldInView(field, value, view) {
          var flag = false;
          var scales = view.get('scales');
          var fieldScale = scales[field];

          if (fieldScale && fieldScale.values) {
            flag = Util.inArray(fieldScale.values, value);
          }

          return flag;
        };

        _proto._bindClickEvent = function _bindClickEvent(legend, scale, filterVals) {
          var self = this;
          var chart = self.chart;
          var views = chart.get('views');
          var field = scale.field;
          var options = self.options;
          legend.on('itemclick', function (ev) {
            if (options.onClick && options.defaultClickHandlerEnabled !== true) {
              options.onClick(ev);
            } else {
              // if 'defaultClickHandlerEnabled' is true the default click behavior would be worked.
              var item = ev.item;
              var checked = ev.checked;
              var isSingleSelected = legend.get('selectedMode') === 'single'; // 图例的选中模式

              var clickedValue = item.dataValue; // import: 需要取该图例项原始的数值

              if (checked) {
                Util.Array.remove(filterVals, clickedValue);

                if (self._isFieldInView(field, clickedValue, chart)) {
                  chart.filter(field, function (field) {
                    return isSingleSelected ? field === clickedValue : !Util.inArray(filterVals, field);
                  });
                }

                Util.each(views, function (view) {
                  if (self._isFieldInView(field, clickedValue, view)) {
                    view.filter(field, function (field) {
                      return isSingleSelected ? field === clickedValue : !Util.inArray(filterVals, field);
                    });
                  }
                });
              } else if (!isSingleSelected) {
                filterVals.push(clickedValue);

                if (self._isFieldInView(field, clickedValue, chart)) {
                  chart.filter(field, function (field) {
                    return !Util.inArray(filterVals, field);
                  });
                }

                Util.each(views, function (view) {
                  if (self._isFieldInView(field, clickedValue, view)) {
                    view.filter(field, function (field) {
                      return !Util.inArray(filterVals, field);
                    });
                  }
                });
              }

              if (options.onClick) {
                options.onClick(ev);
              }

              chart.set('keepLegend', true); // 图例不重新渲染

              chart.set('keepPadding', true); // 边框不重新计算

              chart.repaint();
              chart.set('keepPadding', false);
              chart.set('keepLegend', false);
            }
          });
        };

        _proto._bindClickEventForMix = function _bindClickEventForMix(legend) {
          var self = this;
          var chart = self.chart;
          var geoms = chart.getAllGeoms();
          legend.on('itemclick', function (ev) {
            var itemField = ev.item.field;
            var checked = ev.checked;

            if (checked) {
              Util.each(geoms, function (geom) {
                var field = geom.getYScale().field;

                if (field === itemField) {
                  geom.show();
                }
              });
            } else {
              Util.each(geoms, function (geom) {
                var field = geom.getYScale().field;

                if (field === itemField) {
                  geom.hide();
                }
              });
            }
          });
        };

        _proto._filterLabels = function _filterLabels(shape, geom, visible) {
          if (shape.get('gLabel')) {
            shape.get('gLabel').set('visible', visible);
          } else {
            var labelCfg = geom.get('labelCfg');

            if (labelCfg && labelCfg.fields && labelCfg.fields.length > 0) {
              var xScale = geom.getXScale();
              var yScale = geom.getYScale();
              var xField = xScale.field;
              var yField = yScale.field;

              var shapeData = shape.get('origin')._origin;

              var labelContainer = geom.get('labelContainer');
              var labels = labelContainer.get('labelsGroup').get('children');
              Util.each(labels, function (label) {
                var labelData = label.get('origin') || [];

                if (labelData[xField] === shapeData[xField] && labelData[yField] === shapeData[yField]) {
                  label.set('visible', visible);
                  shape.set('gLabel', label);
                }
              });
            }
          }
        };

        _proto._bindFilterEvent = function _bindFilterEvent(legend, scale) {
          var self = this;
          var chart = this.chart;
          var field = scale.field;
          legend.on('itemfilter', function (ev) {
            var range = ev.range;
            chart.filterShape(function (obj, shape, geom) {
              // @2018-12-21 by blue.lb 由于数值0直接被类型转换为false，这里需要做更精确一点的判断
              if (!Util.isNil(obj[field])) {
                var filtered = obj[field] >= range[0] && obj[field] <= range[1]; // shape 带 label，则还需要隐藏 label

                self._filterLabels(shape, geom, filtered);

                return filtered;
              }

              return true;
            });
            var geoms = chart.getAllGeoms() || [];

            var _loop = function _loop(i) {
              var geom = geoms[i];

              if (geom.get('type') === 'heatmap') {
                requireAnimationFrameFn(function () {
                  geom.drawWithRange(range);
                });
              }
            };

            for (var i = 0; i < geoms.length; i++) {
              _loop(i);
            }
          });
        };

        _proto._getShapeData = function _getShapeData(shape) {
          var originData = shape.get('origin');

          if (Util.isArray(originData)) {
            originData = originData[0];
          }

          return originData[FIELD_ORIGIN];
        };

        _proto._bindHoverEvent = function _bindHoverEvent(legend, field) {
          var self = this;
          var chart = self.chart;
          var geoms = chart.getAllGeoms();
          var options = self.options;
          var canvas = chart.get('canvas');
          legend.on('itemhover', function (ev) {
            var value = ev.item.value;
            var pre = self.pre;

            if (!pre) {
              Util.each(geoms, function (geom) {
                var shapeContainer = geom.get('shapeContainer');
                var shapes = geom.getShapes();
                var activeShapes = [];

                if (field) {
                  var scale = geom.get('scales')[field];
                  Util.each(shapes, function (shape) {
                    var origin = self._getShapeData(shape);

                    if (origin && _snapEqual(origin[field], value, scale)) {
                      activeShapes.push(shape);
                    }
                  });
                } else if (geom.getYScale().field === value) {
                  activeShapes = shapes;
                }

                if (!Util.isEmpty(activeShapes)) {
                  ev.shapes = activeShapes;
                  ev.geom = geom;

                  if (options.onHover) {
                    options.onHover(ev);
                    shapeContainer.sort();
                    canvas.draw();
                  } else {
                    geom.setShapesActived(activeShapes);
                  }
                }
              });
              self.pre = value;
            } else if (pre === value) {
              return;
            }
          });
          legend.on('itemunhover', function (ev) {
            self.pre = null;

            if (options.onUnhover) {
              options.onUnhover(ev);
            }

            Util.each(geoms, function (geom) {
              if (geom.get('activeShapes')) {
                geom.clearActivedShapes();
                canvas.draw();
              }
            });
          });
        };

        _proto._isFiltered = function _isFiltered(scale, filterVals, scaleValue) {
          if (!scale.isCategory) {
            return true;
          }

          var rst = true;
          scaleValue = scale.invert(scaleValue);
          Util.each(filterVals, function (val) {
            if (scale.getText(val) === scale.getText(scaleValue)) {
              rst = false;
              return false;
            }
          });
          return rst;
        };

        _proto._alignLegend = function _alignLegend(legend, pre, region, position) {
          var self = this;
          var viewTheme = self.viewTheme;
          var container = self.container;
          var canvas = container.get('canvas');
          var width = canvas.get('width');
          var height = canvas.get('height');
          var totalRegion = self.totalRegion;
          var plotRange = self.plotRange;
          var backRange = self.getBackRange(); // 背景占得范围

          var offsetX = legend.get('offset')[0] || 0;
          var offsetY = legend.get('offset')[1] || 0; // const offset = Util.isNil(legend.get('offset')) ? MARGIN : legend.get('offset');

          var legendHeight = legend.getHeight();
          var legendWidth = legend.getWidth();
          var borderMargin = viewTheme.legend.margin;
          var innerMargin = viewTheme.legend.legendMargin;
          var legendNum = self.legends[position].length;
          var posArray = position.split('-');
          var x = 0;
          var y = 0;
          var tempoRegion = legendNum > 1 ? totalRegion : region;

          if (posArray[0] === 'left' || posArray[0] === 'right') {
            height = plotRange.br.y;
            x = self._getXAlign(posArray[0], width, region, backRange, legendWidth, borderMargin);

            if (pre) {
              // @2018-10-19 by blue.lb 由于legend中并不存在y属性，这里需要先获取group再获取y值
              // @2019-03-21 by blue.lb 由于内部实现问题，usehtml部分的实例可以直接获取x、y的
              y = (pre.get('y') || pre.get('group').get('y')) + pre.getHeight() + innerMargin;
            } else {
              y = self._getYAlignVertical(posArray[1], height, tempoRegion, backRange, 0, borderMargin, canvas.get('height'));
            }
          } else if (posArray[0] === 'top' || posArray[0] === 'bottom') {
            y = self._getYAlignHorizontal(posArray[0], height, region, backRange, legendHeight, borderMargin);

            if (pre) {
              var preWidth = pre.getWidth(); // @2018-10-19 by blue.lb 由于legend中并不存在x属性，这里需要先获取group再获取x值
              // @2019-03-21 by blue.lb 由于内部实现问题，usehtml部分的实例可以直接获取x、y的

              x = (pre.get('x') || pre.get('group').get('x')) + preWidth + innerMargin;
            } else {
              x = self._getXAlign(posArray[1], width, tempoRegion, backRange, 0, borderMargin);
              if (posArray[1] === 'right') x = plotRange.br.x - tempoRegion.totalWidth;
            }
          }

          legend.move(x + offsetX, y + offsetY);
        };

        _proto._getXAlign = function _getXAlign(pos, width, region, backRange, legendWidth, borderMargin) {
          var leftPos = backRange.minX - legendWidth - borderMargin[3] < 0 ? 0 : backRange.minX - legendWidth - borderMargin[3];
          var x = pos === 'left' ? leftPos : backRange.maxX + borderMargin[1];

          if (pos === 'center') {
            x = (width - region.totalWidth) / 2;
          }

          return x;
        };

        _proto._getYAlignHorizontal = function _getYAlignHorizontal(pos, height, region, backRange, legendHeight, borderMargin) {
          var y = pos === 'top' ? backRange.minY - legendHeight - borderMargin[0] : backRange.maxY + borderMargin[2];
          return y;
        };

        _proto._getYAlignVertical = function _getYAlignVertical(pos, height, region, backRange, legendHeight, borderMargin, canvasHeight) {
          var y = pos === 'top' ? backRange.minY - legendHeight - borderMargin[0] : height - region.totalHeight;

          if (pos === 'center') {
            y = (canvasHeight - region.totalHeight) / 2;
          }

          return y;
        };

        _proto._getSubRegion = function _getSubRegion(legends) {
          var maxWidth = 0;
          var maxHeight = 0;
          var totalWidth = 0;
          var totalHeight = 0;
          Util.each(legends, function (legend) {
            var width = legend.getWidth();
            var height = legend.getHeight();

            if (maxWidth < width) {
              maxWidth = width;
            }

            totalWidth += width;

            if (maxHeight < height) {
              maxHeight = height;
            }

            totalHeight += height;
          });
          return {
            maxWidth: maxWidth,
            totalWidth: totalWidth,
            maxHeight: maxHeight,
            totalHeight: totalHeight
          };
        };

        _proto._getRegion = function _getRegion() {
          var self = this;
          var viewTheme = self.viewTheme;
          var legends = self.legends;
          var innerMargin = viewTheme.legend.legendMargin;
          var subs = [];
          var totalWidth = 0;
          var totalHeight = 0;
          Util.each(legends, function (legendItems) {
            var subRegion = self._getSubRegion(legendItems);

            subs.push(subRegion);
            totalWidth += subRegion.totalWidth + innerMargin;
            totalHeight += subRegion.totalHeight + innerMargin;
          });
          return {
            totalWidth: totalWidth,
            totalHeight: totalHeight,
            subs: subs
          };
        };

        _proto._addCategoryLegend = function _addCategoryLegend(scale, attr, geom, filterVals, position) {
          var self = this;
          var field = scale.field;
          var legendOptions = self.options;
          var fieldOption = legendOptions[field];

          if (fieldOption) {
            legendOptions = fieldOption;
          }

          var legends = self.legends;
          legends[position] = legends[position] || [];
          var container = self.container;
          var items = [];
          var ticks = scale.getTicks();
          var isByAttr = true;
          var shapeType = geom.get('shapeType') || 'point';
          var shape = geom.getDefaultValue('shape') || 'circle';

          if (legendOptions[field] && legendOptions[field].marker) {
            // 用户为 field 对应的图例定义了 marker
            shape = legendOptions[field].marker;
            shapeType = 'point';
            isByAttr = false;
          } else if (legendOptions.marker) {
            shape = legendOptions.marker;
            shapeType = 'point';
            isByAttr = false;
          }

          var chart = self.chart;
          var viewTheme = self.viewTheme;
          var canvas = chart.get('canvas');
          var plotRange = self.plotRange;
          var posArray = position.split('-');
          var maxLength = posArray[0] === 'right' || posArray[0] === 'left' ? plotRange.bl.y - plotRange.tr.y : canvas.get('width');
          Util.each(ticks, function (tick) {
            var text = tick.text;
            var name = text;
            var scaleValue = tick.value;
            var value = scale.invert(scaleValue);
            var cfg = {
              isInCircle: geom.isInCircle()
            };
            var checked = filterVals ? self._isFiltered(scale, filterVals, scaleValue) : true;
            var colorAttr = geom.getAttr('color');
            var shapeAttr = geom.getAttr('shape');

            if (colorAttr) {
              // 存在颜色映射
              if (colorAttr.callback && colorAttr.callback.length > 1) {
                // 多参数映射，阻止程序报错
                var restArgs = Array(colorAttr.callback.length - 1).fill('');
                cfg.color = colorAttr.mapping.apply(colorAttr, [value].concat(restArgs)).join('') || viewTheme.defaultColor;
              } else {
                cfg.color = colorAttr.mapping(value).join('') || viewTheme.defaultColor;
              }
            }

            if (isByAttr && shapeAttr) {
              // 存在形状映射
              if (shapeAttr.callback && shapeAttr.callback.length > 1) {
                // 多参数映射，阻止程序报错
                var _restArgs = Array(shapeAttr.callback.length - 1).fill('');

                shape = shapeAttr.mapping.apply(shapeAttr, [value].concat(_restArgs)).join('');
              } else {
                shape = shapeAttr.mapping(value).join('');
              }
            }

            var shapeObject = Shape.getShapeFactory(shapeType);
            var marker = shapeObject.getMarkerCfg(shape, cfg);

            if (Global.legendMarkerRadius) {
              marker.radius = Global.legendMarkerRadius;
            }

            if (Util.isFunction(shape)) {
              marker.symbol = shape;
            }

            items.push({
              value: name,
              // 图例项显示文本的内容
              dataValue: value,
              // 图例项对应原始数据中的数值
              checked: checked,
              marker: marker
            });
          });
          var legendCfg = Util.deepMix({}, viewTheme.legend[posArray[0]], legendOptions[field] || legendOptions, {
            viewId: chart.get('_id'),
            maxLength: maxLength,
            items: items,
            container: container,
            position: [0, 0]
          });

          if (legendCfg.title) {
            Util.deepMix(legendCfg, {
              title: {
                text: scale.alias || scale.field
              }
            });
          }

          var legend;

          if (self._isTailLegend(legendOptions, geom)) {
            legendCfg.chart = self.chart;
            legendCfg.geom = geom;
            legend = new Tail(legendCfg);
          } else {
            if (legendOptions.useHtml) {
              var canvasEle = container.get('canvas').get('el');
              container = legendOptions.container;

              if (Util.isString(container) && /^\#/.test(container)) {
                // 如果传入 dom 节点的 id
                var id = container.replace('#', '');
                container = document.getElementById(id);
              }

              if (!container) {
                container = canvasEle.parentNode;
              }

              legendCfg.container = container;
              if (legendCfg.legendStyle === undefined) legendCfg.legendStyle = {};
              legendCfg.legendStyle.CONTAINER_CLASS = _extends({}, legendCfg.legendStyle.CONTAINER_CLASS, {
                position: 'absolute',
                overflow: 'auto',
                'z-index': canvasEle.style.zIndex === '' ? 1 : parseInt(canvasEle.style.zIndex, 10) + 1
              });

              if (legendOptions.flipPage) {
                legendCfg.legendStyle.CONTAINER_CLASS.height = posArray[0] === 'right' || posArray[0] === 'left' ? maxLength + 'px' : 'auto';
                legendCfg.legendStyle.CONTAINER_CLASS.width = !(posArray[0] === 'right' || posArray[0] === 'left') ? maxLength + 'px' : 'auto';
                legend = new Legend.CatPageHtml(legendCfg);
              } else {
                legend = new Legend.CatHtml(legendCfg);
              }
            } else {
              legend = new Legend.Category(legendCfg);
            }
          }

          self._bindClickEvent(legend, scale, filterVals);

          legends[position].push(legend);
          return legend;
        };

        _proto._bindChartMove = function _bindChartMove(scale) {
          var chart = this.chart;
          var legends = this.legends;
          chart.on('plotmove', function (ev) {
            var selected = false;

            if (ev.target) {
              var origin = ev.target.get('origin');

              if (origin) {
                var data = origin[FIELD_ORIGIN] || origin[0][FIELD_ORIGIN];
                var field = scale.field;

                if (data) {
                  var value = data[field];
                  Util.each(legends, function (legendItems) {
                    Util.each(legendItems, function (legend) {
                      selected = true;
                      !legend.destroyed && legend.activate(value);
                    });
                  });
                }
              }
            }

            if (!selected) {
              Util.each(legends, function (legendItems) {
                Util.each(legendItems, function (legend) {
                  !legend.destroyed && legend.deactivate();
                });
              });
            }
          });
        };

        _proto._addContinuousLegend = function _addContinuousLegend(scale, attr, position) {
          var self = this;
          var legends = self.legends;
          legends[position] = legends[position] || [];
          var container = self.container;
          var field = scale.field;
          var ticks = scale.getTicks();
          var items = [];
          var legend;
          var minValue;
          var maxValue;
          var viewTheme = self.viewTheme;
          Util.each(ticks, function (tick) {
            var scaleValue = tick.value;
            var invertValue = scale.invert(scaleValue);
            var attrValue = attr.mapping(invertValue).join('');
            items.push({
              value: tick.tickValue,
              // tick.text
              attrValue: attrValue,
              color: attrValue,
              scaleValue: scaleValue
            });

            if (scaleValue === 0) {
              minValue = true;
            }

            if (scaleValue === 1) {
              maxValue = true;
            }
          });

          if (!minValue) {
            items.push({
              value: scale.min,
              attrValue: attr.mapping(0).join(''),
              color: attr.mapping(0).join(''),
              scaleValue: 0
            });
          }

          if (!maxValue) {
            items.push({
              value: scale.max,
              attrValue: attr.mapping(1).join(''),
              color: attr.mapping(1).join(''),
              scaleValue: 1
            });
          }

          var options = self.options;
          var posArray = position.split('-');
          var defaultCfg = viewTheme.legend[posArray[0]];

          if (options && options.slidable === false || options[field] && options[field].slidable === false) {
            defaultCfg = Util.mix({}, defaultCfg, viewTheme.legend.gradient);
          }

          var legendCfg = Util.deepMix({}, defaultCfg, options[field] || options, {
            items: items,
            attr: attr,
            formatter: scale.formatter,
            container: container,
            position: [0, 0]
          });

          if (legendCfg.title) {
            Util.deepMix(legendCfg, {
              title: {
                text: scale.alias || scale.field
              }
            });
          }

          if (attr.type === 'color') {
            legend = new Legend.Color(legendCfg);
          } else if (attr.type === 'size') {
            if (options && options.sizeType === 'circle') legend = new Legend.CircleSize(legendCfg);else legend = new Legend.Size(legendCfg);
          } else {
            return;
          }

          self._bindFilterEvent(legend, scale);

          legends[position].push(legend);
          return legend;
        };

        _proto._isTailLegend = function _isTailLegend(opt, geom) {
          if (opt.hasOwnProperty('attachLast') && opt.attachLast) {
            var geomType = geom.get('type');
            if (geomType === 'line' || geomType === 'lineStack' || geomType === 'area' || geomType === 'areaStack') return true;
          }

          return false;
        };

        _proto._adjustPosition = function _adjustPosition(position, isTailLegend) {
          var pos;

          if (isTailLegend) {
            pos = 'right-top';
          } else if (Util.isArray(position)) {
            pos = String(position[0]) + '-' + String(position[1]);
          } else {
            var posArr = position.split('-');

            if (posArr.length === 1) {
              // 只用了left/right/bottom/top一个位置定位
              if (posArr[0] === 'left') pos = 'left-bottom';
              if (posArr[0] === 'right') pos = 'right-bottom';
              if (posArr[0] === 'top') pos = 'top-center';
              if (posArr[0] === 'bottom') pos = 'bottom-center';
            } else {
              pos = position;
            }
          }

          return pos;
        };

        _proto.addLegend = function addLegend(scale, attr, geom, filterVals) {
          var self = this;
          var legendOptions = self.options;
          var field = scale.field;
          var fieldOption = legendOptions[field];
          var viewTheme = self.viewTheme;

          if (fieldOption === false) {
            // 如果不显示此图例
            return null;
          }

          if (fieldOption && fieldOption.custom) {
            self.addCustomLegend(field);
          } else {
            var position = legendOptions.position || viewTheme.defaultLegendPosition;
            position = self._adjustPosition(position, self._isTailLegend(legendOptions, geom));

            if (fieldOption && fieldOption.position) {
              // 如果对某个图例单独设置 position，则对 position 重新赋值
              position = self._adjustPosition(fieldOption.position, self._isTailLegend(fieldOption, geom));
            }

            var legend;

            if (scale.isLinear) {
              legend = self._addContinuousLegend(scale, attr, position);
            } else {
              legend = self._addCategoryLegend(scale, attr, geom, filterVals, position);
            }

            if (legend) {
              self._bindHoverEvent(legend, field);

              legendOptions.reactive && self._bindChartMove(scale);
            }
          }
        }
        /**
         * 自定义图例
         * @param {string} field 自定义图例的数据字段名，可以为空
         * @return {object} legend 自定义图例实例
         */
        ;

        _proto.addCustomLegend = function addCustomLegend(field) {
          var self = this;
          var chart = self.chart;
          var viewTheme = self.viewTheme;
          var container = self.container;
          var legendOptions = self.options;

          if (field) {
            legendOptions = legendOptions[field];
          }

          var position = legendOptions.position || viewTheme.defaultLegendPosition;
          position = self._adjustPosition(position);
          var legends = self.legends;
          legends[position] = legends[position] || [];
          var items = legendOptions.items;

          if (!items) {
            return;
          }

          var geoms = chart.getAllGeoms();
          Util.each(items, function (item) {
            var geom = findGeom(geoms, item.value);

            if (!Util.isPlainObject(item.marker)) {
              // 直接传入字符串或者回调函数时转换为对象，如 item.marker = 'circle'
              item.marker = {
                symbol: item.marker || 'circle',
                radius: Global.legendMarkerRadius || MARKER_SIZE
              };

              if (Util.indexOf(STROKE_MARKERS, item.marker.symbol) !== -1) {
                item.marker.stroke = item.fill;
              } else {
                item.marker.fill = item.fill;
              }
            } else {
              // 用户传入对象 item.marker = { symbol: 'circle', fill: 'red', radius: 3 }
              item.marker.radius = item.marker.radius || Global.legendMarkerRadius || MARKER_SIZE;
            }

            var symbol = item.marker.symbol;

            if (Util.isString(symbol) && symbol.indexOf('hollow') !== -1) {
              item.marker.symbol = Util.lowerFirst(symbol.substr(6));
            }

            item.checked = Util.isNil(item.checked) ? true : item.checked;
            item.geom = geom;
          });
          var canvas = chart.get('canvas');
          var plotRange = self.plotRange;
          var posArray = position.split('-');
          var maxLength = posArray[0] === 'right' || posArray[0] === 'left' ? plotRange.bl.y - plotRange.tr.y : canvas.get('width');
          var legendCfg = Util.deepMix({}, viewTheme.legend[posArray[0]], legendOptions, {
            maxLength: maxLength,
            items: items,
            container: container,
            position: [0, 0]
          });
          var legend;

          if (legendOptions.useHtml) {
            var htmlContainer = legendOptions.container;

            if (/^\#/.test(container)) {
              // 如果传入 dom 节点的 id
              var id = htmlContainer.replace('#', '');
              htmlContainer = document.getElementById(id);
            } else if (!htmlContainer) {
              htmlContainer = container.get('canvas').get('el').parentNode;
            }

            legendCfg.container = htmlContainer;
            if (legendCfg.legendStyle === undefined) legendCfg.legendStyle = {};

            if (!legendCfg.legendStyle.CONTAINER_CLASS) {
              legendCfg.legendStyle.CONTAINER_CLASS = {
                height: posArray[0] === 'right' || posArray[0] === 'left' ? maxLength + 'px' : 'auto',
                width: !(posArray[0] === 'right' || posArray[0] === 'left') ? maxLength + 'px' : 'auto',
                position: 'absolute',
                overflow: 'auto'
              };
            }

            if (legendOptions.flipPage) legend = new Legend.CatPageHtml(legendCfg);else legend = new Legend.CatHtml(legendCfg);
          } else legend = new Legend.Category(legendCfg);

          legends[position].push(legend);
          legend.on('itemclick', function (ev) {
            if (legendOptions.onClick) {
              // 用户自定义了图例点击事件
              legendOptions.onClick(ev);
            }
          });

          self._bindHoverEvent(legend);

          return legend;
        };

        _proto.addMixedLegend = function addMixedLegend(scales, geoms) {
          var self = this;
          var legendOptions = self.options;
          var items = [];
          Util.each(scales, function (scale) {
            var value = scale.alias || scale.field;
            var fieldLegendOptions = legendOptions[scale.field];
            Util.each(geoms, function (geom) {
              if (geom.getYScale() === scale && scale.values && scale.values.length > 0 && fieldLegendOptions !== false) {
                var shapeType = geom.get('shapeType') || 'point';
                var shape = geom.getDefaultValue('shape') || 'circle';
                var shapeObject = Shape.getShapeFactory(shapeType);
                var cfg = {
                  color: geom.getDefaultValue('color')
                };
                var marker = shapeObject.getMarkerCfg(shape, cfg);

                if (Global.legendMarkerRadius) {
                  marker.radius = Global.legendMarkerRadius;
                }

                var item = {
                  value: value,
                  marker: marker,
                  field: scale.field
                };
                items.push(item);
              }
            }); // end of geom loop
          }); // end of scale loop

          var options = {
            custom: true,
            items: items
          };
          self.options = Util.deepMix({}, options, self.options);
          var legend = self.addCustomLegend();

          self._bindClickEventForMix(legend);
        };

        _proto.alignLegends = function alignLegends() {
          var self = this;
          var legends = self.legends;

          var totalRegion = self._getRegion(legends);

          self.totalRegion = totalRegion;
          var i = 0;
          Util.each(legends, function (legendItems, position) {
            var region =
            /* self._getRegion(legendItems)*/
            totalRegion.subs[i];
            Util.each(legendItems, function (legend, index) {
              var pre = legendItems[index - 1];

              if (!(legend.get('useHtml') && !legend.get('autoPosition'))) {
                self._alignLegend(legend, pre, region, position);
              }
            });
            i++;
          });
          return this;
        };

        return LegendController;
      }();

      module.exports = LegendController;
      /***/
    },
    /* 354 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview The class of tail legend
       * @author Ye Liu
       */


      var Util = __webpack_require__(0); // const Category = require('./category');


      var Components = __webpack_require__(22);

      var Global = __webpack_require__(7);

      var Legend = Components.Legend;
      var Category = Legend.Category;

      var Tail = /*#__PURE__*/function (_Category) {
        _inheritsLoose(Tail, _Category);

        function Tail() {
          return _Category.apply(this, arguments) || this;
        }

        var _proto = Tail.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Category.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            /**
             * type标识
             * @type {String}
             */
            type: 'tail-legend',

            /**
             * 布局方式
             * horizontal 水平
             * vertical 垂直
             * @type {String}
             */
            layout: 'vertical',
            autoLayout: true
          });
        };

        _proto._addItem = function _addItem(item) {
          var itemsGroup = this.get('itemsGroup');

          var x = this._getNextX();

          var y = 0;
          var unCheckColor = this.get('unCheckColor');
          var itemGroup = itemsGroup.addGroup({
            x: 0,
            y: 0,
            value: item.value,
            scaleValue: item.scaleValue,
            checked: item.checked
          });
          itemGroup.translate(x, y);
          itemGroup.set('viewId', itemsGroup.get('viewId'));
          var textStyle = this.get('textStyle');
          var wordSpace = this.get('_wordSpaceing');
          var startX = 0;

          if (item.marker) {
            // 如果有marker添加marker
            var markerAttrs = Util.mix({}, item.marker, {
              x: item.marker.radius,
              y: 0
            });

            if (!item.checked) {
              if (markerAttrs.fill) {
                markerAttrs.fill = unCheckColor;
              }

              if (markerAttrs.stroke) {
                markerAttrs.stroke = unCheckColor;
              }
            }

            var markerShape = itemGroup.addShape('marker', {
              type: 'marker',
              attrs: markerAttrs
            });
            markerShape.attr('cursor', 'pointer');
            markerShape.name = 'legend-marker';
            startX += markerShape.getBBox().width + wordSpace;
          }

          var textAttrs = Util.mix({}, textStyle, {
            x: startX,
            y: 0,
            text: this._formatItemValue(item.value)
          });

          if (!item.checked) {
            Util.mix(textAttrs, {
              fill: unCheckColor
            });
          }

          var textShape = itemGroup.addShape('text', {
            attrs: textAttrs
          });
          textShape.attr('cursor', 'pointer');
          textShape.name = 'legend-text';
          this.get('appendInfo') && textShape.setSilent('appendInfo', this.get('appendInfo')); // 添加一个包围矩形，用于事件支持

          var bbox = itemGroup.getBBox();
          var itemWidth = this.get('itemWidth');
          var wrapperShape = itemGroup.addShape('rect', {
            attrs: {
              x: x,
              y: y - bbox.height / 2,
              fill: '#fff',
              fillOpacity: 0,
              width: itemWidth || bbox.width,
              height: bbox.height
            }
          });
          wrapperShape.attr('cursor', 'pointer');
          wrapperShape.setSilent('origin', item); // 保存图例项相关的数据，便于事件操作

          wrapperShape.name = 'legend-item';
          this.get('appendInfo') && wrapperShape.setSilent('appendInfo', this.get('appendInfo'));
          itemGroup.name = 'legendGroup';
          return itemGroup;
        };

        _proto._adjust = function _adjust() {
          var self = this;
          var geom = self.get('geom');

          if (geom) {
            var groupMatrix = self.get('group').attr('matrix');
            groupMatrix[7] = 0;
            var dataArray = self.get('geom').get('dataArray');
            var groups = this.get('itemsGroup').get('children');
            var index = 0;
            Util.each(groups, function (groupItem) {
              var dArray = dataArray[index];
              var lastY = dArray[dArray.length - 1].y;

              if (Util.isArray(lastY)) {
                lastY = lastY[1];
              }

              var groupHeight = groupItem.getBBox().height;
              var x = groupItem.get('x');
              var y = lastY - groupHeight / 2;
              groupItem.translate(x, y);
              index++;
            });

            if (self.get('autoLayout')) {
              self._antiCollision(groups);
            }
          }
        };

        _proto.render = function render() {
          var _this = this;

          _Category.prototype.render.call(this);

          var chart = this.get('chart');
          chart.once('afterpaint', function () {
            _this._adjust();
          });
        };

        _proto._getPreviousY = function _getPreviousY(item) {
          var y = item.attr('matrix')[7];
          var height = item.getBBox().height;
          return y + height;
        };

        _proto._adjustDenote = function _adjustDenote(group, start, end) {
          var margin = Global.legend.legendMargin;
          var x0 = -2;
          var x2 = -margin * 2;
          group.addShape('path', {
            attrs: {
              path: 'M' + x0 + ',' + start + 'L' + x2 + ',' + (end + 3),
              lineWidth: 1,
              lineDash: [2, 2],
              stroke: '#999999'
            }
          });
        };

        _proto._antiCollision = function _antiCollision(items) {
          if (items === void 0) {
            items = [];
          }

          if (!items.length) return;
          var self = this;
          items.sort(function (a, b) {
            var ay = a.attr('matrix')[7];
            var by = b.attr('matrix')[7];
            return ay - by;
          });
          var overlapping = true;
          var plotRange = self.get('chart').get('plotRange');
          var startY = plotRange.tl.y;
          var totalHeight = Math.abs(startY - plotRange.bl.y);
          var elementHeight = items[0].getBBox().height;
          var minY = Number.MIN_VALUE;
          var maxY = 0;
          var boxes = items.map(function (item) {
            var y = item.attr('matrix')[7];

            if (y > maxY) {
              maxY = y;
            }

            if (y < minY) {
              minY = y;
            }

            return {
              size: item.getBBox().height,
              targets: [y - startY]
            };
          });
          minY -= startY;
          var i = 0;

          while (overlapping) {
            for (var _i = 0; _i < boxes.length; _i++) {
              var box = boxes[_i];
              var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
              box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
            }

            overlapping = false;
            i = boxes.length;

            while (i--) {
              if (i > 0) {
                var previous = boxes[i - 1];
                var current = boxes[i];

                if (previous.pos + previous.size > current.pos) {
                  // overlapping
                  previous.size += current.size;
                  previous.targets = previous.targets.concat(current.targets);
                  boxes.splice(i, 1);
                  overlapping = true;
                }
              }
            } // end of while i

          } // end of while
          // adjust y


          i = 0;
          var group = this.get('itemsGroup').addGroup();
          boxes.forEach(function (b) {
            var posInCompositeBox = startY + elementHeight;
            b.targets.forEach(function () {
              var origin_y = items[i].attr('matrix')[7];
              var y = b.pos + posInCompositeBox - elementHeight / 2;
              var dist = Math.abs(origin_y - y);

              if (dist > elementHeight / 2) {
                self._adjustDenote(group, y, origin_y - self.get('group').attr('matrix')[7] / 2);
              }

              items[i].translate(0, -origin_y);
              items[i].translate(0, y);
              posInCompositeBox += elementHeight;
              i++;
            });
          });
        } // end of antiCollision
        ;

        return Tail;
      }(Category);

      module.exports = Tail;
      /***/
    },
    /* 355 */

    /***/
    function (module, exports, __webpack_require__) {
      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }
      /**
       * @fileOverview The controller of tooltip
       * @author sima.zhang
       */


      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var _require = __webpack_require__(22),
          Tooltip = _require.Tooltip;

      var MatrixUtil = Util.MatrixUtil;
      var Vector2 = MatrixUtil.vec2;
      var TYPE_SHOW_MARKERS = ['line', 'area', 'path', 'areaStack']; // 默认展示 tooltip marker 的几何图形

      var TYPE_SHOW_CROSSHAIRS = ['line', 'area']; // 默认展示十字瞄准线的几何图形
      // TODO FIXME this is HARD CODING

      var IGNORE_TOOLTIP_ITEM_PROPERTIES = ['marker', 'showMarker'];

      function _indexOfArray(items, item) {
        var rst = -1;
        Util.each(items, function (sub, index) {
          var isEqual = true;

          for (var key in item) {
            if (item.hasOwnProperty(key) && !IGNORE_TOOLTIP_ITEM_PROPERTIES.includes(key)) {
              if (!Util.isObject(item[key]) && item[key] !== sub[key]) {
                isEqual = false;
                break;
              }
            }
          }

          if (isEqual) {
            rst = index;
            return false;
          }
        });
        return rst;
      } // 判断是否有样式


      function _hasClass(dom, className) {
        if (!dom) {
          return false;
        }

        var cls = '';
        if (!dom.className) return false;

        if (!Util.isNil(dom.className.baseVal)) {
          cls = dom.className.baseVal;
        } else {
          cls = dom.className;
        }

        return cls.includes(className);
      }

      function _isParent(dom, cls) {
        var parent = dom.parentNode;
        var rst = false;

        while (parent && parent !== document.body) {
          if (_hasClass(parent, cls)) {
            rst = true;
            break;
          }

          parent = parent.parentNode;
        }

        return rst;
      } // 去除重复的值, 去除不同图形相同数据，只展示一份即可


      function _uniqItems(items) {
        var tmp = [];
        Util.each(items, function (item) {
          var index = _indexOfArray(tmp, item);

          if (index === -1) {
            tmp.push(item);
          } else {
            tmp[index] = item;
          }
        });
        return tmp;
      }

      var TooltipController = /*#__PURE__*/function () {
        function TooltipController(cfg) {
          Util.assign(this, cfg);
          this.timeStamp = 0; // tooltip 锁定不能移动

          this.locked = false;
        }

        var _proto = TooltipController.prototype;

        _proto._normalizeEvent = function _normalizeEvent(event) {
          var chart = this.chart;

          var canvas = this._getCanvas();

          var point = canvas.getPointByClient(event.clientX, event.clientY);
          var pixelRatio = canvas.get('pixelRatio');
          point.x = point.x / pixelRatio;
          point.y = point.y / pixelRatio;
          var views = chart.getViewsByPoint(point);
          point.views = views;
          return point;
        };

        _proto._getCanvas = function _getCanvas() {
          return this.chart.get('canvas');
        };

        _proto._getTriggerEvent = function _getTriggerEvent() {
          var options = this.options;
          var triggerOn = options.triggerOn;
          var eventName;

          if (!triggerOn || triggerOn === 'mousemove') {
            eventName = 'plotmove';
          } else if (triggerOn === 'click') {
            eventName = 'plotclick';
          } else if (triggerOn === 'none') {
            eventName = null;
          }

          return eventName;
        };

        _proto._getDefaultTooltipCfg = function _getDefaultTooltipCfg() {
          var self = this;
          var chart = self.chart;
          var viewTheme = self.viewTheme;
          var options = self.options;
          var defaultCfg = Util.mix({}, viewTheme.tooltip);
          var geoms = chart.getAllGeoms().filter(function (geom) {
            return geom.get('visible');
          });
          var shapes = [];
          Util.each(geoms, function (geom) {
            var type = geom.get('type');
            var adjusts = geom.get('adjusts');
            var isSymmetric = false;

            if (adjusts) {
              Util.each(adjusts, function (adjust) {
                if (adjust.type === 'symmetric' || adjust.type === 'Symmetric') {
                  isSymmetric = true;
                  return false;
                }
              });
            }

            if (Util.indexOf(shapes, type) === -1 && !isSymmetric) {
              shapes.push(type);
            }
          });
          var isTransposed = geoms.length && geoms[0].get('coord') ? geoms[0].get('coord').isTransposed : false;
          var crosshairsCfg;

          if (geoms.length && geoms[0].get('coord') && geoms[0].get('coord').type === 'cartesian') {
            if (shapes[0] === 'interval' && options.shared !== false) {
              // 直角坐标系下 interval 的 crosshair 为矩形背景框
              var crosshairs = Util.mix({}, viewTheme.tooltipCrosshairsRect);
              crosshairs.isTransposed = isTransposed;
              crosshairsCfg = {
                zIndex: 0,
                // 矩形背景框不可覆盖 geom
                crosshairs: crosshairs
              };
            } else if (Util.indexOf(TYPE_SHOW_CROSSHAIRS, shapes[0]) > -1) {
              var _crosshairs = Util.mix({}, viewTheme.tooltipCrosshairsLine);

              _crosshairs.isTransposed = isTransposed;
              crosshairsCfg = {
                crosshairs: _crosshairs
              };
            }
          }

          return Util.mix(defaultCfg, crosshairsCfg, {});
        };

        _proto._bindEvent = function _bindEvent() {
          var chart = this.chart;

          var triggerEvent = this._getTriggerEvent();

          if (triggerEvent) {
            chart.on(triggerEvent, Util.wrapBehavior(this, 'onMouseMove'));
            chart.on('plotleave', Util.wrapBehavior(this, 'onMouseOut'));
          }
        };

        _proto._offEvent = function _offEvent() {
          var chart = this.chart;

          var triggerEvent = this._getTriggerEvent();

          if (triggerEvent) {
            chart.off(triggerEvent, Util.getWrapBehavior(this, 'onMouseMove'));
            chart.off('plotleave', Util.getWrapBehavior(this, 'onMouseOut'));
          }
        };

        _proto._setTooltip = function _setTooltip(point, items, markersItems, target) {
          var self = this;
          var tooltip = self.tooltip;
          var prePoint = self.prePoint;

          if (!prePoint || prePoint.x !== point.x || prePoint.y !== point.y) {
            items = _uniqItems(items);
            self.prePoint = point;
            var chart = self.chart;
            var viewTheme = self.viewTheme;
            var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
            var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;

            if (!tooltip.get('visible')) {
              chart.emit('tooltip:show', {
                x: x,
                y: y,
                tooltip: tooltip
              });
            }

            var first = items[0];
            var title = first.title || first.name;

            if (tooltip.isContentChange(title, items)) {
              chart.emit('tooltip:change', {
                tooltip: tooltip,
                x: x,
                y: y,
                items: items
              }); // bugfix: when set the title in the tooltip:change event does not take effect.

              title = items[0].title || items[0].name;
              tooltip.setContent(title, items);

              if (!Util.isEmpty(markersItems)) {
                if (self.options.hideMarkers === true) {
                  // 不展示 tooltip marker
                  tooltip.set('markerItems', markersItems); // 用于 tooltip 辅助线的定位
                } else {
                  tooltip.setMarkers(markersItems, viewTheme.tooltipMarker);
                }
              } else {
                tooltip.clearMarkers(); // clearMarkers 只会将 markerItems 从 markerGroup 中移除
                // 所以我们还要将 markerItems 从 tooltip 中移除
                // 这么做是为了防止上一次设置 marker 时的 markerItems 影响此次 tooltip 辅助线的定位

                tooltip.set('markerItems', []);
              }
            }

            var canvas = this._getCanvas();

            if (target === canvas && tooltip.get('type') === 'mini') {
              // filter mini tooltip
              tooltip.hide();
            } else {
              tooltip.setPosition(x, y, target);
              tooltip.show();
            }
          }
        };

        _proto.hideTooltip = function hideTooltip() {
          var tooltip = this.tooltip;
          var chart = this.chart;

          var canvas = this._getCanvas();

          this.prePoint = null;
          tooltip.hide();
          chart.emit('tooltip:hide', {
            tooltip: tooltip
          });
          canvas.draw();
        };

        _proto.onMouseMove = function onMouseMove(ev) {
          // 锁定时不移动 tooltip
          if (Util.isEmpty(ev.views) || this.locked) {
            return;
          }

          var lastTimeStamp = this.timeStamp;
          var timeStamp = +new Date();
          var point = {
            x: ev.x,
            y: ev.y
          };

          if (timeStamp - lastTimeStamp > 16 && !this.chart.get('stopTooltip')) {
            this.showTooltip(point, ev.views, ev.shape);
            this.timeStamp = timeStamp;
          }
        };

        _proto.onMouseOut = function onMouseOut(ev) {
          var tooltip = this.tooltip; // 锁定 tooltip 时不隐藏

          if (!tooltip.get('visible') || !tooltip.get('follow') || this.locked) {
            return;
          } // 除非离开 plot 时鼠标依然在图形上，这段逻辑没有意义
          // if (ev && ev.target !== canvas) {
          //   return;
          // }


          if (ev && ev.toElement && (_hasClass(ev.toElement, 'g2-tooltip') || _isParent(ev.toElement, 'g2-tooltip'))) {
            return;
          }

          this.hideTooltip();
        };

        _proto.renderTooltip = function renderTooltip() {
          var self = this;

          if (self.tooltip) {
            // tooltip 对象已经创建
            return;
          }

          var chart = self.chart;
          var viewTheme = self.viewTheme;

          var canvas = self._getCanvas();

          var defaultCfg = self._getDefaultTooltipCfg();

          var options = self.options;
          options = Util.deepMix({
            plotRange: chart.get('plotRange'),
            capture: false,
            canvas: canvas,
            frontPlot: chart.get('frontPlot'),
            viewTheme: viewTheme.tooltip,
            backPlot: chart.get('backPlot')
          }, defaultCfg, options);

          if (options.crosshairs && options.crosshairs.type === 'rect') {
            options.zIndex = 0; // toolip 背景框不可遮盖住 geom，防止用户配置了 crosshairs
          }

          options.visible = false; // @2018-09-13 by blue.lb 如果设置shared为false不需要指定position
          // if (options.shared === false && Util.isNil(options.position)) {
          //   options.position = 'top';
          // }

          var tooltip;

          if (options.type === 'mini') {
            options.crosshairs = false; // this.options.shared = false;

            options.position = 'top';
            tooltip = new Tooltip.Mini(options);
          } else if (options.useHtml) {
            tooltip = new Tooltip.Html(options);
          } else {
            tooltip = new Tooltip.Canvas(options);
          }

          self.tooltip = tooltip;

          var triggerEvent = self._getTriggerEvent();

          var tooltipContainer = tooltip.get('container');

          if (!tooltip.get('enterable') && triggerEvent === 'plotmove') {
            // 鼠标不允许进入 tooltip 容器
            if (tooltipContainer) {
              tooltipContainer.onmousemove = function (e) {
                // 避免 tooltip 频繁闪烁
                var eventObj = self._normalizeEvent(e);

                chart.emit(triggerEvent, eventObj);
              };
            }
          } // 优化：鼠标移入 tooltipContainer 然后再移出时，需要隐藏 tooltip


          if (tooltipContainer) {
            tooltipContainer.onmouseleave = function () {
              if (!self.locked) {
                self.hideTooltip();
              }
            };
          }

          self._bindEvent();
        };

        _proto._formatMarkerOfItem = function _formatMarkerOfItem(coord, geom, item) {
          var self = this;
          var options = self.options;
          var point = item.point;

          if (point && point.x && point.y) {
            // hotfix: make sure there is no null value
            var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
            var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;
            point = coord.applyMatrix(x, y, 1);
            item.x = point[0];
            item.y = point[1];
            item.showMarker = true; // bugfix
            // 由于tooltip是DOM而不是Canvas，设置渐变色时，marker无法正常显示
            // 如果，设置的颜色是渐变色并且设置了tooltip使用html方式渲染，则取渐变色的起始颜色作为marker的颜色，暂时解决这个问题

            if (item.color.substring(0, 2) === 'l(' && (!options.hasOwnProperty('useHtml') || options.useHtml)) {
              item.color = item.color.split(' ')[1].substring(2);
            }

            var itemMarker = self._getItemMarker(geom, item);

            item.marker = itemMarker;

            if (Util.indexOf(TYPE_SHOW_MARKERS, geom.get('type')) !== -1) {
              return item;
            }
          }

          return null;
        };

        _proto.lockTooltip = function lockTooltip() {
          this.locked = true;
        };

        _proto.unlockTooltip = function unlockTooltip() {
          this.locked = false;
        };

        _proto.showTooltip = function showTooltip(point, views, target) {
          var _this = this;

          var self = this;

          if (Util.isEmpty(views) || !point) {
            return;
          }

          if (!this.tooltip) {
            this.renderTooltip(); // 如果一开始 tooltip 关闭，用户重新调用的时候需要先生成 tooltip
          }

          var options = self.options;
          var markersItems = [];
          var items = [];
          Util.each(views, function (view) {
            if (!view.get('tooltipEnable')) {
              // 如果不显示tooltip，则跳过
              return true;
            }

            var geoms = view.get('geoms');
            var coord = view.get('coord');
            Util.each(geoms, function (geom) {
              var type = geom.get('type');

              if (geom.get('visible') && geom.get('tooltipCfg') !== false) {
                var dataArray = geom.get('dataArray');

                if (geom.isShareTooltip() || options.shared === false && Util.inArray(['area', 'line', 'path', 'polygon'], type)) {
                  // 打补丁解决 bug: https://github.com/antvis/g2/issues/1248
                  // 当 interval 对应的 color 和 x 字段相同的时候，并且包含 dodge，items 取值逻辑不一样
                  // 这种情况下，每一个 x 字段分成一组
                  var xScale = geom.getXScale();
                  var colorAttr = geom.getAttr('color');
                  var colorField = colorAttr ? colorAttr.field : undefined;

                  if (type === 'interval' && xScale.field === colorField && geom.hasAdjust('dodge')) {
                    // 找不到不为空的
                    var points = Util.find(dataArray, function (obj) {
                      return !!geom.findPoint(point, obj);
                    }); // 转为 tooltip items

                    Util.each(points, function (tmpPoint) {
                      var subItems = geom.getTipItems(tmpPoint, options.title);
                      Util.each(subItems, function (v) {
                        var markerItem = self._formatMarkerOfItem(coord, geom, v);

                        if (markerItem) {
                          markersItems.push(markerItem);
                        }
                      });
                      items = items.concat(subItems);
                    });
                  } else {
                    Util.each(dataArray, function (obj) {
                      var tmpPoint = geom.findPoint(point, obj);

                      if (tmpPoint) {
                        var subItems = geom.getTipItems(tmpPoint, options.title);
                        Util.each(subItems, function (v) {
                          var markerItem = self._formatMarkerOfItem(coord, geom, v);

                          if (markerItem) {
                            markersItems.push(markerItem);
                          }
                        });
                        items = items.concat(subItems);
                      }
                    });
                  }
                } else {
                  var geomContainer = geom.get('shapeContainer');
                  var canvas = geomContainer.get('canvas');
                  var pixelRatio = canvas.get('pixelRatio');
                  var shape = geomContainer.getShape(point.x * pixelRatio, point.y * pixelRatio);

                  if (shape && shape.get('visible') && shape.get('origin')) {
                    items = geom.getTipItems(shape.get('origin'), options.title);
                  }

                  Util.each(items, function (v) {
                    var markerItem = _this._formatMarkerOfItem(coord, geom, v);

                    if (markerItem) {
                      markersItems.push(markerItem);
                    }
                  });
                }
              }
            });
            Util.each(items, function (item) {
              var point = item.point;
              var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
              var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;
              point = coord.applyMatrix(x, y, 1);
              item.x = point[0];
              item.y = point[1];
            });
          });

          if (items.length) {
            var first = items[0]; // bugfix: multiple tooltip items with different titles

            if (!items.every(function (item) {
              return item.title === first.title;
            })) {
              var nearestItem = first;
              var nearestDistance = Infinity;
              items.forEach(function (item) {
                var distance = Vector2.distance([point.x, point.y], [item.x, item.y]);

                if (distance < nearestDistance) {
                  nearestDistance = distance;
                  nearestItem = item;
                }
              });
              items = items.filter(function (item) {
                return item.title === nearestItem.title;
              });
              markersItems = markersItems.filter(function (item) {
                return item.title === nearestItem.title;
              });
            }

            if (options.shared === false && items.length > 1) {
              var snapItem = items[0];
              var min = Math.abs(point.y - snapItem.y);
              Util.each(items, function (aItem) {
                if (Math.abs(point.y - aItem.y) <= min) {
                  snapItem = aItem;
                  min = Math.abs(point.y - aItem.y);
                }
              });

              if (snapItem && snapItem.x && snapItem.y) {
                markersItems = [snapItem];
              }

              items = [snapItem];
            } // 3.0 采用当前鼠标位置作为 tooltip 的参考点
            // if (!Util.isEmpty(markersItems)) {
            //   point = markersItems[0];
            // }


            self._setTooltip(point, items, markersItems, target);
          } else {
            self.hideTooltip();
          }
        };

        _proto.clear = function clear() {
          var tooltip = this.tooltip;
          tooltip && tooltip.destroy();
          this.tooltip = null;
          this.prePoint = null;

          this._offEvent();
        };

        _proto._getItemMarker = function _getItemMarker(geom, item) {
          var options = this.options;
          var markerOption = options.marker || this.viewTheme.tooltip.marker;

          if (Util.isFunction(markerOption)) {
            var shapeType = geom.get('shapeType') || 'point';
            var shape = geom.getDefaultValue('shape') || 'circle';
            var shapeObject = Shape.getShapeFactory(shapeType);
            var cfg = {
              color: item.color
            };
            var marker = shapeObject.getMarkerCfg(shape, cfg);
            return markerOption(marker, item);
          }

          return _extends({
            fill: item.color
          }, markerOption);
        };

        return TooltipController;
      }();

      module.exports = TooltipController;
      /***/
    },
    /* 356 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The controller of chart's events
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      function isSameShape(shape1, shape2) {
        if (Util.isNil(shape1) || Util.isNil(shape2)) {
          return false;
        }

        var shape1Origin = shape1.get('origin');
        var shape2Origin = shape2.get('origin'); // hotfix: if both shapes have no data，just compare shapes.

        if (Util.isNil(shape1Origin) && Util.isNil(shape2Origin)) {
          return Util.isEqual(shape1, shape2);
        }

        return Util.isEqual(shape1Origin, shape2Origin);
      }

      function registerData(eventObj) {
        if (eventObj.shape && eventObj.shape.get('origin')) {
          eventObj.data = eventObj.shape.get('origin');
        }
      }

      var EventController = /*#__PURE__*/function () {
        function EventController(cfg) {
          this.view = null;
          this.canvas = null;
          Util.assign(this, cfg);

          this._init();
        }

        var _proto = EventController.prototype;

        _proto._init = function _init() {
          this.pixelRatio = this.canvas.get('pixelRatio');
        };

        _proto._getShapeEventObj = function _getShapeEventObj(ev) {
          return {
            x: ev.x / this.pixelRatio,
            y: ev.y / this.pixelRatio,
            target: ev.target,
            // canvas 元素
            toElement: ev.event.toElement || ev.event.relatedTarget
          };
        };

        _proto._getShape = function _getShape(x, y) {
          var view = this.view;
          var container = view.get('canvas');
          return container.getShape(x, y);
        };

        _proto._getPointInfo = function _getPointInfo(ev) {
          var view = this.view;
          var point = {
            x: ev.x / this.pixelRatio,
            y: ev.y / this.pixelRatio
          };
          var views = view.getViewsByPoint(point);
          point.views = views;
          return point;
        };

        _proto._getEventObj = function _getEventObj(ev, point, views) {
          return {
            x: point.x,
            y: point.y,
            target: ev.target,
            // canvas 元素
            toElement: ev.event.toElement || ev.event.relatedTarget,
            // 目标元素
            views: views
          };
        };

        _proto.bindEvents = function bindEvents() {
          var canvas = this.canvas;
          canvas.on('mousedown', Util.wrapBehavior(this, 'onDown'));
          canvas.on('mousemove', Util.wrapBehavior(this, 'onMove'));
          canvas.on('mouseleave', Util.wrapBehavior(this, 'onOut'));
          canvas.on('mouseup', Util.wrapBehavior(this, 'onUp'));
          canvas.on('click', Util.wrapBehavior(this, 'onClick'));
          canvas.on('dblclick', Util.wrapBehavior(this, 'onClick'));
          canvas.on('touchstart', Util.wrapBehavior(this, 'onTouchstart'));
          canvas.on('touchmove', Util.wrapBehavior(this, 'onTouchmove'));
          canvas.on('touchend', Util.wrapBehavior(this, 'onTouchend'));
        };

        _proto._triggerShapeEvent = function _triggerShapeEvent(shape, eventName, eventObj) {
          if (shape && shape.name && !shape.get('destroyed')) {
            var view = this.view;

            if (view.isShapeInView(shape)) {
              var name = shape.name + ':' + eventName;
              eventObj.view = view;
              eventObj.appendInfo = shape.get('appendInfo'); // appendInfo is defined by user

              view.emit(name, eventObj);
              var parent = view.get('parent');

              if (parent) {
                // chart 上也需要抛出该事件，本期先不抛出
                parent.emit(name, eventObj);
              }
            }
          }
        };

        _proto.onDown = function onDown(ev) {
          var view = this.view;

          var eventObj = this._getShapeEventObj(ev);

          eventObj.shape = this.currentShape;
          registerData(eventObj);
          view.emit('mousedown', eventObj);

          this._triggerShapeEvent(this.currentShape, 'mousedown', eventObj);
        };

        _proto.onMove = function onMove(ev) {
          var self = this;
          var view = self.view;
          var currentShape = self.currentShape; // 如果图形被销毁，则设置当前 shape 为空

          if (currentShape && currentShape.get('destroyed')) {
            currentShape = null;
            self.currentShape = null;
          }

          var shape = self._getShape(ev.x, ev.y) || ev.currentTarget;

          var eventObj = self._getShapeEventObj(ev);

          eventObj.shape = shape;
          registerData(eventObj);
          view.emit('mousemove', eventObj);

          self._triggerShapeEvent(shape, 'mousemove', eventObj);

          if (currentShape && !isSameShape(currentShape, shape)) {
            var leaveObj = self._getShapeEventObj(ev);

            leaveObj.shape = currentShape;
            leaveObj.toShape = shape;
            registerData(leaveObj);

            self._triggerShapeEvent(currentShape, 'mouseleave', leaveObj);
          }

          if (shape && !isSameShape(currentShape, shape)) {
            var enterObj = self._getShapeEventObj(ev);

            enterObj.shape = shape;
            enterObj.fromShape = currentShape;
            registerData(enterObj);

            self._triggerShapeEvent(shape, 'mouseenter', enterObj);
          }

          self.currentShape = shape;

          var point = self._getPointInfo(ev);

          var preViews = self.curViews || [];

          if (preViews.length === 0 && point.views.length) {
            view.emit('plotenter', self._getEventObj(ev, point, point.views));
          } // point.views 是指当前 view 或者子 view，不会取跟当前 view 同一层级的兄弟元素（view)


          if (preViews.length && point.views.length === 0) {
            view.emit('plotleave', self._getEventObj(ev, point, preViews));
          }

          if (point.views.length) {
            eventObj = self._getEventObj(ev, point, point.views);
            eventObj.shape = shape;
            registerData(eventObj);
            view.emit('plotmove', eventObj);
          }

          self.curViews = point.views;
        };

        _proto.onOut = function onOut(ev) {
          var self = this;
          var view = self.view;

          var point = self._getPointInfo(ev);

          var preViews = self.curViews || [];

          var evtObj = self._getEventObj(ev, point, preViews); // 只有没有padding 时，当前依然在 view 的 plotRange 情况下才会出现这个情况，保证 plotleave 触发


          if (self.curViews && self.curViews.length !== 0 && (!evtObj.toElement || evtObj.toElement.tagName !== 'CANVAS')) {
            view.emit('plotleave', evtObj);
            self.curViews = []; // 清空
          }
        };

        _proto.onUp = function onUp(ev) {
          var view = this.view;

          var eventObj = this._getShapeEventObj(ev);

          eventObj.shape = this.currentShape;
          view.emit('mouseup', eventObj);

          this._triggerShapeEvent(this.currentShape, 'mouseup', eventObj);
        };

        _proto.onClick = function onClick(ev) {
          var self = this;
          var view = self.view;
          var shape = self._getShape(ev.x, ev.y) || ev.currentTarget;

          var shapeEventObj = self._getShapeEventObj(ev);

          shapeEventObj.shape = shape;
          registerData(shapeEventObj);
          view.emit('click', shapeEventObj);

          self._triggerShapeEvent(shape, ev.type, shapeEventObj);

          self.currentShape = shape;

          var point = self._getPointInfo(ev);

          var views = point.views;

          if (!Util.isEmpty(views)) {
            var eventObj = self._getEventObj(ev, point, views);

            if (self.currentShape) {
              var _shape = self.currentShape;
              eventObj.shape = _shape;
              registerData(eventObj); // eventObj.data = shape.get('origin');
            }

            if (ev.type === 'dblclick') {
              view.emit('plotdblclick', eventObj);
              view.emit('dblclick', shapeEventObj);
            } else {
              view.emit('plotclick', eventObj);
            }
          }
        };

        _proto.onTouchstart = function onTouchstart(ev) {
          var view = this.view;
          var shape = this._getShape(ev.x, ev.y) || ev.currentTarget;

          var eventObj = this._getShapeEventObj(ev);

          eventObj.shape = shape;
          registerData(eventObj);
          view.emit('touchstart', eventObj);

          this._triggerShapeEvent(shape, 'touchstart', eventObj);

          this.currentShape = shape;
        };

        _proto.onTouchmove = function onTouchmove(ev) {
          var view = this.view;
          var shape = this._getShape(ev.x, ev.y) || ev.currentTarget;

          var eventObj = this._getShapeEventObj(ev);

          eventObj.shape = shape;
          registerData(eventObj);
          view.emit('touchmove', eventObj);

          this._triggerShapeEvent(shape, 'touchmove', eventObj);

          this.currentShape = shape;
        };

        _proto.onTouchend = function onTouchend(ev) {
          var view = this.view;

          var eventObj = this._getShapeEventObj(ev);

          eventObj.shape = this.currentShape;
          registerData(eventObj);
          view.emit('touchend', eventObj);

          this._triggerShapeEvent(this.currentShape, 'touchend', eventObj);
        };

        _proto.clearEvents = function clearEvents() {
          var canvas = this.canvas;
          canvas.off('mousemove', Util.getWrapBehavior(this, 'onMove'));
          canvas.off('mouseleave', Util.getWrapBehavior(this, 'onOut'));
          canvas.off('mousedown', Util.getWrapBehavior(this, 'onDown'));
          canvas.off('mouseup', Util.getWrapBehavior(this, 'onUp'));
          canvas.off('click', Util.getWrapBehavior(this, 'onClick'));
          canvas.off('dblclick', Util.getWrapBehavior(this, 'onClick'));
          canvas.off('touchstart', Util.getWrapBehavior(this, 'onTouchstart'));
          canvas.off('touchmove', Util.getWrapBehavior(this, 'onTouchmove'));
          canvas.off('touchend', Util.getWrapBehavior(this, 'onTouchend'));
        };

        return EventController;
      }();

      module.exports = EventController;
      /***/
    },
    /* 357 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The entry of chart's animation
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var Animate = __webpack_require__(125);

      var MatrixUtil = Util.MatrixUtil;
      var mat3 = MatrixUtil.mat3; // 获取图组内所有的shapes

      function getShapes(container, viewId) {
        var shapes = [];

        if (container.get('animate') === false) {
          return [];
        }

        var children = container.get('children');
        Util.each(children, function (child) {
          if (child.isGroup) {
            shapes = shapes.concat(getShapes(child, viewId));
          } else if (child.isShape && child._id) {
            var id = child._id;
            id = id.split('-')[0];

            if (id === viewId) {
              shapes.push(child);
            }
          }
        });
        return shapes;
      }

      function cache(shapes) {
        var rst = {};
        Util.each(shapes, function (shape) {
          if (!shape._id || shape.isClip) return;
          var id = shape._id;
          rst[id] = {
            _id: id,
            type: shape.get('type'),
            attrs: Util.cloneDeep(shape.attr()),
            // 原始属性
            name: shape.name,
            index: shape.get('index'),
            animateCfg: shape.get('animateCfg'),
            coord: shape.get('coord')
          };
        });
        return rst;
      }

      function getAnimate(geomType, coord, animationType, animationName) {
        var result;

        if (animationName) {
          result = Animate.Action[animationType][animationName];
        } else {
          result = Animate.getAnimation(geomType, coord, animationType);
        }

        return result;
      }

      function getAnimateCfg(geomType, animationType, animateCfg) {
        var defaultCfg = Animate.getAnimateCfg(geomType, animationType);

        if (animateCfg && animateCfg[animationType]) {
          return Util.deepMix({}, defaultCfg, animateCfg[animationType]);
        }

        return defaultCfg;
      }

      function addAnimate(cache, shapes, canvas, isUpdate) {
        var animate;
        var animateCfg;
        var canvasDrawn = false;

        if (isUpdate) {
          // Step: leave -> update -> enter
          var updateShapes = []; // 存储的是 shapes

          var newShapes = []; // 存储的是 shapes

          Util.each(shapes, function (shape) {
            var result = cache[shape._id];

            if (!result) {
              newShapes.push(shape);
            } else {
              shape.setSilent('cacheShape', result);
              updateShapes.push(shape);
              delete cache[shape._id];
            }
          });
          Util.each(cache, function (deletedShape) {
            var name = deletedShape.name,
                coord = deletedShape.coord,
                _id = deletedShape._id,
                attrs = deletedShape.attrs,
                index = deletedShape.index,
                type = deletedShape.type;
            animateCfg = getAnimateCfg(name, 'leave', deletedShape.animateCfg);
            animate = getAnimate(name, coord, 'leave', animateCfg.animation);

            if (Util.isFunction(animate)) {
              var tempShape = canvas.addShape(type, {
                attrs: attrs,
                index: index
              });
              tempShape._id = _id;
              tempShape.name = name;

              if (coord && name !== 'label') {
                var tempShapeMatrix = tempShape.getMatrix();
                var finalMatrix = mat3.multiply([], tempShapeMatrix, coord.matrix);
                tempShape.setMatrix(finalMatrix);
              }

              canvasDrawn = true;
              animate(tempShape, animateCfg, coord);
            }
          });
          Util.each(updateShapes, function (updateShape) {
            var name = updateShape.name;
            var coord = updateShape.get('coord');
            var cacheAttrs = updateShape.get('cacheShape').attrs; // 判断如果属性相同的话就不进行变换

            if (!Util.isEqual(cacheAttrs, updateShape.attr())) {
              animateCfg = getAnimateCfg(name, 'update', updateShape.get('animateCfg'));
              animate = getAnimate(name, coord, 'update', animateCfg.animation);

              if (Util.isFunction(animate)) {
                animate(updateShape, animateCfg, coord);
              } else {
                var endState = Util.cloneDeep(updateShape.attr());
                updateShape.attr(cacheAttrs);
                updateShape.animate(endState, animateCfg.duration, animateCfg.easing, function () {
                  updateShape.setSilent('cacheShape', null);
                });
              }

              canvasDrawn = true;
            }
          });
          Util.each(newShapes, function (newShape) {
            var name = newShape.name;
            var coord = newShape.get('coord');
            animateCfg = getAnimateCfg(name, 'enter', newShape.get('animateCfg'));
            animate = getAnimate(name, coord, 'enter', animateCfg.animation);

            if (Util.isFunction(animate)) {
              animate(newShape, animateCfg, coord);
              canvasDrawn = true;
            }
          });
        } else {
          Util.each(shapes, function (shape) {
            var name = shape.name;
            var coord = shape.get('coord');
            animateCfg = getAnimateCfg(name, 'appear', shape.get('animateCfg'));
            animate = getAnimate(name, coord, 'appear', animateCfg.animation);

            if (Util.isFunction(animate)) {
              animate(shape, animateCfg, coord);
              canvasDrawn = true;
            }
          });
        }

        return canvasDrawn;
      }

      module.exports = {
        execAnimation: function execAnimation(view, isUpdate) {
          var viewContainer = view.get('middlePlot');
          var axisContainer = view.get('backPlot');
          var viewId = view.get('_id');
          var canvas = view.get('canvas');
          var caches = canvas.get(viewId + 'caches') || [];

          if (caches.length === 0) {
            isUpdate = false;
          }

          var shapes = getShapes(viewContainer, viewId);
          var axisShapes = getShapes(axisContainer, viewId);
          var cacheShapes = shapes.concat(axisShapes);
          canvas.setSilent(viewId + 'caches', cache(cacheShapes));
          var drawn;

          if (isUpdate) {
            drawn = addAnimate(caches, cacheShapes, canvas, isUpdate);
          } else {
            drawn = addAnimate(caches, shapes, canvas, isUpdate);
          }

          if (!drawn) {
            canvas.draw();
          }
        }
      };
      /***/
    },
    /* 358 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview The class of canvas plot
       * @author sima.zhang
       */
      var Util = __webpack_require__(0);

      var _require = __webpack_require__(16),
          Group = _require.Group;

      var AUTO_STR = 'auto';

      var PlotBack = function PlotBack(cfg) {
        PlotBack.superclass.constructor.call(this, cfg);
      };

      Util.extend(PlotBack, Group);
      Util.augment(PlotBack, {
        getDefaultCfg: function getDefaultCfg() {
          return {
            /**
             * 类型
             * @type {String}
             */
            type: 'plotBack',

            /**
             * 画布边距
             * @type {Number | Array | Object | "auto"}
             */
            padding: null,

            /**
             * 大背景
             * @type {Object}
             */
            background: null,

            /**
             * 绘图区域范围
             * @type {Object}
             */
            plotRange: null,

            /**
             * 绘图区域背景
             * @type {Object}
             */
            plotBackground: null
          };
        },
        _beforeRenderUI: function _beforeRenderUI() {
          this._calculateRange();
        },
        _renderUI: function _renderUI() {
          this._renderBackground();

          this._renderPlotBackground();
        },
        _renderBackground: function _renderBackground() {
          var self = this;
          var background = self.get('background');

          if (background) {
            var canvas = this.get('canvas');
            var width = self.get('width') || canvas.get('width');
            var height = self.get('height') || canvas.get('height');
            var cfg = {
              x: 0,
              y: 0,
              width: width,
              height: height
            };
            var rect = self.get('backgroundShape');

            if (!rect) {
              rect = this.addShape('rect', {
                attrs: Util.mix(cfg, background)
              });
              this.set('backgroundShape', rect);
            } else {
              rect.attr(cfg);
            }
          } else {
            return;
          }
        },
        _renderPlotBackground: function _renderPlotBackground() {
          var self = this;
          var plotBackground = self.get('plotBackground');

          if (plotBackground) {
            var plotRange = self.get('plotRange');
            var width = plotRange.br.x - plotRange.bl.x;
            var height = plotRange.br.y - plotRange.tr.y;
            var tl = plotRange.tl;
            var cfg = {
              x: tl.x,
              y: tl.y,
              width: width,
              height: height
            };
            var plotBackShape = self.get('plotBackShape');

            if (!plotBackShape) {
              if (plotBackground.image) {
                cfg.img = plotBackground.image;
                plotBackShape = self.addShape('image', {
                  attrs: cfg
                });
              } else {
                // 矩形
                Util.mix(cfg, plotBackground);
                plotBackShape = self.addShape('rect', {
                  attrs: cfg
                });
              }

              self.set('plotBackShape', plotBackShape);
            } else {
              plotBackShape.attr(cfg);
            }
          } else {
            return;
          }
        },
        _convert: function _convert(val, isHorizontal) {
          if (Util.isString(val)) {
            if (val === AUTO_STR) {
              val = 0;
            } else if (val.includes('%')) {
              var canvas = this.get('canvas');
              var width = this.get('width') || canvas.get('width');
              var height = this.get('height') || canvas.get('height');
              val = parseInt(val, 10) / 100;
              val = isHorizontal ? val * width : val * height;
            }
          }

          return val;
        },
        _calculateRange: function _calculateRange() {
          var self = this;
          var plotRange = self.get('plotRange');

          if (Util.isNil(plotRange)) {
            plotRange = {};
          }

          var padding = self.get('padding');
          var canvas = this.get('canvas');
          var width = self.get('width') || canvas.get('width');
          var height = self.get('height') || canvas.get('height');
          var allPadding = Util.toAllPadding(padding);

          var top = self._convert(allPadding[0], false);

          var right = self._convert(allPadding[1], true);

          var bottom = self._convert(allPadding[2], false);

          var left = self._convert(allPadding[3], true);

          var minX = Math.min(left, width - right);
          var maxX = Math.max(left, width - right);
          var minY = Math.min(height - bottom, top);
          var maxY = Math.max(height - bottom, top);
          plotRange.tl = {
            x: minX,
            y: minY
          }; // top-left

          plotRange.tr = {
            x: maxX,
            y: minY
          }; // top-right

          plotRange.bl = {
            x: minX,
            y: maxY
          }; // bottom-left

          plotRange.br = {
            x: maxX,
            y: maxY
          }; // bottom-right

          plotRange.cc = {
            x: (maxX + minX) / 2,
            y: (maxY + minY) / 2
          };
          this.set('plotRange', plotRange);
        },
        repaint: function repaint() {
          this._calculateRange();

          this._renderBackground();

          this._renderPlotBackground();

          return this;
        }
      });
      module.exports = PlotBack;
      /***/
    },
    /* 359 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 需要计算所占x轴上的宽度的辅助类
       * @author sima.zhang1990@gmail.com
       * @author dxq613@gmail.com
       */
      var Global = __webpack_require__(7);

      var Util = __webpack_require__(0); // 已经排序后的数据查找距离最小的


      function findMinDistance(arr, scale) {
        var count = arr.length; // 日期类型的 values 经常上文本类型，所以需要转换一下

        if (Util.isString(arr[0])) {
          arr = arr.map(function (v) {
            return scale.translate(v);
          });
        }

        var distance = arr[1] - arr[0];

        for (var i = 2; i < count; i++) {
          var tmp = arr[i] - arr[i - 1];

          if (distance > tmp) {
            distance = tmp;
          }
        }

        return distance;
      }

      var SizeMixin = {
        getDefaultSize: function getDefaultSize() {
          var defaultSize = this.get('defaultSize');
          var viewTheme = this.get('viewTheme') || Global;

          if (!defaultSize) {
            var coord = this.get('coord');
            var xScale = this.getXScale();
            var xValues = xScale.values;
            var dataArray = this.get('dataArray');
            var count;

            if (xScale.isLinear && xValues.length > 1) {
              xValues.sort();
              var interval = findMinDistance(xValues, xScale);
              count = (xScale.max - xScale.min) / interval;

              if (xValues.length > count) {
                count = xValues.length;
              }
            } else {
              count = xValues.length;
            }

            var range = xScale.range;
            var normalizeSize = 1 / count;
            var widthRatio = 1;

            if (this.isInCircle()) {
              if (coord.isTransposed && count > 1) {
                // 极坐标下多层环图
                widthRatio = viewTheme.widthRatio.multiplePie;
              } else {
                widthRatio = viewTheme.widthRatio.rose;
              }
              /* if (dataArray.length > 1) {
                normalizeSize *= (range[1] - range[0]);
              } */

            } else {
              if (xScale.isLinear) {
                normalizeSize *= range[1] - range[0];
              }

              widthRatio = viewTheme.widthRatio.column; // 柱状图要除以2
            }

            normalizeSize *= widthRatio;

            if (this.hasAdjust('dodge')) {
              var _this$_getDodgeCfg = this._getDodgeCfg(dataArray),
                  dodgeCount = _this$_getDodgeCfg.dodgeCount,
                  dodgeRatio = _this$_getDodgeCfg.dodgeRatio;

              normalizeSize = normalizeSize / dodgeCount;

              if (dodgeRatio > 0) {
                normalizeSize = dodgeRatio * normalizeSize / widthRatio;
              }
            }

            defaultSize = normalizeSize;
            this.set('defaultSize', defaultSize);
          }

          return defaultSize;
        },
        _getDodgeCfg: function _getDodgeCfg(dataArray) {
          var adjusts = this.get('adjusts');
          var dodgeBy;
          var dodgeRatio;
          var count = dataArray.length;
          Util.each(adjusts, function (adjust) {
            if (adjust.type === 'dodge') {
              dodgeBy = adjust.dodgeBy;
              dodgeRatio = adjust.dodgeRatio;
            }
          });

          if (dodgeBy) {
            var mergeData = Util.Array.merge(dataArray);
            var values = Util.Array.values(mergeData, dodgeBy);
            count = values.length;
          }

          return {
            dodgeCount: count,
            dodgeRatio: dodgeRatio
          };
        },
        getDimWidth: function getDimWidth(dimName) {
          var coord = this.get('coord');
          var start = coord.convertPoint({
            x: 0,
            y: 0
          });
          var end = coord.convertPoint({
            x: dimName === 'x' ? 1 : 0,
            y: dimName === 'x' ? 0 : 1
          });
          var width = 0;

          if (start && end) {
            width = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
          }

          return width;
        },
        _getWidth: function _getWidth() {
          var coord = this.get('coord');
          var width; // x轴的长度

          if (this.isInCircle() && !coord.isTransposed) {
            // 极坐标下 width 为弧长
            width = (coord.endAngle - coord.startAngle) * coord.radius;
          } else {
            width = this.getDimWidth('x'); // 不需要判断transpose
          }

          return width;
        },
        _toNormalizedSize: function _toNormalizedSize(size) {
          var width = this._getWidth();

          return size / width;
        },
        _toCoordSize: function _toCoordSize(normalizeSize) {
          var width = this._getWidth();

          return width * normalizeSize;
        },
        getNormalizedSize: function getNormalizedSize(obj) {
          var size = this.getAttrValue('size', obj);

          if (Util.isNil(size)) {
            size = this.getDefaultSize();
          } else {
            size = this._toNormalizedSize(size);
          }

          return size;
        },
        getSize: function getSize(obj) {
          var size = this.getAttrValue('size', obj);

          if (Util.isNil(size)) {
            var normalizeSize = this.getDefaultSize();
            size = this._toCoordSize(normalizeSize);
          }

          return size;
        }
      };
      module.exports = SizeMixin;
      /***/
    },
    /* 360 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 分割数据用于处理存在 null 值的折线图、区域图
       * @author dxq613@gmail.com
       */
      var Util = __webpack_require__(0);

      var Global = __webpack_require__(7);

      module.exports = {
        splitData: function splitData(data) {
          var viewTheme = this.get('viewTheme') || Global;
          if (!data.length) return [];
          var arr = [];
          var tmp = [];
          var yScale = this.getYScale();
          var yDim = yScale.field;
          var yValue;
          Util.each(data, function (obj) {
            yValue = obj._origin ? obj._origin[yDim] : obj[yDim];

            if (viewTheme.connectNulls) {
              // 如果忽视 Null 直接连接节点，则将 value = null 的数据过滤掉
              if (!Util.isNil(yValue)) {
                tmp.push(obj);
              }
            } else {
              if (Util.isArray(yValue) && Util.isNil(yValue[0]) || Util.isNil(yValue)) {
                if (tmp.length) {
                  arr.push(tmp);
                  tmp = [];
                }
              } else {
                tmp.push(obj);
              }
            }
          });

          if (tmp.length) {
            arr.push(tmp);
          }

          return arr;
        }
      };
      /***/
    },
    /* 361 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 路径图，无序的线图
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var SplitMixin = __webpack_require__(360);

      var Util = __webpack_require__(0);

      var Path = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Path, _GeomBase);

        var _proto = Path.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'path';
          cfg.shapeType = 'line';
          return cfg;
        };

        function Path(cfg) {
          var _this;

          _this = _GeomBase.call(this, cfg) || this;
          Util.assign(_assertThisInitialized(_this), SplitMixin);
          return _this;
        }

        _proto.getDrawCfg = function getDrawCfg(obj) {
          var cfg = _GeomBase.prototype.getDrawCfg.call(this, obj);

          cfg.isStack = this.hasStack();
          return cfg;
        };

        _proto.draw = function draw(data, container, shapeFactory, index) {
          var self = this;
          var splitArray = this.splitData(data);
          var cfg = this.getDrawCfg(data[0]);

          self._applyViewThemeShapeStyle(cfg, cfg.shape, shapeFactory);

          cfg.origin = data; // path,line 等图的origin 是整个序列

          Util.each(splitArray, function (subData, splitedIndex) {
            if (!Util.isEmpty(subData)) {
              cfg.splitedIndex = splitedIndex; // 传入分割片段索引 用于生成id

              cfg.points = subData;
              var geomShape = shapeFactory.drawShape(cfg.shape, cfg, container);
              self.appendShapeInfo(geomShape, index + splitedIndex);
            }
          });
        };

        return Path;
      }(GeomBase);

      GeomBase.Path = Path;
      module.exports = Path;
      /***/
    },
    /* 362 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(373);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__namespaces__ = __webpack_require__(374);

      function creatorInherit(name) {
        return function () {
          var document = this.ownerDocument,
              uri = this.namespaceURI;
          return uri === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b"
          /* xhtml */
          ] && document.documentElement.namespaceURI === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b"
          /* xhtml */
          ] ? document.createElement(name) : document.createElementNS(uri, name);
        };
      }

      function creatorFixed(fullname) {
        return function () {
          return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name) {
        var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__["a"
        /* default */
        ])(name);
        return (fullname.local ? creatorFixed : creatorInherit)(fullname);
      };
      /***/

    },
    /* 363 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (node, event) {
        var svg = node.ownerSVGElement || node;

        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }

        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      };
      /***/

    },
    /* 364 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b) {
        return a = +a, b = +b, function (t) {
          return a * (1 - t) + b * t;
        };
      };
      /***/

    },
    /* 365 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["b"] = tweenValue;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(46);

      function tweenRemove(id, name) {
        var tween0, tween1;
        return function () {
          var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
          /* set */
          ])(this, id),
              tween = schedule.tween; // If this node shared tween with the previous node,
          // just assign the updated shared tween and we’re done!
          // Otherwise, copy-on-write.

          if (tween !== tween0) {
            tween1 = tween0 = tween;

            for (var i = 0, n = tween1.length; i < n; ++i) {
              if (tween1[i].name === name) {
                tween1 = tween1.slice();
                tween1.splice(i, 1);
                break;
              }
            }
          }

          schedule.tween = tween1;
        };
      }

      function tweenFunction(id, name, value) {
        var tween0, tween1;
        if (typeof value !== "function") throw new Error();
        return function () {
          var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
          /* set */
          ])(this, id),
              tween = schedule.tween; // If this node shared tween with the previous node,
          // just assign the updated shared tween and we’re done!
          // Otherwise, copy-on-write.

          if (tween !== tween0) {
            tween1 = (tween0 = tween).slice();

            for (var t = {
              name: name,
              value: value
            }, i = 0, n = tween1.length; i < n; ++i) {
              if (tween1[i].name === name) {
                tween1[i] = t;
                break;
              }
            }

            if (i === n) tween1.push(t);
          }

          schedule.tween = tween1;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value) {
        var id = this._id;
        name += "";

        if (arguments.length < 2) {
          var tween = Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f"
          /* get */
          ])(this.node(), id).tween;

          for (var i = 0, n = tween.length, t; i < n; ++i) {
            if ((t = tween[i]).name === name) {
              return t.value;
            }
          }

          return null;
        }

        return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
      };

      function tweenValue(transition, name, value) {
        var id = transition._id;
        transition.each(function () {
          var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
          /* set */
          ])(this, id);
          (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
        });
        return function (node) {
          return Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f"
          /* get */
          ])(node, id).value[name];
        };
      }
      /***/

    },
    /* 366 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview facets of chart
       * @author dxq613@gmail.com
       */
      var Global = __webpack_require__(7);

      var Util = __webpack_require__(0);

      var assign = Util.assign;
      var isNil = Util.isNil;
      var isArray = Util.isArray;
      var cloneDeep = Util.cloneDeep; // 绑定事件

      var wrapBehavior = Util.wrapBehavior; // 获取绑定的事件

      var getWrapBehavior = Util.getWrapBehavior;

      var Base = /*#__PURE__*/function () {
        var _proto = Base.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          return {
            chart: null,
            group: null,

            /**
             * 是否默认显示每个分面的title
             * @type {Boolean}
             */
            showTitle: true,

            /**
             * 是否自动修改坐标轴的信息
             * @type {Boolean}
             */
            autoSetAxis: true,

            /**
             * View 的内边框
             * @type {Number|Array}
             */
            padding: 10,

            /**
             * 遍历每个view 的回调函数
             * @type {Function}
             */
            eachView: null,

            /**
             * 分面的字段名列表
             * @type {Array}
             */
            fields: [],

            /**
             * 列值的的标题
             * @type {Object}
             */
            colTitle: {
              offsetY: -15,
              style: {
                fontSize: 14,
                textAlign: 'center',
                fill: '#666',
                fontFamily: Global.fontFamily
              }
            },
            rowTitle: {
              offsetX: 15,
              style: {
                fontSize: 14,
                textAlign: 'center',
                rotate: 90,
                fill: '#666',
                fontFamily: Global.fontFamily
              }
            }
          };
        };

        function Base(cfg) {
          var defaultCfg = this.getDefaultCfg();
          assign(this, defaultCfg, cfg);
          this.init();
        }

        _proto.init = function init() {
          if (!this.chart) {
            throw new Error('Facets Error: please specify the chart!');
          }

          this._bindEvent();

          this.initContainer();

          if (this.chart.get('data')) {
            this.initViews();
          }
        };

        _proto.initContainer = function initContainer() {
          var chart = this.chart;
          var frontPlot = chart.get('frontPlot');
          var group = frontPlot.addGroup();
          this.group = group;
        };

        _proto.initViews = function initViews() {
          var chart = this.chart;
          var data = chart.get('data');
          var eachView = this.eachView;
          var facets = this.generateFacets(data);

          for (var i = 0; i < facets.length; i++) {
            var facet = facets[i];
            var region = facet.region;
            var view = chart.view({
              start: region.start,
              end: region.end,
              padding: this.padding
            });
            view.source(facet.data);
            this.beforeProcessView(view, facet);

            if (eachView) {
              eachView(view, facet);
            }

            this.afterProcessView(view, facet);
            facet.view = view;
          }

          this.facets = facets;
        }
        /**
         * 处理 view 前
         * @protected
         */
        ;

        _proto.beforeProcessView = function beforeProcessView()
        /* view, facet */
        {}
        /**
         * 处理view
         * @param {Object} view 视图
         * @param {Object} facet 分面信息
         * @protected
         */
        ;

        _proto.afterProcessView = function afterProcessView(view, facet) {
          if (this.autoSetAxis) {
            this.processAxis(view, facet);
          }
        };

        _proto.processAxis = function processAxis(view, facet) {
          var viewOptions = view.get('options');
          var geoms = view.get('geoms');

          if ((!viewOptions.coord.type || viewOptions.coord.type === 'rect') && geoms.length) {
            var field = geoms[0].get('attrOptions').position.field;
            var fields = isArray(field) ? field : field.split('*').map(function (str) {
              return str.trim();
            });
            var xField = fields[0];
            var yField = fields[1];

            if (isNil(viewOptions.axes)) {
              viewOptions.axes = {};
            }

            var axes = viewOptions.axes;

            if (axes !== false) {
              if (xField && axes[xField] !== false) {
                axes[xField] = axes[xField] || {};
                this.setXAxis(xField, axes, facet);
              }

              if (yField && axes[yField] !== false) {
                axes[yField] = axes[yField] || {};
                this.setYAxis(yField, axes, facet);
              }
            }
          }
        };

        _proto.setXAxis = function setXAxis()
        /* xField, axes, facet */
        {};

        _proto.setYAxis = function setYAxis()
        /* yField, axes, facet */
        {} // 默认显示各列的标题
        ;

        _proto.renderTitle = function renderTitle(view, facet) {
          this.drawColTitle(view, facet);
        };

        _proto.getScaleText = function getScaleText(field, value, view) {
          var rst;

          if (field) {
            var scales = view.get('scales');
            var scale = scales[field];

            if (!scale) {
              scale = view.createScale(field);
            }

            rst = scale.getText(value);
          } else {
            rst = value;
          }

          return rst;
        };

        _proto.drawColTitle = function drawColTitle(view, facet) {
          var text = this.getScaleText(facet.colField, facet.colValue, view);
          var colTextCfg = assign({
            position: ['50%', '0%'],
            content: text
          }, this.colTitle);
          view.guide().text(colTextCfg);
        };

        _proto.drawRowTitle = function drawRowTitle(view, facet) {
          var text = this.getScaleText(facet.rowField, facet.rowValue, view);
          var rowTextCfg = assign({
            position: ['100%', '50%'],
            content: text
          }, cloneDeep(this.rowTitle));
          view.guide().text(rowTextCfg);
        }
        /**
         * 数据过滤器
         * @protected
         * @param {Array} conditions 过滤条件
         * @return {Function} 过滤函数
         */
        ;

        _proto.getFilter = function getFilter(conditions) {
          var filter = function filter(obj) {
            var filtered = true;
            conditions.forEach(function (cond) {
              var field = cond.field;
              var value = cond.value; // const values = cond.values;

              var tmp = true;

              if (!isNil(value) && field) {
                tmp = obj[field] === value;
              }

              filtered = filtered && tmp;
            });
            return filtered;
          };

          return filter;
        }
        /**
         * 获取字段对应的值
         * @protected
         * @param  {String} field 字段名
         * @param  {Array} data 数据
         * @return {Array} 字段对应的值
         */
        ;

        _proto.getFieldValues = function getFieldValues(field, data) {
          var rst = [];
          var tmpMap = {};

          for (var i = 0; i < data.length; i++) {
            var obj = data[i];
            var value = obj[field];

            if (!isNil(value) && !tmpMap[value]) {
              rst.push(value);
              tmpMap[value] = true;
            }
          }

          return rst;
        };

        _proto.getRegion = function getRegion(rows, cols, xIndex, yIndex) {
          var xWidth = 1 / cols; // x轴方向的每个分面的偏移

          var yWidth = 1 / rows; // y轴方向的每个分面的偏移

          var start = {
            x: xWidth * xIndex,
            y: yWidth * yIndex
          };
          var end = {
            x: start.x + xWidth,
            y: start.y + yWidth
          };
          return {
            start: start,
            end: end
          };
        }
        /**
         * 生成分面
         * @protected
         * @return {Array} 多个分面集合
         */
        ;

        _proto.generateFacets = function generateFacets()
        /* data */
        {
          return [];
        };

        _proto._bindEvent = function _bindEvent() {
          var chart = this.chart;
          chart.on('afterchangedata', wrapBehavior(this, 'onDataChange'));
          chart.on('beforeclear', wrapBehavior(this, 'onClear'));
          chart.on('beforedestroy', wrapBehavior(this, 'destroy'));
          chart.on('beforepaint', wrapBehavior(this, 'onPaint'));
          chart.on('setdata', wrapBehavior(this, 'onDataChange'));
        };

        _proto._clearEvent = function _clearEvent() {
          var chart = this.chart;

          if (chart) {
            chart.off('afterchangedata', getWrapBehavior(this, 'onDataChange'));
            chart.off('beforeclear', getWrapBehavior(this, 'onClear'));
            chart.off('beforedestroy', getWrapBehavior(this, 'destroy'));
            chart.off('beforepaint', getWrapBehavior(this, 'onPaint'));
            chart.off('setdata', getWrapBehavior(this, 'onDataChange'));
          }
        };

        _proto._clearFacets = function _clearFacets() {
          var facets = this.facets;
          var chart = this.chart;

          if (facets) {
            for (var i = 0; i < facets.length; i++) {
              var facet = facets[i];
              chart.removeView(facet.view);
            }
          }

          this.facets = null;
        };

        _proto.onClear = function onClear() {
          this.onRemove();
        };

        _proto.onPaint = function onPaint() {
          if (this.showTitle) {
            var facets = this.facets;

            for (var i = 0; i < facets.length; i++) {
              var facet = facets[i];
              var view = facet.view;
              this.renderTitle(view, facet);
            }
          }
        };

        _proto.onDataChange = function onDataChange() {
          this._clearFacets();

          this.initViews();
        };

        _proto.onRemove = function onRemove() {
          this._clearFacets();

          this._clearEvent();

          this.group && this.group.remove();
          this.chart = null;
          this.facets = null;
          this.group = null;
        };

        _proto.destroy = function destroy() {
          this.onRemove();
          this.destroyed = true;
        };

        return Base;
      }();

      module.exports = Base;
      /***/
    },
    /* 367 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview interval geometry
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var Util = __webpack_require__(0);

      var SizeMixin = __webpack_require__(359);

      __webpack_require__(368);

      var Interval = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Interval, _GeomBase);

        var _proto = Interval.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'interval';
          cfg.shapeType = 'interval';
          cfg.generatePoints = true;
          return cfg;
        };

        function Interval(cfg) {
          var _this;

          _this = _GeomBase.call(this, cfg) || this;
          Util.assign(_assertThisInitialized(_this), SizeMixin);
          return _this;
        }

        _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
          var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

          cfg.size = this.getNormalizedSize(obj);
          return cfg;
        };

        _proto.clearInner = function clearInner() {
          _GeomBase.prototype.clearInner.call(this);

          this.set('defaultSize', null);
        };

        return Interval;
      }(GeomBase);

      var IntervalStack = /*#__PURE__*/function (_Interval) {
        _inheritsLoose(IntervalStack, _Interval);

        function IntervalStack() {
          return _Interval.apply(this, arguments) || this;
        }

        var _proto2 = IntervalStack.prototype;

        _proto2.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interval.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'stack'
          }];
          return cfg;
        };

        return IntervalStack;
      }(Interval);

      var IntervalDodge = /*#__PURE__*/function (_Interval2) {
        _inheritsLoose(IntervalDodge, _Interval2);

        function IntervalDodge() {
          return _Interval2.apply(this, arguments) || this;
        }

        var _proto3 = IntervalDodge.prototype;

        _proto3.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interval2.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'dodge'
          }];
          return cfg;
        };

        return IntervalDodge;
      }(Interval);

      var IntervalSymmetric = /*#__PURE__*/function (_Interval3) {
        _inheritsLoose(IntervalSymmetric, _Interval3);

        function IntervalSymmetric() {
          return _Interval3.apply(this, arguments) || this;
        }

        var _proto4 = IntervalSymmetric.prototype;

        _proto4.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interval3.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'symmetric'
          }];
          return cfg;
        };

        return IntervalSymmetric;
      }(Interval);

      Interval.Stack = IntervalStack;
      Interval.Dodge = IntervalDodge;
      Interval.Symmetric = IntervalSymmetric;
      GeomBase.Interval = Interval;
      GeomBase.IntervalStack = IntervalStack;
      GeomBase.IntervalDodge = IntervalDodge;
      GeomBase.IntervalSymmetric = IntervalSymmetric;
      module.exports = Interval;
      /***/
    },
    /* 368 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview interval shapes
       * @author dxq613@gmail.com
       * @author sima.zhang1990@gmail.com
       * @author huangtonger@aliyun.com
       */
      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var PathUtil = __webpack_require__(23);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      var G = __webpack_require__(16);

      var GPathUtil = Util.PathUtil; // 获取柱状图的几个点

      function getRectPoints(cfg, isPyramid) {
        var x = cfg.x;
        var y = cfg.y;
        var y0 = cfg.y0; // 0 点的位置

        var width = cfg.size; // 有3种情况，
        // 1. y，x都不是数组
        // 2. y是数组，x不是
        // 3. x是数组，y不是

        var ymin = y0;
        var ymax = y;

        if (Util.isArray(y)) {
          ymax = y[1];
          ymin = y[0];
        }

        var xmin;
        var xmax;

        if (Util.isArray(x)) {
          xmin = x[0];
          xmax = x[1];
        } else {
          xmin = x - width / 2;
          xmax = x + width / 2;
        }

        var points = [];
        points.push({
          x: xmin,
          y: ymin
        }, {
          x: xmin,
          y: ymax
        });

        if (isPyramid) {
          points.push({
            x: xmax,
            y: (ymax + ymin) / 2
          });
        } else {
          points.push({
            x: xmax,
            y: ymax
          }, {
            x: xmax,
            y: ymin
          });
        }

        return points;
      }

      function getRectPath(points) {
        var path = [];

        for (var i = 0; i < points.length; i++) {
          var point = points[i];

          if (point) {
            var action = i === 0 ? 'M' : 'L';
            path.push([action, point.x, point.y]);
          }
        }

        var first = points[0];
        path.push(['L', first.x, first.y]);
        path.push(['z']);
        return path;
      }

      function getLinePoints(cfg) {
        var x = cfg.x;
        var y = cfg.y;
        var y0 = cfg.y0; // 0 点的位置

        var points = [];

        if (Util.isArray(y)) {
          Util.each(y, function (yItem, idx) {
            points.push({
              x: Util.isArray(x) ? x[idx] : x,
              y: yItem
            });
          });
        } else {
          points.push({
            x: x,
            y: y
          }, {
            x: x,
            y: y0
          });
        }

        return points;
      }

      function getTickPoints(cfg) {
        var x = cfg.x;
        var y = Util.isArray(cfg.y) ? cfg.y[1] : cfg.y;
        var y0 = Util.isArray(cfg.y) ? cfg.y[0] : cfg.y0;
        var barWidth = cfg.size;
        var points = [];
        points.push({
          x: x - barWidth / 2,
          y: y
        }, {
          x: x + barWidth / 2,
          y: y
        }, {
          x: x,
          y: y
        }, {
          x: x,
          y: y0
        }, {
          x: x - barWidth / 2,
          y: y0
        }, {
          x: x + barWidth / 2,
          y: y0
        });
        return points;
      }

      function getTickPath(points) {
        var path = [];
        path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y]);
        return path;
      }

      function getFillAttrs(cfg) {
        var defaultAttrs = Global.shape.interval;
        var attrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addFillAttrs(attrs, cfg);

        if (cfg.color) {
          attrs.stroke = attrs.stroke || cfg.color;
        }

        return attrs;
      }

      function getLineAttrs(cfg) {
        var defaultAttrs = Global.shape.hollowInterval;
        var attrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addStrokeAttrs(attrs, cfg);
        return attrs;
      }

      function getFunnelPath(cfg, isFunnel) {
        var path = [];
        var points = cfg.points;
        var nextPoints = cfg.nextPoints;

        if (!Util.isNil(nextPoints)) {
          path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);
        } else if (isFunnel) {
          path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);
        } else {
          path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[2].x, points[2].y], ['Z']);
        }

        return path;
      }

      function getThetaCfg(point, coord) {
        var r = coord.getRadius();
        var inner = coord.innerRadius;
        var startAngle;
        var endAngle;
        var ir = r * inner;
        var startPoint;
        var endPoint;

        if (!Util.isArray(point.x) && Util.isArray(point.y)) {
          point.x = [point.x, point.x]; // 如果x是一个值，y是数组，将x转成数组
        }

        if (Util.isArray(point.x)) {
          startPoint = {
            x: point.x[0],
            y: point.y[0]
          };
          endPoint = {
            x: point.x[1],
            y: point.y[1]
          };
          startAngle = PathUtil.getPointAngle(coord, startPoint);
          endAngle = PathUtil.getPointAngle(coord, endPoint);

          if (endAngle <= startAngle) {
            // 考虑占比百分百的情形
            endAngle = endAngle + Math.PI * 2;
          }
        } else {
          endPoint = point;
          startAngle = coord.startAngle;
          endAngle = PathUtil.getPointAngle(coord, endPoint);
        }

        return {
          r: r,
          ir: ir,
          startAngle: startAngle,
          endAngle: endAngle
        };
      } // 获取选中时的样式，当前仅支持饼图


      function _getSelectedCfg(type, cfg) {
        var geom = cfg.geom;
        var coord = geom.get('coord');
        var point = cfg.point;
        var r = 7.5;
        var selectedCfg;

        if (coord && coord.type === 'theta') {
          var thetaCfg = getThetaCfg(point, coord);
          var middleAngle = (thetaCfg.endAngle - thetaCfg.startAngle) / 2 + thetaCfg.startAngle;
          var x = r * Math.cos(middleAngle);
          var y = r * Math.sin(middleAngle);
          selectedCfg = {
            transform: [['t', x, y]]
          };
        }

        return Util.mix({}, selectedCfg);
      }

      var Interval = Shape.registerFactory('interval', {
        defaultShapeType: 'rect',
        getActiveCfg: function getActiveCfg(type, cfg) {
          if (!type || Util.inArray(['rect', 'funnel', 'pyramid'], type)) {
            // 透明度降低 0.15
            var fillOpacity = cfg.fillOpacity || cfg.opacity || 1;
            return {
              fillOpacity: fillOpacity - 0.15
            };
          }

          var lineWidth = cfg.lineWidth || 0;
          return {
            lineWidth: lineWidth + 1
          };
        },
        getDefaultPoints: function getDefaultPoints(pointInfo) {
          return getRectPoints(pointInfo);
        },
        getSelectedCfg: function getSelectedCfg(type, cfg) {
          return _getSelectedCfg(type, cfg);
        }
      }); // 默认柱状图

      Shape.registerShape('interval', 'rect', {
        draw: function draw(cfg, container) {
          var attrs = getFillAttrs(cfg);
          var path = getRectPath(cfg.points);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var rectCfg = getFillAttrs(cfg);
          var isInCircle = cfg.isInCircle;
          return Util.mix({
            symbol: isInCircle ? 'circle' : 'square',
            radius: isInCircle ? 4.5 : 4
          }, rectCfg);
        }
      }); // 空心柱状图

      Shape.registerShape('interval', 'hollowRect', {
        draw: function draw(cfg, container) {
          var attrs = getLineAttrs(cfg);
          var path = getRectPath(cfg.points);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var rectCfg = getLineAttrs(cfg);
          var isInCircle = cfg.isInCircle;
          return Util.mix({
            symbol: isInCircle ? 'circle' : 'square',
            radius: isInCircle ? 4.5 : 4
          }, rectCfg);
        }
      }); // 线形柱状图

      Shape.registerShape('interval', 'line', {
        getPoints: function getPoints(pointInfo) {
          return getLinePoints(pointInfo);
        },
        draw: function draw(cfg, container) {
          var attrs = getLineAttrs(cfg);
          attrs.lineWidth = cfg.size || 1; // size 就是线的宽度

          var path = getRectPath(cfg.points);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var lineCfg = getLineAttrs(cfg);
          return Util.mix({
            symbol: 'line',
            radius: 5
          }, lineCfg);
        }
      }); // 钉子形的柱状图

      Shape.registerShape('interval', 'tick', {
        getPoints: function getPoints(pointInfo) {
          return getTickPoints(pointInfo);
        },
        draw: function draw(cfg, container) {
          var attrs = getLineAttrs(cfg); // @2018-12-25 by blue.lb 经过测试发现size代表的是宽度，而style中的lineWidth才是设置线宽，放在interval暂时先特殊处理

          if (!attrs.lineWidth) {
            attrs.lineWidth = 2;
          }

          var path = getTickPath(cfg.points);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var lineCfg = getLineAttrs(cfg);
          return Util.mix({
            symbol: 'tick',
            radius: 5
          }, lineCfg);
        }
      }); // 漏斗图

      Shape.registerShape('interval', 'funnel', {
        getPoints: function getPoints(pointInfo) {
          pointInfo.size = pointInfo.size * 2; // 漏斗图的 size 是柱状图的两倍

          return getRectPoints(pointInfo);
        },
        draw: function draw(cfg, container) {
          var attrs = getFillAttrs(cfg);
          var path = getFunnelPath(cfg, true);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var funnelCfg = getFillAttrs(cfg);
          return Util.mix({
            symbol: 'square',
            radius: 4
          }, funnelCfg);
        }
      }); // 金字塔图

      Shape.registerShape('interval', 'pyramid', {
        getPoints: function getPoints(pointInfo) {
          pointInfo.size = pointInfo.size * 2; // 漏斗图的 size 是柱状图的两倍

          return getRectPoints(pointInfo, true);
        },
        draw: function draw(cfg, container) {
          var attrs = getFillAttrs(cfg);
          var path = getFunnelPath(cfg, false);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var funnelCfg = getFillAttrs(cfg);
          return Util.mix({
            symbol: 'square',
            radius: 4
          }, funnelCfg);
        }
      }); // 水波图

      /**
       * 用贝塞尔曲线模拟正弦波
       * Using Bezier curves to fit sine wave.
       * There is 4 control points for each curve of wave,
       * which is at 1/4 wave length of the sine wave.
       *
       * The control points for a wave from (a) to (d) are a-b-c-d:
       *          c *----* d
       *     b *
       *       |
       * ... a * ..................
       *
       * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)
       *
       * @param {number} x          x position of the left-most point (a)
       * @param {number} stage      0-3, stating which part of the wave it is
       * @param {number} waveLength wave length of the sine wave
       * @param {number} amplitude  wave amplitude
       * @return {Array} 正弦片段曲线
       */

      function getWaterWavePositions(x, stage, waveLength, amplitude) {
        if (stage === 0) {
          return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];
        } else if (stage === 1) {
          return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];
        } else if (stage === 2) {
          return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];
        }

        return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];
      }
      /**
       * 获取水波路径
       * @param  {number} radius          半径
       * @param  {number} waterLevel      水位
       * @param  {number} waveLength      波长
       * @param  {number} phase           相位
       * @param  {number} amplitude       震幅
       * @param  {number} cx              圆心x
       * @param  {number} cy              圆心y
       * @return {Array}  path            路径
       * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135
       */


      function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
        var curves = Math.ceil(2 * radius / waveLength * 4) * 2;
        var path = []; // map phase to [-Math.PI * 2, 0]

        while (phase < -Math.PI * 2) {
          phase += Math.PI * 2;
        }

        while (phase > 0) {
          phase -= Math.PI * 2;
        }

        phase = phase / Math.PI / 2 * waveLength;
        var left = cx - radius + phase - radius * 2;
        /**
         * top-left corner as start point
         *
         * draws this point
         *  |
         * \|/
         *  ~~~~~~~~
         *  |      |
         *  +------+
         */

        path.push(['M', left, waterLevel]);
        /**
         * top wave
         *
         * ~~~~~~~~ <- draws this sine wave
         * |      |
         * +------+
         */

        var waveRight = 0;

        for (var c = 0; c < curves; ++c) {
          var stage = c % 4;
          var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);
          path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);

          if (c === curves - 1) {
            waveRight = pos[2][0];
          }
        }
        /**
         * top-right corner
         *
         *                       ~~~~~~~~
         * 3. draws this line -> |      | <- 1. draws this line
         *                       +------+
         *                          ^
         *                          |
         *                  2. draws this line
         */


        path.push(['L', waveRight + left, cy + radius]);
        path.push(['L', left, cy + radius]);
        path.push(['L', left, waterLevel]);
        return path;
      }
      /**
       * 添加水波
       * @param {number} x           中心x
       * @param {number} y           中心y
       * @param {number} level       水位等级 0～1
       * @param {number} waveCount   水波数
       * @param {number} colors      色值
       * @param {number} group       图组
       * @param {number} clip        用于剪切的图形
       * @param {number} radius      绘制图形的高度
       */


      function addWaterWave(x, y, level, waveCount, colors, group, clip, radius) {
        var bbox = clip.getBBox();
        var width = bbox.maxX - bbox.minX;
        var height = bbox.maxY - bbox.minY;
        var duration = 5000;
        var delayDiff = 300;

        for (var i = 0; i < waveCount; i++) {
          var wave = group.addShape('path', {
            attrs: {
              path: getWaterWavePath(radius, bbox.minY + height * level, width / 4, 0, width / 64, x, y),
              fill: colors[i],
              clip: clip
            }
          }); // FIXME wave animation error in svg

          if (Global.renderer === 'canvas') {
            wave.animate({
              transform: [['t', width / 2, 0]],
              repeat: true
            }, duration - i * delayDiff);
          }
        }
      }

      Shape.registerShape('interval', 'liquid-fill-gauge', {
        draw: function draw(cfg, container) {
          var self = this;
          var cy = 0.5;
          var sumX = 0;
          var minX = Infinity;
          Util.each(cfg.points, function (p) {
            if (p.x < minX) {
              minX = p.x;
            }

            sumX += p.x;
          });
          var cx = sumX / cfg.points.length;
          var cp = self.parsePoint({
            x: cx,
            y: cy
          });
          var minP = self.parsePoint({
            x: minX,
            y: 0.5
          });
          var xWidth = cp.x - minP.x;
          var radius = Math.min(xWidth, minP.y);
          var attrs = getFillAttrs(cfg);
          var clipCircle = new G.Circle({
            attrs: {
              x: cp.x,
              y: cp.y,
              r: radius
            }
          });
          addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, clipCircle, radius * 4);
          return container.addShape('circle', {
            attrs: Util.mix(getLineAttrs(cfg), {
              x: cp.x,
              y: cp.y,
              r: radius + radius / 8
            })
          });
        }
      });
      var pathMetaCache = {};
      Shape.registerShape('interval', 'liquid-fill-path', {
        draw: function draw(cfg, container) {
          var self = this;
          var attrs = Util.mix({}, getFillAttrs(cfg));
          var path = cfg.shape[1];
          var cy = 0.5;
          var sumX = 0;
          var minX = Infinity;
          Util.each(cfg.points, function (p) {
            if (p.x < minX) {
              minX = p.x;
            }

            sumX += p.x;
          });
          var cx = sumX / cfg.points.length;
          var cp = self.parsePoint({
            x: cx,
            y: cy
          });
          var minP = self.parsePoint({
            x: minX,
            y: 0.5
          });
          var xWidth = cp.x - minP.x;
          var radius = Math.min(xWidth, minP.y);
          var pathMeta;

          if (pathMetaCache[path]) {
            pathMeta = pathMetaCache[path];
          } else {
            var segments = GPathUtil.parsePathString(path);
            pathMetaCache[path] = pathMeta = {
              segments: segments
            };
          }

          var transform = [];

          if (attrs.rotate) {
            transform.push(['r', attrs.rotate / 180 * Math.PI]);
            delete attrs.rotate;
          }

          var shape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              fillOpacity: 0,
              path: pathMeta.segments
            })
          });
          var bbox = Util.cloneDeep(shape.getBBox());
          var rangeX = bbox.maxX - bbox.minX;
          var rangeY = bbox.maxY - bbox.minY;
          var range = Math.max(rangeX, rangeY);
          var scale = radius * 2 / range;
          shape.transform(transform.concat([['s', scale, scale]]));
          var dw = scale * rangeX / 2; // (bbox.maxX - bbox.minX) / 2;

          var dh = scale * rangeY / 2; // (bbox.maxY - bbox.minY) / 2;

          shape.transform([['t', cp.x - dw, cp.y - dh]]);
          addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, shape, minP.y * 4);
          var keyShape = container.addShape('path', {
            attrs: Util.mix(getLineAttrs(cfg), {
              path: pathMeta.segments
            })
          });
          keyShape.transform(transform.concat([['s', scale, scale], ['t', cp.x - dw, cp.y - dh]]));
          return keyShape;
        }
      });
      Shape.registerShape('interval', 'top-line', {
        draw: function draw(cfg, container) {
          var attrs = getFillAttrs(cfg);
          var style = cfg.style || {};
          var linePath = [['M', cfg.points[1].x, cfg.points[1].y], ['L', cfg.points[2].x, cfg.points[2].y]];
          var lineAttrs = {
            stroke: style.stroke || 'white',
            lineWidth: style.lineWidth || 1,
            path: this.parsePath(linePath)
          };
          var path = getRectPath(cfg.points);
          path = this.parsePath(path);
          delete attrs.stroke; // 不在柱子上绘制线

          var rectShape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              zIndex: 0,
              path: path
            })
          });
          container.addShape('path', {
            zIndex: 1,
            attrs: lineAttrs
          });
          return rectShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var rectCfg = getFillAttrs(cfg);
          var isInCircle = cfg.isInCircle;
          return Util.mix({
            symbol: isInCircle ? 'circle' : 'square',
            radius: isInCircle ? 4.5 : 4
          }, rectCfg);
        }
      });
      module.exports = Interval;
      /***/
    },
    /* 369 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 线图
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var Path = __webpack_require__(361);

      __webpack_require__(370);

      var Line = /*#__PURE__*/function (_Path) {
        _inheritsLoose(Line, _Path);

        function Line() {
          return _Path.apply(this, arguments) || this;
        }

        var _proto = Line.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Path.prototype.getDefaultCfg.call(this);

          cfg.type = 'line';
          cfg.sortable = true;
          return cfg;
        };

        return Line;
      }(Path);

      var LineStack = /*#__PURE__*/function (_Line) {
        _inheritsLoose(LineStack, _Line);

        function LineStack() {
          return _Line.apply(this, arguments) || this;
        }

        var _proto2 = LineStack.prototype;

        _proto2.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Line.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'stack'
          }];
          return cfg;
        };

        return LineStack;
      }(Line);

      Line.Stack = LineStack;
      GeomBase.Line = Line;
      GeomBase.LineStack = LineStack;
      module.exports = Line;
      /***/
    },
    /* 370 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview line shapes
       * @author dxq613@gmail.com
       * @author sima.zhang1990@gmail.com
       * @author huangtonger@aliyun.com
       */
      var Util = __webpack_require__(0);

      var PathUtil = __webpack_require__(23);

      var ShapeUtil = __webpack_require__(45);

      var Shape = __webpack_require__(19);

      var Global = __webpack_require__(7);

      var DOT_ARR = [1, 1];
      var DASH_ARR = [5.5, 1];

      function getAttrs(cfg) {
        var defaultCfg = Global.shape.line;
        var lineAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addStrokeAttrs(lineAttrs, cfg);

        if (cfg.size) {
          lineAttrs.lineWidth = cfg.size;
        }

        return lineAttrs;
      }

      function getMarkerAttrs(cfg) {
        var defaultCfg = Global.shape.line;
        var lineAttrs = Util.mix({
          lineWidth: 2,
          radius: 6
        }, defaultCfg, cfg.style);
        ShapeUtil.addStrokeAttrs(lineAttrs, cfg);
        return lineAttrs;
      } // 获取带有上下区间的 path


      function getRangePath(points, smooth, isInCircle, cfg) {
        var topPoints = [];
        var isStack = cfg.isStack;
        var bottomPoints = [];

        for (var i = 0; i < points.length; i++) {
          var point = points[i];
          var tmp = ShapeUtil.splitPoints(point);
          bottomPoints.push(tmp[0]);
          topPoints.push(tmp[1]);
        }

        var topPath = getSinglePath(topPoints, smooth, isInCircle, cfg);
        var bottomPath = getSinglePath(bottomPoints, smooth, isInCircle, cfg);

        if (isStack) {
          return topPath;
        }

        return topPath.concat(bottomPath);
      } // 单条 path


      function getSinglePath(points, smooth, isInCircle, cfg) {
        var path;

        if (!smooth) {
          path = PathUtil.getLinePath(points, false);

          if (isInCircle) {
            path.push(['Z']);
          }
        } else {
          // 直角坐标系下绘制曲线时限制最大值、最小值
          var constraint = cfg.constraint;

          if (isInCircle && points.length) {
            points.push({
              x: points[0].x,
              y: points[0].y
            });
          }

          path = PathUtil.getSplinePath(points, false, constraint);
        }

        return path;
      } // get line path


      function getPath(cfg, smooth) {
        var path;
        var points = cfg.points;
        var isInCircle = cfg.isInCircle;
        var first = points[0];

        if (Util.isArray(first.y)) {
          path = getRangePath(points, smooth, isInCircle, cfg);
        } else {
          path = getSinglePath(points, smooth, isInCircle, cfg);
        }

        return path;
      }

      function _interpPoints(points, fn) {
        var tmpPoints = [];
        Util.each(points, function (point, index) {
          var nextPoint = points[index + 1];
          tmpPoints.push(point);

          if (nextPoint) {
            tmpPoints = tmpPoints.concat(fn(point, nextPoint));
          }
        });
        return tmpPoints;
      } // 插值的图形path，不考虑null


      function _getInterPath(points) {
        var path = [];
        Util.each(points, function (point, index) {
          var subPath = index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];
          path.push(subPath);
        });
        return path;
      } // 插值的图形


      function _getInterPointShapeCfg(cfg, fn) {
        var points = _interpPoints(cfg.points, fn);

        return _getInterPath(points);
      }

      function _markerFn(x, y, r) {
        return [['M', x - r, y], ['L', x + r, y]];
      }

      function _smoothMarkerFn(x, y, r) {
        return [['M', x - r, y], ['A', r / 2, r / 2, 0, 1, 1, x, y], ['A', r / 2, r / 2, 0, 1, 0, x + r, y]];
      } // get marker cfg


      function _getMarkerCfg(cfg, smooth) {
        return Util.mix({
          symbol: smooth ? _smoothMarkerFn : _markerFn
        }, getMarkerAttrs(cfg));
      }

      function _getInterMarkerCfg(cfg, fn) {
        return Util.mix({
          symbol: fn
        }, getMarkerAttrs(cfg));
      } // 当只有一个数据时绘制点


      function drawPointShape(shapeObj, cfg, container) {
        var point = cfg.points[0];
        return container.addShape('circle', {
          attrs: Util.mix({
            x: point.x,
            y: point.y,
            r: 2,
            fill: cfg.color
          }, cfg.style)
        });
      } // regist line geom


      var Line = Shape.registerFactory('line', {
        // 默认的shape
        defaultShapeType: 'line',

        /* getMarkerCfg(type, cfg) {
          const lineObj = Line[type] || Line.line;
          return lineObj.getMarkerCfg(cfg);
        }, */
        getActiveCfg: function getActiveCfg(type, cfg) {
          var lineWidth = cfg.lineWidth || 0;
          return {
            lineWidth: lineWidth + 1
          };
        },
        // 计算点 如果存在多个点，分割成单个的点, 不考虑多个x对应一个y的情况
        getDefaultPoints: function getDefaultPoints(pointInfo) {
          return ShapeUtil.splitPoints(pointInfo);
        },
        drawShape: function drawShape(type, cfg, container) {
          var shape = this.getShape(type);
          var gShape;

          if (cfg.points.length === 1 && Global.showSinglePoint) {
            gShape = drawPointShape(this, cfg, container);
          } else {
            gShape = shape.draw(cfg, container);
          }

          if (gShape) {
            gShape.set('origin', cfg.origin);
            gShape._id = cfg.splitedIndex ? cfg._id + cfg.splitedIndex : cfg._id;
            gShape.name = this.name;
          }

          return gShape;
        }
      }); // draw line shape

      Shape.registerShape('line', 'line', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);
          var path = getPath(cfg, false);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getMarkerCfg(cfg);
        }
      }); // 点线 ···

      Shape.registerShape('line', 'dot', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);
          var path = getPath(cfg, false);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path,
              lineDash: DOT_ARR
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var tmp = _getMarkerCfg(cfg, false);

          tmp.lineDash = DOT_ARR;
          return tmp;
        }
      }); // 断线 - - -

      Shape.registerShape('line', 'dash', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);
          var path = getPath(cfg, false);
          return container.addShape('path', {
            attrs: Util.mix({
              path: path,
              lineDash: DASH_ARR
            }, attrs)
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var tmp = _getMarkerCfg(cfg, false);

          tmp.lineDash = tmp.lineDash || DASH_ARR;
          return tmp;
        }
      }); // draw smooth line shape

      Shape.registerShape('line', 'smooth', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);
          var coord = this._coord; // 曲线的限制

          cfg.constraint = [[coord.start.x, coord.end.y], [coord.end.x, coord.start.y]];
          var path = getPath(cfg, true);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getMarkerCfg(cfg, true);
        }
      });
      Shape.registerShape('line', 'hv', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);

          var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            var tmp = [];
            tmp.push({
              x: nextPoint.x,
              y: point.y
            });
            return tmp;
          });

          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getInterMarkerCfg(cfg, function (x, y, r) {
            return [['M', x - r - 1, y - 2.5], ['L', x, y - 2.5], ['L', x, y + 2.5], ['L', x + r + 1, y + 2.5]];
          });
        }
      });
      Shape.registerShape('line', 'vh', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);

          var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            var tmp = [];
            tmp.push({
              x: point.x,
              y: nextPoint.y
            });
            return tmp;
          });

          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getInterMarkerCfg(cfg, function (x, y, r) {
            return [['M', x - r - 1, y + 2.5], ['L', x, y + 2.5], ['L', x, y - 2.5], ['L', x + r + 1, y - 2.5]];
          });
        }
      });
      Shape.registerShape('line', 'hvh', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);

          var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            var tmp = [];
            var middlex = (nextPoint.x - point.x) / 2 + point.x;
            tmp.push({
              x: middlex,
              y: point.y
            });
            tmp.push({
              x: middlex,
              y: nextPoint.y
            });
            return tmp;
          });

          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getInterMarkerCfg(cfg, function (x, y, r) {
            return [['M', x - (r + 1), y + 2.5], ['L', x - r / 2, y + 2.5], ['L', x - r / 2, y - 2.5], ['L', x + r / 2, y - 2.5], ['L', x + r / 2, y + 2.5], ['L', x + r + 1, y + 2.5]];
          });
        }
      });
      Shape.registerShape('line', 'vhv', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);

          var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            var tmp = [];
            var middley = (nextPoint.y - point.y) / 2 + point.y;
            tmp.push({
              x: point.x,
              y: middley
            });
            tmp.push({
              x: nextPoint.x,
              y: middley
            });
            return tmp;
          });

          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getInterMarkerCfg(cfg, function (x, y) {
            // 宽 13px，高 8px
            return [['M', x - 5, y + 2.5], ['L', x - 5, y], ['L', x, y], ['L', x, y - 3], ['L', x, y + 3], ['L', x + 6.5, y + 3]];
          });
        }
      });
      Line.spline = Line.smooth;
      module.exports = Line;
      /***/
    },
    /* 371 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 点图
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var Util = __webpack_require__(0);

      __webpack_require__(372);

      var Point = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Point, _GeomBase);

        function Point() {
          return _GeomBase.apply(this, arguments) || this;
        }

        var _proto = Point.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'point';
          cfg.shapeType = 'point';
          cfg.generatePoints = true;
          return cfg;
        };

        _proto.drawPoint = function drawPoint(obj, container, shapeFactory, index) {
          var self = this;
          var shape = obj.shape;
          var cfg = self.getDrawCfg(obj);

          self._applyViewThemeShapeStyle(cfg, shape, shapeFactory);

          var geomShape;

          if (Util.isArray(obj.y)) {
            var hasAdjust = self.hasStack();
            Util.each(obj.y, function (y, idx) {
              cfg.y = y;
              cfg.yIndex = idx;

              if (!hasAdjust || idx !== 0) {
                geomShape = shapeFactory.drawShape(shape, cfg, container);
                self.appendShapeInfo(geomShape, index + idx);
              }
            });
          } else if (!Util.isNil(obj.y)) {
            geomShape = shapeFactory.drawShape(shape, cfg, container);
            self.appendShapeInfo(geomShape, index);
          }
        };

        return Point;
      }(GeomBase);

      var PointJitter = /*#__PURE__*/function (_Point) {
        _inheritsLoose(PointJitter, _Point);

        function PointJitter() {
          return _Point.apply(this, arguments) || this;
        }

        var _proto2 = PointJitter.prototype;

        _proto2.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Point.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'jitter'
          }];
          return cfg;
        };

        return PointJitter;
      }(Point);

      var PointStack = /*#__PURE__*/function (_Point2) {
        _inheritsLoose(PointStack, _Point2);

        function PointStack() {
          return _Point2.apply(this, arguments) || this;
        }

        var _proto3 = PointStack.prototype;

        _proto3.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Point2.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'stack'
          }];
          return cfg;
        };

        return PointStack;
      }(Point);

      Point.Jitter = PointJitter;
      Point.Stack = PointStack;
      GeomBase.Point = Point;
      GeomBase.PointJitter = PointJitter;
      GeomBase.PointStack = PointStack;
      module.exports = Point;
      /***/
    },
    /* 372 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview point shapes
       * @author dxq613@gmail.com
       * @author sima.zhang1990@gmail.com
       * @author huangtonger@aliyun.com
       */
      var Util = __webpack_require__(0);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      var Shape = __webpack_require__(19); // const svgpath = require('svgpath');


      var _require = __webpack_require__(16),
          Marker = _require.Marker;

      var PathUtil = Util.PathUtil;
      var SHAPES = ['circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down'];
      var HOLLOW_SHAPES = ['cross', 'tick', 'plus', 'hyphen', 'line', 'pointerLine', 'pointerArrow'];
      var SQRT_3 = Math.sqrt(3); // 增加marker

      Util.mix(Marker.Symbols, {
        hexagon: function hexagon(x, y, r) {
          var diffX = r / 2 * SQRT_3;
          return [['M', x, y - r], ['L', x + diffX, y - r / 2], ['L', x + diffX, y + r / 2], ['L', x, y + r], ['L', x - diffX, y + r / 2], ['L', x - diffX, y - r / 2], ['Z']];
        },
        bowtie: function bowtie(x, y, r) {
          var diffY = r - 1.5;
          return [['M', x - r, y - diffY], ['L', x + r, y + diffY], ['L', x + r, y - diffY], ['L', x - r, y + diffY], ['Z']];
        },
        cross: function cross(x, y, r) {
          return [['M', x - r, y - r], ['L', x + r, y + r], ['M', x + r, y - r], ['L', x - r, y + r]];
        },
        tick: function tick(x, y, r) {
          return [['M', x - r / 2, y - r], ['L', x + r / 2, y - r], ['M', x, y - r], ['L', x, y + r], ['M', x - r / 2, y + r], ['L', x + r / 2, y + r]];
        },
        plus: function plus(x, y, r) {
          return [['M', x - r, y], ['L', x + r, y], ['M', x, y - r], ['L', x, y + r]];
        },
        hyphen: function hyphen(x, y, r) {
          return [['M', x - r, y], ['L', x + r, y]];
        },
        line: function line(x, y, r) {
          return [['M', x, y - r], ['L', x, y + r]];
        }
      });

      function getFillAttrs(cfg) {
        var defaultAttrs = Global.shape.point;
        var pointAttrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addFillAttrs(pointAttrs, cfg);

        if (Util.isNumber(cfg.size)) {
          pointAttrs.radius = cfg.size;
        }

        return pointAttrs;
      }

      function getLineAttrs(cfg) {
        var defaultAttrs = Global.shape.hollowPoint;
        var pointAttrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addStrokeAttrs(pointAttrs, cfg);

        if (Util.isNumber(cfg.size)) {
          pointAttrs.radius = cfg.size;
        }

        return pointAttrs;
      }

      var Point = Shape.registerFactory('point', {
        defaultShapeType: 'hollowCircle',
        getActiveCfg: function getActiveCfg(type, cfg) {
          // 点放大 + 颜色加亮
          var radius = cfg.radius;
          var color;

          if (type && (type.indexOf('hollow') === 0 || Util.indexOf(HOLLOW_SHAPES, type) !== -1) || !type) {
            color = cfg.stroke || cfg.strokeStyle;
          } else {
            color = cfg.fill || cfg.fillStyle;
          }

          return {
            radius: radius + 1,
            shadowBlur: radius,
            shadowColor: color,
            stroke: color,
            strokeOpacity: 1,
            lineWidth: 1
          };
        },
        getDefaultPoints: function getDefaultPoints(pointInfo) {
          return ShapeUtil.splitPoints(pointInfo);
        }
      });

      function getRectPath(cfg) {
        var x = cfg.points[0].x;
        var y = cfg.points[0].y;
        var w = cfg.size[0];
        var h = cfg.size[1];
        var path = [['M', x - 0.5 * w, y - 0.5 * h], ['L', x + 0.5 * w, y - 0.5 * h], ['L', x + 0.5 * w, y + 0.5 * h], ['L', x - 0.5 * w, y + 0.5 * h], ['z']];
        return path;
      } // 用于桑基图的节点


      Shape.registerShape('point', 'rect', {
        draw: function draw(cfg, container) {
          var rectAttrs = getFillAttrs(cfg);
          var path = getRectPath(cfg);
          path = this.parsePath(path);
          var gShape = container.addShape('path', {
            attrs: Util.mix(rectAttrs, {
              path: path
            })
          });
          return gShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          var attrs = getFillAttrs(cfg);
          attrs.symbol = 'rect';
          attrs.radius = 4.5;
          return attrs;
        }
      }); // 添加shapes

      Util.each(SHAPES, function (shape) {
        Shape.registerShape('point', shape, {
          draw: function draw(cfg, container) {
            // cfg.points = this.parsePoints(cfg.points);
            var attrs = getFillAttrs(cfg);
            return container.addShape('Marker', {
              attrs: Util.mix(attrs, {
                symbol: shape,
                x: cfg.x,
                y: cfg.y
              })
            });
          },
          getMarkerCfg: function getMarkerCfg(cfg) {
            var attrs = getFillAttrs(cfg);
            attrs.symbol = shape;
            attrs.radius = 4.5;
            return attrs;
          }
        }); // 添加该 shape 对应的 hollowShape

        Shape.registerShape('point', 'hollow' + Util.upperFirst(shape), {
          draw: function draw(cfg, container) {
            // cfg.points = this.parsePoints(cfg.points);
            var attrs = getLineAttrs(cfg);
            return container.addShape('Marker', {
              attrs: Util.mix(attrs, {
                symbol: shape,
                x: cfg.x,
                y: cfg.y
              })
            });
          },
          getMarkerCfg: function getMarkerCfg(cfg) {
            var attrs = getLineAttrs(cfg);
            attrs.symbol = shape;
            attrs.radius = 4.5;
            return attrs;
          }
        });
      }); // 添加 hollowShapes

      Util.each(HOLLOW_SHAPES, function (shape) {
        Shape.registerShape('point', shape, {
          draw: function draw(cfg, container) {
            var attrs = getLineAttrs(cfg);
            return container.addShape('Marker', {
              attrs: Util.mix(attrs, {
                symbol: shape,
                x: cfg.x,
                y: cfg.y
              })
            });
          },
          getMarkerCfg: function getMarkerCfg(cfg) {
            var attrs = getLineAttrs(cfg);
            attrs.symbol = shape;
            attrs.radius = 4.5;
            return attrs;
          }
        });
      }); // image

      Shape.registerShape('point', 'image', {
        draw: function draw(cfg, container) {
          cfg.points = this.parsePoints(cfg.points);
          return container.addShape('image', {
            attrs: {
              x: cfg.points[0].x - cfg.size / 2,
              y: cfg.points[0].y - cfg.size,
              width: cfg.size,
              height: cfg.size,
              img: cfg.shape[1]
            }
          });
        }
      }); // path

      var pathMetaCache = {};
      Shape.registerShape('point', 'path', {
        draw: function draw(cfg, container) {
          var attrs = Util.mix({}, getLineAttrs(cfg), getFillAttrs(cfg));
          var path = cfg.shape[1];
          var size = cfg.size || 10;
          var pathMeta;

          if (pathMetaCache[path]) {
            pathMeta = pathMetaCache[path];
          } else {
            var segments = PathUtil.parsePathString(path);
            var nums = Util.flatten(segments).filter(function (num) {
              return Util.isNumber(num);
            });
            pathMetaCache[path] = pathMeta = {
              range: Math.max.apply(null, nums) - Math.min.apply(null, nums),
              segments: segments
            };
          }

          var scale = size / pathMeta.range;
          var transform = [];

          if (attrs.rotate) {
            transform.push(['r', attrs.rotate / 180 * Math.PI]);
            delete attrs.rotate;
          }

          var shape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: pathMeta.segments
            })
          });
          transform.push(['s', scale, scale], ['t', cfg.x, cfg.y]);
          shape.transform(transform);
          return shape;
        }
      });
      module.exports = Point;
      /***/
    },
    /* 373 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__namespaces__ = __webpack_require__(374);
      /* harmony default export */


      __webpack_exports__["a"] = function (name) {
        var prefix = name += "",
            i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
        return __WEBPACK_IMPORTED_MODULE_0__namespaces__["a"
        /* default */
        ].hasOwnProperty(prefix) ? {
          space: __WEBPACK_IMPORTED_MODULE_0__namespaces__["a"
          /* default */
          ][prefix],
          local: name
        } : name;
      };
      /***/

    },
    /* 374 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return xhtml;
      });

      var xhtml = "http://www.w3.org/1999/xhtml";
      /* harmony default export */

      __webpack_exports__["a"] = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      /***/
    },
    /* 375 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function none() {}
      /* harmony default export */


      __webpack_exports__["a"] = function (selector) {
        return selector == null ? none : function () {
          return this.querySelector(selector);
        };
      };
      /***/

    },
    /* 376 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (node) {
        return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node
        node.document && node // node is a Window
        || node.defaultView; // node is a Document
      };
      /***/

    },
    /* 377 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "c", function () {
        return event;
      });
      /* harmony export (immutable) */


      __webpack_exports__["a"] = customEvent;
      var filterEvents = {};
      var event = null;

      if (typeof document !== "undefined") {
        var element = document.documentElement;

        if (!("onmouseenter" in element)) {
          filterEvents = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
          };
        }
      }

      function filterContextListener(listener, index, group) {
        listener = contextListener(listener, index, group);
        return function (event) {
          var related = event.relatedTarget;

          if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
            listener.call(this, event);
          }
        };
      }

      function contextListener(listener, index, group) {
        return function (event1) {
          var event0 = event; // Events can be reentrant (e.g., focus).

          event = event1;

          try {
            listener.call(this, this.__data__, index, group);
          } finally {
            event = event0;
          }
        };
      }

      function parseTypenames(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
          var name = "",
              i = t.indexOf(".");
          if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
          return {
            type: t,
            name: name
          };
        });
      }

      function onRemove(typename) {
        return function () {
          var on = this.__on;
          if (!on) return;

          for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
            if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.capture);
            } else {
              on[++i] = o;
            }
          }

          if (++i) on.length = i;else delete this.__on;
        };
      }

      function onAdd(typename, value, capture) {
        var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
        return function (d, i, group) {
          var on = this.__on,
              o,
              listener = wrap(value, i, group);
          if (on) for (var j = 0, m = on.length; j < m; ++j) {
            if ((o = on[j]).type === typename.type && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.capture);
              this.addEventListener(o.type, o.listener = listener, o.capture = capture);
              o.value = value;
              return;
            }
          }
          this.addEventListener(typename.type, listener, capture);
          o = {
            type: typename.type,
            name: typename.name,
            value: value,
            listener: listener,
            capture: capture
          };
          if (!on) this.__on = [o];else on.push(o);
        };
      }
      /* harmony default export */


      __webpack_exports__["b"] = function (typename, value, capture) {
        var typenames = parseTypenames(typename + ""),
            i,
            n = typenames.length,
            t;

        if (arguments.length < 2) {
          var on = this.node().__on;

          if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
            for (i = 0, o = on[j]; i < n; ++i) {
              if ((t = typenames[i]).type === o.type && t.name === o.name) {
                return o.value;
              }
            }
          }
          return;
        }

        on = value ? onAdd : onRemove;
        if (capture == null) capture = false;

        for (i = 0; i < n; ++i) {
          this.each(on(typenames[i], value, capture));
        }

        return this;
      };

      function customEvent(event1, listener, that, args) {
        var event0 = event;
        event1.sourceEvent = event;
        event = event1;

        try {
          return listener.apply(that, args);
        } finally {
          event = event0;
        }
      }
      /***/

    },
    /* 378 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__selection_on__ = __webpack_require__(377);
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        var current = __WEBPACK_IMPORTED_MODULE_0__selection_on__["c"
        /* event */
        ],
            source;

        while (source = current.sourceEvent) {
          current = source;
        }

        return current;
      };
      /***/

    },
    /* 379 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__value_js__ = __webpack_require__(380);
      /* unused harmony reexport interpolate */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__array_js__ = __webpack_require__(396);
      /* unused harmony reexport interpolateArray */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__basis_js__ = __webpack_require__(381);
      /* unused harmony reexport interpolateBasis */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__basisClosed_js__ = __webpack_require__(394);
      /* unused harmony reexport interpolateBasisClosed */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__date_js__ = __webpack_require__(397);
      /* unused harmony reexport interpolateDate */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__discrete_js__ = __webpack_require__(457);
      /* unused harmony reexport interpolateDiscrete */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__hue_js__ = __webpack_require__(458);
      /* unused harmony reexport interpolateHue */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__number_js__ = __webpack_require__(364);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return __WEBPACK_IMPORTED_MODULE_7__number_js__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__numberArray_js__ = __webpack_require__(382);
      /* unused harmony reexport interpolateNumberArray */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__object_js__ = __webpack_require__(398);
      /* unused harmony reexport interpolateObject */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_10__round_js__ = __webpack_require__(459);
      /* unused harmony reexport interpolateRound */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_11__string_js__ = __webpack_require__(399);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "c", function () {
        return __WEBPACK_IMPORTED_MODULE_11__string_js__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_12__transform_index_js__ = __webpack_require__(460);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return __WEBPACK_IMPORTED_MODULE_12__transform_index_js__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "e", function () {
        return __WEBPACK_IMPORTED_MODULE_12__transform_index_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_13__zoom_js__ = __webpack_require__(463);
      /* unused harmony reexport interpolateZoom */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_14__rgb_js__ = __webpack_require__(393);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return __WEBPACK_IMPORTED_MODULE_14__rgb_js__["a"];
      });
      /* unused harmony reexport interpolateRgbBasis */

      /* unused harmony reexport interpolateRgbBasisClosed */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_15__hsl_js__ = __webpack_require__(464);
      /* unused harmony reexport interpolateHsl */

      /* unused harmony reexport interpolateHslLong */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_16__lab_js__ = __webpack_require__(465);
      /* unused harmony reexport interpolateLab */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_17__hcl_js__ = __webpack_require__(466);
      /* unused harmony reexport interpolateHcl */

      /* unused harmony reexport interpolateHclLong */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_18__cubehelix_js__ = __webpack_require__(467);
      /* unused harmony reexport interpolateCubehelix */

      /* unused harmony reexport interpolateCubehelixLong */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_19__piecewise_js__ = __webpack_require__(468);
      /* unused harmony reexport piecewise */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_20__quantize_js__ = __webpack_require__(469);
      /* unused harmony reexport quantize */

      /***/

    },
    /* 380 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__rgb_js__ = __webpack_require__(393);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__array_js__ = __webpack_require__(396);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__date_js__ = __webpack_require__(397);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__number_js__ = __webpack_require__(364);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__object_js__ = __webpack_require__(398);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__string_js__ = __webpack_require__(399);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__constant_js__ = __webpack_require__(395);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__numberArray_js__ = __webpack_require__(382);
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var t = typeof b,
            c;
        return b == null || t === "boolean" ? Object(__WEBPACK_IMPORTED_MODULE_7__constant_js__["a"
        /* default */
        ])(b) : (t === "number" ? __WEBPACK_IMPORTED_MODULE_4__number_js__["a"
        /* default */
        ] : t === "string" ? (c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a"
        /* color */
        ])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1__rgb_js__["a"
        /* default */
        ]) : __WEBPACK_IMPORTED_MODULE_6__string_js__["a"
        /* default */
        ] : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["a"
        /* color */
        ] ? __WEBPACK_IMPORTED_MODULE_1__rgb_js__["a"
        /* default */
        ] : b instanceof Date ? __WEBPACK_IMPORTED_MODULE_3__date_js__["a"
        /* default */
        ] : Object(__WEBPACK_IMPORTED_MODULE_8__numberArray_js__["b"
        /* isNumberArray */
        ])(b) ? __WEBPACK_IMPORTED_MODULE_8__numberArray_js__["a"
        /* default */
        ] : Array.isArray(b) ? __WEBPACK_IMPORTED_MODULE_2__array_js__["a"
        /* genericArray */
        ] : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? __WEBPACK_IMPORTED_MODULE_5__object_js__["a"
        /* default */
        ] : __WEBPACK_IMPORTED_MODULE_4__number_js__["a"
        /* default */
        ])(a, b);
      };
      /***/

    },
    /* 381 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = basis;

      function basis(t1, v0, v1, v2, v3) {
        var t2 = t1 * t1,
            t3 = t2 * t1;
        return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
      }
      /* harmony default export */


      __webpack_exports__["b"] = function (values) {
        var n = values.length - 1;
        return function (t) {
          var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
              v1 = values[i],
              v2 = values[i + 1],
              v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
              v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
          return basis((t - i / n) * n, v0, v1, v2, v3);
        };
      };
      /***/

    },
    /* 382 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["b"] = isNumberArray;
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b) {
        if (!b) b = [];
        var n = a ? Math.min(b.length, a.length) : 0,
            c = b.slice(),
            i;
        return function (t) {
          for (i = 0; i < n; ++i) {
            c[i] = a[i] * (1 - t) + b[i] * t;
          }

          return c;
        };
      };

      function isNumberArray(x) {
        return ArrayBuffer.isView(x) && !(x instanceof DataView);
      }
      /***/

    },
    /* 383 */

    /***/
    function (module, exports) {
      module.exports = function (chart) {
        var scaleController = chart.get('scaleController') || {};
        return scaleController.defs;
      };
      /***/

    },
    /* 384 */

    /***/
    function (module, exports, __webpack_require__) {
      var getColDefs = __webpack_require__(383);

      module.exports = function (chart, field) {
        var colDefs = getColDefs(chart);

        if (colDefs && colDefs[field]) {
          return colDefs[field];
        }
      };
      /***/

    },
    /* 385 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      var TimeUtil = __webpack_require__(71);

      module.exports = function (data, scale) {
        var result;
        var field = scale.field,
            type = scale.type;
        var values = Util.Array.values(data, field);

        if (type === 'linear') {
          result = Util.Array.getRange(values);

          if (scale.min < result.min) {
            result.min = scale.min;
          }

          if (scale.max > result.max) {
            result.max = scale.max;
          }
        } else if (type === 'timeCat') {
          Util.each(values, function (v, i) {
            values[i] = TimeUtil.toTimeStamp(v);
          });
          values.sort(function (v1, v2) {
            return v1 - v2;
          });
          result = values;
        } else {
          result = values;
        }

        return result;
      };
      /***/

    },
    /* 386 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(70);
      /* harmony default export */


      __webpack_exports__["a"] = function (selector) {
        return typeof selector === "string" ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a"
        /* Selection */
        ]([[document.querySelector(selector)]], [document.documentElement]) : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a"
        /* Selection */
        ]([[selector]], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c"
        /* root */
        ]);
      };
      /***/

    },
    /* 387 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function empty() {
        return [];
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (selector) {
        return selector == null ? empty : function () {
          return this.querySelectorAll(selector);
        };
      };
      /***/

    },
    /* 388 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (selector) {
        return function () {
          return this.matches(selector);
        };
      };
      /***/

    },
    /* 389 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = EnterNode;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(390);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(70);
      /* harmony default export */


      __webpack_exports__["b"] = function () {
        return new __WEBPACK_IMPORTED_MODULE_1__index__["a"
        /* Selection */
        ](this._enter || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a"
        /* default */
        ]), this._parents);
      };

      function EnterNode(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
      }

      EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: function appendChild(child) {
          return this._parent.insertBefore(child, this._next);
        },
        insertBefore: function insertBefore(child, next) {
          return this._parent.insertBefore(child, next);
        },
        querySelector: function querySelector(selector) {
          return this._parent.querySelector(selector);
        },
        querySelectorAll: function querySelectorAll(selector) {
          return this._parent.querySelectorAll(selector);
        }
      };
      /***/
    },
    /* 390 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (update) {
        return new Array(update.length);
      };
      /***/

    },
    /* 391 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["b"] = styleValue;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(376);

      function styleRemove(name) {
        return function () {
          this.style.removeProperty(name);
        };
      }

      function styleConstant(name, value, priority) {
        return function () {
          this.style.setProperty(name, value, priority);
        };
      }

      function styleFunction(name, value, priority) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value, priority) {
        return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
      };

      function styleValue(node, name) {
        return node.style.getPropertyValue(name) || Object(__WEBPACK_IMPORTED_MODULE_0__window__["a"
        /* default */
        ])(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      /***/

    },
    /* 392 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__ = __webpack_require__(46);
      /* harmony default export */


      __webpack_exports__["a"] = function (node, name) {
        var schedules = node.__transition,
            schedule,
            active,
            empty = true,
            i;
        if (!schedules) return;
        name = name == null ? null : name + "";

        for (i in schedules) {
          if ((schedule = schedules[i]).name !== name) {
            empty = false;
            continue;
          }

          active = schedule.state > __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__["d"
          /* STARTING */
          ] && schedule.state < __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__["b"
          /* ENDING */
          ];
          schedule.state = __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__["a"
          /* ENDED */
          ];
          schedule.timer.stop();
          schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
          delete schedules[i];
        }

        if (empty) delete node.__transition;
      };
      /***/

    },
    /* 393 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export rgbBasis */

      /* unused harmony export rgbBasisClosed */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__basis_js__ = __webpack_require__(381);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__basisClosed_js__ = __webpack_require__(394);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__color_js__ = __webpack_require__(174);
      /* harmony default export */


      __webpack_exports__["a"] = function rgbGamma(y) {
        var color = Object(__WEBPACK_IMPORTED_MODULE_3__color_js__["b"
        /* gamma */
        ])(y);

        function rgb(start, end) {
          var r = color((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f"
          /* rgb */
          ])(start)).r, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f"
          /* rgb */
          ])(end)).r),
              g = color(start.g, end.g),
              b = color(start.b, end.b),
              opacity = Object(__WEBPACK_IMPORTED_MODULE_3__color_js__["a"
          /* default */
          ])(start.opacity, end.opacity);
          return function (t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
          };
        }

        rgb.gamma = rgbGamma;
        return rgb;
      }(1);

      function rgbSpline(spline) {
        return function (colors) {
          var n = colors.length,
              r = new Array(n),
              g = new Array(n),
              b = new Array(n),
              i,
              color;

          for (i = 0; i < n; ++i) {
            color = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f"
            /* rgb */
            ])(colors[i]);
            r[i] = color.r || 0;
            g[i] = color.g || 0;
            b[i] = color.b || 0;
          }

          r = spline(r);
          g = spline(g);
          b = spline(b);
          color.opacity = 1;
          return function (t) {
            color.r = r(t);
            color.g = g(t);
            color.b = b(t);
            return color + "";
          };
        };
      }

      var rgbBasis = rgbSpline(__WEBPACK_IMPORTED_MODULE_1__basis_js__["b"
      /* default */
      ]);
      var rgbBasisClosed = rgbSpline(__WEBPACK_IMPORTED_MODULE_2__basisClosed_js__["a"
      /* default */
      ]);
      /***/
    },
    /* 394 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__basis_js__ = __webpack_require__(381);
      /* harmony default export */


      __webpack_exports__["a"] = function (values) {
        var n = values.length;
        return function (t) {
          var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
              v0 = values[(i + n - 1) % n],
              v1 = values[i % n],
              v2 = values[(i + 1) % n],
              v3 = values[(i + 2) % n];
          return Object(__WEBPACK_IMPORTED_MODULE_0__basis_js__["a"
          /* basis */
          ])((t - i / n) * n, v0, v1, v2, v3);
        };
      };
      /***/

    },
    /* 395 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (x) {
        return function () {
          return x;
        };
      };
      /***/

    },
    /* 396 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = genericArray;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__value_js__ = __webpack_require__(380);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__numberArray_js__ = __webpack_require__(382);
      /* unused harmony default export */


      var _unused_webpack_default_export = function _unused_webpack_default_export(a, b) {
        return (Object(__WEBPACK_IMPORTED_MODULE_1__numberArray_js__["b"
        /* isNumberArray */
        ])(b) ? __WEBPACK_IMPORTED_MODULE_1__numberArray_js__["a"
        /* default */
        ] : genericArray)(a, b);
      };

      function genericArray(a, b) {
        var nb = b ? b.length : 0,
            na = a ? Math.min(nb, a.length) : 0,
            x = new Array(na),
            c = new Array(nb),
            i;

        for (i = 0; i < na; ++i) {
          x[i] = Object(__WEBPACK_IMPORTED_MODULE_0__value_js__["a"
          /* default */
          ])(a[i], b[i]);
        }

        for (; i < nb; ++i) {
          c[i] = b[i];
        }

        return function (t) {
          for (i = 0; i < na; ++i) {
            c[i] = x[i](t);
          }

          return c;
        };
      }
      /***/

    },
    /* 397 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b) {
        var d = new Date();
        return a = +a, b = +b, function (t) {
          return d.setTime(a * (1 - t) + b * t), d;
        };
      };
      /***/

    },
    /* 398 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__value_js__ = __webpack_require__(380);
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var i = {},
            c = {},
            k;
        if (a === null || typeof a !== "object") a = {};
        if (b === null || typeof b !== "object") b = {};

        for (k in b) {
          if (k in a) {
            i[k] = Object(__WEBPACK_IMPORTED_MODULE_0__value_js__["a"
            /* default */
            ])(a[k], b[k]);
          } else {
            c[k] = b[k];
          }
        }

        return function (t) {
          for (k in i) {
            c[k] = i[k](t);
          }

          return c;
        };
      };
      /***/

    },
    /* 399 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__number_js__ = __webpack_require__(364);

      var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          reB = new RegExp(reA.source, "g");

      function zero(b) {
        return function () {
          return b;
        };
      }

      function one(b) {
        return function (t) {
          return b(t) + "";
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0,
            // scan index for next number in b
        am,
            // current match in a
        bm,
            // current match in b
        bs,
            // string preceding current number in b, if any
        i = -1,
            // index in s
        s = [],
            // string constants and placeholders
        q = []; // number interpolators
        // Coerce inputs to strings.

        a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

        while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
          if ((bs = bm.index) > bi) {
            // a string precedes the next number in b
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs; // coalesce with previous string
            else s[++i] = bs;
          }

          if ((am = am[0]) === (bm = bm[0])) {
            // numbers in a & b match
            if (s[i]) s[i] += bm; // coalesce with previous string
            else s[++i] = bm;
          } else {
            // interpolate non-matching numbers
            s[++i] = null;
            q.push({
              i: i,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number_js__["a"
              /* default */
              ])(am, bm)
            });
          }

          bi = reB.lastIndex;
        } // Add remains of b.


        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        } // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.


        return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
          for (var i = 0, o; i < b; ++i) {
            s[(o = q[i]).i] = o.x(t);
          }

          return s.join("");
        });
      };
      /***/

    },
    /* 400 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(379);
      /* harmony default export */


      __webpack_exports__["a"] = function (a, b) {
        var c;
        return (typeof b === "number" ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["a"
        /* interpolateNumber */
        ] : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["a"
        /* color */
        ] ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["b"
        /* interpolateRgb */
        ] : (c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a"
        /* color */
        ])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["b"
        /* interpolateRgb */
        ]) : __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["c"
        /* interpolateString */
        ])(a, b);
      };
      /***/

    },
    /* 401 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 分面的基类
       * @author dxq613@gmail.com
       */


      var Base = __webpack_require__(366);
      /**
       * 矩形的 facet 有以下属性：
       * - colField 列的字段
       * - rowField 行的字段
       * - colValue 列字段的值
       * - rowValue 行字段的值
       * - cols 列数
       * - rows 行数
       * - colIndex 列的序号
       * - rowIndex 行的序号
       */

      /**
       * 用于生成分面的类
       * @class Facets.Rect
       */


      var Rect = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Rect, _Base);

        function Rect() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Rect.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          cfg.type = 'rect';
          return cfg;
        };

        _proto.generateFacets = function generateFacets(data) {
          var self = this;
          var fields = self.fields; // var defs = self.defs;

          var rst = [];
          var rows = 1;
          var cols = 1;
          var colField = fields[0];
          var rowField = fields[1];
          var colValues = [''];
          var rowValues = [''];

          if (colField) {
            colValues = self.getFieldValues(colField, data);
            cols = colValues.length;
          }

          if (rowField) {
            rowValues = self.getFieldValues(rowField, data);
            rows = rowValues.length;
          } // 获取每个维度对应的frame


          colValues.forEach(function (xVal, xIndex) {
            rowValues.forEach(function (yVal, yIndex) {
              var conditions = [{
                field: colField,
                value: xVal,
                values: colValues
              }, {
                field: rowField,
                value: yVal,
                values: rowValues
              }];
              var filter = self.getFilter(conditions);
              var subData = data.filter(filter);
              var facet = {
                type: self.type,
                colValue: xVal,
                rowValue: yVal,
                colField: colField,
                rowField: rowField,
                colIndex: xIndex,
                rowIndex: yIndex,
                cols: cols,
                rows: rows,
                data: subData,
                region: self.getRegion(rows, cols, xIndex, yIndex)
              };
              rst.push(facet);
            });
          });
          return rst;
        } // 设置 x 坐标轴的文本、title 是否显示
        ;

        _proto.setXAxis = function setXAxis(xField, axes, facet) {
          if (facet.rowIndex !== facet.rows - 1) {
            axes[xField].title = null;
            axes[xField].label = null;
          } else if (facet.colIndex !== parseInt((facet.cols - 1) / 2)) {
            axes[xField].title = null;
          }
        } // 设置 y 坐标轴的文本、title 是否显示
        ;

        _proto.setYAxis = function setYAxis(yField, axes, facet) {
          if (facet.colIndex !== 0) {
            axes[yField].title = null;
            axes[yField].label = null;
          } else if (facet.rowIndex !== parseInt((facet.rows - 1) / 2)) {
            axes[yField].title = null;
          }
        };

        _proto.renderTitle = function renderTitle(view, facet) {
          if (facet.rowIndex === 0) {
            this.drawColTitle(view, facet);
          }

          if (facet.colIndex === facet.cols - 1) {
            this.drawRowTitle(view, facet);
          }
        };

        return Rect;
      }(Base);

      module.exports = Rect;
      /***/
    },
    /* 402 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview list facets, support cols
       */


      var Base = __webpack_require__(366);
      /**
       * 用于生成分面的类
       * @class Facets.List
       */


      var List = /*#__PURE__*/function (_Base) {
        _inheritsLoose(List, _Base);

        function List() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = List.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          cfg.type = 'list';
          cfg.cols = null; // 用户不设置时就显示一行

          return cfg;
        };

        _proto.generateFacets = function generateFacets(data) {
          var self = this;
          var fields = self.fields;
          var colField = fields[0];

          if (!colField) {
            throw 'Please specify for the field for facet!';
          }

          var colValues = self.getFieldValues(colField, data);
          var count = colValues.length;
          var cols = self.cols || count;
          var rows = parseInt((count + cols - 1) / cols);
          var rst = [];
          colValues.forEach(function (xVal, index) {
            var row = parseInt(index / cols);
            var col = index % cols;
            var conditions = [{
              field: colField,
              value: xVal,
              values: colValues
            }];
            var filter = self.getFilter(conditions);
            var subData = data.filter(filter);
            var facet = {
              type: self.type,
              count: count,
              colValue: xVal,
              colField: colField,
              rowField: null,
              rowValue: xVal,
              colIndex: col,
              rowIndex: row,
              cols: cols,
              rows: rows,
              data: subData,
              region: self.getRegion(rows, cols, col, row)
            };
            rst.push(facet);
          });
          return rst;
        } // 设置 x 坐标轴的文本、title 是否显示
        ;

        _proto.setXAxis = function setXAxis(xField, axes, facet) {
          // 当是最后一行或者下面没有 view 时文本不显示
          if (facet.rowIndex !== facet.rows - 1 && facet.cols * facet.rowIndex + facet.colIndex + 1 + facet.cols <= facet.count) {
            axes[xField].label = null;
            axes[xField].title = null;
          }
        } // 设置 y 坐标轴的文本、title 是否显示
        ;

        _proto.setYAxis = function setYAxis(yField, axes, facet) {
          if (facet.colIndex !== 0) {
            axes[yField].title = null;
            axes[yField].label = null;
          }
        };

        return List;
      }(Base);

      module.exports = List;
      /***/
    },
    /* 403 */

    /***/
    function (module, exports, __webpack_require__) {
      var G2 = __webpack_require__(172); // geoms


      __webpack_require__(404);

      __webpack_require__(406);

      __webpack_require__(408);

      __webpack_require__(367);

      __webpack_require__(369);

      __webpack_require__(361);

      __webpack_require__(371);

      __webpack_require__(409);

      __webpack_require__(411);

      __webpack_require__(413);

      __webpack_require__(489); // facets


      __webpack_require__(491); // interaction


      __webpack_require__(496);

      module.exports = G2;
      /***/
    },
    /* 404 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 面积图
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var SplitMixin = __webpack_require__(360);

      var Util = __webpack_require__(0);

      __webpack_require__(405);

      var Area = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Area, _GeomBase);

        var _proto = Area.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'area';
          cfg.shapeType = 'area';
          cfg.generatePoints = true;
          cfg.sortable = true;
          return cfg;
        };

        function Area(cfg) {
          var _this;

          _this = _GeomBase.call(this, cfg) || this;
          Util.assign(_assertThisInitialized(_this), SplitMixin);
          return _this;
        }

        _proto.draw = function draw(data, container, shapeFactory, index) {
          var self = this;
          var cfg = this.getDrawCfg(data[0]);

          self._applyViewThemeShapeStyle(cfg, cfg.shape, shapeFactory);

          var splitArray = this.splitData(data);
          cfg.origin = data; // path,line,area 等图的origin 是整个序列

          Util.each(splitArray, function (subData, splitedIndex) {
            cfg.splitedIndex = splitedIndex; // 传入分割片段索引 用于生成id

            var points = subData.map(function (obj) {
              return obj.points;
            });
            cfg.points = points;
            var geomShape = shapeFactory.drawShape(cfg.shape, cfg, container);
            self.appendShapeInfo(geomShape, index + splitedIndex);
          });
        };

        return Area;
      }(GeomBase);

      var AreaStack = /*#__PURE__*/function (_Area) {
        _inheritsLoose(AreaStack, _Area);

        function AreaStack() {
          return _Area.apply(this, arguments) || this;
        }

        var _proto2 = AreaStack.prototype;

        _proto2.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Area.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'stack'
          }];
          return cfg;
        };

        return AreaStack;
      }(Area);

      Area.Stack = AreaStack;
      GeomBase.Area = Area;
      GeomBase.AreaStack = AreaStack;
      module.exports = Area;
      /***/
    },
    /* 405 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview area shape
       * @author dxq613@gmail.com
       * @author sima.zhang1990@gmail.com
       */
      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var PathUtil = __webpack_require__(23);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      function getLineAttrs(cfg) {
        var defaultAttrs = Global.shape.hollowArea;
        var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addStrokeAttrs(lineAttrs, cfg);

        if (Util.isNumber(cfg.size)) {
          lineAttrs.lineWidth = cfg.size;
        }

        return lineAttrs;
      }

      function getFillAttrs(cfg) {
        var defaultAttrs = Global.shape.area;
        var areaAttrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addFillAttrs(areaAttrs, cfg);

        if (cfg.color) {
          areaAttrs.stroke = areaAttrs.stroke || cfg.color;
        }

        if (Util.isNumber(cfg.size)) {
          areaAttrs.lineWidth = cfg.size;
        }

        return areaAttrs;
      }

      function getPath(cfg, smooth, shape) {
        var path = [];
        var pointsArr = [];
        var topLinePoints = []; // area 区域上部分

        var bottomLinePoints = []; // area 区域下部分

        var isInCircle = cfg.isInCircle;
        Util.each(cfg.points, function (point) {
          topLinePoints.push(point[1]);
          bottomLinePoints.push(point[0]);
        }); // if (!isInCircle) {

        bottomLinePoints = bottomLinePoints.reverse(); // }

        pointsArr.push(topLinePoints, bottomLinePoints);
        Util.each(pointsArr, function (points, index) {
          var subPath = [];
          points = shape.parsePoints(points);
          var p1 = points[0];

          if (isInCircle) {
            points.push({
              x: p1.x,
              y: p1.y
            });
          }

          if (smooth) {
            subPath = PathUtil.getSplinePath(points, false, cfg.constraint);
          } else {
            subPath = PathUtil.getLinePath(points, false);
          }

          if (index > 0) {
            subPath[0][0] = 'L';
          }

          path = path.concat(subPath);
        });
        path.push(['Z']);
        return path;
      } // get marker cfg


      function _getMarkerCfg(cfg) {
        return {
          symbol: function symbol(x, y, r) {
            return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
          },
          radius: 5,
          fill: cfg.color,
          fillOpacity: 0.6
        };
      } // 鼠标悬浮触发active状态


      function _getActiveCfg(type, cfg) {
        if (type === 'line' || type === 'smoothLine') {
          // 线加粗
          var lineWidth = cfg.lineWidth || 0;
          return {
            lineWidth: lineWidth + 1
          };
        }

        var opacity = cfg.fillOpacity || cfg.opacity || 1;
        return {
          fillOpacity: opacity - 0.15,
          strokeOpacity: opacity - 0.15
        };
      } // 当只有一个数据时绘制点


      function drawPointShape(shapeObj, cfg, container) {
        var coord = shapeObj._coord;
        var point = coord.convertPoint(cfg.points[0][1]);
        return container.addShape('circle', {
          attrs: Util.mix({
            x: point.x,
            y: point.y,
            r: 2,
            fill: cfg.color
          }, cfg.style)
        });
      }

      var Area = Shape.registerFactory('area', {
        defaultShapeType: 'area',

        /**
         * @override
         * @protected
         * 计算点 如果存在多个点，分割成单个的点, 不考虑多个x对应一个y的情况
         * 单点则补上y0点
         */
        getDefaultPoints: function getDefaultPoints(pointInfo) {
          var points = [];
          var x = pointInfo.x;
          var y = pointInfo.y;
          var y0 = pointInfo.y0;
          y = Util.isArray(y) ? y : [y0, y];
          Util.each(y, function (yItem) {
            points.push({
              x: x,
              y: yItem
            });
          });
          return points;
        },
        // 获取激活的图形属性
        getActiveCfg: function getActiveCfg(type, cfg) {
          return _getActiveCfg(type, cfg);
        },
        drawShape: function drawShape(type, cfg, container) {
          var shape = this.getShape(type);
          var gShape;

          if (cfg.points.length === 1 && Global.showSinglePoint) {
            gShape = drawPointShape(this, cfg, container);
          } else {
            gShape = shape.draw(cfg, container);
          }

          if (gShape) {
            gShape.set('origin', cfg.origin);
            gShape._id = cfg.splitedIndex ? cfg._id + cfg.splitedIndex : cfg._id;
            gShape.name = this.name;
          }

          return gShape;
        },
        getSelectedCfg: function getSelectedCfg(type, cfg) {
          if (cfg && cfg.style) {
            return cfg.style;
          }

          return this.getActiveCfg(type, cfg);
        }
      }); // 默认：填充区域图

      Shape.registerShape('area', 'area', {
        draw: function draw(cfg, container) {
          var attrs = getFillAttrs(cfg);
          var path = getPath(cfg, false, this); // path = this.parsePath(path, false);

          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getMarkerCfg(cfg);
        }
      }); // 填充平滑区域图

      Shape.registerShape('area', 'smooth', {
        draw: function draw(cfg, container) {
          var attrs = getFillAttrs(cfg);
          var coord = this._coord; // 曲线的限制

          cfg.constraint = [[coord.start.x, coord.end.y], [coord.end.x, coord.start.y]];
          var path = getPath(cfg, true, this); // path = this.parsePath(path, false);

          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getMarkerCfg(cfg);
        }
      }); // 封闭的折线

      Shape.registerShape('area', 'line', {
        draw: function draw(cfg, container) {
          var attrs = getLineAttrs(cfg);
          var path = getPath(cfg, false, this); // path = this.parsePath(path, false);

          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getMarkerCfg(cfg);
        }
      }); // 封闭的平滑线

      Shape.registerShape('area', 'smoothLine', {
        draw: function draw(cfg, container) {
          var attrs = getLineAttrs(cfg);
          var path = getPath(cfg, true, this);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return _getMarkerCfg(cfg);
        }
      });
      Area.spline = Area.smooth;
      module.exports = Area;
      /***/
    },
    /* 406 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 边，用于关系图的边
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      __webpack_require__(407);

      var Edge = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Edge, _GeomBase);

        function Edge() {
          return _GeomBase.apply(this, arguments) || this;
        }

        var _proto = Edge.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'edge';
          cfg.shapeType = 'edge';
          cfg.generatePoints = true;
          return cfg;
        };

        return Edge;
      }(GeomBase);

      GeomBase.Edge = Edge;
      module.exports = Edge;
      /***/
    },
    /* 407 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 边的 shape
       * @author dxq613@gmail.com
       */
      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      var PathUtil = __webpack_require__(23);

      var CORNER_PERCENT = 1 / 3;

      function getAttrs(cfg) {
        var defaultCfg = Global.shape.edge;
        var lineAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addStrokeAttrs(lineAttrs, cfg);

        if (cfg.size) {
          lineAttrs.lineWidth = cfg.size;
        }

        return lineAttrs;
      }

      var Edge = Shape.registerFactory('edge', {
        defaultShapeType: 'line',
        getDefaultPoints: function getDefaultPoints(pointInfo) {
          return ShapeUtil.splitPoints(pointInfo);
        },
        getActiveCfg: function getActiveCfg(type, cfg) {
          var lineWidth = cfg.lineWidth || 0;
          return {
            lineWidth: lineWidth + 1
          };
        }
      });

      function getCPath(from, to) {
        var points = [];
        points.push({
          x: from.x,
          y: from.y * (1 - 1 / 2) + to.y * 1 / 2
        });
        points.push({
          y: from.y * (1 - 1 / 2) + to.y * 1 / 2,
          x: to.x
        });
        points.push(to);
        var sub = ['C'];
        Util.each(points, function (point) {
          sub.push(point.x, point.y);
        });
        return sub;
      }

      function getQPath(to, center) {
        var points = [];
        points.push({
          x: center.x,
          y: center.y
        });
        points.push(to);
        var sub = ['Q'];
        Util.each(points, function (point) {
          sub.push(point.x, point.y);
        });
        return sub;
      }

      function createSmoothPath(from, to) {
        var sub = getCPath(from, to);
        var path = [['M', from.x, from.y]];
        path.push(sub);
        return path;
      }

      function createArcPath(from, to, center) {
        var sub = getQPath(to, center);
        var path = [['M', from.x, from.y]];
        path.push(sub);
        return path;
      }

      function createArcWeightPath(points, center) {
        var arc1 = getQPath(points[1], center);
        var arc2 = getQPath(points[3], center);
        var path = [['M', points[0].x, points[0].y]];
        path.push(arc2);
        path.push(['L', points[3].x, points[3].y]);
        path.push(['L', points[2].x, points[2].y]);
        path.push(arc1);
        path.push(['L', points[1].x, points[1].y]);
        path.push(['L', points[0].x, points[0].y]);
        path.push(['Z']);
        return path;
      }

      function createRectPath(from, to) {
        var points = [];
        points.push({
          y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
          x: from.x
        });
        points.push({
          y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
          x: to.x
        });
        points.push(to);
        var path = [['M', from.x, from.y]];
        Util.each(points, function (point) {
          path.push(['L', point.x, point.y]);
        });
        return path;
      }

      Shape.registerShape('edge', 'line', {
        draw: function draw(cfg, container) {
          var points = this.parsePoints(cfg.points);
          var attrCfg = getAttrs(cfg);
          var path = PathUtil.getLinePath(points);
          var line = container.addShape('path', {
            attrs: Util.mix(attrCfg, {
              path: path
            })
          });
          return line;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4.5
          }, getAttrs(cfg));
        }
      });
      Shape.registerShape('edge', 'vhv', {
        draw: function draw(cfg, container) {
          var points = cfg.points;
          var attrCfg = getAttrs(cfg);
          var path = createRectPath(points[0], points[1]);
          path = this.parsePath(path);
          var line = container.addShape('path', {
            attrs: Util.mix(attrCfg, {
              path: path
            })
          });
          return line;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4.5
          }, getAttrs(cfg));
        }
      });
      Shape.registerShape('edge', 'smooth', {
        draw: function draw(cfg, container) {
          var points = cfg.points;
          var attrCfg = getAttrs(cfg);
          var path = createSmoothPath(points[0], points[1]);
          path = this.parsePath(path);
          var line = container.addShape('path', {
            attrs: Util.mix(attrCfg, {
              path: path
            })
          });
          return line;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4.5
          }, getAttrs(cfg));
        }
      }); //  弧线包括笛卡尔坐标系下的半圆弧线、极坐标系下以圆心为控制点的二阶曲线、笛卡尔坐标系下带权重的三阶曲线、极坐标系下带权重的以圆心为控制点的二阶曲线

      Shape.registerShape('edge', 'arc', {
        draw: function draw(cfg, container) {
          var points = cfg.points;
          var type = points.length > 2 ? 'weight' : 'normal';
          var attrCfg = getAttrs(cfg);
          var line;
          var path;

          if (cfg.isInCircle) {
            var center = {
              x: 0,
              y: 1
            };

            if (type === 'normal') {
              path = createArcPath(points[0], points[1], center);
            } else {
              attrCfg.fill = attrCfg.stroke;
              path = createArcWeightPath(points, center);
            }

            path = this.parsePath(path);
            line = container.addShape('path', {
              attrs: Util.mix(attrCfg, {
                path: path
              })
            });
          } else {
            if (type === 'normal') {
              points = this.parsePoints(points);
              line = container.addShape('arc', {
                attrs: Util.mix(attrCfg, {
                  x: (points[1].x + points[0].x) / 2,
                  y: points[0].y,
                  r: Math.abs(points[1].x - points[0].x) / 2,
                  startAngle: Math.PI,
                  endAngle: Math.PI * 2
                })
              });
            } else {
              path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y]];
              var c1 = getCPath(points[1], points[3]);
              var c2 = getCPath(points[2], points[0]);
              path.push(c1);
              path.push(['L', points[3].x, points[3].y]);
              path.push(['L', points[2].x, points[2].y]);
              path.push(c2);
              path.push(['Z']);
              path = this.parsePath(path);
              attrCfg.fill = attrCfg.stroke;
              line = container.addShape('path', {
                attrs: Util.mix(attrCfg, {
                  path: path
                })
              });
            }
          }

          return line;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4.5
          }, getAttrs(cfg));
        }
      });
      module.exports = Edge;
      /***/
    },
    /* 408 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview heatmap
       * @author leungwensen@gmail.com
       */


      var _require = __webpack_require__(73),
          ColorUtil = _require.ColorUtil; // TODO: ColorUtil 独立成包，从 attr 包中抽离


      var GeomBase = __webpack_require__(21);

      var Util = __webpack_require__(0);

      var ORIGIN_FIELD = '_origin';
      var SHADOW_CANVAS = 'shadowCanvas';
      var VALUE_RANGE = 'valueRange';
      var IMAGE_SHAPE = 'imageShape';
      var MAPPED_DATA = 'mappedData';
      var GRAY_SCALE_BLURRED_CANVAS = 'grayScaleBlurredCanvas';
      var HEATMAP_SIZE = 'heatmapSize';

      var Heatmap = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Heatmap, _GeomBase);

        function Heatmap() {
          return _GeomBase.apply(this, arguments) || this;
        }

        var _proto = Heatmap.prototype;
        /**
         * get default configuration
         * @protected
         * @return {Object} configuration
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'heatmap';
          cfg.paletteCache = {}; // cfg.shapeType = 'heatmap';

          return cfg;
        };

        _proto._prepareRange = function _prepareRange() {
          var self = this;
          var data = self.get(MAPPED_DATA);
          var colorAttr = self.getAttr('color');
          var colorField = colorAttr.field;
          var min = Infinity;
          var max = -Infinity;
          data.forEach(function (row) {
            var value = row[ORIGIN_FIELD][colorField];

            if (value > max) {
              max = value;
            }

            if (value < min) {
              min = value;
            }
          });

          if (min === max) {
            min = max - 1;
          }

          var range = [min, max];
          self.set(VALUE_RANGE, range);
        };

        _proto._prepareSize = function _prepareSize() {
          var self = this;
          var radius = self.getDefaultValue('size');

          if (!Util.isNumber(radius)) {
            radius = self._getDefaultSize();
          }

          var styleOptions = self.get('styleOptions');
          var blur = styleOptions && Util.isObject(styleOptions.style) ? styleOptions.style.blur : null;

          if (!Util.isFinite(blur) || blur === null) {
            blur = radius / 2;
          }

          self.set(HEATMAP_SIZE, {
            blur: blur,
            radius: radius
          });
        };

        _proto._getDefaultSize = function _getDefaultSize() {
          var self = this;
          var position = self.getAttr('position');
          var coord = self.get('coord');
          var radius = Math.min(coord.width / (position.scales[0].ticks.length * 4), coord.height / (position.scales[1].ticks.length * 4));
          return radius;
        };

        _proto._colorize = function _colorize(img) {
          var self = this;
          var colorAttr = self.getAttr('color');
          var pixels = img.data;
          var paletteCache = self.get('paletteCache');

          for (var i = 3; i < pixels.length; i += 4) {
            var alpha = pixels[i]; // get gradient color from opacity value

            if (alpha) {
              var palette = void 0;

              if (paletteCache[alpha]) {
                palette = paletteCache[alpha];
              } else {
                palette = ColorUtil.rgb2arr(colorAttr.gradient(alpha / 256));
                paletteCache[alpha] = palette;
              } // const palette = colorUtil.rgb2arr(colorAttr.gradient(alpha / 256));


              pixels[i - 3] = palette[0];
              pixels[i - 2] = palette[1];
              pixels[i - 1] = palette[2];
              pixels[i] = alpha;
            }
          }
        };

        _proto._prepareGreyScaleBlurredCircle = function _prepareGreyScaleBlurredCircle(r, blur) {
          var self = this;
          var circleCanvas = self.get(GRAY_SCALE_BLURRED_CANVAS);

          if (!circleCanvas) {
            circleCanvas = document.createElement('canvas');
            self.set(GRAY_SCALE_BLURRED_CANVAS, circleCanvas);
          }

          var r2 = r + blur;
          var ctx = circleCanvas.getContext('2d');
          circleCanvas.width = circleCanvas.height = r2 * 2;
          ctx.clearRect(0, 0, circleCanvas.width, circleCanvas.height); // ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;

          ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
          ctx.shadowBlur = blur;
          ctx.shadowColor = 'black';
          ctx.beginPath();
          ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fill();
        };

        _proto._drawGrayScaleBlurredCircle = function _drawGrayScaleBlurredCircle(x, y, r, alpha, ctx) {
          var self = this;
          var circleCanvas = self.get(GRAY_SCALE_BLURRED_CANVAS);
          ctx.globalAlpha = alpha;
          ctx.drawImage(circleCanvas, x - r, y - r);
        };

        _proto._getShadowCanvasCtx = function _getShadowCanvasCtx() {
          var self = this;
          var canvas = self.get(SHADOW_CANVAS);

          if (!canvas) {
            canvas = document.createElement('canvas');
            self.set(SHADOW_CANVAS, canvas);
          }

          var coord = self.get('coord');

          if (coord) {
            canvas.width = coord.width;
            canvas.height = coord.height;
          }

          return canvas.getContext('2d');
        };

        _proto._clearShadowCanvasCtx = function _clearShadowCanvasCtx() {
          var ctx = this._getShadowCanvasCtx();

          ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        };

        _proto._getImageShape = function _getImageShape() {
          var self = this;
          var imageShape = self.get(IMAGE_SHAPE);

          if (imageShape) {
            return imageShape;
          }

          var container = self.get('container');
          imageShape = container.addShape('Image', {});
          self.set(IMAGE_SHAPE, imageShape);
          return imageShape;
        };

        _proto.clear = function clear() {
          // @2019-02-28 by blue.lb 由于设置了SHADOW_CANVAS作为像素缓存canvas，每次销毁chart时，也需要清除该缓冲区
          this._clearShadowCanvasCtx();

          _GeomBase.prototype.clear.call(this);
        };

        _proto.drawWithRange = function drawWithRange(range) {
          var self = this; // canvas size

          var _self$get = self.get('coord'),
              start = _self$get.start,
              end = _self$get.end,
              width = _self$get.width,
              height = _self$get.height; // value, range, etc


          var valueField = self.getAttr('color').field;
          var size = self.get(HEATMAP_SIZE); // prepare shadow canvas context

          self._clearShadowCanvasCtx();

          var ctx = self._getShadowCanvasCtx(); // filter data


          var data = self.get(MAPPED_DATA);

          if (range) {
            data = data.filter(function (row) {
              return row[ORIGIN_FIELD][valueField] <= range[1] && row[ORIGIN_FIELD][valueField] >= range[0];
            });
          } // step1. draw points with shadow


          var scale = self._getScale(valueField);

          for (var i = 0; i < data.length; i++) {
            var obj = data[i];
            var cfg = self.getDrawCfg(obj);
            var alpha = scale.scale(obj[ORIGIN_FIELD][valueField]);

            self._drawGrayScaleBlurredCircle(cfg.x - start.x, cfg.y - end.y, size.radius + size.blur, alpha, ctx);
          } // step2. convert pixels


          var colored = ctx.getImageData(0, 0, width, height);

          self._clearShadowCanvasCtx();

          self._colorize(colored);

          ctx.putImageData(colored, 0, 0);

          var imageShape = self._getImageShape();

          imageShape.attr('x', start.x);
          imageShape.attr('y', end.y);
          imageShape.attr('width', width);
          imageShape.attr('height', height);
          imageShape.attr('img', ctx.canvas);
        };

        _proto.draw = function draw(data
        /* , container, shapeFactory, index */
        ) {
          var self = this;
          self.set(MAPPED_DATA, data);

          self._prepareRange();

          self._prepareSize();

          var size = self.get(HEATMAP_SIZE);

          self._prepareGreyScaleBlurredCircle(size.radius, size.blur);

          var range = self.get(VALUE_RANGE);
          self.drawWithRange(range); // super.draw(data, container, shapeFactory, index);
        };

        return Heatmap;
      }(GeomBase);

      GeomBase.Heatmap = Heatmap;
      module.exports = Heatmap;
      /***/
    },
    /* 409 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 多边形
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var Util = __webpack_require__(0);

      __webpack_require__(410);

      var Polygon = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Polygon, _GeomBase);

        function Polygon() {
          return _GeomBase.apply(this, arguments) || this;
        }

        var _proto = Polygon.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'polygon';
          cfg.shapeType = 'polygon';
          cfg.generatePoints = true;
          return cfg;
        };

        _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
          var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

          var self = this;
          var x = cfg.x;
          var y = cfg.y;
          var temp;

          if (!(Util.isArray(x) && Util.isArray(y))) {
            // x y 都是数组时，不做处理
            var xScale = self.getXScale();
            var yScale = self.getYScale();
            var xCount = xScale.values ? xScale.values.length : xScale.ticks.length;
            var yCount = yScale.values ? yScale.values.length : yScale.ticks.length;
            var xOffset = 0.5 * 1 / xCount;
            var yOffset = 0.5 * 1 / yCount;

            if (xScale.isCategory && yScale.isCategory) {
              // 如果x,y都是分类
              x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
              y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
            } else if (Util.isArray(x)) {
              // x 是数组
              temp = x;
              x = [temp[0], temp[0], temp[1], temp[1]];
              y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
            } else if (Util.isArray(y)) {
              // y 是数组
              temp = y;
              y = [temp[0], temp[1], temp[1], temp[0]];
              x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
            }

            cfg.x = x;
            cfg.y = y;
          }

          return cfg;
        };

        return Polygon;
      }(GeomBase);

      GeomBase.Polygon = Polygon;
      module.exports = Polygon;
      /***/
    },
    /* 410 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview line shapes
       * @author dxq613@gmail.com
       * @author sima.zhang1990@gmail.com
       * @author huangtonger@aliyun.com
       # @author liuye10@yahoo.com
       */
      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      function getAttrs(cfg) {
        var defaultCfg = Global.shape.polygon;
        var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addFillAttrs(pathAttrs, cfg);
        return pathAttrs;
      }

      function getHollowAttrs(cfg) {
        var defaultCfg = Global.shape.hollowPolygon;
        var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addStrokeAttrs(pathAttrs, cfg);
        return pathAttrs;
      }

      function getPath(points) {
        var flag = points[0];
        var i = 1;
        var path = [['M', flag.x, flag.y]];

        while (i < points.length) {
          var c = points[i];

          if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
            path.push(['L', c.x, c.y]);

            if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
              flag = points[i + 1];
              path.push(['Z']);
              path.push(['M', flag.x, flag.y]);
              i++;
            }
          }

          i++;
        }

        if (!Util.isEqual(path[path.length - 1], flag)) {
          path.push(['L', flag.x, flag.y]);
        }

        path.push(['Z']);
        return path;
      } // regist line geom


      var Polygon = Shape.registerFactory('polygon', {
        defaultShapeType: 'polygon',
        getDefaultPoints: function getDefaultPoints(pointInfo) {
          var points = [];
          Util.each(pointInfo.x, function (subX, index) {
            var subY = pointInfo.y[index];
            points.push({
              x: subX,
              y: subY
            });
          });
          return points;
        },
        getActiveCfg: function getActiveCfg(type, cfg) {
          var lineWidth = cfg.lineWidth || 1;

          if (type === 'hollow') {
            return {
              lineWidth: lineWidth + 1
            };
          }

          var opacity = cfg.fillOpacity || cfg.opacity || 1;
          return {
            // lineWidth,
            fillOpacity: opacity - 0.08
          };
        },
        getSelectedCfg: function getSelectedCfg(type, cfg) {
          if (cfg && cfg.style) {
            return cfg.style;
          }

          return this.getActiveCfg(type, cfg);
        }
      });
      Shape.registerShape('polygon', 'polygon', {
        draw: function draw(cfg, container) {
          if (!Util.isEmpty(cfg.points)) {
            var attrs = getAttrs(cfg);
            var path = getPath(cfg.points);
            path = this.parsePath(path);
            return container.addShape('path', {
              attrs: Util.mix(attrs, {
                path: path
              })
            });
          }
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'square',
            radius: 4
          }, getAttrs(cfg));
        }
      });
      Shape.registerShape('polygon', 'hollow', {
        draw: function draw(cfg, container) {
          if (!Util.isEmpty(cfg.points)) {
            var attrs = getHollowAttrs(cfg);
            var path = getPath(cfg.points);
            path = this.parsePath(path);
            return container.addShape('path', {
              attrs: Util.mix(attrs, {
                path: path
              })
            });
          }
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'square',
            radius: 4
          }, getAttrs(cfg));
        }
      });
      module.exports = Polygon;
      /***/
    },
    /* 411 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview 自定义图形
       * @author dxq613@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var Util = __webpack_require__(0);

      var SizeMixin = __webpack_require__(359);

      __webpack_require__(412);

      var Schema = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Schema, _GeomBase);

        var _proto = Schema.prototype;
        /**
         * 获取默认的配置属性
         * @protected
         * @return {Object} 默认属性
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'schema';
          cfg.shapeType = 'schema';
          cfg.generatePoints = true;
          return cfg;
        };

        function Schema(cfg) {
          var _this;

          _this = _GeomBase.call(this, cfg) || this;
          Util.assign(_assertThisInitialized(_this), SizeMixin);
          return _this;
        }

        _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
          var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

          cfg.size = this.getNormalizedSize(obj);
          return cfg;
        };

        _proto.clearInner = function clearInner() {
          _GeomBase.prototype.clearInner.call(this);

          this.set('defaultSize', null);
        };

        return Schema;
      }(GeomBase);

      var SchemaDodge = /*#__PURE__*/function (_Schema) {
        _inheritsLoose(SchemaDodge, _Schema);

        function SchemaDodge() {
          return _Schema.apply(this, arguments) || this;
        }

        var _proto2 = SchemaDodge.prototype;

        _proto2.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Schema.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'dodge'
          }];
          return cfg;
        };

        return SchemaDodge;
      }(Schema);

      Schema.Dodge = SchemaDodge;
      GeomBase.Schema = Schema;
      GeomBase.SchemaDodge = SchemaDodge;
      module.exports = Schema;
      /***/
    },
    /* 412 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview 自定义的 shape
       * @author dxq613@gmail.com
       * @author sima.zhang1990@gmail.com
       */
      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      function _parseValue(value) {
        if (!Util.isArray(value)) {
          value = [value];
        }

        var min = value[0]; // 最小值

        var max = value[value.length - 1]; // 最大值

        var min1 = value.length > 1 ? value[1] : min;
        var max1 = value.length > 3 ? value[3] : max;
        var median = value.length > 2 ? value[2] : min1;
        return {
          min: min,
          // 最小值
          max: max,
          // 最大值
          min1: min1,
          max1: max1,
          median: median
        };
      }

      function addPoints(from, to) {
        Util.each(from, function (subArr) {
          to.push({
            x: subArr[0],
            y: subArr[1]
          });
        });
      }

      function getAttrs(cfg) {
        var defaultAttrs = Global.shape.schema;
        var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addStrokeAttrs(lineAttrs, cfg);
        return lineAttrs;
      }

      function getFillAttrs(cfg) {
        var defaultAttrs = Global.shape.schema;
        var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);
        ShapeUtil.addFillAttrs(lineAttrs, cfg);

        if (cfg.color) {
          lineAttrs.stroke = cfg.color || lineAttrs.stroke;
        }

        return lineAttrs;
      }

      function getBoxPoints(x, y, width) {
        var points = [];
        var pointsArray;
        var obj;

        if (Util.isArray(y)) {
          // 2维
          obj = _parseValue(y);
          pointsArray = [[x - width / 2, obj.max], [x + width / 2, obj.max], [x, obj.max], [x, obj.max1], [x - width / 2, obj.min1], [x - width / 2, obj.max1], [x + width / 2, obj.max1], [x + width / 2, obj.min1], [x, obj.min1], [x, obj.min], [x - width / 2, obj.min], [x + width / 2, obj.min], [x - width / 2, obj.median], [x + width / 2, obj.median]];
        } else {
          // 只有一个维度
          y = y || 0.5;
          obj = _parseValue(x);
          pointsArray = [[obj.min, y - width / 2], [obj.min, y + width / 2], [obj.min, y], [obj.min1, y], [obj.min1, y - width / 2], [obj.min1, y + width / 2], [obj.max1, y + width / 2], [obj.max1, y - width / 2], [obj.max1, y], [obj.max, y], [obj.max, y - width / 2], [obj.max, y + width / 2], [obj.median, y - width / 2], [obj.median, y + width / 2]];
        }

        addPoints(pointsArray, points);
        return points;
      }

      function _sortValue(value) {
        if (!Util.isArray(value)) {
          value = [value];
        } // 从大到小排序


        var sorted = value.sort(function (a, b) {
          return a < b ? 1 : -1;
        });
        var length = sorted.length;

        if (length < 4) {
          var min = sorted[length - 1];

          for (var i = 0; i < 4 - length; i++) {
            sorted.push(min);
          }
        }

        return sorted;
      } // 获取K线图的points


      function getCandlePoints(x, y, width) {
        var yValues = _sortValue(y);

        var points = [{
          x: x,
          y: yValues[0]
        }, {
          x: x,
          y: yValues[1]
        }, {
          x: x - width / 2,
          y: yValues[2]
        }, {
          x: x - width / 2,
          y: yValues[1]
        }, {
          x: x + width / 2,
          y: yValues[1]
        }, {
          x: x + width / 2,
          y: yValues[2]
        }, {
          x: x,
          y: yValues[2]
        }, {
          x: x,
          y: yValues[3]
        }]; // 按照顺时针连接

        return points;
      }

      function getBoxPath(points) {
        var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], // 封闭 z
        ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x, points[10].y], ['L', points[11].x, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
        return path;
      }

      function getCandlePath(points) {
        var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
        return path;
      }

      var Schema = Shape.registerFactory('schema', {
        defaultShapeType: '',
        getActiveCfg: function getActiveCfg(type, cfg) {
          if (type === 'box') {
            var lineWidth = cfg.lineWidth || 1;
            return {
              lineWidth: lineWidth + 1
            };
          }

          var opacity = cfg.fillOpacity || cfg.opacity || 1;
          return {
            fillOpacity: opacity - 0.15,
            strokeOpacity: opacity - 0.15
          };
        },
        getSelectedCfg: function getSelectedCfg(type, cfg) {
          if (cfg && cfg.style) {
            return cfg.style;
          }

          return this.getActiveCfg(type, cfg);
        }
      }); // 箱线图

      Shape.registerShape('schema', 'box', {
        getPoints: function getPoints(pointInfo) {
          return getBoxPoints(pointInfo.x, pointInfo.y, pointInfo.size);
        },
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);
          var path = getBoxPath(cfg.points);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return {
            symbol: function symbol(x, y, r) {
              var yValues = [y - 6, y - 3, y, y + 3, y + 6];
              var points = getBoxPoints(x, yValues, r);
              return [['M', points[0].x + 1, points[0].y], ['L', points[1].x - 1, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x + 1, points[10].y], ['L', points[11].x - 1, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
            },
            radius: 6,
            lineWidth: 1,
            stroke: cfg.color
          };
        }
      }); // K线

      Shape.registerShape('schema', 'candle', {
        getPoints: function getPoints(pointInfo) {
          return getCandlePoints(pointInfo.x, pointInfo.y, pointInfo.size);
        },
        draw: function draw(cfg, container) {
          var attrs = getFillAttrs(cfg);
          var path = getCandlePath(cfg.points);
          path = this.parsePath(path);
          return container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return {
            symbol: function symbol(x, y, r) {
              y = [y + 7.5, y + 3, y - 3, y - 7.5];
              var points = getCandlePoints(x, y, r);
              return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
            },
            lineWidth: 1,
            stroke: cfg.color,
            fill: cfg.color,
            radius: 6
          };
        }
      });
      module.exports = Schema;
      /***/
    },
    /* 413 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview Venn Diagram
       * @author leungwensen@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var Util = __webpack_require__(0);

      var _require = __webpack_require__(414),
          venn = _require.venn,
          scaleSolution = _require.scaleSolution,
          circlePath = _require.circlePath,
          intersectionAreaPath = _require.intersectionAreaPath,
          computeTextCentres = _require.computeTextCentres;

      __webpack_require__(488);

      var Venn = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Venn, _GeomBase);

        function Venn() {
          return _GeomBase.apply(this, arguments) || this;
        }

        var _proto = Venn.prototype;
        /**
         * get default configuration
         * @protected
         * @return {Object} configuration
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'venn';
          cfg.shapeType = 'venn';
          cfg.generatePoints = false; // super.draw(data, container, shapeFactory, index);

          return cfg;
        };

        _proto._getAttrValues = function _getAttrValues(attr, record) {
          if (attr.type === 'position') {
            return [record.x, record.y];
          }

          return _GeomBase.prototype._getAttrValues.call(this, attr, record);
        };

        _proto.sets = function sets(field) {
          this.set('setsField', field);
          return this;
        };

        _proto._initAttrs = function _initAttrs() {
          var self = this;

          _GeomBase.prototype._initAttrs.call(this);

          var attrOptions = self.get('attrOptions');
          var setsField = self.get('setsField') || 'sets';
          var data = self.get('data');
          var sizeField = attrOptions.size ? attrOptions.size.field : 'size'; // prepare data

          data.forEach(function (row) {
            row.sets = row[setsField];
            row._sets = row[setsField].join('&');
            row.size = row[sizeField];
          });
          var solution = venn(data); // scaling

          var coord = self.get('coord');
          var xRange = [Math.min(coord.x.end, coord.x.start), Math.max(coord.x.end, coord.x.start)];
          var yRange = [Math.min(coord.y.end, coord.y.start), Math.max(coord.y.end, coord.y.start)];
          var width = xRange[1] - xRange[0];
          var height = yRange[1] - yRange[0];
          var styleOptions = self.get('styleOptions');
          var padding = styleOptions && Util.isObject(styleOptions.style) ? styleOptions.style.padding : 0;

          if (!Util.isFinite(padding)) {
            padding = 0;
          }

          var circles = scaleSolution(solution, width, height, padding);
          var textCenters = computeTextCentres(circles, data);
          data.forEach(function (row) {
            var sets = row.sets;
            var id = sets.join(',');
            row.id = id;

            if (sets.length === 1) {
              var circle = circles[id];
              row.path = circlePath(circle.x, circle.y, circle.radius);
              Util.assign(row, circle);
            } else {
              var setCircles = sets.map(function (set) {
                return circles[set];
              });
              var path = intersectionAreaPath(setCircles);

              if (!/[zZ]$/.test(path)) {
                path += 'Z';
              }

              row.path = path;
              var center = textCenters[id] || {
                x: 0,
                y: 0
              };
              Util.assign(row, center);
            }
          }); // x, y scales
          // self.position('x*y');
          // self.scale('x', { type: 'identity' });
          // self.scale('y', { type: 'identity' });
        } // createShapePointsCfg(obj) {
        //   const xScale = this.getXScale();
        //   const yScale = this.getYScale();
        //   return {
        //     x: obj[xScale.field],
        //     y: obj[yScale.field],
        //     y0: yScale ? yScale.scale(this.getYMinValue()) : undefined
        //   };
        // }
        // paint() {
        //   super.paint();
        //   const self = this;
        //   const dataArray = self.get('dataArray');
        //   const shapeContainer = self.get('shapeContainer');
        //   // add labels
        //   dataArray.forEach(row => {
        //     const cfg = self.getDrawCfg(row[0]);
        //     const origin = cfg.origin._origin;
        //     shapeContainer.addShape('text', {
        //       attrs: Util.mix({}, {
        //         x: origin.x,
        //         y: origin.y,
        //         text: origin.label || '',
        //         fontSize: 18,
        //         fill: cfg.shape === 'hollow' ? cfg.color : '#666',
        //         textAlign: 'center',
        //         textBaseline: 'middle'
        //       }, cfg.style ? cfg.style.textStyle : {})
        //     });
        //   });
        // }
        ;

        return Venn;
      }(GeomBase);

      GeomBase.Venn = Venn;
      module.exports = Venn;
      /***/
    },
    /* 414 */

    /***/
    function (module, exports, __webpack_require__) {
      (function (global, factory) {
        true ? factory(exports, __webpack_require__(72), __webpack_require__(450)) : undefined;
      })(this, function (exports, d3Selection, d3Transition) {
        'use strict';

        var SMALL = 1e-10;
        /** Returns the intersection area of a bunch of circles (where each circle
         is an object having an x,y and radius property) */

        function intersectionArea(circles, stats) {
          // get all the intersection points of the circles
          var intersectionPoints = getIntersectionPoints(circles); // filter out points that aren't included in all the circles

          var innerPoints = intersectionPoints.filter(function (p) {
            return containedInCircles(p, circles);
          });
          var arcArea = 0,
              polygonArea = 0,
              arcs = [],
              i; // if we have intersection points that are within all the circles,
          // then figure out the area contained by them

          if (innerPoints.length > 1) {
            // sort the points by angle from the center of the polygon, which lets
            // us just iterate over points to get the edges
            var center = getCenter(innerPoints);

            for (i = 0; i < innerPoints.length; ++i) {
              var p = innerPoints[i];
              p.angle = Math.atan2(p.x - center.x, p.y - center.y);
            }

            innerPoints.sort(function (a, b) {
              return b.angle - a.angle;
            }); // iterate over all points, get arc between the points
            // and update the areas

            var p2 = innerPoints[innerPoints.length - 1];

            for (i = 0; i < innerPoints.length; ++i) {
              var p1 = innerPoints[i]; // polygon area updates easily ...

              polygonArea += (p2.x + p1.x) * (p1.y - p2.y); // updating the arc area is a little more involved

              var midPoint = {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
              },
                  arc = null;

              for (var j = 0; j < p1.parentIndex.length; ++j) {
                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
                  // figure out the angle halfway between the two points
                  // on the current circle
                  var circle = circles[p1.parentIndex[j]],
                      a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
                      a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);
                  var angleDiff = a2 - a1;

                  if (angleDiff < 0) {
                    angleDiff += 2 * Math.PI;
                  } // and use that angle to figure out the width of the
                  // arc


                  var a = a2 - angleDiff / 2,
                      width = distance(midPoint, {
                    x: circle.x + circle.radius * Math.sin(a),
                    y: circle.y + circle.radius * Math.cos(a)
                  }); // clamp the width to the largest is can actually be
                  // (sometimes slightly overflows because of FP errors)

                  if (width > circle.radius * 2) {
                    width = circle.radius * 2;
                  } // pick the circle whose arc has the smallest width


                  if (arc === null || arc.width > width) {
                    arc = {
                      circle: circle,
                      width: width,
                      p1: p1,
                      p2: p2
                    };
                  }
                }
              }

              if (arc !== null) {
                arcs.push(arc);
                arcArea += circleArea(arc.circle.radius, arc.width);
                p2 = p1;
              }
            }
          } else {
            // no intersection points, is either disjoint - or is completely
            // overlapped. figure out which by examining the smallest circle
            var smallest = circles[0];

            for (i = 1; i < circles.length; ++i) {
              if (circles[i].radius < smallest.radius) {
                smallest = circles[i];
              }
            } // make sure the smallest circle is completely contained in all
            // the other circles


            var disjoint = false;

            for (i = 0; i < circles.length; ++i) {
              if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
                disjoint = true;
                break;
              }
            }

            if (disjoint) {
              arcArea = polygonArea = 0;
            } else {
              arcArea = smallest.radius * smallest.radius * Math.PI;
              arcs.push({
                circle: smallest,
                p1: {
                  x: smallest.x,
                  y: smallest.y + smallest.radius
                },
                p2: {
                  x: smallest.x - SMALL,
                  y: smallest.y + smallest.radius
                },
                width: smallest.radius * 2
              });
            }
          }

          polygonArea /= 2;

          if (stats) {
            stats.area = arcArea + polygonArea;
            stats.arcArea = arcArea;
            stats.polygonArea = polygonArea;
            stats.arcs = arcs;
            stats.innerPoints = innerPoints;
            stats.intersectionPoints = intersectionPoints;
          }

          return arcArea + polygonArea;
        }
        /** returns whether a point is contained by all of a list of circles */


        function containedInCircles(point, circles) {
          for (var i = 0; i < circles.length; ++i) {
            if (distance(point, circles[i]) > circles[i].radius + SMALL) {
              return false;
            }
          }

          return true;
        }
        /** Gets all intersection points between a bunch of circles */


        function getIntersectionPoints(circles) {
          var ret = [];

          for (var i = 0; i < circles.length; ++i) {
            for (var j = i + 1; j < circles.length; ++j) {
              var intersect = circleCircleIntersection(circles[i], circles[j]);

              for (var k = 0; k < intersect.length; ++k) {
                var p = intersect[k];
                p.parentIndex = [i, j];
                ret.push(p);
              }
            }
          }

          return ret;
        }
        /** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */


        function circleArea(r, width) {
          return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
        }
        /** euclidean distance between two points */


        function distance(p1, p2) {
          return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
        }
        /** Returns the overlap area of two circles of radius r1 and r2 - that
        have their centers separated by distance d. Simpler faster
        circle intersection for only two circles */


        function circleOverlap(r1, r2, d) {
          // no overlap
          if (d >= r1 + r2) {
            return 0;
          } // completely overlapped


          if (d <= Math.abs(r1 - r2)) {
            return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
          }

          var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
              w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
          return circleArea(r1, w1) + circleArea(r2, w2);
        }
        /** Given two circles (containing a x/y/radius attributes),
        returns the intersecting points if possible.
        note: doesn't handle cases where there are infinitely many
        intersection points (circles are equivalent):, or only one intersection point*/


        function circleCircleIntersection(p1, p2) {
          var d = distance(p1, p2),
              r1 = p1.radius,
              r2 = p2.radius; // if to far away, or self contained - can't be done

          if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
            return [];
          }

          var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
              h = Math.sqrt(r1 * r1 - a * a),
              x0 = p1.x + a * (p2.x - p1.x) / d,
              y0 = p1.y + a * (p2.y - p1.y) / d,
              rx = -(p2.y - p1.y) * (h / d),
              ry = -(p2.x - p1.x) * (h / d);
          return [{
            x: x0 + rx,
            y: y0 - ry
          }, {
            x: x0 - rx,
            y: y0 + ry
          }];
        }
        /** Returns the center of a bunch of points */


        function getCenter(points) {
          var center = {
            x: 0,
            y: 0
          };

          for (var i = 0; i < points.length; ++i) {
            center.x += points[i].x;
            center.y += points[i].y;
          }

          center.x /= points.length;
          center.y /= points.length;
          return center;
        }
        /** finds the zeros of a function, given two starting points (which must
         * have opposite signs */


        function bisect(f, a, b, parameters) {
          parameters = parameters || {};
          var maxIterations = parameters.maxIterations || 100,
              tolerance = parameters.tolerance || 1e-10,
              fA = f(a),
              fB = f(b),
              delta = b - a;

          if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
          }

          if (fA === 0) return a;
          if (fB === 0) return b;

          for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
              a = mid;
            }

            if (Math.abs(delta) < tolerance || fMid === 0) {
              return mid;
            }
          }

          return a + delta;
        } // need some basic operations on vectors, rather than adding a dependency,
        // just define here


        function zeros(x) {
          var r = new Array(x);

          for (var i = 0; i < x; ++i) {
            r[i] = 0;
          }

          return r;
        }

        function zerosM(x, y) {
          return zeros(x).map(function () {
            return zeros(y);
          });
        }

        function dot(a, b) {
          var ret = 0;

          for (var i = 0; i < a.length; ++i) {
            ret += a[i] * b[i];
          }

          return ret;
        }

        function norm2(a) {
          return Math.sqrt(dot(a, a));
        }

        function scale(ret, value, c) {
          for (var i = 0; i < value.length; ++i) {
            ret[i] = value[i] * c;
          }
        }

        function weightedSum(ret, w1, v1, w2, v2) {
          for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
          }
        }
        /** minimizes a function using the downhill simplex method */


        function nelderMead(f, x0, parameters) {
          parameters = parameters || {};
          var maxIterations = parameters.maxIterations || x0.length * 200,
              nonZeroDelta = parameters.nonZeroDelta || 1.05,
              zeroDelta = parameters.zeroDelta || 0.001,
              minErrorDelta = parameters.minErrorDelta || 1e-6,
              minTolerance = parameters.minErrorDelta || 1e-5,
              rho = parameters.rho !== undefined ? parameters.rho : 1,
              chi = parameters.chi !== undefined ? parameters.chi : 2,
              psi = parameters.psi !== undefined ? parameters.psi : -0.5,
              sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,
              maxDiff; // initialize simplex.

          var N = x0.length,
              simplex = new Array(N + 1);
          simplex[0] = x0;
          simplex[0].fx = f(x0);
          simplex[0].id = 0;

          for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i + 1] = point;
            simplex[i + 1].fx = f(point);
            simplex[i + 1].id = i + 1;
          }

          function updateSimplex(value) {
            for (var i = 0; i < value.length; i++) {
              simplex[N][i] = value[i];
            }

            simplex[N].fx = value.fx;
          }

          var sortOrder = function sortOrder(a, b) {
            return a.fx - b.fx;
          };

          var centroid = x0.slice(),
              reflected = x0.slice(),
              contracted = x0.slice(),
              expanded = x0.slice();

          for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);

            if (parameters.history) {
              // copy the simplex (since later iterations will mutate) and
              // sort it to have a consistent order between iterations
              var sortedSimplex = simplex.map(function (x) {
                var state = x.slice();
                state.fx = x.fx;
                state.id = x.id;
                return state;
              });
              sortedSimplex.sort(function (a, b) {
                return a.id - b.id;
              });
              parameters.history.push({
                x: simplex[0].slice(),
                fx: simplex[0].fx,
                simplex: sortedSimplex
              });
            }

            maxDiff = 0;

            for (i = 0; i < N; ++i) {
              maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }

            if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
              break;
            } // compute the centroid of all but the worst point in the simplex


            for (i = 0; i < N; ++i) {
              centroid[i] = 0;

              for (var j = 0; j < N; ++j) {
                centroid[i] += simplex[j][i];
              }

              centroid[i] /= N;
            } // reflect the worst point past the centroid  and compute loss at reflected
            // point


            var worst = simplex[N];
            weightedSum(reflected, 1 + rho, centroid, -rho, worst);
            reflected.fx = f(reflected); // if the reflected point is the best seen, then possibly expand

            if (reflected.fx < simplex[0].fx) {
              weightedSum(expanded, 1 + chi, centroid, -chi, worst);
              expanded.fx = f(expanded);

              if (expanded.fx < reflected.fx) {
                updateSimplex(expanded);
              } else {
                updateSimplex(reflected);
              }
            } // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N - 1].fx) {
                var shouldReduce = false;

                if (reflected.fx > worst.fx) {
                  // do an inside contraction
                  weightedSum(contracted, 1 + psi, centroid, -psi, worst);
                  contracted.fx = f(contracted);

                  if (contracted.fx < worst.fx) {
                    updateSimplex(contracted);
                  } else {
                    shouldReduce = true;
                  }
                } else {
                  // do an outside contraction
                  weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
                  contracted.fx = f(contracted);

                  if (contracted.fx < reflected.fx) {
                    updateSimplex(contracted);
                  } else {
                    shouldReduce = true;
                  }
                }

                if (shouldReduce) {
                  // if we don't contract here, we're done
                  if (sigma >= 1) break; // do a reduction

                  for (i = 1; i < simplex.length; ++i) {
                    weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                    simplex[i].fx = f(simplex[i]);
                  }
                }
              } else {
                updateSimplex(reflected);
              }
          }

          simplex.sort(sortOrder);
          return {
            fx: simplex[0].fx,
            x: simplex[0]
          };
        } /// searches along line 'pk' for a point that satifies the wolfe conditions
        /// See 'Numerical Optimization' by Nocedal and Wright p59-60
        /// f : objective function
        /// pk : search direction
        /// current: object containing current gradient/loss
        /// next: output: contains next gradient/loss
        /// returns a: step size taken


        function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
          var phi0 = current.fx,
              phiPrime0 = dot(current.fxprime, pk),
              phi = phi0,
              phi_old = phi0,
              phiPrime = phiPrime0,
              a0 = 0;
          a = a || 1;
          c1 = c1 || 1e-6;
          c2 = c2 || 0.1;

          function zoom(a_lo, a_high, phi_lo) {
            for (var iteration = 0; iteration < 16; ++iteration) {
              a = (a_lo + a_high) / 2;
              weightedSum(next.x, 1.0, current.x, a, pk);
              phi = next.fx = f(next.x, next.fxprime);
              phiPrime = dot(next.fxprime, pk);

              if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {
                a_high = a;
              } else {
                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                  return a;
                }

                if (phiPrime * (a_high - a_lo) >= 0) {
                  a_high = a_lo;
                }

                a_lo = a;
                phi_lo = phi;
              }
            }

            return 0;
          }

          for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = dot(next.fxprime, pk);

            if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {
              return zoom(a0, a, phi_old);
            }

            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
              return a;
            }

            if (phiPrime >= 0) {
              return zoom(a, a0, phi);
            }

            phi_old = phi;
            a0 = a;
            a *= 2;
          }

          return a;
        }

        function conjugateGradient(f, initial, params) {
          // allocate all memory up front here, keep out of the loop for perfomance
          // reasons
          var current = {
            x: initial.slice(),
            fx: 0,
            fxprime: initial.slice()
          },
              next = {
            x: initial.slice(),
            fx: 0,
            fxprime: initial.slice()
          },
              yk = initial.slice(),
              pk,
              temp,
              a = 1,
              maxIterations;
          params = params || {};
          maxIterations = params.maxIterations || initial.length * 20;
          current.fx = f(current.x, current.fxprime);
          pk = current.fxprime.slice();
          scale(pk, current.fxprime, -1);

          for (var i = 0; i < maxIterations; ++i) {
            a = wolfeLineSearch(f, pk, current, next, a); // todo: history in wrong spot?

            if (params.history) {
              params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice(),
                alpha: a
              });
            }

            if (!a) {
              // faiiled to find point that satifies wolfe conditions.
              // reset direction for next iteration
              scale(pk, current.fxprime, -1);
            } else {
              // update direction using Polak–Ribiere CG method
              weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
              var delta_k = dot(current.fxprime, current.fxprime),
                  beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);
              weightedSum(pk, beta_k, pk, -1, next.fxprime);
              temp = current;
              current = next;
              next = temp;
            }

            if (norm2(current.fxprime) <= 1e-5) {
              break;
            }
          }

          if (params.history) {
            params.history.push({
              x: current.x.slice(),
              fx: current.fx,
              fxprime: current.fxprime.slice(),
              alpha: a
            });
          }

          return current;
        }
        /** given a list of set objects, and their corresponding overlaps.
        updates the (x, y, radius) attribute on each set such that their positions
        roughly correspond to the desired overlaps */


        function venn(areas, parameters) {
          parameters = parameters || {};
          parameters.maxIterations = parameters.maxIterations || 500;
          var initialLayout = parameters.initialLayout || bestInitialLayout;
          var loss = parameters.lossFunction || lossFunction; // add in missing pairwise areas as having 0 size

          areas = addMissingAreas(areas); // initial layout is done greedily

          var circles = initialLayout(areas, parameters); // transform x/y coordinates to a vector to optimize

          var initial = [],
              setids = [],
              setid;

          for (setid in circles) {
            if (circles.hasOwnProperty(setid)) {
              initial.push(circles[setid].x);
              initial.push(circles[setid].y);
              setids.push(setid);
            }
          } // optimize initial layout from our loss function


          var solution = nelderMead(function (values) {
            var current = {};

            for (var i = 0; i < setids.length; ++i) {
              var setid = setids[i];
              current[setid] = {
                x: values[2 * i],
                y: values[2 * i + 1],
                radius: circles[setid].radius // size : circles[setid].size

              };
            }

            return loss(current, areas);
          }, initial, parameters); // transform solution vector back to x/y points

          var positions = solution.x;

          for (var i = 0; i < setids.length; ++i) {
            setid = setids[i];
            circles[setid].x = positions[2 * i];
            circles[setid].y = positions[2 * i + 1];
          }

          return circles;
        }

        var SMALL$1 = 1e-10;
        /** Returns the distance necessary for two circles of radius r1 + r2 to
        have the overlap area 'overlap' */

        function distanceFromIntersectArea(r1, r2, overlap) {
          // handle complete overlapped circles
          if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {
            return Math.abs(r1 - r2);
          }

          return bisect(function (distance$$1) {
            return circleOverlap(r1, r2, distance$$1) - overlap;
          }, 0, r1 + r2);
        }
        /** Missing pair-wise intersection area data can cause problems:
         treating as an unknown means that sets will be laid out overlapping,
         which isn't what people expect. To reflect that we want disjoint sets
         here, set the overlap to 0 for all missing pairwise set intersections */


        function addMissingAreas(areas) {
          areas = areas.slice(); // two circle intersections that aren't defined

          var ids = [],
              pairs = {},
              i,
              j,
              a,
              b;

          for (i = 0; i < areas.length; ++i) {
            var area = areas[i];

            if (area.sets.length == 1) {
              ids.push(area.sets[0]);
            } else if (area.sets.length == 2) {
              a = area.sets[0];
              b = area.sets[1];
              pairs[[a, b]] = true;
              pairs[[b, a]] = true;
            }
          }

          ids.sort(function (a, b) {
            return a > b;
          });

          for (i = 0; i < ids.length; ++i) {
            a = ids[i];

            for (j = i + 1; j < ids.length; ++j) {
              b = ids[j];

              if (!([a, b] in pairs)) {
                areas.push({
                  'sets': [a, b],
                  'size': 0
                });
              }
            }
          }

          return areas;
        } /// Returns two matrices, one of the euclidean distances between the sets
        /// and the other indicating if there are subset or disjoint set relationships


        function getDistanceMatrices(areas, sets, setids) {
          // initialize an empty distance matrix between all the points
          var distances = zerosM(sets.length, sets.length),
              constraints = zerosM(sets.length, sets.length); // compute required distances between all the sets such that
          // the areas match

          areas.filter(function (x) {
            return x.sets.length == 2;
          }).map(function (current) {
            var left = setids[current.sets[0]],
                right = setids[current.sets[1]],
                r1 = Math.sqrt(sets[left].size / Math.PI),
                r2 = Math.sqrt(sets[right].size / Math.PI),
                distance$$1 = distanceFromIntersectArea(r1, r2, current.size);
            distances[left][right] = distances[right][left] = distance$$1; // also update constraints to indicate if its a subset or disjoint
            // relationship

            var c = 0;

            if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {
              c = 1;
            } else if (current.size <= 1e-10) {
              c = -1;
            }

            constraints[left][right] = constraints[right][left] = c;
          });
          return {
            distances: distances,
            constraints: constraints
          };
        } /// computes the gradient and loss simulatenously for our constrained MDS optimizer


        function constrainedMDSGradient(x, fxprime, distances, constraints) {
          var loss = 0,
              i;

          for (i = 0; i < fxprime.length; ++i) {
            fxprime[i] = 0;
          }

          for (i = 0; i < distances.length; ++i) {
            var xi = x[2 * i],
                yi = x[2 * i + 1];

            for (var j = i + 1; j < distances.length; ++j) {
              var xj = x[2 * j],
                  yj = x[2 * j + 1],
                  dij = distances[i][j],
                  constraint = constraints[i][j];
              var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),
                  distance$$1 = Math.sqrt(squaredDistance),
                  delta = squaredDistance - dij * dij;

              if (constraint > 0 && distance$$1 <= dij || constraint < 0 && distance$$1 >= dij) {
                continue;
              }

              loss += 2 * delta * delta;
              fxprime[2 * i] += 4 * delta * (xi - xj);
              fxprime[2 * i + 1] += 4 * delta * (yi - yj);
              fxprime[2 * j] += 4 * delta * (xj - xi);
              fxprime[2 * j + 1] += 4 * delta * (yj - yi);
            }
          }

          return loss;
        } /// takes the best working variant of either constrained MDS or greedy


        function bestInitialLayout(areas, params) {
          var initial = greedyLayout(areas, params);
          var loss = params.lossFunction || lossFunction; // greedylayout is sufficient for all 2/3 circle cases. try out
          // constrained MDS for higher order problems, take its output
          // if it outperforms. (greedy is aesthetically better on 2/3 circles
          // since it axis aligns)

          if (areas.length >= 8) {
            var constrained = constrainedMDSLayout(areas, params),
                constrainedLoss = loss(constrained, areas),
                greedyLoss = loss(initial, areas);

            if (constrainedLoss + 1e-8 < greedyLoss) {
              initial = constrained;
            }
          }

          return initial;
        } /// use the constrained MDS variant to generate an initial layout


        function constrainedMDSLayout(areas, params) {
          params = params || {};
          var restarts = params.restarts || 10; // bidirectionally map sets to a rowid  (so we can create a matrix)

          var sets = [],
              setids = {},
              i;

          for (i = 0; i < areas.length; ++i) {
            var area = areas[i];

            if (area.sets.length == 1) {
              setids[area.sets[0]] = sets.length;
              sets.push(area);
            }
          }

          var matrices = getDistanceMatrices(areas, sets, setids),
              distances = matrices.distances,
              constraints = matrices.constraints; // keep distances bounded, things get messed up otherwise.
          // TODO: proper preconditioner?

          var norm = norm2(distances.map(norm2)) / distances.length;
          distances = distances.map(function (row) {
            return row.map(function (value) {
              return value / norm;
            });
          });

          var obj = function obj(x, fxprime) {
            return constrainedMDSGradient(x, fxprime, distances, constraints);
          };

          var best, current;

          for (i = 0; i < restarts; ++i) {
            var initial = zeros(distances.length * 2).map(Math.random);
            current = conjugateGradient(obj, initial, params);

            if (!best || current.fx < best.fx) {
              best = current;
            }
          }

          var positions = best.x; // translate rows back to (x,y,radius) coordinates

          var circles = {};

          for (i = 0; i < sets.length; ++i) {
            var set = sets[i];
            circles[set.sets[0]] = {
              x: positions[2 * i] * norm,
              y: positions[2 * i + 1] * norm,
              radius: Math.sqrt(set.size / Math.PI)
            };
          }

          if (params.history) {
            for (i = 0; i < params.history.length; ++i) {
              scale(params.history[i].x, norm);
            }
          }

          return circles;
        }
        /** Lays out a Venn diagram greedily, going from most overlapped sets to
        least overlapped, attempting to position each new set such that the
        overlapping areas to already positioned sets are basically right */


        function greedyLayout(areas, params) {
          var loss = params && params.lossFunction ? params.lossFunction : lossFunction; // define a circle for each set

          var circles = {},
              setOverlaps = {},
              set;

          for (var i = 0; i < areas.length; ++i) {
            var area = areas[i];

            if (area.sets.length == 1) {
              set = area.sets[0];
              circles[set] = {
                x: 1e10,
                y: 1e10,
                rowid: circles.length,
                size: area.size,
                radius: Math.sqrt(area.size / Math.PI)
              };
              setOverlaps[set] = [];
            }
          }

          areas = areas.filter(function (a) {
            return a.sets.length == 2;
          }); // map each set to a list of all the other sets that overlap it

          for (i = 0; i < areas.length; ++i) {
            var current = areas[i];
            var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;
            var left = current.sets[0],
                right = current.sets[1]; // completely overlapped circles shouldn't be positioned early here

            if (current.size + SMALL$1 >= Math.min(circles[left].size, circles[right].size)) {
              weight = 0;
            }

            setOverlaps[left].push({
              set: right,
              size: current.size,
              weight: weight
            });
            setOverlaps[right].push({
              set: left,
              size: current.size,
              weight: weight
            });
          } // get list of most overlapped sets


          var mostOverlapped = [];

          for (set in setOverlaps) {
            if (setOverlaps.hasOwnProperty(set)) {
              var size = 0;

              for (i = 0; i < setOverlaps[set].length; ++i) {
                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;
              }

              mostOverlapped.push({
                set: set,
                size: size
              });
            }
          } // sort by size desc


          function sortOrder(a, b) {
            return b.size - a.size;
          }

          mostOverlapped.sort(sortOrder); // keep track of what sets have been laid out

          var positioned = {};

          function isPositioned(element) {
            return element.set in positioned;
          } // adds a point to the output


          function positionSet(point, index) {
            circles[index].x = point.x;
            circles[index].y = point.y;
            positioned[index] = true;
          } // add most overlapped set at (0,0)


          positionSet({
            x: 0,
            y: 0
          }, mostOverlapped[0].set); // get distances between all points. TODO, necessary?
          // answer: probably not
          // var distances = venn.getDistanceMatrices(circles, areas).distances;

          for (i = 1; i < mostOverlapped.length; ++i) {
            var setIndex = mostOverlapped[i].set,
                overlap = setOverlaps[setIndex].filter(isPositioned);
            set = circles[setIndex];
            overlap.sort(sortOrder);

            if (overlap.length === 0) {
              // this shouldn't happen anymore with addMissingAreas
              throw "ERROR: missing pairwise overlap information";
            }

            var points = [];

            for (var j = 0; j < overlap.length; ++j) {
              // get appropriate distance from most overlapped already added set
              var p1 = circles[overlap[j].set],
                  d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size); // sample positions at 90 degrees for maximum aesthetics

              points.push({
                x: p1.x + d1,
                y: p1.y
              });
              points.push({
                x: p1.x - d1,
                y: p1.y
              });
              points.push({
                y: p1.y + d1,
                x: p1.x
              });
              points.push({
                y: p1.y - d1,
                x: p1.x
              }); // if we have at least 2 overlaps, then figure out where the
              // set should be positioned analytically and try those too

              for (var k = j + 1; k < overlap.length; ++k) {
                var p2 = circles[overlap[k].set],
                    d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);
                var extraPoints = circleCircleIntersection({
                  x: p1.x,
                  y: p1.y,
                  radius: d1
                }, {
                  x: p2.x,
                  y: p2.y,
                  radius: d2
                });

                for (var l = 0; l < extraPoints.length; ++l) {
                  points.push(extraPoints[l]);
                }
              }
            } // we have some candidate positions for the set, examine loss
            // at each position to figure out where to put it at


            var bestLoss = 1e50,
                bestPoint = points[0];

            for (j = 0; j < points.length; ++j) {
              circles[setIndex].x = points[j].x;
              circles[setIndex].y = points[j].y;
              var localLoss = loss(circles, areas);

              if (localLoss < bestLoss) {
                bestLoss = localLoss;
                bestPoint = points[j];
              }
            }

            positionSet(bestPoint, setIndex);
          }

          return circles;
        }
        /** Given a bunch of sets, and the desired overlaps between these sets - computes
        the distance from the actual overlaps to the desired overlaps. Note that
        this method ignores overlaps of more than 2 circles */


        function lossFunction(sets, overlaps) {
          var output = 0;

          function getCircles(indices) {
            return indices.map(function (i) {
              return sets[i];
            });
          }

          for (var i = 0; i < overlaps.length; ++i) {
            var area = overlaps[i],
                overlap;

            if (area.sets.length == 1) {
              continue;
            } else if (area.sets.length == 2) {
              var left = sets[area.sets[0]],
                  right = sets[area.sets[1]];
              overlap = circleOverlap(left.radius, right.radius, distance(left, right));
            } else {
              overlap = intersectionArea(getCircles(area.sets));
            }

            var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;
            output += weight * (overlap - area.size) * (overlap - area.size);
          }

          return output;
        } // orientates a bunch of circles to point in orientation


        function orientateCircles(circles, orientation, orientationOrder) {
          if (orientationOrder === null) {
            circles.sort(function (a, b) {
              return b.radius - a.radius;
            });
          } else {
            circles.sort(orientationOrder);
          }

          var i; // shift circles so largest circle is at (0, 0)

          if (circles.length > 0) {
            var largestX = circles[0].x,
                largestY = circles[0].y;

            for (i = 0; i < circles.length; ++i) {
              circles[i].x -= largestX;
              circles[i].y -= largestY;
            }
          }

          if (circles.length == 2) {
            // if the second circle is a subset of the first, arrange so that
            // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120
            var dist = distance(circles[0], circles[1]);

            if (dist < Math.abs(circles[1].radius - circles[0].radius)) {
              circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;
              circles[1].y = circles[0].y;
            }
          } // rotate circles so that second largest is at an angle of 'orientation'
          // from largest


          if (circles.length > 1) {
            var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,
                c = Math.cos(rotation),
                s = Math.sin(rotation),
                x,
                y;

            for (i = 0; i < circles.length; ++i) {
              x = circles[i].x;
              y = circles[i].y;
              circles[i].x = c * x - s * y;
              circles[i].y = s * x + c * y;
            }
          } // mirror solution if third solution is above plane specified by
          // first two circles


          if (circles.length > 2) {
            var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;

            while (angle < 0) {
              angle += 2 * Math.PI;
            }

            while (angle > 2 * Math.PI) {
              angle -= 2 * Math.PI;
            }

            if (angle > Math.PI) {
              var slope = circles[1].y / (1e-10 + circles[1].x);

              for (i = 0; i < circles.length; ++i) {
                var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);
                circles[i].x = 2 * d - circles[i].x;
                circles[i].y = 2 * d * slope - circles[i].y;
              }
            }
          }
        }

        function disjointCluster(circles) {
          // union-find clustering to get disjoint sets
          circles.map(function (circle) {
            circle.parent = circle;
          }); // path compression step in union find

          function find(circle) {
            if (circle.parent !== circle) {
              circle.parent = find(circle.parent);
            }

            return circle.parent;
          }

          function union(x, y) {
            var xRoot = find(x),
                yRoot = find(y);
            xRoot.parent = yRoot;
          } // get the union of all overlapping sets


          for (var i = 0; i < circles.length; ++i) {
            for (var j = i + 1; j < circles.length; ++j) {
              var maxDistance = circles[i].radius + circles[j].radius;

              if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {
                union(circles[j], circles[i]);
              }
            }
          } // find all the disjoint clusters and group them together


          var disjointClusters = {},
              setid;

          for (i = 0; i < circles.length; ++i) {
            setid = find(circles[i]).parent.setid;

            if (!(setid in disjointClusters)) {
              disjointClusters[setid] = [];
            }

            disjointClusters[setid].push(circles[i]);
          } // cleanup bookkeeping


          circles.map(function (circle) {
            delete circle.parent;
          }); // return in more usable form

          var ret = [];

          for (setid in disjointClusters) {
            if (disjointClusters.hasOwnProperty(setid)) {
              ret.push(disjointClusters[setid]);
            }
          }

          return ret;
        }

        function getBoundingBox(circles) {
          var minMax = function minMax(d) {
            var hi = Math.max.apply(null, circles.map(function (c) {
              return c[d] + c.radius;
            })),
                lo = Math.min.apply(null, circles.map(function (c) {
              return c[d] - c.radius;
            }));
            return {
              max: hi,
              min: lo
            };
          };

          return {
            xRange: minMax('x'),
            yRange: minMax('y')
          };
        }

        function normalizeSolution(solution, orientation, orientationOrder) {
          if (orientation === null) {
            orientation = Math.PI / 2;
          } // work with a list instead of a dictionary, and take a copy so we
          // don't mutate input


          var circles = [],
              i,
              setid;

          for (setid in solution) {
            if (solution.hasOwnProperty(setid)) {
              var previous = solution[setid];
              circles.push({
                x: previous.x,
                y: previous.y,
                radius: previous.radius,
                setid: setid
              });
            }
          } // get all the disjoint clusters


          var clusters = disjointCluster(circles); // orientate all disjoint sets, get sizes

          for (i = 0; i < clusters.length; ++i) {
            orientateCircles(clusters[i], orientation, orientationOrder);
            var bounds = getBoundingBox(clusters[i]);
            clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);
            clusters[i].bounds = bounds;
          }

          clusters.sort(function (a, b) {
            return b.size - a.size;
          }); // orientate the largest at 0,0, and get the bounds

          circles = clusters[0];
          var returnBounds = circles.bounds;
          var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;

          function addCluster(cluster, right, bottom) {
            if (!cluster) return;
            var bounds = cluster.bounds,
                xOffset,
                yOffset,
                centreing;

            if (right) {
              xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;
            } else {
              xOffset = returnBounds.xRange.max - bounds.xRange.max;
              centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;
              if (centreing < 0) xOffset += centreing;
            }

            if (bottom) {
              yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;
            } else {
              yOffset = returnBounds.yRange.max - bounds.yRange.max;
              centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;
              if (centreing < 0) yOffset += centreing;
            }

            for (var j = 0; j < cluster.length; ++j) {
              cluster[j].x += xOffset;
              cluster[j].y += yOffset;
              circles.push(cluster[j]);
            }
          }

          var index = 1;

          while (index < clusters.length) {
            addCluster(clusters[index], true, false);
            addCluster(clusters[index + 1], false, true);
            addCluster(clusters[index + 2], true, true);
            index += 3; // have one cluster (in top left). lay out next three relative
            // to it in a grid

            returnBounds = getBoundingBox(circles);
          } // convert back to solution form


          var ret = {};

          for (i = 0; i < circles.length; ++i) {
            ret[circles[i].setid] = circles[i];
          }

          return ret;
        }
        /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
        a rectangle of width/height - with padding around the borders. also
        centers the diagram in the available space at the same time */


        function scaleSolution(solution, width, height, padding) {
          var circles = [],
              setids = [];

          for (var setid in solution) {
            if (solution.hasOwnProperty(setid)) {
              setids.push(setid);
              circles.push(solution[setid]);
            }
          }

          width -= 2 * padding;
          height -= 2 * padding;
          var bounds = getBoundingBox(circles),
              xRange = bounds.xRange,
              yRange = bounds.yRange;

          if (xRange.max == xRange.min || yRange.max == yRange.min) {
            console.log("not scaling solution: zero size detected");
            return solution;
          }

          var xScaling = width / (xRange.max - xRange.min),
              yScaling = height / (yRange.max - yRange.min),
              scaling = Math.min(yScaling, xScaling),
              // while we're at it, center the diagram too
          xOffset = (width - (xRange.max - xRange.min) * scaling) / 2,
              yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
          var scaled = {};

          for (var i = 0; i < circles.length; ++i) {
            var circle = circles[i];
            scaled[setids[i]] = {
              radius: scaling * circle.radius,
              x: padding + xOffset + (circle.x - xRange.min) * scaling,
              y: padding + yOffset + (circle.y - yRange.min) * scaling
            };
          }

          return scaled;
        }
        /*global console:true*/


        function VennDiagram() {
          var width = 600,
              height = 350,
              padding = 15,
              duration = 1000,
              orientation = Math.PI / 2,
              normalize = true,
              wrap = true,
              styled = true,
              fontSize = null,
              orientationOrder = null,
              // mimic the behaviour of d3.scale.category10 from the previous
          // version of d3
          colourMap = {},
              // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0
          // since we can support older versions of d3 as long as we don't force this,
          // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10
          colourScheme = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"],
              colourIndex = 0,
              colours = function colours(key) {
            if (key in colourMap) {
              return colourMap[key];
            }

            var ret = colourMap[key] = colourScheme[colourIndex];
            colourIndex += 1;

            if (colourIndex >= colourScheme.length) {
              colourIndex = 0;
            }

            return ret;
          },
              layoutFunction = venn,
              loss = lossFunction;

          function chart(selection) {
            var data = selection.datum(); // handle 0-sized sets by removing from input

            var toremove = {};
            data.forEach(function (datum) {
              if (datum.size == 0 && datum.sets.length == 1) {
                toremove[datum.sets[0]] = 1;
              }
            });
            data = data.filter(function (datum) {
              return !datum.sets.some(function (set) {
                return set in toremove;
              });
            });
            var circles = {};
            var textCentres = {};

            if (data.length > 0) {
              var solution = layoutFunction(data, {
                lossFunction: loss
              });

              if (normalize) {
                solution = normalizeSolution(solution, orientation, orientationOrder);
              }

              circles = scaleSolution(solution, width, height, padding);
              textCentres = computeTextCentres(circles, data);
            } // Figure out the current label for each set. These can change
            // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)


            var labels = {};
            data.forEach(function (datum) {
              if (datum.label) {
                labels[datum.sets] = datum.label;
              }
            });

            function label(d) {
              if (d.sets in labels) {
                return labels[d.sets];
              }

              if (d.sets.length == 1) {
                return '' + d.sets[0];
              }
            } // create svg if not already existing


            selection.selectAll("svg").data([circles]).enter().append("svg");
            var svg = selection.select("svg").attr("width", width).attr("height", height); // to properly transition intersection areas, we need the
            // previous circles locations. load from elements

            var previous = {},
                hasPrevious = false;
            svg.selectAll(".venn-area path").each(function (d) {
              var path = d3Selection.select(this).attr("d");

              if (d.sets.length == 1 && path) {
                hasPrevious = true;
                previous[d.sets[0]] = circleFromPath(path);
              }
            }); // interpolate intersection area paths between previous and
            // current paths

            var pathTween = function pathTween(d) {
              return function (t) {
                var c = d.sets.map(function (set) {
                  var start = previous[set],
                      end = circles[set];

                  if (!start) {
                    start = {
                      x: width / 2,
                      y: height / 2,
                      radius: 1
                    };
                  }

                  if (!end) {
                    end = {
                      x: width / 2,
                      y: height / 2,
                      radius: 1
                    };
                  }

                  return {
                    'x': start.x * (1 - t) + end.x * t,
                    'y': start.y * (1 - t) + end.y * t,
                    'radius': start.radius * (1 - t) + end.radius * t
                  };
                });
                return intersectionAreaPath(c);
              };
            }; // update data, joining on the set ids


            var nodes = svg.selectAll(".venn-area").data(data, function (d) {
              return d.sets;
            }); // create new nodes

            var enter = nodes.enter().append('g').attr("class", function (d) {
              return "venn-area venn-" + (d.sets.length == 1 ? "circle" : "intersection");
            }).attr("data-venn-sets", function (d) {
              return d.sets.join("_");
            });
            var enterPath = enter.append("path"),
                enterText = enter.append("text").attr("class", "label").text(function (d) {
              return label(d);
            }).attr("text-anchor", "middle").attr("dy", ".35em").attr("x", width / 2).attr("y", height / 2); // apply minimal style if wanted

            if (styled) {
              enterPath.style("fill-opacity", "0").filter(function (d) {
                return d.sets.length == 1;
              }).style("fill", function (d) {
                return colours(d.sets);
              }).style("fill-opacity", ".25");
              enterText.style("fill", function (d) {
                return d.sets.length == 1 ? colours(d.sets) : "#444";
              });
            } // update existing, using pathTween if necessary


            var update = selection;

            if (hasPrevious) {
              update = selection.transition("venn").duration(duration);
              update.selectAll("path").attrTween("d", pathTween);
            } else {
              update.selectAll("path").attr("d", function (d) {
                return intersectionAreaPath(d.sets.map(function (set) {
                  return circles[set];
                }));
              });
            }

            var updateText = update.selectAll("text").filter(function (d) {
              return d.sets in textCentres;
            }).text(function (d) {
              return label(d);
            }).attr("x", function (d) {
              return Math.floor(textCentres[d.sets].x);
            }).attr("y", function (d) {
              return Math.floor(textCentres[d.sets].y);
            });

            if (wrap) {
              if (hasPrevious) {
                // d3 4.0 uses 'on' for events on transitions,
                // but d3 3.0 used 'each' instead. switch appropiately
                if ('on' in updateText) {
                  updateText.on("end", wrapText(circles, label));
                } else {
                  updateText.each("end", wrapText(circles, label));
                }
              } else {
                updateText.each(wrapText(circles, label));
              }
            } // remove old


            var exit = nodes.exit().transition('venn').duration(duration).remove();
            exit.selectAll("path").attrTween("d", pathTween);
            var exitText = exit.selectAll("text").attr("x", width / 2).attr("y", height / 2); // if we've been passed a fontSize explicitly, use it to
            // transition

            if (fontSize !== null) {
              enterText.style("font-size", "0px");
              updateText.style("font-size", fontSize);
              exitText.style("font-size", "0px");
            }

            return {
              'circles': circles,
              'textCentres': textCentres,
              'nodes': nodes,
              'enter': enter,
              'update': update,
              'exit': exit
            };
          }

          chart.wrap = function (_) {
            if (!arguments.length) return wrap;
            wrap = _;
            return chart;
          };

          chart.width = function (_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
          };

          chart.height = function (_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
          };

          chart.padding = function (_) {
            if (!arguments.length) return padding;
            padding = _;
            return chart;
          };

          chart.colours = function (_) {
            if (!arguments.length) return colours;
            colours = _;
            return chart;
          };

          chart.fontSize = function (_) {
            if (!arguments.length) return fontSize;
            fontSize = _;
            return chart;
          };

          chart.duration = function (_) {
            if (!arguments.length) return duration;
            duration = _;
            return chart;
          };

          chart.layoutFunction = function (_) {
            if (!arguments.length) return layoutFunction;
            layoutFunction = _;
            return chart;
          };

          chart.normalize = function (_) {
            if (!arguments.length) return normalize;
            normalize = _;
            return chart;
          };

          chart.styled = function (_) {
            if (!arguments.length) return styled;
            styled = _;
            return chart;
          };

          chart.orientation = function (_) {
            if (!arguments.length) return orientation;
            orientation = _;
            return chart;
          };

          chart.orientationOrder = function (_) {
            if (!arguments.length) return orientationOrder;
            orientationOrder = _;
            return chart;
          };

          chart.lossFunction = function (_) {
            if (!arguments.length) return loss;
            loss = _;
            return chart;
          };

          return chart;
        } // sometimes text doesn't fit inside the circle, if thats the case lets wrap
        // the text here such that it fits
        // todo: looks like this might be merged into d3 (
        // https://github.com/mbostock/d3/issues/1642),
        // also worth checking out is
        // http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/
        // this seems to be one of those things that should be easy but isn't


        function wrapText(circles, labeller) {
          return function () {
            var text = d3Selection.select(this),
                data = text.datum(),
                width = circles[data.sets[0]].radius || 50,
                label = labeller(data) || '';
            var words = label.split(/\s+/).reverse(),
                maxLines = 3,
                minChars = (label.length + words.length) / maxLines,
                word = words.pop(),
                line = [word],
                joined,
                lineNumber = 0,
                lineHeight = 1.1,
                // ems
            tspan = text.text(null).append("tspan").text(word);

            while (true) {
              word = words.pop();
              if (!word) break;
              line.push(word);
              joined = line.join(" ");
              tspan.text(joined);

              if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").text(word);
                lineNumber++;
              }
            }

            var initial = 0.35 - lineNumber * lineHeight / 2,
                x = text.attr("x"),
                y = text.attr("y");
            text.selectAll("tspan").attr("x", x).attr("y", y).attr("dy", function (d, i) {
              return initial + i * lineHeight + "em";
            });
          };
        }

        function circleMargin(current, interior, exterior) {
          var margin = interior[0].radius - distance(interior[0], current),
              i,
              m;

          for (i = 1; i < interior.length; ++i) {
            m = interior[i].radius - distance(interior[i], current);

            if (m <= margin) {
              margin = m;
            }
          }

          for (i = 0; i < exterior.length; ++i) {
            m = distance(exterior[i], current) - exterior[i].radius;

            if (m <= margin) {
              margin = m;
            }
          }

          return margin;
        } // compute the center of some circles by maximizing the margin of
        // the center point relative to the circles (interior) after subtracting
        // nearby circles (exterior)


        function computeTextCentre(interior, exterior) {
          // get an initial estimate by sampling around the interior circles
          // and taking the point with the biggest margin
          var points = [],
              i;

          for (i = 0; i < interior.length; ++i) {
            var c = interior[i];
            points.push({
              x: c.x,
              y: c.y
            });
            points.push({
              x: c.x + c.radius / 2,
              y: c.y
            });
            points.push({
              x: c.x - c.radius / 2,
              y: c.y
            });
            points.push({
              x: c.x,
              y: c.y + c.radius / 2
            });
            points.push({
              x: c.x,
              y: c.y - c.radius / 2
            });
          }

          var initial = points[0],
              margin = circleMargin(points[0], interior, exterior);

          for (i = 1; i < points.length; ++i) {
            var m = circleMargin(points[i], interior, exterior);

            if (m >= margin) {
              initial = points[i];
              margin = m;
            }
          } // maximize the margin numerically


          var solution = nelderMead(function (p) {
            return -1 * circleMargin({
              x: p[0],
              y: p[1]
            }, interior, exterior);
          }, [initial.x, initial.y], {
            maxIterations: 500,
            minErrorDelta: 1e-10
          }).x;
          var ret = {
            x: solution[0],
            y: solution[1]
          }; // check solution, fallback as needed (happens if fully overlapped
          // etc)

          var valid = true;

          for (i = 0; i < interior.length; ++i) {
            if (distance(ret, interior[i]) > interior[i].radius) {
              valid = false;
              break;
            }
          }

          for (i = 0; i < exterior.length; ++i) {
            if (distance(ret, exterior[i]) < exterior[i].radius) {
              valid = false;
              break;
            }
          }

          if (!valid) {
            if (interior.length == 1) {
              ret = {
                x: interior[0].x,
                y: interior[0].y
              };
            } else {
              var areaStats = {};
              intersectionArea(interior, areaStats);

              if (areaStats.arcs.length === 0) {
                ret = {
                  'x': 0,
                  'y': -1000,
                  disjoint: true
                };
              } else if (areaStats.arcs.length == 1) {
                ret = {
                  'x': areaStats.arcs[0].circle.x,
                  'y': areaStats.arcs[0].circle.y
                };
              } else if (exterior.length) {
                // try again without other circles
                ret = computeTextCentre(interior, []);
              } else {
                // take average of all the points in the intersection
                // polygon. this should basically never happen
                // and has some issues:
                // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777
                ret = getCenter(areaStats.arcs.map(function (a) {
                  return a.p1;
                }));
              }
            }
          }

          return ret;
        } // given a dictionary of {setid : circle}, returns
        // a dictionary of setid to list of circles that completely overlap it


        function getOverlappingCircles(circles) {
          var ret = {},
              circleids = [];

          for (var circleid in circles) {
            circleids.push(circleid);
            ret[circleid] = [];
          }

          for (var i = 0; i < circleids.length; i++) {
            var a = circles[circleids[i]];

            for (var j = i + 1; j < circleids.length; ++j) {
              var b = circles[circleids[j]],
                  d = distance(a, b);

              if (d + b.radius <= a.radius + 1e-10) {
                ret[circleids[j]].push(circleids[i]);
              } else if (d + a.radius <= b.radius + 1e-10) {
                ret[circleids[i]].push(circleids[j]);
              }
            }
          }

          return ret;
        }

        function computeTextCentres(circles, areas) {
          var ret = {},
              overlapped = getOverlappingCircles(circles);

          for (var i = 0; i < areas.length; ++i) {
            var area = areas[i].sets,
                areaids = {},
                exclude = {};

            for (var j = 0; j < area.length; ++j) {
              areaids[area[j]] = true;
              var overlaps = overlapped[area[j]]; // keep track of any circles that overlap this area,
              // and don't consider for purposes of computing the text
              // centre

              for (var k = 0; k < overlaps.length; ++k) {
                exclude[overlaps[k]] = true;
              }
            }

            var interior = [],
                exterior = [];

            for (var setid in circles) {
              if (setid in areaids) {
                interior.push(circles[setid]);
              } else if (!(setid in exclude)) {
                exterior.push(circles[setid]);
              }
            }

            var centre = computeTextCentre(interior, exterior);
            ret[area] = centre;

            if (centre.disjoint && areas[i].size > 0) {
              console.log("WARNING: area " + area + " not represented on screen");
            }
          }

          return ret;
        } // sorts all areas in the venn diagram, so that
        // a particular area is on top (relativeTo) - and
        // all other areas are so that the smallest areas are on top


        function sortAreas(div, relativeTo) {
          // figure out sets that are completly overlapped by relativeTo
          var overlaps = getOverlappingCircles(div.selectAll("svg").datum());
          var exclude = {};

          for (var i = 0; i < relativeTo.sets.length; ++i) {
            var check = relativeTo.sets[i];

            for (var setid in overlaps) {
              var overlap = overlaps[setid];

              for (var j = 0; j < overlap.length; ++j) {
                if (overlap[j] == check) {
                  exclude[setid] = true;
                  break;
                }
              }
            }
          } // checks that all sets are in exclude;


          function shouldExclude(sets) {
            for (var i = 0; i < sets.length; ++i) {
              if (!(sets[i] in exclude)) {
                return false;
              }
            }

            return true;
          } // need to sort div's so that Z order is correct


          div.selectAll("g").sort(function (a, b) {
            // highest order set intersections first
            if (a.sets.length != b.sets.length) {
              return a.sets.length - b.sets.length;
            }

            if (a == relativeTo) {
              return shouldExclude(b.sets) ? -1 : 1;
            }

            if (b == relativeTo) {
              return shouldExclude(a.sets) ? 1 : -1;
            } // finally by size


            return b.size - a.size;
          });
        }

        function circlePath(x, y, r) {
          var ret = [];
          ret.push("\nM", x, y);
          ret.push("\nm", -r, 0);
          ret.push("\na", r, r, 0, 1, 0, r * 2, 0);
          ret.push("\na", r, r, 0, 1, 0, -r * 2, 0);
          return ret.join(" ");
        } // inverse of the circlePath function, returns a circle object from an svg path


        function circleFromPath(path) {
          var tokens = path.split(' ');
          return {
            'x': parseFloat(tokens[1]),
            'y': parseFloat(tokens[2]),
            'radius': -parseFloat(tokens[4])
          };
        }
        /** returns a svg path of the intersection area of a bunch of circles */


        function intersectionAreaPath(circles) {
          var stats = {};
          intersectionArea(circles, stats);
          var arcs = stats.arcs;

          if (arcs.length === 0) {
            return "M 0 0";
          } else if (arcs.length == 1) {
            var circle = arcs[0].circle;
            return circlePath(circle.x, circle.y, circle.radius);
          } else {
            // draw path around arcs
            var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];

            for (var i = 0; i < arcs.length; ++i) {
              var arc = arcs[i],
                  r = arc.circle.radius,
                  wide = arc.width > r;
              ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
            }

            return ret.join(" ");
          }
        }

        exports.intersectionArea = intersectionArea;
        exports.circleCircleIntersection = circleCircleIntersection;
        exports.circleOverlap = circleOverlap;
        exports.circleArea = circleArea;
        exports.distance = distance;
        exports.venn = venn;
        exports.greedyLayout = greedyLayout;
        exports.scaleSolution = scaleSolution;
        exports.normalizeSolution = normalizeSolution;
        exports.bestInitialLayout = bestInitialLayout;
        exports.lossFunction = lossFunction;
        exports.disjointCluster = disjointCluster;
        exports.distanceFromIntersectArea = distanceFromIntersectArea;
        exports.VennDiagram = VennDiagram;
        exports.wrapText = wrapText;
        exports.computeTextCentres = computeTextCentres;
        exports.computeTextCentre = computeTextCentre;
        exports.sortAreas = sortAreas;
        exports.circlePath = circlePath;
        exports.circleFromPath = circleFromPath;
        exports.intersectionAreaPath = intersectionAreaPath;
        Object.defineProperty(exports, '__esModule', {
          value: true
        });
      });
      /***/

    },
    /* 415 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(362);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__select__ = __webpack_require__(386);
      /* harmony default export */


      __webpack_exports__["a"] = function (name) {
        return Object(__WEBPACK_IMPORTED_MODULE_1__select__["a"
        /* default */
        ])(Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a"
        /* default */
        ])(name).call(document.documentElement));
      };
      /***/

    },
    /* 416 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(70);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(375);
      /* harmony default export */


      __webpack_exports__["a"] = function (select) {
        if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_1__selector__["a"
        /* default */
        ])(select);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
            if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
              if ("__data__" in node) subnode.__data__ = node.__data__;
              subgroup[i] = subnode;
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_0__index__["a"
        /* Selection */
        ](subgroups, this._parents);
      };
      /***/

    },
    /* 417 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(70);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__selectorAll__ = __webpack_require__(387);
      /* harmony default export */


      __webpack_exports__["a"] = function (select) {
        if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_1__selectorAll__["a"
        /* default */
        ])(select);

        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              subgroups.push(select.call(node, node.__data__, i, group));
              parents.push(node);
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_0__index__["a"
        /* Selection */
        ](subgroups, parents);
      };
      /***/

    },
    /* 418 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(70);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__matcher__ = __webpack_require__(388);
      /* harmony default export */


      __webpack_exports__["a"] = function (match) {
        if (typeof match !== "function") match = Object(__WEBPACK_IMPORTED_MODULE_1__matcher__["a"
        /* default */
        ])(match);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
            if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
              subgroup.push(node);
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_0__index__["a"
        /* Selection */
        ](subgroups, this._parents);
      };
      /***/

    },
    /* 419 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(70);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__enter__ = __webpack_require__(389);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(420);

      var keyPrefix = "$"; // Protect against keys like “__proto__”.

      function bindIndex(parent, group, enter, update, exit, data) {
        var i = 0,
            node,
            groupLength = group.length,
            dataLength = data.length; // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.

        for (; i < dataLength; ++i) {
          if (node = group[i]) {
            node.__data__ = data[i];
            update[i] = node;
          } else {
            enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["a"
            /* EnterNode */
            ](parent, data[i]);
          }
        } // Put any non-null nodes that don’t fit into exit.


        for (; i < groupLength; ++i) {
          if (node = group[i]) {
            exit[i] = node;
          }
        }
      }

      function bindKey(parent, group, enter, update, exit, data, key) {
        var i,
            node,
            nodeByKeyValue = {},
            groupLength = group.length,
            dataLength = data.length,
            keyValues = new Array(groupLength),
            keyValue; // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.

        for (i = 0; i < groupLength; ++i) {
          if (node = group[i]) {
            keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);

            if (keyValue in nodeByKeyValue) {
              exit[i] = node;
            } else {
              nodeByKeyValue[keyValue] = node;
            }
          }
        } // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.


        for (i = 0; i < dataLength; ++i) {
          keyValue = keyPrefix + key.call(parent, data[i], i, data);

          if (node = nodeByKeyValue[keyValue]) {
            update[i] = node;
            node.__data__ = data[i];
            nodeByKeyValue[keyValue] = null;
          } else {
            enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["a"
            /* EnterNode */
            ](parent, data[i]);
          }
        } // Add any remaining nodes that were not bound to data to exit.


        for (i = 0; i < groupLength; ++i) {
          if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
            exit[i] = node;
          }
        }
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value, key) {
        if (!value) {
          data = new Array(this.size()), j = -1;
          this.each(function (d) {
            data[++j] = d;
          });
          return data;
        }

        var bind = key ? bindKey : bindIndex,
            parents = this._parents,
            groups = this._groups;
        if (typeof value !== "function") value = Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a"
        /* default */
        ])(value);

        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
          var parent = parents[j],
              group = groups[j],
              groupLength = group.length,
              data = value.call(parent, parent && parent.__data__, j, parents),
              dataLength = data.length,
              enterGroup = enter[j] = new Array(dataLength),
              updateGroup = update[j] = new Array(dataLength),
              exitGroup = exit[j] = new Array(groupLength);
          bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that
          // appendChild can insert the materialized enter node before this node,
          // rather than at the end of the parent node.

          for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
            if (previous = enterGroup[i0]) {
              if (i0 >= i1) i1 = i0 + 1;

              while (!(next = updateGroup[i1]) && ++i1 < dataLength) {
                ;
              }

              previous._next = next || null;
            }
          }
        }

        update = new __WEBPACK_IMPORTED_MODULE_0__index__["a"
        /* Selection */
        ](update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
      };
      /***/

    },
    /* 420 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (x) {
        return function () {
          return x;
        };
      };
      /***/

    },
    /* 421 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(390);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(70);
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        return new __WEBPACK_IMPORTED_MODULE_1__index__["a"
        /* Selection */
        ](this._exit || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a"
        /* default */
        ]), this._parents);
      };
      /***/

    },
    /* 422 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (onenter, onupdate, onexit) {
        var enter = this.enter(),
            update = this,
            exit = this.exit();
        enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
        if (onupdate != null) update = onupdate(update);
        if (onexit == null) exit.remove();else onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
      };
      /***/

    },
    /* 423 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(70);
      /* harmony default export */


      __webpack_exports__["a"] = function (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
          for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group0[i] || group1[i]) {
              merge[i] = node;
            }
          }
        }

        for (; j < m0; ++j) {
          merges[j] = groups0[j];
        }

        return new __WEBPACK_IMPORTED_MODULE_0__index__["a"
        /* Selection */
        ](merges, this._parents);
      };
      /***/

    },
    /* 424 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
          for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
            if (node = group[i]) {
              if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }

        return this;
      };
      /***/

    },
    /* 425 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(70);
      /* harmony default export */


      __webpack_exports__["a"] = function (compare) {
        if (!compare) compare = ascending;

        function compareNode(a, b) {
          return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }

        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              sortgroup[i] = node;
            }
          }

          sortgroup.sort(compareNode);
        }

        return new __WEBPACK_IMPORTED_MODULE_0__index__["a"
        /* Selection */
        ](sortgroups, this._parents).order();
      };

      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      /***/

    },
    /* 426 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
      };
      /***/

    },
    /* 427 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function () {
        var nodes = new Array(this.size()),
            i = -1;
        this.each(function () {
          nodes[++i] = this;
        });
        return nodes;
      };
      /***/

    },
    /* 428 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
          for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
            var node = group[i];
            if (node) return node;
          }
        }

        return null;
      };
      /***/

    },
    /* 429 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function () {
        var size = 0;
        this.each(function () {
          ++size;
        });
        return size;
      };
      /***/

    },
    /* 430 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function () {
        return !this.node();
      };
      /***/

    },
    /* 431 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
          for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
            if (node = group[i]) callback.call(node, node.__data__, i, group);
          }
        }

        return this;
      };
      /***/

    },
    /* 432 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(373);

      function attrRemove(name) {
        return function () {
          this.removeAttribute(name);
        };
      }

      function attrRemoveNS(fullname) {
        return function () {
          this.removeAttributeNS(fullname.space, fullname.local);
        };
      }

      function attrConstant(name, value) {
        return function () {
          this.setAttribute(name, value);
        };
      }

      function attrConstantNS(fullname, value) {
        return function () {
          this.setAttributeNS(fullname.space, fullname.local, value);
        };
      }

      function attrFunction(name, value) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
        };
      }

      function attrFunctionNS(fullname, value) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value) {
        var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__["a"
        /* default */
        ])(name);

        if (arguments.length < 2) {
          var node = this.node();
          return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
        }

        return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
      };
      /***/

    },
    /* 433 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function propertyRemove(name) {
        return function () {
          delete this[name];
        };
      }

      function propertyConstant(name, value) {
        return function () {
          this[name] = value;
        };
      }

      function propertyFunction(name, value) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) delete this[name];else this[name] = v;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value) {
        return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
      };
      /***/

    },
    /* 434 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function classArray(string) {
        return string.trim().split(/^|\s+/);
      }

      function classList(node) {
        return node.classList || new ClassList(node);
      }

      function ClassList(node) {
        this._node = node;
        this._names = classArray(node.getAttribute("class") || "");
      }

      ClassList.prototype = {
        add: function add(name) {
          var i = this._names.indexOf(name);

          if (i < 0) {
            this._names.push(name);

            this._node.setAttribute("class", this._names.join(" "));
          }
        },
        remove: function remove(name) {
          var i = this._names.indexOf(name);

          if (i >= 0) {
            this._names.splice(i, 1);

            this._node.setAttribute("class", this._names.join(" "));
          }
        },
        contains: function contains(name) {
          return this._names.indexOf(name) >= 0;
        }
      };

      function classedAdd(node, names) {
        var list = classList(node),
            i = -1,
            n = names.length;

        while (++i < n) {
          list.add(names[i]);
        }
      }

      function classedRemove(node, names) {
        var list = classList(node),
            i = -1,
            n = names.length;

        while (++i < n) {
          list.remove(names[i]);
        }
      }

      function classedTrue(names) {
        return function () {
          classedAdd(this, names);
        };
      }

      function classedFalse(names) {
        return function () {
          classedRemove(this, names);
        };
      }

      function classedFunction(names, value) {
        return function () {
          (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value) {
        var names = classArray(name + "");

        if (arguments.length < 2) {
          var list = classList(this.node()),
              i = -1,
              n = names.length;

          while (++i < n) {
            if (!list.contains(names[i])) return false;
          }

          return true;
        }

        return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
      };
      /***/

    },
    /* 435 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function textRemove() {
        this.textContent = "";
      }

      function textConstant(value) {
        return function () {
          this.textContent = value;
        };
      }

      function textFunction(value) {
        return function () {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value) {
        return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
      };
      /***/

    },
    /* 436 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function htmlRemove() {
        this.innerHTML = "";
      }

      function htmlConstant(value) {
        return function () {
          this.innerHTML = value;
        };
      }

      function htmlFunction(value) {
        return function () {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value) {
        return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
      };
      /***/

    },
    /* 437 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function raise() {
        if (this.nextSibling) this.parentNode.appendChild(this);
      }
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        return this.each(raise);
      };
      /***/

    },
    /* 438 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function lower() {
        if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
      }
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        return this.each(lower);
      };
      /***/

    },
    /* 439 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(362);
      /* harmony default export */


      __webpack_exports__["a"] = function (name) {
        var create = typeof name === "function" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a"
        /* default */
        ])(name);
        return this.select(function () {
          return this.appendChild(create.apply(this, arguments));
        });
      };
      /***/

    },
    /* 440 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(362);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(375);

      function constantNull() {
        return null;
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, before) {
        var create = typeof name === "function" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a"
        /* default */
        ])(name),
            select = before == null ? constantNull : typeof before === "function" ? before : Object(__WEBPACK_IMPORTED_MODULE_1__selector__["a"
        /* default */
        ])(before);
        return this.select(function () {
          return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
      };
      /***/

    },
    /* 441 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function remove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
      }
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        return this.each(remove);
      };
      /***/

    },
    /* 442 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function selection_cloneShallow() {
        var clone = this.cloneNode(false),
            parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
      }

      function selection_cloneDeep() {
        var clone = this.cloneNode(true),
            parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (deep) {
        return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
      };
      /***/

    },
    /* 443 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony default export */

      __webpack_exports__["a"] = function (value) {
        return arguments.length ? this.property("__data__", value) : this.node().__data__;
      };
      /***/

    },
    /* 444 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(376);

      function dispatchEvent(node, type, params) {
        var window = Object(__WEBPACK_IMPORTED_MODULE_0__window__["a"
        /* default */
        ])(node),
            event = window.CustomEvent;

        if (typeof event === "function") {
          event = new event(type, params);
        } else {
          event = window.document.createEvent("Event");
          if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
        }

        node.dispatchEvent(event);
      }

      function dispatchConstant(type, params) {
        return function () {
          return dispatchEvent(this, type, params);
        };
      }

      function dispatchFunction(type, params) {
        return function () {
          return dispatchEvent(this, type, params.apply(this, arguments));
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (type, params) {
        return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
      };
      /***/

    },
    /* 445 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = local;
      var nextId = 0;

      function local() {
        return new Local();
      }

      function Local() {
        this._ = "@" + (++nextId).toString(36);
      }

      Local.prototype = local.prototype = {
        constructor: Local,
        get: function get(node) {
          var id = this._;

          while (!(id in node)) {
            if (!(node = node.parentNode)) return;
          }

          return node[id];
        },
        set: function set(node, value) {
          return node[this._] = value;
        },
        remove: function remove(node) {
          return this._ in node && delete node[this._];
        },
        toString: function toString() {
          return this._;
        }
      };
      /***/
    },
    /* 446 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(378);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(363);
      /* harmony default export */


      __webpack_exports__["a"] = function (node) {
        var event = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a"
        /* default */
        ])();
        if (event.changedTouches) event = event.changedTouches[0];
        return Object(__WEBPACK_IMPORTED_MODULE_1__point__["a"
        /* default */
        ])(node, event);
      };
      /***/

    },
    /* 447 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(70);
      /* harmony default export */


      __webpack_exports__["a"] = function (selector) {
        return typeof selector === "string" ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a"
        /* Selection */
        ]([document.querySelectorAll(selector)], [document.documentElement]) : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a"
        /* Selection */
        ]([selector == null ? [] : selector], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c"
        /* root */
        ]);
      };
      /***/

    },
    /* 448 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(378);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(363);
      /* harmony default export */


      __webpack_exports__["a"] = function (node, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a"
        /* default */
        ])().changedTouches;

        for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
          if ((touch = touches[i]).identifier === identifier) {
            return Object(__WEBPACK_IMPORTED_MODULE_1__point__["a"
            /* default */
            ])(node, touch);
          }
        }

        return null;
      };
      /***/

    },
    /* 449 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(378);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(363);
      /* harmony default export */


      __webpack_exports__["a"] = function (node, touches) {
        if (touches == null) touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a"
        /* default */
        ])().touches;

        for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
          points[i] = Object(__WEBPACK_IMPORTED_MODULE_1__point__["a"
          /* default */
          ])(node, touches[i]);
        }

        return points;
      };
      /***/

    },
    /* 450 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__selection_index_js__ = __webpack_require__(451);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__transition_index_js__ = __webpack_require__(169);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "transition", function () {
        return __WEBPACK_IMPORTED_MODULE_1__transition_index_js__["b"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__active_js__ = __webpack_require__(487);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "active", function () {
        return __WEBPACK_IMPORTED_MODULE_2__active_js__["a"];
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__interrupt_js__ = __webpack_require__(392);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "interrupt", function () {
        return __WEBPACK_IMPORTED_MODULE_3__interrupt_js__["a"];
      });
      /***/

    },
    /* 451 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__interrupt_js__ = __webpack_require__(452);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__transition_js__ = __webpack_require__(455);

      __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.interrupt = __WEBPACK_IMPORTED_MODULE_1__interrupt_js__["a"
      /* default */
      ];
      __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.transition = __WEBPACK_IMPORTED_MODULE_2__transition_js__["a"
      /* default */
      ];
      /***/
    },
    /* 452 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__interrupt_js__ = __webpack_require__(392);
      /* harmony default export */


      __webpack_exports__["a"] = function (name) {
        return this.each(function () {
          Object(__WEBPACK_IMPORTED_MODULE_0__interrupt_js__["a"
          /* default */
          ])(this, name);
        });
      };
      /***/

    },
    /* 453 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__dispatch_js__ = __webpack_require__(454);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return __WEBPACK_IMPORTED_MODULE_0__dispatch_js__["a"];
      });
      /***/

    },
    /* 454 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var noop = {
        value: function value() {}
      };

      function dispatch() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
          if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
          _[t] = [];
        }

        return new Dispatch(_);
      }

      function Dispatch(_) {
        this._ = _;
      }

      function parseTypenames(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
          var name = "",
              i = t.indexOf(".");
          if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
          if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
          return {
            type: t,
            name: name
          };
        });
      }

      Dispatch.prototype = dispatch.prototype = {
        constructor: Dispatch,
        on: function on(typename, callback) {
          var _ = this._,
              T = parseTypenames(typename + "", _),
              t,
              i = -1,
              n = T.length; // If no callback was specified, return the callback of the given type and name.

          if (arguments.length < 2) {
            while (++i < n) {
              if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
            }

            return;
          } // If a type was specified, set the callback for the given type and name.
          // Otherwise, if a null callback was specified, remove callbacks of the given name.


          if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

          while (++i < n) {
            if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) {
              _[t] = set(_[t], typename.name, null);
            }
          }

          return this;
        },
        copy: function copy() {
          var copy = {},
              _ = this._;

          for (var t in _) {
            copy[t] = _[t].slice();
          }

          return new Dispatch(copy);
        },
        call: function call(type, that) {
          if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) {
            args[i] = arguments[i + 2];
          }
          if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

          for (t = this._[type], i = 0, n = t.length; i < n; ++i) {
            t[i].value.apply(that, args);
          }
        },
        apply: function apply(type, that, args) {
          if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

          for (var t = this._[type], i = 0, n = t.length; i < n; ++i) {
            t[i].value.apply(that, args);
          }
        }
      };

      function get(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
          if ((c = type[i]).name === name) {
            return c.value;
          }
        }
      }

      function set(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
          if (type[i].name === name) {
            type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
            break;
          }
        }

        if (callback != null) type.push({
          name: name,
          value: callback
        });
        return type;
      }
      /* harmony default export */


      __webpack_exports__["a"] = dispatch;
      /***/
    },
    /* 455 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__transition_index_js__ = __webpack_require__(169);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__ = __webpack_require__(46);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_d3_ease__ = __webpack_require__(173);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3_d3_timer__ = __webpack_require__(170);

      var defaultTiming = {
        time: null,
        // Set on use.
        delay: 0,
        duration: 250,
        ease: __WEBPACK_IMPORTED_MODULE_2_d3_ease__["easeCubicInOut"]
      };

      function inherit(node, id) {
        var timing;

        while (!(timing = node.__transition) || !(timing = timing[id])) {
          if (!(node = node.parentNode)) {
            return defaultTiming.time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["now"])(), defaultTiming;
          }
        }

        return timing;
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name) {
        var id, timing;

        if (name instanceof __WEBPACK_IMPORTED_MODULE_0__transition_index_js__["a"
        /* Transition */
        ]) {
          id = name._id, name = name._name;
        } else {
          id = Object(__WEBPACK_IMPORTED_MODULE_0__transition_index_js__["c"
          /* newId */
          ])(), (timing = defaultTiming).time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["now"])(), name = name == null ? null : name + "";
        }

        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              Object(__WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__["e"
              /* default */
              ])(node, name, id, i, group, timing || inherit(node, id));
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_0__transition_index_js__["a"
        /* Transition */
        ](groups, this._parents, name, id);
      };
      /***/

    },
    /* 456 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(379);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__tween_js__ = __webpack_require__(365);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__interpolate_js__ = __webpack_require__(400);

      function attrRemove(name) {
        return function () {
          this.removeAttribute(name);
        };
      }

      function attrRemoveNS(fullname) {
        return function () {
          this.removeAttributeNS(fullname.space, fullname.local);
        };
      }

      function attrConstant(name, interpolate, value1) {
        var string00,
            string1 = value1 + "",
            interpolate0;
        return function () {
          var string0 = this.getAttribute(name);
          return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
        };
      }

      function attrConstantNS(fullname, interpolate, value1) {
        var string00,
            string1 = value1 + "",
            interpolate0;
        return function () {
          var string0 = this.getAttributeNS(fullname.space, fullname.local);
          return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
        };
      }

      function attrFunction(name, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
          var string0,
              value1 = value(this),
              string1;
          if (value1 == null) return void this.removeAttribute(name);
          string0 = this.getAttribute(name);
          string1 = value1 + "";
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
      }

      function attrFunctionNS(fullname, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
          var string0,
              value1 = value(this),
              string1;
          if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
          string0 = this.getAttributeNS(fullname.space, fullname.local);
          string1 = value1 + "";
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value) {
        var fullname = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["namespace"])(name),
            i = fullname === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["e"
        /* interpolateTransformSvg */
        ] : __WEBPACK_IMPORTED_MODULE_3__interpolate_js__["a"
        /* default */
        ];
        return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(__WEBPACK_IMPORTED_MODULE_2__tween_js__["b"
        /* tweenValue */
        ])(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
      };
      /***/

    },
    /* 457 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony default export */

      var _unused_webpack_default_export = function _unused_webpack_default_export(range) {
        var n = range.length;
        return function (t) {
          return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
        };
      };
      /***/

    },
    /* 458 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__color_js__ = __webpack_require__(174);
      /* unused harmony default export */


      var _unused_webpack_default_export = function _unused_webpack_default_export(a, b) {
        var i = Object(__WEBPACK_IMPORTED_MODULE_0__color_js__["c"
        /* hue */
        ])(+a, +b);
        return function (t) {
          var x = i(t);
          return x - 360 * Math.floor(x / 360);
        };
      };
      /***/

    },
    /* 459 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony default export */

      var _unused_webpack_default_export = function _unused_webpack_default_export(a, b) {
        return a = +a, b = +b, function (t) {
          return Math.round(a * (1 - t) + b * t);
        };
      };
      /***/

    },
    /* 460 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return interpolateTransformCss;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return interpolateTransformSvg;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0__number_js__ = __webpack_require__(364);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__parse_js__ = __webpack_require__(461);

      function interpolateTransform(parse, pxComma, pxParen, degParen) {
        function pop(s) {
          return s.length ? s.pop() + " " : "";
        }

        function translate(xa, ya, xb, yb, s, q) {
          if (xa !== xb || ya !== yb) {
            var i = s.push("translate(", null, pxComma, null, pxParen);
            q.push({
              i: i - 4,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number_js__["a"
              /* default */
              ])(xa, xb)
            }, {
              i: i - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number_js__["a"
              /* default */
              ])(ya, yb)
            });
          } else if (xb || yb) {
            s.push("translate(" + xb + pxComma + yb + pxParen);
          }
        }

        function rotate(a, b, s, q) {
          if (a !== b) {
            if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

            q.push({
              i: s.push(pop(s) + "rotate(", null, degParen) - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number_js__["a"
              /* default */
              ])(a, b)
            });
          } else if (b) {
            s.push(pop(s) + "rotate(" + b + degParen);
          }
        }

        function skewX(a, b, s, q) {
          if (a !== b) {
            q.push({
              i: s.push(pop(s) + "skewX(", null, degParen) - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number_js__["a"
              /* default */
              ])(a, b)
            });
          } else if (b) {
            s.push(pop(s) + "skewX(" + b + degParen);
          }
        }

        function scale(xa, ya, xb, yb, s, q) {
          if (xa !== xb || ya !== yb) {
            var i = s.push(pop(s) + "scale(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number_js__["a"
              /* default */
              ])(xa, xb)
            }, {
              i: i - 2,
              x: Object(__WEBPACK_IMPORTED_MODULE_0__number_js__["a"
              /* default */
              ])(ya, yb)
            });
          } else if (xb !== 1 || yb !== 1) {
            s.push(pop(s) + "scale(" + xb + "," + yb + ")");
          }
        }

        return function (a, b) {
          var s = [],
              // string constants and placeholders
          q = []; // number interpolators

          a = parse(a), b = parse(b);
          translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
          rotate(a.rotate, b.rotate, s, q);
          skewX(a.skewX, b.skewX, s, q);
          scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
          a = b = null; // gc

          return function (t) {
            var i = -1,
                n = q.length,
                o;

            while (++i < n) {
              s[(o = q[i]).i] = o.x(t);
            }

            return s.join("");
          };
        };
      }

      var interpolateTransformCss = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse_js__["a"
      /* parseCss */
      ], "px, ", "px)", "deg)");
      var interpolateTransformSvg = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse_js__["b"
      /* parseSvg */
      ], ", ", ")", ")");
      /***/
    },
    /* 461 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = parseCss;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = parseSvg;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__decompose_js__ = __webpack_require__(462);

      var cssNode, cssRoot, cssView, svgNode;

      function parseCss(value) {
        if (value === "none") return __WEBPACK_IMPORTED_MODULE_0__decompose_js__["b"
        /* identity */
        ];
        if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
        cssNode.style.transform = value;
        value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
        cssRoot.removeChild(cssNode);
        value = value.slice(7, -1).split(",");
        return Object(__WEBPACK_IMPORTED_MODULE_0__decompose_js__["a"
        /* default */
        ])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
      }

      function parseSvg(value) {
        if (value == null) return __WEBPACK_IMPORTED_MODULE_0__decompose_js__["b"
        /* identity */
        ];
        if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode.setAttribute("transform", value);
        if (!(value = svgNode.transform.baseVal.consolidate())) return __WEBPACK_IMPORTED_MODULE_0__decompose_js__["b"
        /* identity */
        ];
        value = value.matrix;
        return Object(__WEBPACK_IMPORTED_MODULE_0__decompose_js__["a"
        /* default */
        ])(value.a, value.b, value.c, value.d, value.e, value.f);
      }
      /***/

    },
    /* 462 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return identity;
      });

      var degrees = 180 / Math.PI;
      var identity = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
      };
      /* harmony default export */

      __webpack_exports__["a"] = function (a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
        if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
          translateX: e,
          translateY: f,
          rotate: Math.atan2(b, a) * degrees,
          skewX: Math.atan(skewX) * degrees,
          scaleX: scaleX,
          scaleY: scaleY
        };
      };
      /***/

    },
    /* 463 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var rho = Math.SQRT2,
          rho2 = 2,
          rho4 = 4,
          epsilon2 = 1e-12;

      function cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }

      function sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }

      function tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      } // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]

      /* unused harmony default export */


      var _unused_webpack_default_export = function _unused_webpack_default_export(p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S; // Special case for u0 ≅ u1.

        if (d2 < epsilon2) {
          S = Math.log(w1 / w0) / rho;

          i = function i(t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
          };
        } // General case.
        else {
            var d1 = Math.sqrt(d2),
                b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
                b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
                r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
                r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / rho;

            i = function i(t) {
              var s = t * S,
                  coshr0 = cosh(r0),
                  u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
              return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
            };
          }

        i.duration = S * 1000;
        return i;
      };
      /***/

    },
    /* 464 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export hslLong */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(174);

      function hsl(hue) {
        return function (start, end) {
          var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d"
          /* hsl */
          ])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d"
          /* hsl */
          ])(end)).h),
              s = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
          /* default */
          ])(start.s, end.s),
              l = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
          /* default */
          ])(start.l, end.l),
              opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
          /* default */
          ])(start.opacity, end.opacity);
          return function (t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
          };
        };
      }
      /* unused harmony default export */


      var _unused_webpack_default_export = hsl(__WEBPACK_IMPORTED_MODULE_1__color_js__["c"
      /* hue */
      ]);

      var hslLong = hsl(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
      /* default */
      ]);
      /***/
    },
    /* 465 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export default */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(174);

      function lab(start, end) {
        var l = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
        /* default */
        ])((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e"
        /* lab */
        ])(start)).l, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e"
        /* lab */
        ])(end)).l),
            a = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
        /* default */
        ])(start.a, end.a),
            b = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
        /* default */
        ])(start.b, end.b),
            opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
        /* default */
        ])(start.opacity, end.opacity);
        return function (t) {
          start.l = l(t);
          start.a = a(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
      /***/

    },
    /* 466 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export hclLong */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(174);

      function hcl(hue) {
        return function (start, end) {
          var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c"
          /* hcl */
          ])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c"
          /* hcl */
          ])(end)).h),
              c = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
          /* default */
          ])(start.c, end.c),
              l = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
          /* default */
          ])(start.l, end.l),
              opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
          /* default */
          ])(start.opacity, end.opacity);
          return function (t) {
            start.h = h(t);
            start.c = c(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
          };
        };
      }
      /* unused harmony default export */


      var _unused_webpack_default_export = hcl(__WEBPACK_IMPORTED_MODULE_1__color_js__["c"
      /* hue */
      ]);

      var hclLong = hcl(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
      /* default */
      ]);
      /***/
    },
    /* 467 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export cubehelixLong */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(174);

      function cubehelix(hue) {
        return function cubehelixGamma(y) {
          y = +y;

          function cubehelix(start, end) {
            var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b"
            /* cubehelix */
            ])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b"
            /* cubehelix */
            ])(end)).h),
                s = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
            /* default */
            ])(start.s, end.s),
                l = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
            /* default */
            ])(start.l, end.l),
                opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
            /* default */
            ])(start.opacity, end.opacity);
            return function (t) {
              start.h = h(t);
              start.s = s(t);
              start.l = l(Math.pow(t, y));
              start.opacity = opacity(t);
              return start + "";
            };
          }

          cubehelix.gamma = cubehelixGamma;
          return cubehelix;
        }(1);
      }
      /* unused harmony default export */


      var _unused_webpack_default_export = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color_js__["c"
      /* hue */
      ]);

      var cubehelixLong = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color_js__["a"
      /* default */
      ]);
      /***/
    },
    /* 468 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export default */

      function piecewise(interpolate, values) {
        var i = 0,
            n = values.length - 1,
            v = values[0],
            I = new Array(n < 0 ? 0 : n);

        while (i < n) {
          I[i] = interpolate(v, v = values[++i]);
        }

        return function (t) {
          var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
          return I[i](t - i);
        };
      }
      /***/

    },
    /* 469 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony default export */

      var _unused_webpack_default_export = function _unused_webpack_default_export(interpolator, n) {
        var samples = new Array(n);

        for (var i = 0; i < n; ++i) {
          samples[i] = interpolator(i / (n - 1));
        }

        return samples;
      };
      /***/

    },
    /* 470 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);

      function attrInterpolate(name, i) {
        return function (t) {
          this.setAttribute(name, i.call(this, t));
        };
      }

      function attrInterpolateNS(fullname, i) {
        return function (t) {
          this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
        };
      }

      function attrTweenNS(fullname, value) {
        var t0, i0;

        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
          return t0;
        }

        tween._value = value;
        return tween;
      }

      function attrTween(name, value) {
        var t0, i0;

        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
          return t0;
        }

        tween._value = value;
        return tween;
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value) {
        var key = "attr." + name;
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error();
        var fullname = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["namespace"])(name);
        return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
      };
      /***/

    },
    /* 471 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(46);

      function delayFunction(id, value) {
        return function () {
          Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["g"
          /* init */
          ])(this, id).delay = +value.apply(this, arguments);
        };
      }

      function delayConstant(id, value) {
        return value = +value, function () {
          Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["g"
          /* init */
          ])(this, id).delay = value;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value) {
        var id = this._id;
        return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f"
        /* get */
        ])(this.node(), id).delay;
      };
      /***/

    },
    /* 472 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(46);

      function durationFunction(id, value) {
        return function () {
          Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
          /* set */
          ])(this, id).duration = +value.apply(this, arguments);
        };
      }

      function durationConstant(id, value) {
        return value = +value, function () {
          Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
          /* set */
          ])(this, id).duration = value;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value) {
        var id = this._id;
        return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f"
        /* get */
        ])(this.node(), id).duration;
      };
      /***/

    },
    /* 473 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(46);

      function easeConstant(id, value) {
        if (typeof value !== "function") throw new Error();
        return function () {
          Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
          /* set */
          ])(this, id).ease = value;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value) {
        var id = this._id;
        return arguments.length ? this.each(easeConstant(id, value)) : Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f"
        /* get */
        ])(this.node(), id).ease;
      };
      /***/

    },
    /* 474 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__index_js__ = __webpack_require__(169);
      /* harmony default export */


      __webpack_exports__["a"] = function (match) {
        if (typeof match !== "function") match = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["matcher"])(match);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
            if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
              subgroup.push(node);
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_1__index_js__["a"
        /* Transition */
        ](subgroups, this._parents, this._name, this._id);
      };
      /***/

    },
    /* 475 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(169);
      /* harmony default export */


      __webpack_exports__["a"] = function (transition) {
        if (transition._id !== this._id) throw new Error();

        for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
          for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group0[i] || group1[i]) {
              merge[i] = node;
            }
          }
        }

        for (; j < m0; ++j) {
          merges[j] = groups0[j];
        }

        return new __WEBPACK_IMPORTED_MODULE_0__index_js__["a"
        /* Transition */
        ](merges, this._parents, this._name, this._id);
      };
      /***/

    },
    /* 476 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(46);

      function start(name) {
        return (name + "").trim().split(/^|\s+/).every(function (t) {
          var i = t.indexOf(".");
          if (i >= 0) t = t.slice(0, i);
          return !t || t === "start";
        });
      }

      function onFunction(id, name, listener) {
        var on0,
            on1,
            sit = start(name) ? __WEBPACK_IMPORTED_MODULE_0__schedule_js__["g"
        /* init */
        ] : __WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
        /* set */
        ];
        return function () {
          var schedule = sit(this, id),
              on = schedule.on; // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.

          if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
          schedule.on = on1;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, listener) {
        var id = this._id;
        return arguments.length < 2 ? Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f"
        /* get */
        ])(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
      };
      /***/

    },
    /* 477 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function removeFunction(id) {
        return function () {
          var parent = this.parentNode;

          for (var i in this.__transition) {
            if (+i !== id) return;
          }

          if (parent) parent.removeChild(this);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        return this.on("end.remove", removeFunction(this._id));
      };
      /***/

    },
    /* 478 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__index_js__ = __webpack_require__(169);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__schedule_js__ = __webpack_require__(46);
      /* harmony default export */


      __webpack_exports__["a"] = function (select) {
        var name = this._name,
            id = this._id;
        if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selector"])(select);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
            if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
              if ("__data__" in node) subnode.__data__ = node.__data__;
              subgroup[i] = subnode;
              Object(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["e"
              /* default */
              ])(subgroup[i], name, id, i, subgroup, Object(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["f"
              /* get */
              ])(node, id));
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_1__index_js__["a"
        /* Transition */
        ](subgroups, this._parents, name, id);
      };
      /***/

    },
    /* 479 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__index_js__ = __webpack_require__(169);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__schedule_js__ = __webpack_require__(46);
      /* harmony default export */


      __webpack_exports__["a"] = function (select) {
        var name = this._name,
            id = this._id;
        if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selectorAll"])(select);

        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["f"
              /* get */
              ])(node, id), k = 0, l = children.length; k < l; ++k) {
                if (child = children[k]) {
                  Object(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["e"
                  /* default */
                  ])(child, name, id, k, children, inherit);
                }
              }

              subgroups.push(children);
              parents.push(node);
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_1__index_js__["a"
        /* Transition */
        ](subgroups, parents, name, id);
      };
      /***/

    },
    /* 480 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);

      var Selection = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.constructor;
      /* harmony default export */

      __webpack_exports__["a"] = function () {
        return new Selection(this._groups, this._parents);
      };
      /***/

    },
    /* 481 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(379);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__schedule_js__ = __webpack_require__(46);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__tween_js__ = __webpack_require__(365);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__interpolate_js__ = __webpack_require__(400);

      function styleNull(name, interpolate) {
        var string00, string10, interpolate0;
        return function () {
          var string0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name),
              string1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name));
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
        };
      }

      function styleRemove(name) {
        return function () {
          this.style.removeProperty(name);
        };
      }

      function styleConstant(name, interpolate, value1) {
        var string00,
            string1 = value1 + "",
            interpolate0;
        return function () {
          var string0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name);
          return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
        };
      }

      function styleFunction(name, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
          var string0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name),
              value1 = value(this),
              string1 = value1 + "";
          if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name));
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
      }

      function styleMaybeRemove(id, name) {
        var on0,
            on1,
            listener0,
            key = "style." + name,
            event = "end." + key,
            remove;
        return function () {
          var schedule = Object(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["h"
          /* set */
          ])(this, id),
              on = schedule.on,
              listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined; // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.

          if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
          schedule.on = on1;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value, priority) {
        var i = (name += "") === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["d"
        /* interpolateTransformCss */
        ] : __WEBPACK_IMPORTED_MODULE_4__interpolate_js__["a"
        /* default */
        ];
        return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, Object(__WEBPACK_IMPORTED_MODULE_3__tween_js__["b"
        /* tweenValue */
        ])(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
      };
      /***/

    },
    /* 482 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function styleInterpolate(name, i, priority) {
        return function (t) {
          this.style.setProperty(name, i.call(this, t), priority);
        };
      }

      function styleTween(name, value, priority) {
        var t, i0;

        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
          return t;
        }

        tween._value = value;
        return tween;
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error();
        return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
      };
      /***/

    },
    /* 483 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__tween_js__ = __webpack_require__(365);

      function textConstant(value) {
        return function () {
          this.textContent = value;
        };
      }

      function textFunction(value) {
        return function () {
          var value1 = value(this);
          this.textContent = value1 == null ? "" : value1;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value) {
        return this.tween("text", typeof value === "function" ? textFunction(Object(__WEBPACK_IMPORTED_MODULE_0__tween_js__["b"
        /* tweenValue */
        ])(this, "text", value)) : textConstant(value == null ? "" : value + ""));
      };
      /***/

    },
    /* 484 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function textInterpolate(i) {
        return function (t) {
          this.textContent = i.call(this, t);
        };
      }

      function textTween(value) {
        var t0, i0;

        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
          return t0;
        }

        tween._value = value;
        return tween;
      }
      /* harmony default export */


      __webpack_exports__["a"] = function (value) {
        var key = "text";
        if (arguments.length < 1) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error();
        return this.tween(key, textTween(value));
      };
      /***/

    },
    /* 485 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(169);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__schedule_js__ = __webpack_require__(46);
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        var name = this._name,
            id0 = this._id,
            id1 = Object(__WEBPACK_IMPORTED_MODULE_0__index_js__["c"
        /* newId */
        ])();

        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              var inherit = Object(__WEBPACK_IMPORTED_MODULE_1__schedule_js__["f"
              /* get */
              ])(node, id0);
              Object(__WEBPACK_IMPORTED_MODULE_1__schedule_js__["e"
              /* default */
              ])(node, name, id1, i, group, {
                time: inherit.time + inherit.delay + inherit.duration,
                delay: 0,
                duration: inherit.duration,
                ease: inherit.ease
              });
            }
          }
        }

        return new __WEBPACK_IMPORTED_MODULE_0__index_js__["a"
        /* Transition */
        ](groups, this._parents, name, id1);
      };
      /***/

    },
    /* 486 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(46);
      /* harmony default export */


      __webpack_exports__["a"] = function () {
        var on0,
            on1,
            that = this,
            id = that._id,
            size = that.size();
        return new Promise(function (resolve, reject) {
          var cancel = {
            value: reject
          },
              end = {
            value: function value() {
              if (--size === 0) resolve();
            }
          };
          that.each(function () {
            var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["h"
            /* set */
            ])(this, id),
                on = schedule.on; // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.

            if (on !== on0) {
              on1 = (on0 = on).copy();

              on1._.cancel.push(cancel);

              on1._.interrupt.push(cancel);

              on1._.end.push(end);
            }

            schedule.on = on1;
          });
        });
      };
      /***/

    },
    /* 487 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__transition_index_js__ = __webpack_require__(169);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__ = __webpack_require__(46);

      var root = [null];
      /* harmony default export */

      __webpack_exports__["a"] = function (node, name) {
        var schedules = node.__transition,
            schedule,
            i;

        if (schedules) {
          name = name == null ? null : name + "";

          for (i in schedules) {
            if ((schedule = schedules[i]).state > __WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__["c"
            /* SCHEDULED */
            ] && schedule.name === name) {
              return new __WEBPACK_IMPORTED_MODULE_0__transition_index_js__["a"
              /* Transition */
              ]([[node]], root, name, +i);
            }
          }
        }

        return null;
      };
      /***/

    },
    /* 488 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview venn shapes
       * @author leungwensen@gmail.com
       */
      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      var PathUtil = Util.PathUtil;

      function getAttrs(cfg) {
        var defaultCfg = Global.shape.venn;
        var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addFillAttrs(pathAttrs, cfg);
        return pathAttrs;
      }

      function getHollowAttrs(cfg) {
        var defaultCfg = Global.shape.hollowVenn;
        var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addStrokeAttrs(pathAttrs, cfg);
        return pathAttrs;
      } // register venn geom


      var Venn = Shape.registerFactory('venn', {
        defaultShapeType: 'venn',
        getActiveCfg: function getActiveCfg(type, cfg) {
          var lineWidth = cfg.lineWidth || 1;

          if (type === 'hollow') {
            return {
              lineWidth: lineWidth + 1
            };
          }

          var opacity = cfg.fillOpacity || cfg.opacity || 1;
          return {
            // lineWidth,
            fillOpacity: opacity - 0.08
          };
        },
        getSelectedCfg: function getSelectedCfg(type, cfg) {
          if (cfg && cfg.style) {
            return cfg.style;
          }

          return this.getActiveCfg(type, cfg);
        }
      });
      Shape.registerShape('venn', 'venn', {
        draw: function draw(cfg, container) {
          var origin = cfg.origin._origin;
          var path = origin.path;
          var attrs = getAttrs(cfg);
          var segments = PathUtil.parsePathString(path);
          var pathShape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: segments
            })
          });
          return pathShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4
          }, getAttrs(cfg));
        }
      });
      Shape.registerShape('venn', 'hollow', {
        draw: function draw(cfg, container) {
          var origin = cfg.origin._origin;
          var path = origin.path;
          var attrs = getHollowAttrs(cfg);
          var segments = PathUtil.parsePathString(path);
          var pathShape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: segments
            })
          });
          return pathShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4
          }, getAttrs(cfg));
        }
      });
      module.exports = Venn;
      /***/
    },
    /* 489 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview Venn Diagram
       * @author leungwensen@gmail.com
       */


      var GeomBase = __webpack_require__(21);

      var Util = __webpack_require__(0);

      var SizeMixin = __webpack_require__(359);

      __webpack_require__(490);

      var Violin = /*#__PURE__*/function (_GeomBase) {
        _inheritsLoose(Violin, _GeomBase);

        var _proto = Violin.prototype;
        /**
         * get default configuration
         * @protected
         * @return {Object} configuration
         */

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

          cfg.type = 'violin';
          cfg.shapeType = 'violin';
          cfg.generatePoints = true; // super.draw(data, container, shapeFactory, index);

          return cfg;
        };

        function Violin(cfg) {
          var _this;

          _this = _GeomBase.call(this, cfg) || this;
          Util.assign(_assertThisInitialized(_this), SizeMixin);
          return _this;
        }

        _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
          var self = this;

          var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

          cfg.size = self.getNormalizedSize(obj);
          var sizeField = self.get('_sizeField');
          cfg._size = obj._origin[sizeField];
          return cfg;
        };

        _proto.clearInner = function clearInner() {
          _GeomBase.prototype.clearInner.call(this);

          this.set('defaultSize', null);
        };

        _proto._initAttrs = function _initAttrs() {
          var self = this;
          var attrOptions = self.get('attrOptions');
          var sizeField = attrOptions.size ? attrOptions.size.field : self.get('_sizeField') ? self.get('_sizeField') : 'size';
          self.set('_sizeField', sizeField);
          delete attrOptions.size;

          _GeomBase.prototype._initAttrs.call(this);
        };

        return Violin;
      }(GeomBase);

      var ViolinDodge = /*#__PURE__*/function (_Violin) {
        _inheritsLoose(ViolinDodge, _Violin);

        function ViolinDodge() {
          return _Violin.apply(this, arguments) || this;
        }

        var _proto2 = ViolinDodge.prototype;

        _proto2.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Violin.prototype.getDefaultCfg.call(this);

          cfg.hasDefaultAdjust = true;
          cfg.adjusts = [{
            type: 'dodge'
          }];
          return cfg;
        };

        return ViolinDodge;
      }(Violin);

      Violin.Dodge = ViolinDodge;
      GeomBase.Violin = Violin;
      GeomBase.ViolinDodge = ViolinDodge;
      module.exports = Violin;
      /***/
    },
    /* 490 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview venn shapes
       * @author leungwensen@gmail.com
       */
      var Util = __webpack_require__(0);

      var Shape = __webpack_require__(19);

      var ShapeUtil = __webpack_require__(45);

      var Global = __webpack_require__(7);

      var PathUtil = __webpack_require__(23);

      function getAttrs(cfg) {
        var defaultCfg = Global.shape.venn;
        var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addFillAttrs(pathAttrs, cfg);

        if (cfg.color) {
          pathAttrs.stroke = pathAttrs.stroke || cfg.color;
        }

        return pathAttrs;
      }

      function getHollowAttrs(cfg) {
        var defaultCfg = Global.shape.hollowVenn;
        var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
        ShapeUtil.addStrokeAttrs(pathAttrs, cfg);
        return pathAttrs;
      }

      function getViolinPath(points) {
        var path = [];

        for (var i = 0; i < points.length; i++) {
          var point = points[i];

          if (point) {
            var action = i === 0 ? 'M' : 'L';
            path.push([action, point.x, point.y]);
          }
        }

        var first = points[0];

        if (first) {
          path.push(['L', first.x, first.y]);
          path.push(['z']);
        }

        return path;
      }

      function getSmoothViolinPath(points) {
        var half = points.length / 2;
        var leftPoints = [];
        var rightPoints = [];

        for (var i = 0; i < points.length; i++) {
          if (i < half) {
            leftPoints.push(points[i]);
          } else {
            rightPoints.push(points[i]);
          }
        }

        var leftPath = PathUtil.getSplinePath(leftPoints, false);
        var rightPath = PathUtil.getSplinePath(rightPoints, false);

        if (rightPoints.length) {
          leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);
        }

        rightPath.shift();
        var path = leftPath.concat(rightPath);

        if (leftPoints.length) {
          path.push(['L', leftPoints[0].x, leftPoints[0].y]);
        }

        path.push(['z']);
        return path;
      }

      function normalizeSize(arr) {
        var max = Math.max.apply(null, arr);
        return arr.map(function (num) {
          return num / max;
        });
      } // register violin geom shape


      var Violin = Shape.registerFactory('violin', {
        defaultShapeType: 'violin',
        getDefaultPoints: function getDefaultPoints(pointInfo) {
          var radius = pointInfo.size / 2;
          var points = [];
          var sizeArr = normalizeSize(pointInfo._size);
          Util.each(pointInfo.y, function (y, index) {
            var offset = sizeArr[index] * radius;
            var isMin = index === 0;
            var isMax = index === pointInfo.y.length - 1;
            points.push({
              isMin: isMin,
              isMax: isMax,
              x: pointInfo.x - offset,
              y: y
            });
            points.unshift({
              isMin: isMin,
              isMax: isMax,
              x: pointInfo.x + offset,
              y: y
            });
          });
          return points;
        },
        getActiveCfg: function getActiveCfg(type, cfg) {
          var lineWidth = cfg.lineWidth || 1;

          if (type === 'hollow') {
            return {
              lineWidth: lineWidth + 1
            };
          }

          var opacity = cfg.fillOpacity || cfg.opacity || 1;
          return {
            // lineWidth,
            fillOpacity: opacity - 0.08
          };
        },
        getSelectedCfg: function getSelectedCfg(type, cfg) {
          if (cfg && cfg.style) {
            return cfg.style;
          }

          return this.getActiveCfg(type, cfg);
        }
      }); // normal violin, filled path

      Shape.registerShape('violin', 'violin', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);
          var path = getViolinPath(cfg.points);
          path = this.parsePath(path);
          var pathShape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
          return pathShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4
          }, getAttrs(cfg));
        }
      }); // smooth spline violin, filled path

      Shape.registerShape('violin', 'smooth', {
        draw: function draw(cfg, container) {
          var attrs = getAttrs(cfg);
          var path = getSmoothViolinPath(cfg.points);
          path = this.parsePath(path);
          var pathShape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
          return pathShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4
          }, getAttrs(cfg));
        }
      }); // hollow violin, stroked path

      Shape.registerShape('violin', 'hollow', {
        draw: function draw(cfg, container) {
          var attrs = getHollowAttrs(cfg);
          var path = getViolinPath(cfg.points);
          path = this.parsePath(path);
          var pathShape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
          return pathShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4
          }, getHollowAttrs(cfg));
        }
      }); // hollow smooth spline violin, stroked path

      Shape.registerShape('violin', 'smoothHollow', {
        draw: function draw(cfg, container) {
          var attrs = getHollowAttrs(cfg);
          var path = getSmoothViolinPath(cfg.points);
          path = this.parsePath(path);
          var pathShape = container.addShape('path', {
            attrs: Util.mix(attrs, {
              path: path
            })
          });
          return pathShape;
        },
        getMarkerCfg: function getMarkerCfg(cfg) {
          return Util.mix({
            symbol: 'circle',
            radius: 4
          }, getHollowAttrs(cfg));
        }
      });
      module.exports = Violin;
      /***/
    },
    /* 491 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview Facet 的入口
       * @author dxq613@gmail.com
       */
      var Util = __webpack_require__(0);

      var Chart = __webpack_require__(146);

      var Facets = {};
      Facets.Rect = __webpack_require__(401);
      Facets.List = __webpack_require__(402);
      Facets.Circle = __webpack_require__(492);
      Facets.Tree = __webpack_require__(493);
      Facets.Mirror = __webpack_require__(494);
      Facets.Matrix = __webpack_require__(495);

      Chart.prototype.facet = function (type, cfg) {
        var cls = Facets[Util.upperFirst(type)];

        if (!cls) {
          throw new Error('Not support such type of facets as: ' + type);
        }

        var preFacets = this.get('facets');

        if (preFacets) {
          preFacets.destroy();
        }

        cfg.chart = this;
        var facets = new cls(cfg);
        this.set('facets', facets);
      };

      module.exports = Facets;
      /***/
    },
    /* 492 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview circle facets
       * @author dxq613@gmail.com
       */


      var Base = __webpack_require__(366);

      function getPoint(center, r, angle) {
        return {
          x: center.x + r * Math.cos(angle),
          y: center.y + r * Math.sin(angle)
        };
      }

      var Circle = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Circle, _Base);

        function Circle() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Circle.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          cfg.type = 'circle';
          return cfg;
        };

        _proto.getRegion = function getRegion(count, index) {
          var r = 1 / 2; // 画布半径

          var avgAngle = Math.PI * 2 / count;
          var angle = -1 * Math.PI / 2 + avgAngle * index; // 当前分面所在的弧度

          var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
          var center = {
            x: 0.5,
            y: 0.5
          }; // 画布圆心

          var middle = getPoint(center, r - facetR, angle); // 分面的中心点

          var startAngle = Math.PI * 5 / 4; // 右上角

          var endAngle = Math.PI * 1 / 4; // 左下角

          return {
            start: getPoint(middle, facetR, startAngle),
            end: getPoint(middle, facetR, endAngle)
          };
        };

        _proto.generateFacets = function generateFacets(data) {
          var self = this;
          var fields = self.fields;
          var field = fields[0];

          if (!field) {
            throw 'Please specify for the field for facet!';
          }

          var values = self.getFieldValues(field, data);
          var count = values.length;
          var rst = [];
          values.forEach(function (value, index) {
            var conditions = [{
              field: field,
              value: value,
              values: values
            }];
            var filter = self.getFilter(conditions);
            var subData = data.filter(filter);
            var facet = {
              type: self.type,
              colValue: value,
              colField: field,
              colIndex: index,
              cols: count,
              rows: 1,
              rowIndex: 0,
              data: subData,
              region: self.getRegion(count, index)
            };
            rst.push(facet);
          });
          return rst;
        };

        return Circle;
      }(Base);

      module.exports = Circle;
      /***/
    },
    /* 493 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview tree facets
       * @author dxq613@gmail.com
       */


      var Base = __webpack_require__(366);

      var Util = __webpack_require__(0);

      var assign = Util.assign;

      var Tree = /*#__PURE__*/function (_Base) {
        _inheritsLoose(Tree, _Base);

        function Tree() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = Tree.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Base.prototype.getDefaultCfg.call(this);

          cfg.type = 'tree';
          cfg.line = {
            lineWidth: 1,
            stroke: '#ddd'
          };
          cfg.lineSmooth = false;
          return cfg;
        };

        _proto.generateFacets = function generateFacets(data) {
          var self = this;
          var fields = self.fields;

          if (!fields.length) {
            throw 'Please specify for the fields for facet!';
          }

          var rst = [];
          var root = self.getRootFacet(data); // if (self.showRoot) {

          rst.push(root); // }

          root.children = self.getChildFacets(data, 1, rst);
          self.setRegion(rst);
          return rst;
        };

        _proto.getRootFacet = function getRootFacet(data) {
          var self = this;
          var facet = {
            type: self.type,
            rows: self.getRows(),
            rowIndex: 0,
            colIndex: 0,
            colValue: self.rootTitle,
            data: data
          };
          return facet;
        };

        _proto.getRows = function getRows() {
          return this.fields.length + 1;
        } // get child
        ;

        _proto.getChildFacets = function getChildFacets(data, level, arr) {
          var self = this;
          var fields = self.fields;
          var length = fields.length;

          if (length < level) {
            return;
          }

          var rst = [];
          var field = fields[level - 1];
          var values = self.getFieldValues(field, data);
          values.forEach(function (value, index) {
            var conditions = [{
              field: field,
              value: value,
              values: values
            }];
            var filter = self.getFilter(conditions);
            var subData = data.filter(filter);

            if (subData.length) {
              var facet = {
                type: self.type,
                colValue: value,
                colField: field,
                colIndex: index,
                rows: self.getRows(),
                rowIndex: level,
                data: subData,
                children: self.getChildFacets(subData, level + 1, arr)
              };
              rst.push(facet);
              arr.push(facet);
            }
          });
          return rst;
        } // 设置 region
        ;

        _proto.setRegion = function setRegion(facets) {
          var self = this;
          self.forceColIndex(facets);
          facets.forEach(function (facet) {
            facet.region = self.getRegion(facet.rows, facet.cols, facet.colIndex, facet.rowIndex);
          });
        } // set column index of facets
        ;

        _proto.forceColIndex = function forceColIndex(facets) {
          var self = this;
          var leafs = [];
          var index = 0;
          facets.forEach(function (facet) {
            if (self.isLeaf(facet)) {
              leafs.push(facet);
              facet.colIndex = index;
              index++;
            }
          });
          leafs.forEach(function (facet) {
            facet.cols = leafs.length;
          });
          var maxLevel = self.fields.length;

          for (var i = maxLevel - 1; i >= 0; i--) {
            var levelFacets = self.getFacetsByLevel(facets, i); // var yIndex = maxLevel - i;

            for (var j = 0; j < levelFacets.length; j++) {
              var facet = levelFacets[j];

              if (!self.isLeaf(facet)) {
                facet.originColIndex = facet.colIndex;
                facet.colIndex = self.getRegionIndex(facet.children);
                facet.cols = leafs.length;
              }
            }
          }
        } // get facet use level
        ;

        _proto.getFacetsByLevel = function getFacetsByLevel(facets, level) {
          var rst = [];
          facets.forEach(function (facet) {
            if (facet.rowIndex === level) {
              rst.push(facet);
            }
          });
          return rst;
        } // set facets region
        ;

        _proto.getRegion = function getRegion(rows, cols, xIndex, yIndex) {
          var xWidth = 1 / cols; // x轴方向的每个分面的偏移

          var yWidth = 1 / rows; // y轴方向的每个分面的偏移

          var start = {
            x: xWidth * xIndex,
            y: yWidth * yIndex
          };
          var end = {
            x: start.x + xWidth,
            y: start.y + yWidth * 2 / 3 // 预留1/3的空隙，方便添加连接线

          };
          return {
            start: start,
            end: end
          };
        } // if the facet has children , make it's column index in the middle of it's children
        ;

        _proto.getRegionIndex = function getRegionIndex(children) {
          var first = children[0];
          var last = children[children.length - 1];
          return (last.colIndex - first.colIndex) / 2 + first.colIndex;
        } // is  a leaf without children
        ;

        _proto.isLeaf = function isLeaf(facet) {
          return !facet.children || !facet.children.length;
        };

        _proto.setXAxis = function setXAxis(xField, axes, facet) {
          // 当是最后一行或者下面没有 view 时文本不显示
          if (facet.rowIndex !== facet.rows - 1) {
            axes[xField].label = null;
            axes[xField].title = null;
          }
        } // 设置 y 坐标轴的文本、title 是否显示
        ;

        _proto.setYAxis = function setYAxis(yField, axes, facet) {
          if (facet.originColIndex !== 0 && facet.colIndex !== 0) {
            axes[yField].title = null;
            axes[yField].label = null;
          }
        } // 绘制完成后
        ;

        _proto.onPaint = function onPaint() {
          _Base.prototype.onPaint.call(this);

          this.group.clear();

          if (this.facets && this.line) {
            this.drawLines(this.facets, this.group);
          }
        };

        _proto.drawLines = function drawLines(facets, group) {
          var self = this;
          var lineGroup = group.addGroup();
          facets.forEach(function (facet) {
            if (!self.isLeaf(facet)) {
              var children = facet.children;

              self._addFacetLines(facet, children, lineGroup);
            }
          });
        } // add lines with it's children
        ;

        _proto._addFacetLines = function _addFacetLines(facet, children, group) {
          var self = this;
          var view = facet.view;
          var region = view.getViewRegion();
          var start = {
            x: region.start.x + (region.end.x - region.start.x) / 2,
            y: region.start.y
          };
          children.forEach(function (subFacet) {
            var subRegion = subFacet.view.getViewRegion();
            var end = {
              x: subRegion.start.x + (subRegion.end.x - subRegion.start.x) / 2,
              y: subRegion.end.y
            };
            var middle1 = {
              x: start.x,
              y: start.y + (end.y - start.y) / 2
            };
            var middle2 = {
              x: end.x,
              y: middle1.y
            };

            self._drawLine([start, middle1, middle2, end], group);
          });
        };

        _proto._getPath = function _getPath(points) {
          var self = this;
          var path = [];
          var smooth = self.lineSmooth;

          if (smooth) {
            path.push(['M', points[0].x, points[0].y]);
            path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
          } else {
            points.forEach(function (point, index) {
              if (index === 0) {
                path.push(['M', point.x, point.y]);
              } else {
                path.push(['L', point.x, point.y]);
              }
            });
          }

          return path;
        } // draw line width points
        ;

        _proto._drawLine = function _drawLine(points, group) {
          var self = this;

          var path = self._getPath(points);

          var line = self.line;
          group.addShape('path', {
            attrs: assign({
              path: path
            }, line)
          });
        };

        return Tree;
      }(Base);

      module.exports = Tree;
      /***/
    },
    /* 494 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview mirror facets
       * @author dxq613@gmail.com
       */


      var List = __webpack_require__(402);

      var Mirror = /*#__PURE__*/function (_List) {
        _inheritsLoose(Mirror, _List);

        function Mirror() {
          return _List.apply(this, arguments) || this;
        }

        var _proto = Mirror.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _List.prototype.getDefaultCfg.call(this);

          cfg.type = 'mirror';
          this.transpose = false;
          return cfg;
        };

        _proto.init = function init() {
          var self = this;

          if (self.transpose) {
            self.cols = 2;
            self.rows = 1;
          } else {
            self.cols = 1;
            self.rows = 2;
          }

          _List.prototype.init.call(this);
        };

        _proto.beforeProcessView = function beforeProcessView(view, facet) {
          if (this.transpose) {
            if (facet.colIndex % 2 === 0) {
              view.coord().transpose().scale(-1, 1);
            } else {
              view.coord().transpose();
            }
          } else {
            if (facet.rowIndex % 2 !== 0) {
              view.coord().scale(1, -1);
            }
          }
        };

        _proto.renderTitle = function renderTitle(view, facet) {
          if (this.transpose) {
            this.drawColTitle(view, facet);
          } else {
            this.drawRowTitle(view, facet);
          }
        };

        _proto.setXAxis = function setXAxis(xField, axes, facet) {
          // 当是最后一行或者下面没有 view 时文本不显示
          if (facet.colIndex === 1 || facet.rowIndex === 1) {
            axes[xField].label = null;
            axes[xField].title = null;
          }
        };

        _proto.setYAxis = function setYAxis()
        /* yField, axes, facet */
        {};

        return Mirror;
      }(List);

      module.exports = Mirror;
      /***/
    },
    /* 495 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @fileOverview Use matrices to compare different fields
       * @author dxq613@gmail.com
       */


      var Rect = __webpack_require__(401);

      var Matrix = /*#__PURE__*/function (_Rect) {
        _inheritsLoose(Matrix, _Rect);

        function Matrix() {
          return _Rect.apply(this, arguments) || this;
        }

        var _proto = Matrix.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Rect.prototype.getDefaultCfg.call(this);

          cfg.type = 'matrix';
          cfg.showTitle = false;
          return cfg;
        };

        _proto.generateFacets = function generateFacets(data) {
          var self = this;
          var fields = self.fields;
          var rows = fields.length;
          var cols = rows; // 矩阵中行列相等，等于指定的字段个数

          var rst = [];

          for (var i = 0; i < cols; i++) {
            var colField = fields[i];

            for (var j = 0; j < rows; j++) {
              var rowField = fields[j];
              var facet = {
                type: self.type,
                colValue: colField,
                rowValue: rowField,
                colField: colField,
                rowField: rowField,
                colIndex: i,
                rowIndex: j,
                cols: cols,
                rows: rows,
                data: data,
                region: self.getRegion(rows, cols, i, j)
              };
              rst.push(facet);
            }
          }

          return rst;
        } // 设置 x 坐标轴的文本、title 是否显示
        ;

        _proto.setXAxis = function setXAxis(xField, axes, facet) {
          if (facet.rowIndex !== facet.rows - 1) {
            axes[xField].title = null;
            axes[xField].label = null;
          }
        } // 设置 y 坐标轴的文本、title 是否显示
        ;

        _proto.setYAxis = function setYAxis(yField, axes, facet) {
          if (facet.colIndex !== 0) {
            axes[yField].title = null;
            axes[yField].label = null;
          }
        };

        return Matrix;
      }(Rect);

      module.exports = Matrix;
      /***/
    },
    /* 496 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * @fileOverview Interaction
       * @author leungwensen@gmail.com
       */
      var G2 = __webpack_require__(172);

      var Chart = __webpack_require__(146);

      var Util = __webpack_require__(0);

      var Interactions = {
        Base: __webpack_require__(171),
        Brush: __webpack_require__(497),
        Drag: __webpack_require__(498),
        ScrollBar: __webpack_require__(500),
        ShapeSelect: __webpack_require__(502),
        Slider: __webpack_require__(503),
        Zoom: __webpack_require__(505)
      };
      G2._Interactions = {};

      G2.registerInteraction = function (type, constructor) {
        G2._Interactions[type] = constructor;
      };

      G2.getInteraction = function (type) {
        return G2._Interactions[type];
      }; // binding on View


      Chart.prototype.getInteractions = function () {
        var me = this;

        if (!me._interactions) {
          me._interactions = {};
        }

        return me._interactions;
      };

      Chart.prototype._setInteraction = function (type, interaction) {
        var me = this;
        var interactions = me.getInteractions();

        if (interactions[type] && interactions[type] !== interaction) {
          // only one interaction for a key
          interactions[type].destroy();
        }

        interactions[type] = interaction;
      };

      Chart.prototype.clearInteraction = function (type) {
        var me = this;
        var interactions = me.getInteractions();

        if (type) {
          if (interactions[type]) {
            interactions[type]._reset();

            interactions[type].destroy();
          }

          delete interactions[type];
        } else {
          Util.each(interactions, function (interaction, key) {
            interaction._reset();

            interaction.destroy();
            delete interactions[key];
          });
        }
      };

      Chart.prototype.interact = Chart.prototype.interaction = function (type, cfg) {
        var me = this;
        var Ctor = G2.getInteraction(type);
        var interaction = new Ctor(cfg, me);

        me._setInteraction(type, interaction);

        return me;
      };

      G2.registerInteraction('brush', Interactions.Brush);
      G2.registerInteraction('Brush', Interactions.Brush);
      G2.registerInteraction('drag', Interactions.Drag);
      G2.registerInteraction('Drag', Interactions.Drag);
      G2.registerInteraction('zoom', Interactions.Zoom);
      G2.registerInteraction('Zoom', Interactions.Zoom);
      G2.registerInteraction('scroll-bar', Interactions.ScrollBar);
      G2.registerInteraction('ScrollBar', Interactions.ScrollBar);
      G2.registerInteraction('shape-select', Interactions.ShapeSelect);
      G2.registerInteraction('ShapeSelect', Interactions.ShapeSelect);
      G2.registerInteraction('slider', Interactions.Slider);
      G2.registerInteraction('Slider', Interactions.Slider);
      module.exports = Interactions;
      /***/
    },
    /* 497 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(0);

      var Interaction = __webpack_require__(171); // const G2 = require('../core.js');


      var BRUSH_TYPES = ['X', 'Y', 'XY', 'POLYGON'];
      var DEFAULT_TYPE = 'XY';

      var Brush = /*#__PURE__*/function (_Interaction) {
        _inheritsLoose(Brush, _Interaction);

        var _proto = Brush.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interaction.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            type: DEFAULT_TYPE,
            startPoint: null,
            brushing: false,
            dragging: false,
            brushShape: null,
            container: null,
            polygonPath: null,
            style: {
              fill: '#C5D4EB',
              opacity: 0.3,
              lineWidth: 1,
              stroke: '#82A6DD'
            },
            draggable: false,
            dragOffX: 0,
            dragOffY: 0,
            inPlot: true,
            xField: null,
            yField: null
          });
        };

        function Brush(cfg, view) {
          var _this;

          _this = _Interaction.call(this, cfg, view) || this;

          var me = _assertThisInitialized(_this);

          me.filter = !me.draggable;
          me.type = me.type.toUpperCase();
          me.chart = view;

          if (!BRUSH_TYPES.includes(me.type)) {
            me.type = DEFAULT_TYPE;
          }

          var canvas = me.canvas;

          if (canvas) {
            var plotRange;
            canvas.get('children').map(function (child) {
              if (child.get('type') === 'plotBack') {
                plotRange = child.get('plotRange');
                return false;
              }

              return child;
            });
            me.plot = {
              start: plotRange.bl,
              end: plotRange.tr
            };
          }

          if (view) {
            var coord = view.get('coord');
            me.plot = {
              start: coord.start,
              end: coord.end
            };
            view.on('afterrender', function () {
              me.plot = {
                start: coord.start,
                end: coord.end
              };
            });
            me.isTransposed = coord.isTransposed;

            var xScales = view._getScales('x');

            var yScales = view._getScales('y');

            me.xScale = me.xField ? xScales[me.xField] : view.getXScale();
            me.yScale = me.yField ? yScales[me.yField] : view.getYScales()[0];
          }

          return _this;
        } // onBurshstart() { }
        // onBrushmove() { }
        // onBrushend() {}
        // onDragstart() {}
        // onDragmove() {}
        // onDragend() {}


        _proto.start = function start(ev) {
          var me = this;
          var canvas = me.canvas,
              type = me.type,
              brushShape = me.brushShape;
          if (!type) return;

          if (me.brushing) {
            // 鼠标移动到图表外up, 回到图表内点击即结束绘制，mousedown的时候却正在绘制中
            me.end(ev);
          }

          var startPoint = {
            x: ev.offsetX,
            y: ev.offsetY
          };
          if (!startPoint.x) return;
          var isInPlot = me.plot && me.inPlot;
          var canvasDOM = canvas.get('canvasDOM');
          var pixelRatio = canvas.get('pixelRatio');
          if (me.selection) me.selection = null;

          if (me.draggable && brushShape && !brushShape.get('destroyed')) {
            // allow drag the brushShape
            if (brushShape.isHit(startPoint.x * pixelRatio, startPoint.y * pixelRatio)) {
              canvasDOM.style.cursor = 'move';
              me.selection = brushShape;
              me.dragging = true;

              if (type === 'X') {
                me.dragoffX = startPoint.x - brushShape.attr('x');
                me.dragoffY = 0;
              } else if (type === 'Y') {
                me.dragoffX = 0;
                me.dragoffY = startPoint.y - brushShape.attr('y');
              } else if (type === 'XY') {
                me.dragoffX = startPoint.x - brushShape.attr('x');
                me.dragoffY = startPoint.y - brushShape.attr('y');
              } else if (type === 'POLYGON') {
                var box = brushShape.getBBox();
                me.dragoffX = startPoint.x - box.minX;
                me.dragoffY = startPoint.y - box.minY;
              }

              if (isInPlot) {// me.selection.attr('clip', canvas.addShape('rect', {
                //   attrs: {
                //     x: this.plot.start.x,
                //     y: this.plot.end.y,
                //     width: this.plot.end.x - this.plot.start.x,
                //     height: this.plot.start.y - this.plot.end.y,
                //     fill: '#fff',
                //     fillOpacity: 0
                //   }
                // }));
              }

              me.onDragstart && me.onDragstart(ev);
            }

            me.prePoint = startPoint;
          }

          if (!me.dragging) {
            // brush start
            me.onBrushstart && me.onBrushstart(startPoint);
            var container = me.container;

            if (isInPlot) {
              var _me$plot = me.plot,
                  start = _me$plot.start,
                  end = _me$plot.end;
              if (startPoint.x < start.x || startPoint.x > end.x || startPoint.y < end.y || startPoint.y > start.y) return;
            }

            canvasDOM.style.cursor = 'crosshair';
            me.startPoint = startPoint;
            me.brushShape = null;
            me.brushing = true;

            if (!container) {
              container = canvas.addGroup({
                zIndex: 5 // upper

              });
              container.initTransform();
            } else {
              container.clear();
            }

            me.container = container;
            if (type === 'POLYGON') me.polygonPath = "M " + startPoint.x + " " + startPoint.y;
          }
        };

        _proto.process = function process(ev) {
          var me = this;
          var brushing = me.brushing,
              dragging = me.dragging,
              type = me.type,
              plot = me.plot,
              startPoint = me.startPoint,
              xScale = me.xScale,
              yScale = me.yScale,
              canvas = me.canvas;

          if (!brushing && !dragging) {
            return;
          }

          var currentPoint = {
            x: ev.offsetX,
            y: ev.offsetY
          };
          var canvasDOM = canvas.get('canvasDOM');

          if (brushing) {
            canvasDOM.style.cursor = 'crosshair';
            var start = plot.start,
                end = plot.end;
            var polygonPath = me.polygonPath;
            var brushShape = me.brushShape;
            var container = me.container;

            if (me.plot && me.inPlot) {
              currentPoint = me._limitCoordScope(currentPoint);
            }

            var rectStartX;
            var rectStartY;
            var rectWidth;
            var rectHeight;

            if (type === 'Y') {
              rectStartX = start.x;
              rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;
              rectWidth = Math.abs(start.x - end.x);
              rectHeight = Math.abs(startPoint.y - currentPoint.y);
            } else if (type === 'X') {
              rectStartX = currentPoint.x >= startPoint.x ? startPoint.x : currentPoint.x;
              rectStartY = end.y;
              rectWidth = Math.abs(startPoint.x - currentPoint.x);
              rectHeight = Math.abs(end.y - start.y);
            } else if (type === 'XY') {
              if (currentPoint.x >= startPoint.x) {
                rectStartX = startPoint.x;
                rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;
              } else {
                rectStartX = currentPoint.x;
                rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;
              }

              rectWidth = Math.abs(startPoint.x - currentPoint.x);
              rectHeight = Math.abs(startPoint.y - currentPoint.y);
            } else if (type === 'POLYGON') {
              polygonPath += "L " + currentPoint.x + " " + currentPoint.y;
              me.polygonPath = polygonPath;

              if (!brushShape) {
                brushShape = container.addShape('path', {
                  attrs: Util.mix(me.style, {
                    path: polygonPath
                  })
                });
              } else {
                !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {
                  path: polygonPath
                }));
              }
            }

            if (type !== 'POLYGON') {
              if (!brushShape) {
                brushShape = container.addShape('rect', {
                  attrs: Util.mix(me.style, {
                    x: rectStartX,
                    y: rectStartY,
                    width: rectWidth,
                    height: rectHeight
                  })
                });
              } else {
                !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {
                  x: rectStartX,
                  y: rectStartY,
                  width: rectWidth,
                  height: rectHeight
                }));
              }
            }

            me.brushShape = brushShape;
          } else if (dragging) {
            canvasDOM.style.cursor = 'move';
            var selection = me.selection;

            if (selection && !selection.get('destroyed')) {
              if (type === 'POLYGON') {
                var prePoint = me.prePoint;
                me.selection.translate(currentPoint.x - prePoint.x, currentPoint.y - prePoint.y);
              } else {
                me.dragoffX && selection.attr('x', currentPoint.x - me.dragoffX);
                me.dragoffY && selection.attr('y', currentPoint.y - me.dragoffY);
              }
            }
          }

          me.prePoint = currentPoint;
          canvas.draw();

          var _me$_getSelected = me._getSelected(),
              data = _me$_getSelected.data,
              shapes = _me$_getSelected.shapes,
              xValues = _me$_getSelected.xValues,
              yValues = _me$_getSelected.yValues;

          var eventObj = {
            data: data,
            shapes: shapes
          };

          if (xScale) {
            eventObj[xScale.field] = xValues;
          }

          if (yScale) {
            eventObj[yScale.field] = yValues;
          } // 将框选的数据传递给 ev，供 onEnd 钩子使用


          Util.mix(ev, eventObj);
          eventObj.x = currentPoint.x;
          eventObj.y = currentPoint.y;
          me.onDragmove && me.onDragmove(eventObj);
          me.onBrushmove && me.onBrushmove(eventObj);
        };

        _proto.end = function end(ev) {
          var me = this;

          if (!me.brushing && !me.dragging) {
            return;
          }

          var data = me.data,
              shapes = me.shapes,
              xValues = me.xValues,
              yValues = me.yValues,
              canvas = me.canvas,
              type = me.type,
              startPoint = me.startPoint,
              chart = me.chart,
              container = me.container,
              xScale = me.xScale,
              yScale = me.yScale;
          var offsetX = ev.offsetX,
              offsetY = ev.offsetY;
          var canvasDOM = canvas.get('canvasDOM');
          canvasDOM.style.cursor = 'default';

          if (startPoint === null) {
            return;
          }

          if (Math.abs(startPoint.x - offsetX) <= 1 && Math.abs(startPoint.y - offsetY) <= 1) {
            // 防止点击事件
            me.brushing = false;
            me.dragging = false;
            container.clear();
            canvas.draw();
            return;
          }

          var eventObj = {
            data: data,
            shapes: shapes
          };

          if (xScale) {
            eventObj[xScale.field] = xValues;
          }

          if (yScale) {
            eventObj[yScale.field] = yValues;
          } // 将框选的数据传递给 ev，供 onEnd 钩子使用


          Util.mix(ev, eventObj);
          eventObj.x = offsetX;
          eventObj.y = offsetY;

          if (me.dragging) {
            me.dragging = false;
            me.onDragend && me.onDragend(eventObj);
          } else if (me.brushing) {
            me.brushing = false;
            var brushShape = me.brushShape;
            var polygonPath = me.polygonPath;

            if (type === 'POLYGON') {
              polygonPath += 'z';
              brushShape && !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {
                path: polygonPath
              }));
              me.polygonPath = polygonPath;
              canvas.draw();
            }

            if (me.onBrushend) {
              me.onBrushend(eventObj);
            } else if (chart && me.filter) {
              container.clear(); // clear the brush
              // filter data

              if (!me.isTransposed && type === 'X' || me.isTransposed && type === 'Y') {
                xScale && chart.filter(xScale.field, function (val) {
                  return xValues.indexOf(val) > -1;
                });
              } else if (!me.isTransposed && type === 'Y' || me.isTransposed && type === 'X') {
                yScale && chart.filter(yScale.field, function (val) {
                  return yValues.indexOf(val) > -1;
                });
              } else {
                xScale && chart.filter(xScale.field, function (val) {
                  return xValues.indexOf(val) > -1;
                });
                yScale && chart.filter(yScale.field, function (val) {
                  return yValues.indexOf(val) > -1;
                });
              }

              chart.repaint();
            }
          }
        };

        _proto.reset = function reset() {
          var me = this;
          var chart = me.chart,
              filter = me.filter,
              brushShape = me.brushShape,
              canvas = me.canvas;

          this._init(); // 重置各种参考值


          if (chart && filter) {
            chart.get('options').filters = {};
            chart.repaint();
          }

          if (brushShape) {
            brushShape.destroy();
            canvas.draw();
          }
        };

        _proto._limitCoordScope = function _limitCoordScope(point) {
          var plot = this.plot;
          var start = plot.start,
              end = plot.end;

          if (point.x < start.x) {
            point.x = start.x;
          }

          if (point.x > end.x) {
            point.x = end.x;
          }

          if (point.y < end.y) {
            point.y = end.y;
          }

          if (point.y > start.y) {
            point.y = start.y;
          }

          return point;
        };

        _proto._getSelected = function _getSelected() {
          var me = this;
          var chart = me.chart,
              xScale = me.xScale,
              yScale = me.yScale,
              brushShape = me.brushShape,
              canvas = me.canvas;
          var pixelRatio = canvas.get('pixelRatio');
          var selectedShapes = [];
          var xValues = [];
          var yValues = [];
          var selectedData = [];

          if (chart) {
            var geoms = chart.get('geoms');
            geoms.map(function (geom) {
              var shapes = geom.getShapes();
              shapes.map(function (shape) {
                var shapeData = shape.get('origin');

                if (!Array.isArray(shapeData)) {
                  // 线图、区域图等
                  shapeData = [shapeData];
                }

                shapeData.map(function (each) {
                  if (brushShape.isHit(each.x * pixelRatio, each.y * pixelRatio)) {
                    selectedShapes.push(shape);
                    var origin = each._origin;
                    selectedData.push(origin);
                    xScale && xValues.push(origin[xScale.field]);
                    yScale && yValues.push(origin[yScale.field]);
                  }

                  return each;
                });
                return shape;
              });
              return geom;
            });
          }

          me.shapes = selectedShapes;
          me.xValues = xValues;
          me.yValues = yValues;
          me.data = selectedData;
          canvas.draw();
          return {
            data: selectedData,
            xValues: xValues,
            yValues: yValues,
            shapes: selectedShapes
          };
        };

        return Brush;
      }(Interaction); // G2.registerInteraction('brush', Brush);
      // G2.registerInteraction('Brush', Brush);


      module.exports = Brush;
      /***/
    },
    /* 498 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(0);

      var Interaction = __webpack_require__(171);

      var filterData = __webpack_require__(499);

      var getColDef = __webpack_require__(384);

      var getLimitRange = __webpack_require__(385);

      var DAY_TIMESTAMPS = 86400000; // const G2 = require('../core.js');

      var DRAGGING_TYPES = ['X', 'Y', 'XY'];
      var DEFAULT_TYPE = 'X';

      var Drag = /*#__PURE__*/function (_Interaction) {
        _inheritsLoose(Drag, _Interaction);

        var _proto = Drag.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interaction.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            type: DEFAULT_TYPE,
            stepRatio: 0.05,
            limitRange: {},
            stepByField: {},
            threshold: 20,
            originScaleDefsByField: {},
            previousPoint: null,
            isDragging: false
          });
        };

        _proto._disableTooltip = function _disableTooltip() {
          var me = this;
          var chart = me.chart;
          var tooltipController = chart.get('tooltipController');

          if (tooltipController) {
            me._showTooltip = true;
            chart.tooltip(false);
          }
        };

        _proto._enableTooltip = function _enableTooltip(ev) {
          var me = this;
          var chart = me.chart;

          if (me._showTooltip) {
            chart.tooltip(true);
            chart.showTooltip(ev);
          }
        };

        function Drag(cfg, chart) {
          var _this;

          _this = _Interaction.call(this, cfg, chart) || this;

          var me = _assertThisInitialized(_this);

          me.type = me.type.toUpperCase();
          me.chart = chart;
          me.coord = chart.get('coord');
          var data = me.data = chart.get('data'); // pre process

          filterData(chart);
          var scales = chart.getYScales();
          var xScale = chart.getXScale();
          scales.push(xScale);
          var scaleController = chart.get('scaleController');
          scales.forEach(function (scale) {
            var field = scale.field;
            me.limitRange[field] = getLimitRange(data, scale);
            var def = scaleController.defs[field] || {};
            me.originScaleDefsByField[field] = Util.mix(def, {
              nice: !!def.nice
            });

            if (scale.isLinear) {
              me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;
            }
          });

          if (!DRAGGING_TYPES.includes(me.type)) {
            me.type = DEFAULT_TYPE;
          }

          me._disableTooltip();

          return _this;
        } // onDragstart() { }
        // onDrag() { }
        // onDragend() { }


        _proto._applyTranslate = function _applyTranslate(scale, offset, total) {
          if (offset === void 0) {
            offset = 0;
          }

          var me = this;

          if (scale.isLinear) {
            me._translateLinearScale(scale, offset, total);
          } else {
            me._translateCatScale(scale, offset, total);
          }
        };

        _proto._translateCatScale = function _translateCatScale(scale, offset, total) {
          var me = this;
          var chart = me.chart;
          var type = scale.type,
              field = scale.field,
              values = scale.values,
              ticks = scale.ticks;
          var colDef = getColDef(chart, field);
          var originValues = me.limitRange[field];
          var ratio = offset / total;
          var valueLength = values.length;
          var deltaCount = Math.max(1, Math.abs(parseInt(ratio * valueLength)));
          var firstIndex = originValues.indexOf(values[0]);
          var lastIndex = originValues.indexOf(values[valueLength - 1]);

          if (offset > 0 && firstIndex >= 0) {
            // right
            for (var i = 0; i < deltaCount && firstIndex > 0; i++) {
              firstIndex -= 1;
              lastIndex -= 1;
            }

            var newValues = originValues.slice(firstIndex, lastIndex + 1);
            var newTicks = null;

            if (type === 'timeCat') {
              var tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;

              for (var _i = ticks[0] - tickGap; _i >= newValues[0]; _i -= tickGap) {
                ticks.unshift(_i);
              }

              newTicks = ticks;
            }

            chart.scale(field, Util.mix({}, colDef, {
              values: newValues,
              ticks: newTicks
            }));
          } else if (offset < 0 && lastIndex <= originValues.length - 1) {
            // left
            for (var _i2 = 0; _i2 < deltaCount && lastIndex < originValues.length - 1; _i2++) {
              firstIndex += 1;
              lastIndex += 1;
            }

            var _newValues = originValues.slice(firstIndex, lastIndex + 1);

            var _newTicks = null;

            if (type === 'timeCat') {
              var _tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;

              for (var _i3 = ticks[ticks.length - 1] + _tickGap; _i3 <= _newValues[_newValues.length - 1]; _i3 += _tickGap) {
                ticks.push(_i3);
              }

              _newTicks = ticks;
            }

            chart.scale(field, Util.mix({}, colDef, {
              values: _newValues,
              ticks: _newTicks
            }));
          }
        };

        _proto._translateLinearScale = function _translateLinearScale(scale, offset, total) {
          var me = this;
          var chart = me.chart,
              limitRange = me.limitRange; // linear / cat

          var min = scale.min,
              max = scale.max,
              field = scale.field;
          if (min === limitRange[field].min && max === limitRange[field].max) return;
          var ratio = offset / total;
          var range = max - min;
          var colDef = getColDef(chart, field);
          chart.scale(field, Util.mix({}, colDef, {
            nice: false,
            min: min + ratio * range,
            max: max + ratio * range
          }));
        };

        _proto.start = function start(ev) {
          var me = this;
          var canvas = me.canvas;
          var canvasDOM = canvas.get('canvasDOM');
          canvasDOM.style.cursor = 'pointer'; // const coord = chart.get('coord');

          me.isDragging = true;
          me.previousPoint = {
            x: ev.x,
            y: ev.y
          };

          me._disableTooltip();
        };

        _proto.process = function process(ev) {
          var me = this;

          if (me.isDragging) {
            var chart = me.chart,
                type = me.type,
                canvas = me.canvas,
                coord = me.coord,
                threshold = me.threshold;
            var canvasDOM = canvas.get('canvasDOM');
            canvasDOM.style.cursor = 'move'; // const coord = chart.get('coord');

            var previousPoint = me.previousPoint;
            var currentPoint = ev;
            var deltaX = currentPoint.x - previousPoint.x;
            var deltaY = currentPoint.y - previousPoint.y;
            var modified = false;

            if (Math.abs(deltaX) > threshold && type.indexOf('X') > -1) {
              modified = true;
              var xScale = chart.getXScale();

              me._applyTranslate(xScale, xScale.isLinear ? -deltaX : deltaX, coord.width);
            }

            if (Math.abs(deltaY) > threshold && type.indexOf('Y') > -1) {
              modified = true;
              var yScales = chart.getYScales();
              yScales.forEach(function (yScale) {
                me._applyTranslate(yScale, currentPoint.y - previousPoint.y, coord.height);
              });
            }

            if (modified) {
              me.previousPoint = currentPoint;
              chart.repaint();
            }
          }
        };

        _proto.end = function end(ev) {
          var me = this;
          me.isDragging = false;
          var canvas = me.canvas;
          var canvasDOM = canvas.get('canvasDOM');
          canvasDOM.style.cursor = 'default';

          me._enableTooltip(ev);
        };

        _proto.reset = function reset() {
          var me = this;
          var view = me.view,
              originScaleDefsByField = me.originScaleDefsByField;
          var scales = view.getYScales();
          var xScale = view.getXScale();
          scales.push(xScale);
          scales.forEach(function (scale) {
            if (scale.isLinear) {
              var field = scale.field;
              view.scale(field, originScaleDefsByField[field]);
            }
          });
          view.repaint();

          me._disableTooltip();
        };

        return Drag;
      }(Interaction);

      module.exports = Drag;
      /***/
    },
    /* 499 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      var TimeUtil = __webpack_require__(71);

      var getColDefs = __webpack_require__(383);

      module.exports = function (chart) {
        chart.on('beforeinitgeoms', function () {
          chart.set('limitInPlot', true);
          var data = chart.get('data');
          var colDefs = getColDefs(chart);
          if (!colDefs) return data;
          var geoms = chart.get('geoms');
          var isSpecialGeom = false;
          Util.each(geoms, function (geom) {
            if (['area', 'line', 'path'].includes(geom.get('type'))) {
              isSpecialGeom = true;
              return false;
            }
          });
          var fields = [];
          Util.each(colDefs, function (def, key) {
            if (!isSpecialGeom && def && (def.values || def.min || def.max)) {
              fields.push(key);
            }
          });

          if (fields.length === 0) {
            return data;
          }

          var geomData = [];
          Util.each(data, function (obj) {
            var flag = true;
            Util.each(fields, function (field) {
              var value = obj[field];

              if (value) {
                var colDef = colDefs[field];

                if (colDef.type === 'timeCat') {
                  var values = colDef.values;

                  if (Util.isNumber(values[0])) {
                    value = TimeUtil.toTimeStamp(value);
                  }
                }

                if (colDef.values && !colDef.values.includes(value) || colDef.min && value < colDef.min || colDef.max && value > colDef.max) {
                  flag = false;
                }
              }
            });

            if (flag) {
              geomData.push(obj);
            }
          });
          chart.set('filteredData', geomData);
        });
      };
      /***/

    },
    /* 500 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(0);

      var Interaction = __webpack_require__(171);

      var getFieldRange = __webpack_require__(501);

      var getLimitRange = __webpack_require__(385);

      var DEFAULT_TYPE = 'X';

      var ScrollBar = /*#__PURE__*/function (_Interaction) {
        _inheritsLoose(ScrollBar, _Interaction);

        var _proto = ScrollBar.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interaction.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            startEvent: null,
            processEvent: null,
            endEvent: null,
            resetEvent: null,
            type: DEFAULT_TYPE,
            xStyle: {
              backgroundColor: 'rgba(202, 215, 239, .2)',
              fillerColor: 'rgba(202, 215, 239, .75)',
              size: 4,
              lineCap: 'round',
              offsetX: 0,
              offsetY: -10
            },
            yStyle: {
              backgroundColor: 'rgba(202, 215, 239, .2)',
              fillerColor: 'rgba(202, 215, 239, .75)',
              size: 4,
              lineCap: 'round',
              offsetX: 8,
              offsetY: 0
            }
          });
        };

        _proto._renderScrollBars = function _renderScrollBars() {
          var chart = this.chart;
          var scrollBarCfg = chart.get('_scrollBarCfg');
          if (!scrollBarCfg) return;
          var data = chart.get('data');
          var plotRange = chart.get('plotRange');
          plotRange.width = Math.abs(plotRange.br.x - plotRange.bl.x);
          plotRange.height = Math.abs(plotRange.tl.y - plotRange.bl.y);
          var backPlot = chart.get('backPlot');
          var canvas = chart.get('canvas');
          var canvasHeight = canvas.get('height');
          var limitRange = chart.get('_limitRange');
          var type = scrollBarCfg.type;

          if (type.indexOf('X') > -1) {
            var _scrollBarCfg$xStyle = scrollBarCfg.xStyle,
                offsetX = _scrollBarCfg$xStyle.offsetX,
                offsetY = _scrollBarCfg$xStyle.offsetY,
                lineCap = _scrollBarCfg$xStyle.lineCap,
                backgroundColor = _scrollBarCfg$xStyle.backgroundColor,
                fillerColor = _scrollBarCfg$xStyle.fillerColor,
                size = _scrollBarCfg$xStyle.size;
            var xScale = chart.getXScale();
            var xLimitRange = limitRange[xScale.field];

            if (!xLimitRange) {
              xLimitRange = getLimitRange(data, xScale);
              limitRange[xScale.field] = xLimitRange;
            }

            var currentRange = getFieldRange(xScale, xLimitRange, xScale.type);
            var horizontalBar = chart.get('_horizontalBar');
            var yPos = canvasHeight - size / 2 + offsetY;

            if (horizontalBar) {
              var progressLine = horizontalBar.get('children')[1];
              progressLine.attr({
                x1: Math.max(plotRange.bl.x + plotRange.width * currentRange[0] + offsetX, plotRange.bl.x),
                x2: Math.min(plotRange.bl.x + plotRange.width * currentRange[1] + offsetX, plotRange.br.x)
              });
            } else {
              horizontalBar = backPlot.addGroup({
                className: 'horizontalBar'
              });
              horizontalBar.addShape('line', {
                attrs: {
                  x1: plotRange.bl.x + offsetX,
                  y1: yPos,
                  x2: plotRange.br.x + offsetX,
                  y2: yPos,
                  lineWidth: size,
                  stroke: backgroundColor,
                  lineCap: lineCap
                }
              });
              horizontalBar.addShape('line', {
                attrs: {
                  x1: Math.max(plotRange.bl.x + plotRange.width * currentRange[0] + offsetX, plotRange.bl.x),
                  y1: yPos,
                  x2: Math.min(plotRange.bl.x + plotRange.width * currentRange[1] + offsetX, plotRange.br.x),
                  y2: yPos,
                  lineWidth: size,
                  stroke: fillerColor,
                  lineCap: lineCap
                }
              });
              chart.set('_horizontalBar', horizontalBar);
            }
          }

          if (type.indexOf('Y') > -1) {
            var _scrollBarCfg$yStyle = scrollBarCfg.yStyle,
                _offsetX = _scrollBarCfg$yStyle.offsetX,
                _offsetY = _scrollBarCfg$yStyle.offsetY,
                _lineCap = _scrollBarCfg$yStyle.lineCap,
                _backgroundColor = _scrollBarCfg$yStyle.backgroundColor,
                _fillerColor = _scrollBarCfg$yStyle.fillerColor,
                _size = _scrollBarCfg$yStyle.size;
            var yScale = chart.getYScales()[0];
            var yLimitRange = limitRange[yScale.field];

            if (!yLimitRange) {
              yLimitRange = getLimitRange(data, yScale);
              limitRange[yScale.field] = yLimitRange;
            }

            var _currentRange = getFieldRange(yScale, yLimitRange, yScale.type);

            var verticalBar = chart.get('_verticalBar');
            var xPos = _size / 2 + _offsetX;

            if (verticalBar) {
              var _progressLine = verticalBar.get('children')[1];

              _progressLine.attr({
                y1: Math.max(plotRange.tl.y + plotRange.height * _currentRange[0] + _offsetY, plotRange.tl.y),
                y2: Math.min(plotRange.tl.y + plotRange.height * _currentRange[1] + _offsetY, plotRange.bl.y)
              });
            } else {
              verticalBar = backPlot.addGroup({
                className: 'verticalBar'
              });
              verticalBar.addShape('line', {
                attrs: {
                  x1: xPos,
                  y1: plotRange.tl.y + _offsetY,
                  x2: xPos,
                  y2: plotRange.bl.y + _offsetY,
                  lineWidth: _size,
                  stroke: _backgroundColor,
                  lineCap: _lineCap
                }
              });
              verticalBar.addShape('line', {
                attrs: {
                  x1: xPos,
                  y1: Math.max(plotRange.tl.y + plotRange.height * _currentRange[0] + _offsetY, plotRange.tl.y),
                  x2: xPos,
                  y2: Math.min(plotRange.tl.y + plotRange.height * _currentRange[1] + _offsetY, plotRange.bl.y),
                  lineWidth: _size,
                  stroke: _fillerColor,
                  lineCap: _lineCap
                }
              });
              chart.set('_verticalBar', verticalBar);
            }
          }
        };

        function ScrollBar(cfg, chart) {
          var _this;

          _this = _Interaction.call(this, cfg, chart) || this;

          var defaultCfg = _this.getDefaultCfg();

          chart.set('_scrollBarCfg', Util.deepMix({}, defaultCfg, cfg));
          chart.set('_limitRange', {});

          if (!chart.get('_horizontalBar') && !chart.get('_verticalBar')) {
            _this._renderScrollBars();
          }

          return _this;
        }

        _proto._clear = function _clear() {
          var chart = this.chart;

          if (chart) {
            var hBar = chart.get('_horizontalBar');
            var vBar = chart.get('_verticalBar');
            hBar && hBar.remove(true);
            vBar && vBar.remove(true);
            chart.set('_horizontalBar', null);
            chart.set('_verticalBar', null);
          }
        };

        _proto._bindEvents = function _bindEvents() {
          this._onAfterclearOrBeforechangedata = this._onAfterclearOrBeforechangedata.bind(this);
          this._onAfterclearinner = this._onAfterclearinner.bind(this);
          this._onAfterdrawgeoms = this._onAfterdrawgeoms.bind(this);
          var chart = this.chart;
          chart.on('afterclear', this._onAfterclearOrBeforechangedata);
          chart.on('beforechangedata', this._onAfterclearOrBeforechangedata);
          chart.on('afterclearinner', this._onAfterclearinner);
          chart.on('afterdrawgeoms', this._onAfterdrawgeoms);
        };

        _proto._onAfterclearOrBeforechangedata = function _onAfterclearOrBeforechangedata() {
          this.chart && this.chart.set('_limitRange', {});
        };

        _proto._onAfterclearinner = function _onAfterclearinner() {
          this._clear();
        };

        _proto._onAfterdrawgeoms = function _onAfterdrawgeoms() {
          this._renderScrollBars();
        };

        _proto._clearEvents = function _clearEvents() {
          var chart = this.chart;

          if (chart) {
            chart.off('afterclear', this._onAfterclearOrBeforechangedata);
            chart.off('beforechangedata', this._onAfterclearOrBeforechangedata);
            chart.off('afterclearinner', this._onAfterclearinner);
            chart.off('afterdrawgeoms', this._onAfterdrawgeoms);
          }
        };

        _proto.destroy = function destroy() {
          this._clearEvents();

          this._clear();

          this.canvas.draw();
        };

        return ScrollBar;
      }(Interaction);

      module.exports = ScrollBar;
      /***/
    },
    /* 501 */

    /***/
    function (module, exports) {
      module.exports = function (scale, limitRange, type) {
        if (!scale) return [0, 1];
        var minRatio = 0;
        var maxRatio = 0;

        if (type === 'linear') {
          var min = limitRange.min,
              max = limitRange.max;
          var range = max - min;
          minRatio = (scale.min - min) / range;
          maxRatio = (scale.max - min) / range;
        } else {
          var originValues = limitRange;
          var values = scale.values;
          var firstIndex = originValues.indexOf(values[0]);
          var lastIndex = originValues.indexOf(values[values.length - 1]);
          minRatio = firstIndex / (originValues.length - 1);
          maxRatio = lastIndex / (originValues.length - 1);
        }

        return [minRatio, maxRatio];
      };
      /***/

    },
    /* 502 */

    /***/
    function (module, exports, __webpack_require__) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(0);

      var Interaction = __webpack_require__(171);

      function getOriginalAttrs(attrs, styles) {
        var origin = {};

        for (var style in styles) {
          origin[style] = attrs[style];
        }

        return origin;
      }

      var Select = /*#__PURE__*/function (_Interaction) {
        _inheritsLoose(Select, _Interaction);

        function Select() {
          return _Interaction.apply(this, arguments) || this;
        }

        var _proto = Select.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var defaultCfg = _Interaction.prototype.getDefaultCfg.call(this);

          return Util.mix({}, defaultCfg, {
            startEvent: 'mouseup',
            processEvent: null,
            selectStyle: {
              fillOpacity: 1
            },
            unSelectStyle: {
              fillOpacity: 0.1
            },
            cancelable: true
          });
        };

        _proto.start = function start(ev) {
          var self = this;
          var chart = self.view;
          var selectedShape;
          var unSelectedShapes = [];
          chart.eachShape(function (obj, shape) {
            if (shape.isPointInPath(ev.x, ev.y)) {
              selectedShape = shape;
            } else {
              unSelectedShapes.push(shape);
            }
          });

          if (!selectedShape) {
            self.reset();
            return;
          }

          if (selectedShape.get('_selected')) {
            // 已经被选中
            if (!self.cancelable) {
              // 不允许取消选中则不处理
              return;
            }

            self.reset(); // 允许取消选中
          } else {
            // 未被选中
            var selectStyle = self.selectStyle,
                unSelectStyle = self.unSelectStyle; // 获取选中效果对应的本来效果,保存下来

            var originAttrs = getOriginalAttrs(selectedShape.attr(), selectedShape);
            selectedShape.set('_originAttrs', originAttrs);
            selectedShape.attr(selectStyle);
            Util.each(unSelectedShapes, function (child) {
              var originAttrs = child.get('_originAttrs'); // 先恢复到默认状态下

              if (originAttrs) {
                child.attr(originAttrs);
              }

              child.set('_selected', false); // 保存未选中效果对应的原始效果

              if (unSelectStyle) {
                originAttrs = getOriginalAttrs(child.attr(), unSelectStyle);
                child.set('_originAttrs', originAttrs);
                child.attr(unSelectStyle);
              }
            });
            selectedShape.set('_selected', true);
            self.selectedShape = selectedShape;
            self.canvas.draw();
          }
        };

        _proto.end = function end(ev) {
          var selectedShape = this.selectedShape;

          if (selectedShape && !selectedShape.get('destroyed') && selectedShape.get('origin')) {
            ev.data = selectedShape.get('origin')._origin; // 绘制数据，包含原始数据啊

            ev.shapeInfo = selectedShape.get('origin');
            ev.shape = selectedShape;
            ev.selected = !!selectedShape.get('_selected'); // 返回选中的状态
          }
        };

        _proto.reset = function reset() {
          var self = this;

          if (!self.selectedShape) {
            return;
          }

          var chart = self.view;
          var geom = chart.get('geoms')[0];
          var container = geom.get('container').get('children')[0];
          var children = container.get('children');
          Util.each(children, function (child) {
            var originAttrs = child.get('_originAttrs');

            if (originAttrs) {
              child._attrs = originAttrs;
              child.set('_originAttrs', null);
            }

            child.set('_selected', false);
          });
          self.canvas.draw();
        };

        return Select;
      }(Interaction);

      module.exports = Select;
      /***/
    },
    /* 503 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Range = __webpack_require__(504);

      var Chart = __webpack_require__(146);

      var Util = __webpack_require__(0);

      var G = __webpack_require__(16);

      var Global = __webpack_require__(7);

      var Interaction = __webpack_require__(171);

      var getColDef = __webpack_require__(384);

      var getColDefs = __webpack_require__(383);

      var Canvas = G.Canvas;
      var DomUtil = Util.DomUtil,
          isNumber = Util.isNumber;

      var Slider = /*#__PURE__*/function (_Interaction) {
        _inheritsLoose(Slider, _Interaction);

        var _proto = Slider.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interaction.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            startEvent: null,
            processEvent: null,
            endEvent: null,
            resetEvent: null,
            height: 26,
            width: 'auto',
            // 默认自适应
            padding: Global.plotCfg.padding,
            container: null,
            xAxis: null,
            yAxis: null,
            // 选中区域的样式
            fillerStyle: {
              fill: '#BDCCED',
              fillOpacity: 0.3
            },
            // 滑动条背景样式
            backgroundStyle: {
              stroke: '#CCD6EC',
              fill: '#CCD6EC',
              fillOpacity: 0.3,
              lineWidth: 1
            },
            range: [0, 100],
            layout: 'horizontal',
            // 文本颜色
            textStyle: {
              fill: '#545454'
            },
            // 滑块的样式
            handleStyle: {
              img: 'https://gw.alipayobjects.com/zos/rmsportal/QXtfhORGlDuRvLXFzpsQ.png',
              width: 5
            },
            // 背景图表的配置，如果为 false 则表示不渲染
            backgroundChart: {
              type: ['area'],
              // 图表的类型，可以是字符串也可是是数组
              color: '#CCD6EC'
            }
          });
        };

        _proto._initContainer = function _initContainer() {
          var me = this;
          var container = me.container;

          if (!container) {
            throw new Error('Please specify the container for the Slider!');
          }

          if (Util.isString(container)) {
            me.domContainer = document.getElementById(container);
          } else {
            me.domContainer = container;
          }
        };

        _proto.forceFit = function forceFit() {
          var me = this;

          if (!me || me.destroyed) {
            return;
          }

          var width = DomUtil.getWidth(me.domContainer);
          var height = me.height;

          if (width !== me.domWidth) {
            var canvas = me.canvas;
            canvas.changeSize(width, height); // 改变画布尺寸

            me.bgChart && me.bgChart.changeWidth(width);
            canvas.clear();

            me._initWidth();

            me._initSlider(); // 初始化滑动条


            me._bindEvent();

            canvas.draw();
          }
        };

        _proto._initForceFitEvent = function _initForceFitEvent() {
          var me = this;
          var timer = setTimeout(Util.wrapBehavior(me, 'forceFit'), 200);
          clearTimeout(me.resizeTimer);
          me.resizeTimer = timer;
        };

        _proto._initStyle = function _initStyle() {
          var me = this;
          me.handleStyle = Util.mix({
            width: me.height,
            height: me.height
          }, me.handleStyle);

          if (me.width === 'auto') {
            // 宽度自适应
            window.addEventListener('resize', Util.wrapBehavior(me, '_initForceFitEvent'));
          }
        };

        _proto._initWidth = function _initWidth() {
          var me = this;
          var width;

          if (me.width === 'auto') {
            width = DomUtil.getWidth(me.domContainer);
          } else {
            width = me.width;
          }

          me.domWidth = width;
          var padding = Util.toAllPadding(me.padding);

          if (me.layout === 'horizontal') {
            me.plotWidth = width - padding[1] - padding[3];
            me.plotPadding = padding[3];
            me.plotHeight = me.height;
          } else if (me.layout === 'vertical') {
            me.plotWidth = me.width;
            me.plotHeight = me.height - padding[0] - padding[2];
            me.plotPadding = padding[0];
          }
        };

        _proto._initCanvas = function _initCanvas() {
          var me = this;
          var width = me.domWidth;
          var height = me.height;
          var canvas = new Canvas({
            width: width,
            height: height,
            containerDOM: me.domContainer,
            capture: false
          });
          var node = canvas.get('el');
          node.style.position = 'absolute';
          node.style.top = 0;
          node.style.left = 0;
          node.style.zIndex = 3;
          me.canvas = canvas;
        };

        _proto._initBackground = function _initBackground() {
          var _Util$deepMix;

          var me = this;
          var chart = this.chart;
          var geom = chart.getAllGeoms[0];
          var data = me.data = me.data || chart.get('data');
          var xScale = chart.getXScale();
          var xAxis = me.xAxis || xScale.field;
          var yAxis = me.yAxis || chart.getYScales()[0].field;
          var scales = Util.deepMix((_Util$deepMix = {}, _Util$deepMix["" + xAxis] = {
            range: [0, 1]
          }, _Util$deepMix), getColDefs(chart), me.scales); // 用户列定义

          delete scales[xAxis].min;
          delete scales[xAxis].max;

          if (!data) {
            // 没有数据，则不创建
            throw new Error('Please specify the data!');
          }

          if (!xAxis) {
            throw new Error('Please specify the xAxis!');
          }

          if (!yAxis) {
            throw new Error('Please specify the yAxis!');
          }

          var backgroundChart = me.backgroundChart;
          var type = backgroundChart.type || geom.get('type');
          var color = backgroundChart.color || 'grey';
          var shape = backgroundChart.shape;

          if (!Util.isArray(type)) {
            type = [type];
          }

          var padding = Util.toAllPadding(me.padding);
          var bgChart = new Chart({
            container: me.container,
            width: me.domWidth,
            height: me.height,
            padding: [0, padding[1], 0, padding[3]],
            animate: false
          });
          bgChart.source(data);
          bgChart.scale(scales);
          bgChart.axis(false);
          bgChart.tooltip(false);
          bgChart.legend(false);
          Util.each(type, function (eachType, index) {
            var bgGeom = bgChart[eachType]().position(xAxis + '*' + yAxis).opacity(1);
            var colorItem = Util.isArray(color) ? color[index] : color;

            if (colorItem) {
              if (Util.isObject(colorItem)) {
                // 通过 { field: 'ss', colors: [ ] } 的方式申明color
                if (colorItem.field) {
                  bgGeom.color(colorItem.field, colorItem.colors);
                }
              } else {
                bgGeom.color(colorItem);
              }
            }

            var shapeItem = Util.isArray(shape) ? shape[index] : shape;

            if (shapeItem) {
              if (Util.isObject(shapeItem)) {
                // 通过 { field: 'ss', shapes: [ ], callback } 的方式申明shape
                if (shapeItem.field) {
                  bgGeom.shape(shapeItem.field, shapeItem.callback || shapeItem.shapes);
                }
              } else {
                bgGeom.shape(shapeItem);
              }
            }
          });
          bgChart.render();
          me.bgChart = bgChart;
          me.scale = me.layout === 'horizontal' ? bgChart.getXScale() : bgChart.getYScales()[0];

          if (me.layout === 'vertical') {
            bgChart.destroy();
          }
        };

        _proto._initRange = function _initRange() {
          var me = this;
          var startRadio = me.startRadio;
          var endRadio = me.endRadio;
          var start = me._startValue;
          var end = me._endValue;
          var scale = me.scale;
          var min = 0;
          var max = 1; // startRadio 优先级高于 start

          if (isNumber(startRadio)) {
            min = startRadio;
          } else if (start) {
            min = scale.scale(scale.translate(start));
          } // endRadio 优先级高于 end


          if (isNumber(endRadio)) {
            max = endRadio;
          } else if (end) {
            max = scale.scale(scale.translate(end));
          }

          var minSpan = me.minSpan,
              maxSpan = me.maxSpan;
          var totalSpan = 0;

          if (scale.type === 'time' || scale.type === 'timeCat') {
            // 时间类型已排序
            var values = scale.values;
            var firstValue = values[0];
            var lastValue = values[values.length - 1];
            totalSpan = lastValue - firstValue;
          } else if (scale.isLinear) {
            totalSpan = scale.max - scale.min;
          }

          if (totalSpan && minSpan) {
            me.minRange = minSpan / totalSpan * 100;
          }

          if (totalSpan && maxSpan) {
            me.maxRange = maxSpan / totalSpan * 100;
          }

          var range = [min * 100, max * 100];
          me.range = range;
          return range;
        };

        _proto._getHandleValue = function _getHandleValue(type) {
          var me = this;
          var value;
          var range = me.range;
          var min = range[0] / 100;
          var max = range[1] / 100;
          var scale = me.scale;

          if (type === 'min') {
            value = me._startValue ? me._startValue : scale.invert(min);
          } else {
            value = me._endValue ? me._endValue : scale.invert(max);
          }

          return value;
        };

        _proto._initSlider = function _initSlider() {
          var me = this;
          var canvas = me.canvas;

          var range = me._initRange();

          var scale = me.scale;
          var rangeElement = canvas.addGroup(Range, {
            middleAttr: me.fillerStyle,
            range: range,
            minRange: me.minRange,
            maxRange: me.maxRange,
            layout: me.layout,
            width: me.plotWidth,
            height: me.plotHeight,
            backgroundStyle: me.backgroundStyle,
            textStyle: me.textStyle,
            handleStyle: me.handleStyle,
            minText: scale.getText(me._getHandleValue('min')),
            maxText: scale.getText(me._getHandleValue('max'))
          });

          if (me.layout === 'horizontal') {
            rangeElement.translate(me.plotPadding, 0);
          } else if (me.layout === 'vertical') {
            rangeElement.translate(0, me.plotPadding);
          }

          me.rangeElement = rangeElement;
        };

        _proto._updateElement = function _updateElement(minRatio, maxRatio) {
          var me = this;
          var chart = me.chart,
              scale = me.scale,
              rangeElement = me.rangeElement;
          var field = scale.field;
          var minTextElement = rangeElement.get('minTextElement');
          var maxTextElement = rangeElement.get('maxTextElement');
          var min = scale.invert(minRatio);
          var max = scale.invert(maxRatio);
          var minText = scale.getText(min);
          var maxText = scale.getText(max);
          minTextElement.attr('text', minText);
          maxTextElement.attr('text', maxText);
          me._startValue = minText;
          me._endValue = maxText;

          if (me.onChange) {
            me.onChange({
              startText: minText,
              endText: maxText,
              startValue: min,
              endValue: max,
              startRadio: minRatio,
              endRadio: maxRatio
            });
          }

          chart.scale(field, Util.mix({}, getColDef(chart, field), {
            nice: false,
            min: min,
            max: max
          }));
          chart.repaint();
        };

        _proto._bindEvent = function _bindEvent() {
          var me = this;
          var rangeElement = me.rangeElement;
          rangeElement.on('sliderchange', function (ev) {
            var range = ev.range;
            var minRatio = range[0] / 100;
            var maxRatio = range[1] / 100;

            me._updateElement(minRatio, maxRatio);
          });
        };

        function Slider(cfg, chart) {
          var _this;

          _this = _Interaction.call(this, cfg, chart) || this;

          var me = _assertThisInitialized(_this);

          me._initContainer();

          me._initStyle();

          me.render();
          return _this;
        }

        _proto.clear = function clear() {
          var me = this;
          me.canvas.clear();
          me.bgChart && me.bgChart.destroy();
          me.bgChart = null;
          me.scale = null;
          me.canvas.draw();
        };

        _proto.repaint = function repaint() {
          var me = this;
          me.clear();
          me.render();
        };

        _proto.render = function render() {
          var me = this;

          me._initWidth();

          me._initCanvas();

          me._initBackground();

          me._initSlider();

          me._bindEvent();

          me.canvas.draw();
        };

        _proto.destroy = function destroy() {
          var me = this;
          clearTimeout(me.resizeTimer);
          var rangeElement = me.rangeElement;
          rangeElement.off('sliderchange');
          me.bgChart && me.bgChart.destroy();
          me.canvas.destroy();
          var container = me.domContainer;

          while (container.hasChildNodes()) {
            container.removeChild(container.firstChild);
          }

          window.removeEventListener('resize', Util.getWrapBehavior(me, '_initForceFitEvent'));
          me.destroyed = true;
        };

        return Slider;
      }(Interaction);

      module.exports = Slider;
      /***/
    },
    /* 504 */

    /***/
    function (module, exports, __webpack_require__) {
      var Util = __webpack_require__(0);

      var G = __webpack_require__(16);

      var Group = G.Group;
      var DomUtil = Util.DomUtil;
      var OFFSET = 5;

      var Range = function Range(cfg) {
        Range.superclass.constructor.call(this, cfg);
      };

      Util.extend(Range, Group);
      Util.augment(Range, {
        getDefaultCfg: function getDefaultCfg() {
          return {
            /**
             * 范围
             * @type {Array}
             */
            range: null,

            /**
             * 中滑块属性
             * @type {ATTRS}
             */
            middleAttr: null,

            /**
             * 背景
             * @type {G-Element}
             */
            backgroundElement: null,

            /**
             * 下滑块
             * @type {G-Element}
             */
            minHandleElement: null,

            /**
             * 上滑块
             * @type {G-Element}
             */
            maxHandleElement: null,

            /**
             * 中块
             * @type {G-Element}
             */
            middleHandleElement: null,

            /**
             * 当前的激活的元素
             * @type {G-Element}
             */
            currentTarget: null,

            /**
             * 布局方式： horizontal，vertical
             * @type {String}
             */
            layout: 'vertical',

            /**
             * 宽
             * @type {Number}
             */
            width: null,

            /**
             * 高
             * @type {Number}
             */
            height: null,

            /**
             * 当前的PageX
             * @type {Number}
             */
            pageX: null,

            /**
             * 当前的PageY
             * @type {Number}
             */
            pageY: null
          };
        },
        _initHandle: function _initHandle(type) {
          var self = this;
          var handle = self.addGroup();
          var layout = self.get('layout');
          var handleStyle = self.get('handleStyle');
          var img = handleStyle.img;
          var iconWidth = handleStyle.width;
          var iconHeight = handleStyle.height;
          var text;
          var handleIcon;
          var triggerCursor;

          if (layout === 'horizontal') {
            var _iconWidth = handleStyle.width;
            triggerCursor = 'ew-resize';
            handleIcon = handle.addShape('Image', {
              attrs: {
                x: -_iconWidth / 2,
                y: 0,
                width: _iconWidth,
                height: iconHeight,
                img: img,
                cursor: triggerCursor
              }
            });
            text = handle.addShape('Text', {
              attrs: Util.mix({
                x: type === 'min' ? -(_iconWidth / 2 + OFFSET) : _iconWidth / 2 + OFFSET,
                y: iconHeight / 2,
                textAlign: type === 'min' ? 'end' : 'start',
                textBaseline: 'middle',
                text: type === 'min' ? this.get('minText') : this.get('maxText'),
                cursor: triggerCursor
              }, this.get('textStyle'))
            });
          } else {
            triggerCursor = 'ns-resize';
            handleIcon = handle.addShape('Image', {
              attrs: {
                x: 0,
                y: -iconHeight / 2,
                width: iconWidth,
                height: iconHeight,
                img: img,
                cursor: triggerCursor
              }
            });
            text = handle.addShape('Text', {
              attrs: Util.mix({
                x: iconWidth / 2,
                y: type === 'min' ? iconHeight / 2 + OFFSET : -(iconHeight / 2 + OFFSET),
                textAlign: 'center',
                textBaseline: 'middle',
                text: type === 'min' ? this.get('minText') : this.get('maxText'),
                cursor: triggerCursor
              }, this.get('textStyle'))
            });
          }

          this.set(type + 'TextElement', text);
          this.set(type + 'IconElement', handleIcon);
          return handle;
        },
        _initSliderBackground: function _initSliderBackground() {
          var backgroundElement = this.addGroup();
          backgroundElement.initTransform();
          backgroundElement.translate(0, 0);
          backgroundElement.addShape('Rect', {
            attrs: Util.mix({
              x: 0,
              y: 0,
              width: this.get('width'),
              height: this.get('height')
            }, this.get('backgroundStyle'))
          });
          return backgroundElement;
        },
        _beforeRenderUI: function _beforeRenderUI() {
          var backgroundElement = this._initSliderBackground();

          var minHandleElement = this._initHandle('min');

          var maxHandleElement = this._initHandle('max');

          var middleHandleElement = this.addShape('rect', {
            attrs: this.get('middleAttr')
          });
          this.set('middleHandleElement', middleHandleElement);
          this.set('minHandleElement', minHandleElement);
          this.set('maxHandleElement', maxHandleElement);
          this.set('backgroundElement', backgroundElement);
          backgroundElement.set('zIndex', 0);
          middleHandleElement.set('zIndex', 1);
          minHandleElement.set('zIndex', 2);
          maxHandleElement.set('zIndex', 2);
          middleHandleElement.attr('cursor', 'move');
          this.sort();
        },
        _renderUI: function _renderUI() {
          if (this.get('layout') === 'horizontal') {
            this._renderHorizontal();
          } else {
            this._renderVertical();
          }
        },
        _transform: function _transform(layout) {
          var range = this.get('range');
          var minRatio = range[0] / 100;
          var maxRatio = range[1] / 100;
          var width = this.get('width');
          var height = this.get('height');
          var minHandleElement = this.get('minHandleElement');
          var maxHandleElement = this.get('maxHandleElement');
          var middleHandleElement = this.get('middleHandleElement');

          if (minHandleElement.resetMatrix) {
            minHandleElement.resetMatrix();
            maxHandleElement.resetMatrix();
          } else {
            minHandleElement.initTransform();
            maxHandleElement.initTransform();
          }

          if (layout === 'horizontal') {
            middleHandleElement.attr({
              x: width * minRatio,
              y: 0,
              width: (maxRatio - minRatio) * width,
              height: height
            });
            minHandleElement.translate(minRatio * width, 0);
            maxHandleElement.translate(maxRatio * width, 0);
          } else {
            middleHandleElement.attr({
              x: 0,
              y: height * (1 - maxRatio),
              width: width,
              height: (maxRatio - minRatio) * height
            });
            minHandleElement.translate(0, (1 - minRatio) * height);
            maxHandleElement.translate(0, (1 - maxRatio) * height);
          }
        },
        _renderHorizontal: function _renderHorizontal() {
          this._transform('horizontal');
        },
        _renderVertical: function _renderVertical() {
          this._transform('vertical');
        },
        _bindUI: function _bindUI() {
          this.on('mousedown', Util.wrapBehavior(this, '_onMouseDown'));
        },
        _isElement: function _isElement(target, name) {
          // 判断是否是该元素
          var element = this.get(name);

          if (target === element) {
            return true;
          }

          if (element.isGroup) {
            var elementChildren = element.get('children');
            return elementChildren.indexOf(target) > -1;
          }

          return false;
        },
        _getRange: function _getRange(diff, range) {
          var rst = diff + range;
          rst = rst > 100 ? 100 : rst;
          rst = rst < 0 ? 0 : rst;
          return rst;
        },
        _limitRange: function _limitRange(diff, limit, range) {
          range[0] = this._getRange(diff, range[0]);
          range[1] = range[0] + limit;

          if (range[1] > 100) {
            range[1] = 100;
            range[0] = range[1] - limit;
          }
        },
        _updateStatus: function _updateStatus(dim, ev) {
          var totalLength = dim === 'x' ? this.get('width') : this.get('height');
          dim = Util.upperFirst(dim);
          var range = this.get('range');
          var page = this.get('page' + dim);
          var currentTarget = this.get('currentTarget');
          var rangeStash = this.get('rangeStash');
          var layout = this.get('layout');
          var sign = layout === 'vertical' ? -1 : 1;
          var currentPage = ev['page' + dim];
          var diffPage = currentPage - page;
          var diffRange = diffPage / totalLength * 100 * sign;
          var diffStashRange;
          var minRange = this.get('minRange');
          var maxRange = this.get('maxRange');

          if (range[1] <= range[0]) {
            if (this._isElement(currentTarget, 'minHandleElement') || this._isElement(currentTarget, 'maxHandleElement')) {
              range[0] = this._getRange(diffRange, range[0]);
              range[1] = this._getRange(diffRange, range[0]);
            }
          } else {
            if (this._isElement(currentTarget, 'minHandleElement')) {
              range[0] = this._getRange(diffRange, range[0]);

              if (minRange) {
                // 设置了最小范围
                if (range[1] - range[0] <= minRange) {
                  this._limitRange(diffRange, minRange, range);
                }
              }

              if (maxRange) {
                // 设置了最大范围
                if (range[1] - range[0] >= maxRange) {
                  this._limitRange(diffRange, maxRange, range);
                }
              }
            }

            if (this._isElement(currentTarget, 'maxHandleElement')) {
              range[1] = this._getRange(diffRange, range[1]);

              if (minRange) {
                // 设置了最小范围
                if (range[1] - range[0] <= minRange) {
                  this._limitRange(diffRange, minRange, range);
                }
              }

              if (maxRange) {
                // 设置了最大范围
                if (range[1] - range[0] >= maxRange) {
                  this._limitRange(diffRange, maxRange, range);
                }
              }
            }
          }

          if (this._isElement(currentTarget, 'middleHandleElement')) {
            diffStashRange = rangeStash[1] - rangeStash[0];

            this._limitRange(diffRange, diffStashRange, range);
          }

          this.emit('sliderchange', {
            range: range
          });
          this.set('page' + dim, currentPage);

          this._renderUI();

          this.get('canvas').draw(); // need delete

          return;
        },
        _onMouseDown: function _onMouseDown(ev) {
          var currentTarget = ev.currentTarget;
          var originEvent = ev.event;
          var range = this.get('range');
          originEvent.stopPropagation();
          originEvent.preventDefault();
          this.set('pageX', originEvent.pageX);
          this.set('pageY', originEvent.pageY);
          this.set('currentTarget', currentTarget);
          this.set('rangeStash', [range[0], range[1]]);

          this._bindCanvasEvents();
        },
        _bindCanvasEvents: function _bindCanvasEvents() {
          var containerDOM = this.get('canvas').get('containerDOM');
          this.onMouseMoveListener = DomUtil.addEventListener(containerDOM, 'mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));
          this.onMouseUpListener = DomUtil.addEventListener(containerDOM, 'mouseup', Util.wrapBehavior(this, '_onCanvasMouseUp')); // @2018-06-06 by blue.lb 添加mouseleave事件监听，让用户在操作出滑块区域后有一个“正常”的效果，可以正常重新触发滑块的操作流程

          this.onMouseLeaveListener = DomUtil.addEventListener(containerDOM, 'mouseleave', Util.wrapBehavior(this, '_onCanvasMouseUp'));
        },
        _onCanvasMouseMove: function _onCanvasMouseMove(ev) {
          var layout = this.get('layout');

          if (layout === 'horizontal') {
            this._updateStatus('x', ev);
          } else {
            this._updateStatus('y', ev);
          }
        },
        _onCanvasMouseUp: function _onCanvasMouseUp() {
          this._removeDocumentEvents();
        },
        _removeDocumentEvents: function _removeDocumentEvents() {
          this.onMouseMoveListener.remove();
          this.onMouseUpListener.remove();
          this.onMouseLeaveListener.remove();
        }
      });
      module.exports = Range;
      /***/
    },
    /* 505 */

    /***/
    function (module, exports, __webpack_require__) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Util = __webpack_require__(0);

      var Interaction = __webpack_require__(171);

      var getColDef = __webpack_require__(384);

      var getLimitRange = __webpack_require__(385);

      var ZOOMING_TYPES = ['X', 'Y', 'XY'];
      var DEFAULT_TYPE = 'X';

      var Zoom = /*#__PURE__*/function (_Interaction) {
        _inheritsLoose(Zoom, _Interaction);

        var _proto = Zoom.prototype;

        _proto.getDefaultCfg = function getDefaultCfg() {
          var cfg = _Interaction.prototype.getDefaultCfg.call(this);

          return Util.mix({}, cfg, {
            processEvent: 'mousewheel',
            type: DEFAULT_TYPE,
            stepRatio: 0.05,
            stepByField: {},
            minScale: 1,
            maxScale: 4,
            catStep: 2,
            limitRange: {},
            originScaleDefsByField: {}
          });
        };

        function Zoom(cfg, chart) {
          var _this;

          _this = _Interaction.call(this, cfg, chart) || this;

          var me = _assertThisInitialized(_this);

          me.chart = chart;
          me.type = me.type.toUpperCase();
          var data = me.data = chart.get('data');
          var scales = chart.getYScales();
          var xScale = chart.getXScale();
          scales.push(xScale);
          var scaleController = chart.get('scaleController');
          scales.forEach(function (scale) {
            var field = scale.field;
            var def = scaleController.defs[field] || {};
            me.limitRange[field] = getLimitRange(data, scale);
            me.originScaleDefsByField[field] = Util.mix(def, {
              nice: !!def.nice
            });

            if (scale.isLinear) {
              me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;
            } else {
              me.stepByField[field] = me.catStep;
            }
          });

          if (!ZOOMING_TYPES.includes(me.type)) {
            me.type = DEFAULT_TYPE;
          }

          return _this;
        } // onZoom() { }
        // onZoomin() { }
        // onZoomout() { }


        _proto._applyScale = function _applyScale(scale, delta, minOffset, center) {
          if (minOffset === void 0) {
            minOffset = 0;
          }

          var me = this;
          var chart = me.chart,
              stepByField = me.stepByField;

          if (scale.isLinear) {
            var min = scale.min,
                max = scale.max,
                field = scale.field;
            var maxOffset = 1 - minOffset;
            var step = stepByField[field] * delta;
            var newMin = min + step * minOffset;
            var newMax = max - step * maxOffset;

            if (newMax > newMin) {
              var colDef = getColDef(chart, field); // @2019-02-28 by blue.lb 这里需要将原始scale的配置整合新算出的最大及最小值

              chart.scale(field, Util.mix({}, colDef, {
                nice: false,
                min: newMin,
                max: newMax
              }));
            }
          } else {
            var _field = scale.field,
                values = scale.values;
            var _chart = me.chart;

            var coord = _chart.get('coord');

            var _colDef = getColDef(_chart, _field);

            var originValues = me.limitRange[_field];
            var originValuesLen = originValues.length;
            var maxScale = me.maxScale;
            var minScale = me.minScale;
            var minCount = originValuesLen / maxScale;
            var maxCount = originValuesLen / minScale;
            var valuesLength = values.length;
            var offsetPoint = coord.invertPoint(center);
            var percent = offsetPoint.x;
            var deltaCount = valuesLength - delta * this.catStep;
            var minDelta = parseInt(deltaCount * percent);
            var maxDelta = deltaCount + minDelta;

            if (delta > 0 && valuesLength >= minCount) {
              // zoom out
              var _min = minDelta;
              var _max = maxDelta;

              if (maxDelta > valuesLength) {
                _max = valuesLength - 1;
                _min = valuesLength - deltaCount;
              }

              var newValues = values.slice(_min, _max);

              _chart.scale(_field, Util.mix({}, _colDef, {
                values: newValues
              }));
            } else if (delta < 0 && valuesLength <= maxCount) {
              // zoom in
              var firstIndex = originValues.indexOf(values[0]);
              var lastIndex = originValues.indexOf(values[valuesLength - 1]);
              var minIndex = Math.max(0, firstIndex - minDelta);
              var maxIndex = Math.min(lastIndex + maxDelta, originValuesLen);

              var _newValues = originValues.slice(minIndex, maxIndex);

              _chart.scale(_field, Util.mix({}, _colDef, {
                values: _newValues
              }));
            }
          }
        };

        _proto.process = function process(ev) {
          var me = this;
          var chart = me.chart,
              type = me.type;
          var coord = chart.get('coord');
          var deltaY = ev.deltaY;
          var offsetPoint = coord.invertPoint(ev);

          if (deltaY) {
            me.onZoom && me.onZoom(deltaY, offsetPoint, me);

            if (deltaY > 0) {
              me.onZoomin && me.onZoomin(deltaY, offsetPoint, me);
            } else {
              me.onZoomout && me.onZoomout(deltaY, offsetPoint, me);
            }

            var delta = deltaY / Math.abs(deltaY);

            if (type.indexOf('X') > -1) {
              me._applyScale(chart.getXScale(), delta, offsetPoint.x, ev);
            }

            if (type.indexOf('Y') > -1) {
              var yScales = chart.getYScales();
              yScales.forEach(function (yScale) {
                me._applyScale(yScale, delta, offsetPoint.y, ev);
              });
            }
          }

          chart.repaint();
        };

        _proto.reset = function reset() {
          var me = this;
          var view = me.view,
              originScaleDefsByField = me.originScaleDefsByField;
          var scales = view.getYScales();
          var xScale = view.getXScale();
          scales.push(xScale);
          scales.forEach(function (scale) {
            if (scale.isLinear) {
              var field = scale.field;
              view.scale(field, originScaleDefsByField[field]);
            }
          });
          view.repaint();
        };

        return Zoom;
      }(Interaction); // G2.registerInteraction('zoom', Zoom);
      // G2.registerInteraction('Zoom', Zoom);


      module.exports = Zoom;
      /***/
    }
    /******/
    ])
  );
});

/***/ }),

/***/ "gou2":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("zWQs");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "gtO+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__("b8Rm");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "gtwY":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "h3fB":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CheckOutlined = {
  "name": "check",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"
      }
    }]
  }
};
exports["default"] = CheckOutlined;

/***/ }),

/***/ "hGr/":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");
var defined = __webpack_require__("GCOZ");
var fails = __webpack_require__("E7Vc");
var spaces = __webpack_require__("SvMv");
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),

/***/ "hMok":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("b01t")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "hRGL":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__("VNvs");

__webpack_require__("asZ9");

__webpack_require__("7t+O");

__webpack_require__("7lGJ");

__webpack_require__("+3V6");

__webpack_require__("V7cS");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("9p7t");

__webpack_require__("yIlq");

__webpack_require__("3y5y");

__webpack_require__("Z8gF");

__webpack_require__("5hJT");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

exports.__esModule = true;
exports.warn = exports.requestAnimationFrame = exports.reducePropsToState = exports.mapStateOnServer = exports.handleClientStateChange = exports.convertReactPropstoHtmlAttributes = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _objectAssign = __webpack_require__("IL7q");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _HelmetConstants = __webpack_require__("doOt");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var encodeSpecialCharacters = function encodeSpecialCharacters(str) {
  var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (encode === false) {
    return String(str);
  }

  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};

var getTitleFromPropsList = function getTitleFromPropsList(propsList) {
  var innermostTitle = getInnermostProperty(propsList, _HelmetConstants.TAG_NAMES.TITLE);
  var innermostTemplate = getInnermostProperty(propsList, _HelmetConstants.HELMET_PROPS.TITLE_TEMPLATE);

  if (innermostTemplate && innermostTitle) {
    // use function arg to avoid need to escape $ characters
    return innermostTemplate.replace(/%s/g, function () {
      return innermostTitle;
    });
  }

  var innermostDefaultTitle = getInnermostProperty(propsList, _HelmetConstants.HELMET_PROPS.DEFAULT_TITLE);
  return innermostTitle || innermostDefaultTitle || undefined;
};

var getOnChangeClientState = function getOnChangeClientState(propsList) {
  return getInnermostProperty(propsList, _HelmetConstants.HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || function () {};
};

var getAttributesFromPropsList = function getAttributesFromPropsList(tagType, propsList) {
  return propsList.filter(function (props) {
    return typeof props[tagType] !== "undefined";
  }).map(function (props) {
    return props[tagType];
  }).reduce(function (tagAttrs, current) {
    return _extends({}, tagAttrs, current);
  }, {});
};

var getBaseTagFromPropsList = function getBaseTagFromPropsList(primaryAttributes, propsList) {
  return propsList.filter(function (props) {
    return typeof props[_HelmetConstants.TAG_NAMES.BASE] !== "undefined";
  }).map(function (props) {
    return props[_HelmetConstants.TAG_NAMES.BASE];
  }).reverse().reduce(function (innermostBaseTag, tag) {
    if (!innermostBaseTag.length) {
      var keys = Object.keys(tag);

      for (var i = 0; i < keys.length; i++) {
        var attributeKey = keys[i];
        var lowerCaseAttributeKey = attributeKey.toLowerCase();

        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
          return innermostBaseTag.concat(tag);
        }
      }
    }

    return innermostBaseTag;
  }, []);
};

var getTagsFromPropsList = function getTagsFromPropsList(tagName, primaryAttributes, propsList) {
  // Calculate list of tags, giving priority innermost component (end of the propslist)
  var approvedSeenTags = {};
  return propsList.filter(function (props) {
    if (Array.isArray(props[tagName])) {
      return true;
    }

    if (typeof props[tagName] !== "undefined") {
      warn("Helmet: " + tagName + " should be of type \"Array\". Instead found type \"" + _typeof(props[tagName]) + "\"");
    }

    return false;
  }).map(function (props) {
    return props[tagName];
  }).reverse().reduce(function (approvedTags, instanceTags) {
    var instanceSeenTags = {};
    instanceTags.filter(function (tag) {
      var primaryAttributeKey = void 0;
      var keys = Object.keys(tag);

      for (var i = 0; i < keys.length; i++) {
        var attributeKey = keys[i];
        var lowerCaseAttributeKey = attributeKey.toLowerCase(); // Special rule with link tags, since rel and href are both primary tags, rel takes priority

        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === _HelmetConstants.TAG_PROPERTIES.REL && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === _HelmetConstants.TAG_PROPERTIES.REL && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
          primaryAttributeKey = lowerCaseAttributeKey;
        } // Special case for innerHTML which doesn't work lowercased


        if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === _HelmetConstants.TAG_PROPERTIES.INNER_HTML || attributeKey === _HelmetConstants.TAG_PROPERTIES.CSS_TEXT || attributeKey === _HelmetConstants.TAG_PROPERTIES.ITEM_PROP)) {
          primaryAttributeKey = attributeKey;
        }
      }

      if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
        return false;
      }

      var value = tag[primaryAttributeKey].toLowerCase();

      if (!approvedSeenTags[primaryAttributeKey]) {
        approvedSeenTags[primaryAttributeKey] = {};
      }

      if (!instanceSeenTags[primaryAttributeKey]) {
        instanceSeenTags[primaryAttributeKey] = {};
      }

      if (!approvedSeenTags[primaryAttributeKey][value]) {
        instanceSeenTags[primaryAttributeKey][value] = true;
        return true;
      }

      return false;
    }).reverse().forEach(function (tag) {
      return approvedTags.push(tag);
    }); // Update seen tags with tags from this instance

    var keys = Object.keys(instanceSeenTags);

    for (var i = 0; i < keys.length; i++) {
      var attributeKey = keys[i];
      var tagUnion = (0, _objectAssign2["default"])({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);
      approvedSeenTags[attributeKey] = tagUnion;
    }

    return approvedTags;
  }, []).reverse();
};

var getInnermostProperty = function getInnermostProperty(propsList, property) {
  for (var i = propsList.length - 1; i >= 0; i--) {
    var props = propsList[i];

    if (props.hasOwnProperty(property)) {
      return props[property];
    }
  }

  return null;
};

var reducePropsToState = function reducePropsToState(propsList) {
  return {
    baseTag: getBaseTagFromPropsList([_HelmetConstants.TAG_PROPERTIES.HREF], propsList),
    bodyAttributes: getAttributesFromPropsList(_HelmetConstants.ATTRIBUTE_NAMES.BODY, propsList),
    defer: getInnermostProperty(propsList, _HelmetConstants.HELMET_PROPS.DEFER),
    encode: getInnermostProperty(propsList, _HelmetConstants.HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: getAttributesFromPropsList(_HelmetConstants.ATTRIBUTE_NAMES.HTML, propsList),
    linkTags: getTagsFromPropsList(_HelmetConstants.TAG_NAMES.LINK, [_HelmetConstants.TAG_PROPERTIES.REL, _HelmetConstants.TAG_PROPERTIES.HREF], propsList),
    metaTags: getTagsFromPropsList(_HelmetConstants.TAG_NAMES.META, [_HelmetConstants.TAG_PROPERTIES.NAME, _HelmetConstants.TAG_PROPERTIES.CHARSET, _HelmetConstants.TAG_PROPERTIES.HTTPEQUIV, _HelmetConstants.TAG_PROPERTIES.PROPERTY, _HelmetConstants.TAG_PROPERTIES.ITEM_PROP], propsList),
    noscriptTags: getTagsFromPropsList(_HelmetConstants.TAG_NAMES.NOSCRIPT, [_HelmetConstants.TAG_PROPERTIES.INNER_HTML], propsList),
    onChangeClientState: getOnChangeClientState(propsList),
    scriptTags: getTagsFromPropsList(_HelmetConstants.TAG_NAMES.SCRIPT, [_HelmetConstants.TAG_PROPERTIES.SRC, _HelmetConstants.TAG_PROPERTIES.INNER_HTML], propsList),
    styleTags: getTagsFromPropsList(_HelmetConstants.TAG_NAMES.STYLE, [_HelmetConstants.TAG_PROPERTIES.CSS_TEXT], propsList),
    title: getTitleFromPropsList(propsList),
    titleAttributes: getAttributesFromPropsList(_HelmetConstants.ATTRIBUTE_NAMES.TITLE, propsList)
  };
};

var rafPolyfill = function () {
  var clock = Date.now();
  return function (callback) {
    var currentTime = Date.now();

    if (currentTime - clock > 16) {
      clock = currentTime;
      callback(currentTime);
    } else {
      setTimeout(function () {
        rafPolyfill(callback);
      }, 0);
    }
  };
}();

var cafPolyfill = function cafPolyfill(id) {
  return clearTimeout(id);
};

var requestAnimationFrame = typeof window !== "undefined" ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || rafPolyfill : global.requestAnimationFrame || rafPolyfill;
var cancelAnimationFrame = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || cafPolyfill : global.cancelAnimationFrame || cafPolyfill;

var warn = function warn(msg) {
  return console && typeof console.warn === "function" && console.warn(msg);
};

var _helmetCallback = null;

var handleClientStateChange = function handleClientStateChange(newState) {
  if (_helmetCallback) {
    cancelAnimationFrame(_helmetCallback);
  }

  if (newState.defer) {
    _helmetCallback = requestAnimationFrame(function () {
      commitTagChanges(newState, function () {
        _helmetCallback = null;
      });
    });
  } else {
    commitTagChanges(newState);
    _helmetCallback = null;
  }
};

var commitTagChanges = function commitTagChanges(newState, cb) {
  var baseTag = newState.baseTag,
      bodyAttributes = newState.bodyAttributes,
      htmlAttributes = newState.htmlAttributes,
      linkTags = newState.linkTags,
      metaTags = newState.metaTags,
      noscriptTags = newState.noscriptTags,
      onChangeClientState = newState.onChangeClientState,
      scriptTags = newState.scriptTags,
      styleTags = newState.styleTags,
      title = newState.title,
      titleAttributes = newState.titleAttributes;
  updateAttributes(_HelmetConstants.TAG_NAMES.BODY, bodyAttributes);
  updateAttributes(_HelmetConstants.TAG_NAMES.HTML, htmlAttributes);
  updateTitle(title, titleAttributes);
  var tagUpdates = {
    baseTag: updateTags(_HelmetConstants.TAG_NAMES.BASE, baseTag),
    linkTags: updateTags(_HelmetConstants.TAG_NAMES.LINK, linkTags),
    metaTags: updateTags(_HelmetConstants.TAG_NAMES.META, metaTags),
    noscriptTags: updateTags(_HelmetConstants.TAG_NAMES.NOSCRIPT, noscriptTags),
    scriptTags: updateTags(_HelmetConstants.TAG_NAMES.SCRIPT, scriptTags),
    styleTags: updateTags(_HelmetConstants.TAG_NAMES.STYLE, styleTags)
  };
  var addedTags = {};
  var removedTags = {};
  Object.keys(tagUpdates).forEach(function (tagType) {
    var _tagUpdates$tagType = tagUpdates[tagType],
        newTags = _tagUpdates$tagType.newTags,
        oldTags = _tagUpdates$tagType.oldTags;

    if (newTags.length) {
      addedTags[tagType] = newTags;
    }

    if (oldTags.length) {
      removedTags[tagType] = tagUpdates[tagType].oldTags;
    }
  });
  cb && cb();
  onChangeClientState(newState, addedTags, removedTags);
};

var flattenArray = function flattenArray(possibleArray) {
  return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
};

var updateTitle = function updateTitle(title, attributes) {
  if (typeof title !== "undefined" && document.title !== title) {
    document.title = flattenArray(title);
  }

  updateAttributes(_HelmetConstants.TAG_NAMES.TITLE, attributes);
};

var updateAttributes = function updateAttributes(tagName, attributes) {
  var elementTag = document.getElementsByTagName(tagName)[0];

  if (!elementTag) {
    return;
  }

  var helmetAttributeString = elementTag.getAttribute(_HelmetConstants.HELMET_ATTRIBUTE);
  var helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
  var attributesToRemove = [].concat(helmetAttributes);
  var attributeKeys = Object.keys(attributes);

  for (var i = 0; i < attributeKeys.length; i++) {
    var attribute = attributeKeys[i];
    var value = attributes[attribute] || "";

    if (elementTag.getAttribute(attribute) !== value) {
      elementTag.setAttribute(attribute, value);
    }

    if (helmetAttributes.indexOf(attribute) === -1) {
      helmetAttributes.push(attribute);
    }

    var indexToSave = attributesToRemove.indexOf(attribute);

    if (indexToSave !== -1) {
      attributesToRemove.splice(indexToSave, 1);
    }
  }

  for (var _i = attributesToRemove.length - 1; _i >= 0; _i--) {
    elementTag.removeAttribute(attributesToRemove[_i]);
  }

  if (helmetAttributes.length === attributesToRemove.length) {
    elementTag.removeAttribute(_HelmetConstants.HELMET_ATTRIBUTE);
  } else if (elementTag.getAttribute(_HelmetConstants.HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
    elementTag.setAttribute(_HelmetConstants.HELMET_ATTRIBUTE, attributeKeys.join(","));
  }
};

var updateTags = function updateTags(type, tags) {
  var headElement = document.head || document.querySelector(_HelmetConstants.TAG_NAMES.HEAD);
  var tagNodes = headElement.querySelectorAll(type + "[" + _HelmetConstants.HELMET_ATTRIBUTE + "]");
  var oldTags = Array.prototype.slice.call(tagNodes);
  var newTags = [];
  var indexToDelete = void 0;

  if (tags && tags.length) {
    tags.forEach(function (tag) {
      var newElement = document.createElement(type);

      for (var attribute in tag) {
        if (tag.hasOwnProperty(attribute)) {
          if (attribute === _HelmetConstants.TAG_PROPERTIES.INNER_HTML) {
            newElement.innerHTML = tag.innerHTML;
          } else if (attribute === _HelmetConstants.TAG_PROPERTIES.CSS_TEXT) {
            if (newElement.styleSheet) {
              newElement.styleSheet.cssText = tag.cssText;
            } else {
              newElement.appendChild(document.createTextNode(tag.cssText));
            }
          } else {
            var value = typeof tag[attribute] === "undefined" ? "" : tag[attribute];
            newElement.setAttribute(attribute, value);
          }
        }
      }

      newElement.setAttribute(_HelmetConstants.HELMET_ATTRIBUTE, "true"); // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.

      if (oldTags.some(function (existingTag, index) {
        indexToDelete = index;
        return newElement.isEqualNode(existingTag);
      })) {
        oldTags.splice(indexToDelete, 1);
      } else {
        newTags.push(newElement);
      }
    });
  }

  oldTags.forEach(function (tag) {
    return tag.parentNode.removeChild(tag);
  });
  newTags.forEach(function (tag) {
    return headElement.appendChild(tag);
  });
  return {
    oldTags: oldTags,
    newTags: newTags
  };
};

var generateElementAttributesAsString = function generateElementAttributesAsString(attributes) {
  return Object.keys(attributes).reduce(function (str, key) {
    var attr = typeof attributes[key] !== "undefined" ? key + "=\"" + attributes[key] + "\"" : "" + key;
    return str ? str + " " + attr : attr;
  }, "");
};

var generateTitleAsString = function generateTitleAsString(type, title, attributes, encode) {
  var attributeString = generateElementAttributesAsString(attributes);
  var flattenedTitle = flattenArray(title);
  return attributeString ? "<" + type + " " + _HelmetConstants.HELMET_ATTRIBUTE + "=\"true\" " + attributeString + ">" + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">" : "<" + type + " " + _HelmetConstants.HELMET_ATTRIBUTE + "=\"true\">" + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">";
};

var generateTagsAsString = function generateTagsAsString(type, tags, encode) {
  return tags.reduce(function (str, tag) {
    var attributeHtml = Object.keys(tag).filter(function (attribute) {
      return !(attribute === _HelmetConstants.TAG_PROPERTIES.INNER_HTML || attribute === _HelmetConstants.TAG_PROPERTIES.CSS_TEXT);
    }).reduce(function (string, attribute) {
      var attr = typeof tag[attribute] === "undefined" ? attribute : attribute + "=\"" + encodeSpecialCharacters(tag[attribute], encode) + "\"";
      return string ? string + " " + attr : attr;
    }, "");
    var tagContent = tag.innerHTML || tag.cssText || "";
    var isSelfClosing = _HelmetConstants.SELF_CLOSING_TAGS.indexOf(type) === -1;
    return str + "<" + type + " " + _HelmetConstants.HELMET_ATTRIBUTE + "=\"true\" " + attributeHtml + (isSelfClosing ? "/>" : ">" + tagContent + "</" + type + ">");
  }, "");
};

var convertElementAttributestoReactProps = function convertElementAttributestoReactProps(attributes) {
  var initProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object.keys(attributes).reduce(function (obj, key) {
    obj[_HelmetConstants.REACT_TAG_MAP[key] || key] = attributes[key];
    return obj;
  }, initProps);
};

var convertReactPropstoHtmlAttributes = function convertReactPropstoHtmlAttributes(props) {
  var initAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object.keys(props).reduce(function (obj, key) {
    obj[_HelmetConstants.HTML_TAG_MAP[key] || key] = props[key];
    return obj;
  }, initAttributes);
};

var generateTitleAsReactComponent = function generateTitleAsReactComponent(type, title, attributes) {
  var _initProps; // assigning into an array to define toString function on it


  var initProps = (_initProps = {
    key: title
  }, _initProps[_HelmetConstants.HELMET_ATTRIBUTE] = true, _initProps);
  var props = convertElementAttributestoReactProps(attributes, initProps);
  return [_react2["default"].createElement(_HelmetConstants.TAG_NAMES.TITLE, props, title)];
};

var generateTagsAsReactComponent = function generateTagsAsReactComponent(type, tags) {
  return tags.map(function (tag, i) {
    var _mappedTag;

    var mappedTag = (_mappedTag = {
      key: i
    }, _mappedTag[_HelmetConstants.HELMET_ATTRIBUTE] = true, _mappedTag);
    Object.keys(tag).forEach(function (attribute) {
      var mappedAttribute = _HelmetConstants.REACT_TAG_MAP[attribute] || attribute;

      if (mappedAttribute === _HelmetConstants.TAG_PROPERTIES.INNER_HTML || mappedAttribute === _HelmetConstants.TAG_PROPERTIES.CSS_TEXT) {
        var content = tag.innerHTML || tag.cssText;
        mappedTag.dangerouslySetInnerHTML = {
          __html: content
        };
      } else {
        mappedTag[mappedAttribute] = tag[attribute];
      }
    });
    return _react2["default"].createElement(type, mappedTag);
  });
};

var getMethodsForTag = function getMethodsForTag(type, tags, encode) {
  switch (type) {
    case _HelmetConstants.TAG_NAMES.TITLE:
      return {
        toComponent: function toComponent() {
          return generateTitleAsReactComponent(type, tags.title, tags.titleAttributes, encode);
        },
        toString: function toString() {
          return generateTitleAsString(type, tags.title, tags.titleAttributes, encode);
        }
      };

    case _HelmetConstants.ATTRIBUTE_NAMES.BODY:
    case _HelmetConstants.ATTRIBUTE_NAMES.HTML:
      return {
        toComponent: function toComponent() {
          return convertElementAttributestoReactProps(tags);
        },
        toString: function toString() {
          return generateElementAttributesAsString(tags);
        }
      };

    default:
      return {
        toComponent: function toComponent() {
          return generateTagsAsReactComponent(type, tags);
        },
        toString: function toString() {
          return generateTagsAsString(type, tags, encode);
        }
      };
  }
};

var mapStateOnServer = function mapStateOnServer(_ref) {
  var baseTag = _ref.baseTag,
      bodyAttributes = _ref.bodyAttributes,
      encode = _ref.encode,
      htmlAttributes = _ref.htmlAttributes,
      linkTags = _ref.linkTags,
      metaTags = _ref.metaTags,
      noscriptTags = _ref.noscriptTags,
      scriptTags = _ref.scriptTags,
      styleTags = _ref.styleTags,
      _ref$title = _ref.title,
      title = _ref$title === undefined ? "" : _ref$title,
      titleAttributes = _ref.titleAttributes;
  return {
    base: getMethodsForTag(_HelmetConstants.TAG_NAMES.BASE, baseTag, encode),
    bodyAttributes: getMethodsForTag(_HelmetConstants.ATTRIBUTE_NAMES.BODY, bodyAttributes, encode),
    htmlAttributes: getMethodsForTag(_HelmetConstants.ATTRIBUTE_NAMES.HTML, htmlAttributes, encode),
    link: getMethodsForTag(_HelmetConstants.TAG_NAMES.LINK, linkTags, encode),
    meta: getMethodsForTag(_HelmetConstants.TAG_NAMES.META, metaTags, encode),
    noscript: getMethodsForTag(_HelmetConstants.TAG_NAMES.NOSCRIPT, noscriptTags, encode),
    script: getMethodsForTag(_HelmetConstants.TAG_NAMES.SCRIPT, scriptTags, encode),
    style: getMethodsForTag(_HelmetConstants.TAG_NAMES.STYLE, styleTags, encode),
    title: getMethodsForTag(_HelmetConstants.TAG_NAMES.TITLE, {
      title: title,
      titleAttributes: titleAttributes
    }, encode)
  };
};

exports.convertReactPropstoHtmlAttributes = convertReactPropstoHtmlAttributes;
exports.handleClientStateChange = handleClientStateChange;
exports.mapStateOnServer = mapStateOnServer;
exports.reducePropsToState = reducePropsToState;
exports.requestAnimationFrame = requestAnimationFrame;
exports.warn = warn;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("pCvA")))

/***/ }),

/***/ "hV/m":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var equals = __webpack_require__("LGMZ");

var takeLast = __webpack_require__("wp6D");
/**
 * Checks if a list ends with the provided values
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> Boolean
 * @sig String -> Boolean
 * @param {*} suffix
 * @param {*} list
 * @return {Boolean}
 * @example
 *
 *      R.endsWith('c', 'abc')                //=> true
 *      R.endsWith('b', 'abc')                //=> false
 *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
 *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
 */


module.exports = _curry2(function (suffix, list) {
  return equals(takeLast(suffix.length, list), suffix);
});

/***/ }),

/***/ "hYpR":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("ct/D")('meta');
var isObject = __webpack_require__("fGh/");
var has = __webpack_require__("qA3Z");
var setDesc = __webpack_require__("eOWL").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("/Vl9")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "hisu":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "hxuA":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SizeContextProvider; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var SizeContext = react__WEBPACK_IMPORTED_MODULE_0__["createContext"](undefined);
var SizeContextProvider = function SizeContextProvider(_ref) {
  var children = _ref.children,
      size = _ref.size;
  return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](SizeContext.Consumer, null, function (originSize) {
    return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](SizeContext.Provider, {
      value: size || originSize
    }, children);
  });
};
/* harmony default export */ __webpack_exports__["b"] = (SizeContext);

/***/ }),

/***/ "iBmR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // TODO: Use the `URL` global when targeting Node.js 10

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("U8p0");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

var _toConsumableArray = __webpack_require__("5WRv");

__webpack_require__("asZ9");

__webpack_require__("+3V6");

__webpack_require__("Z8gF");

__webpack_require__("FEHE");

__webpack_require__("m8zh");

__webpack_require__("/dwC");

__webpack_require__("5hJT");

__webpack_require__("J8hF");

__webpack_require__("VNvs");

var URLParser = typeof URL === 'undefined' ? __webpack_require__("so/P").URL : URL;

var testParameter = function testParameter(name, filters) {
  return filters.some(function (filter) {
    return filter instanceof RegExp ? filter.test(name) : filter === name;
  });
};

module.exports = function (urlString, opts) {
  opts = Object.assign({
    defaultProtocol: 'http:',
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripHash: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeDirectoryIndex: false,
    sortQueryParameters: true
  }, opts); // Backwards compatibility

  if (Reflect.has(opts, 'normalizeHttps')) {
    opts.forceHttp = opts.normalizeHttps;
  }

  if (Reflect.has(opts, 'normalizeHttp')) {
    opts.forceHttps = opts.normalizeHttp;
  }

  if (Reflect.has(opts, 'stripFragment')) {
    opts.stripHash = opts.stripFragment;
  }

  urlString = urlString.trim();
  var hasRelativeProtocol = urlString.startsWith('//');
  var isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString); // Prepend protocol

  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, opts.defaultProtocol);
  }

  var urlObj = new URLParser(urlString);

  if (opts.forceHttp && opts.forceHttps) {
    throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
  }

  if (opts.forceHttp && urlObj.protocol === 'https:') {
    urlObj.protocol = 'http:';
  }

  if (opts.forceHttps && urlObj.protocol === 'http:') {
    urlObj.protocol = 'https:';
  } // Remove hash


  if (opts.stripHash) {
    urlObj.hash = '';
  } // Remove duplicate slashes if not preceded by a protocol


  if (urlObj.pathname) {
    // TODO: Use the following instead when targeting Node.js 10
    // `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
    urlObj.pathname = urlObj.pathname.replace(/((?![https?:]).)\/{2,}/g, function (_, p1) {
      if (/^(?!\/)/g.test(p1)) {
        return "".concat(p1, "/");
      }

      return '/';
    });
  } // Decode URI octets


  if (urlObj.pathname) {
    urlObj.pathname = decodeURI(urlObj.pathname);
  } // Remove directory index


  if (opts.removeDirectoryIndex === true) {
    opts.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }

  if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length > 0) {
    var pathComponents = urlObj.pathname.split('/');
    var lastComponent = pathComponents[pathComponents.length - 1];

    if (testParameter(lastComponent, opts.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, pathComponents.length - 1);
      urlObj.pathname = pathComponents.slice(1).join('/') + '/';
    }
  }

  if (urlObj.hostname) {
    // Remove trailing dot
    urlObj.hostname = urlObj.hostname.replace(/\.$/, ''); // Remove `www.`
    // eslint-disable-next-line no-useless-escape

    if (opts.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z\.]{2,5})$/.test(urlObj.hostname)) {
      // Each label should be max 63 at length (min: 2).
      // The extension should be max 5 at length (min: 2).
      // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
      urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
    }
  } // Remove query unwanted parameters


  if (Array.isArray(opts.removeQueryParameters)) {
    for (var _i = 0, _arr = _toConsumableArray(urlObj.searchParams.keys()); _i < _arr.length; _i++) {
      var key = _arr[_i];

      if (testParameter(key, opts.removeQueryParameters)) {
        urlObj.searchParams["delete"](key);
      }
    }
  } // Sort query parameters


  if (opts.sortQueryParameters) {
    urlObj.searchParams.sort();
  } // Take advantage of many of the Node `url` normalizations


  urlString = urlObj.toString(); // Remove ending `/`

  if (opts.removeTrailingSlash || urlObj.pathname === '/') {
    urlString = urlString.replace(/\/$/, '');
  } // Restore relative protocol, if applicable


  if (hasRelativeProtocol && !opts.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, '//');
  }

  return urlString;
};

/***/ }),

/***/ "iJnn":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("PAFS");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "iKhv":
/***/ (function(module, exports) {



/***/ }),

/***/ "iNmH":
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__("+Sw5");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "iPMX":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("lQyR");

__webpack_require__("YhIr");

__webpack_require__("+3V6");

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
} //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * stability: stable
 * authors:
 *   - Quildreen Motta
 *
 * type: |
 *   (Number, (Any...) => 'a) => Any... => 'a or ((Any...) => 'a)
 */


var curry = function curry(arity, fn) {
  var curried = function curried(oldArgs) {
    return function () {
      for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
        newArgs[_key] = arguments[_key];
      }

      var allArgs = oldArgs.concat(newArgs);
      var argCount = allArgs.length;
      return argCount < arity ? curried(allArgs) :
      /* otherwise */
      fn.apply(undefined, _toConsumableArray(allArgs));
    };
  };

  return curried([]);
}; // --[ Exports ]-------------------------------------------------------


module.exports = curry;

/***/ }),

/***/ "iXzu":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var core_js_modules_es6_weak_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("orKN");
/* harmony import */ var core_js_modules_es6_weak_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_weak_map__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("yIlq");
/* harmony import */ var core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_map__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("PAbq");
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("3y5y");
/* harmony import */ var core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_reduce__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("75LO");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("9p7t");
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("V7cS");
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es6_date_now__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("7t+O");
/* harmony import */ var core_js_modules_es6_date_now__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_date_now__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("o7PZ");
/* harmony import */ var core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("7lGJ");
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("d3/y");
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es6_array_some__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("VNvs");
/* harmony import */ var core_js_modules_es6_array_some__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_some__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("W1QL");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("K/PF");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("lQyR");
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var core_js_modules_es6_map__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("zx98");
/* harmony import */ var core_js_modules_es6_map__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_map__WEBPACK_IMPORTED_MODULE_16__);


















/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */

/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */


  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }

      return false;
    });
    return result;
  }

  return (
    /** @class */
    function () {
      function class_1() {
        this.__entries__ = [];
      }

      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function get() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      /**
       * @param {*} key
       * @returns {*}
       */

      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */


      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);

        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype["delete"] = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);

        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */


      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */


      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }

        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };

      return class_1;
    }()
  );
}();
/**
 * Detects whether window and document objects are available in current environment.
 */


var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

var global$1 = function () {
  if (typeof global !== 'undefined' && global.Math === Math) {
    return global;
  }

  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }

  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  } // eslint-disable-next-line no-new-func


  return Function('return this')();
}();
/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */


var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }

  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}(); // Defines minimum timeout before adding a trailing call.


var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */

function throttle(callback, delay) {
  var leadingCall = false,
      trailingCall = false,
      lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */

  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }

    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */


  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */


  function proxy() {
    var timeStamp = Date.now();

    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      } // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.


      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }

    lastCallTime = timeStamp;
  }

  return proxy;
} // Minimum delay before invoking the update of observers.


var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.

var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */

var ResizeObserverController =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */

    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */

    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */

    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */


  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    } // Add listeners if they haven't been added yet.


    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */


  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer); // Remove observer if it's present in registry.

    if (~index) {
      observers.splice(index, 1);
    } // Remove listeners if controller has no connected observers.


    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */


  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.

    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */


  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    }); // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.

    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    } // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.


    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */


  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
        propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */


  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */


  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();
/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */


var defineConfigurable = function defineConfigurable(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }

  return target;
};
/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */


var getWindowOf = function getWindowOf(target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
  // provided element.

  return ownerGlobal || global$1;
}; // Placeholder of an empty content rectangle.


var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */

function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */


function getBordersSize(styles) {
  var positions = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }

  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */


function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};

  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }

  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */


function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */


function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.

  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }

  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.

  var width = toFloat(styles.width),
      height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).

  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }

    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  } // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.


  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.

    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }

    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }

  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  } // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens


  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */


function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }

  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }

  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */


function createReadOnlyRect(_a) {
  var x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */


function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */


var ResizeObservation =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */

    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */

    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */


  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */


  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };

  return ResizeObservation;
}();

var ResizeObserverEntry =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.

    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }

  return ResizeObserverEntry;
}();

var ResizeObserverSPI =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */

    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is already being observed.

    if (observations.has(target)) {
      return;
    }

    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this); // Force the update of observations.

    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is not being observed.

    if (!observations.has(target)) {
      return;
    }

    observations["delete"](target);

    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;

    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }

    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */


  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };

  return ResizeObserverSPI;
}(); // Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.


var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */

var ResizeObserver =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }

    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }

  return ResizeObserver;
}(); // Expose public methods of ResizeObserver.


['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;

    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});

var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }

  return ResizeObserver;
}();

/* harmony default export */ __webpack_exports__["default"] = (index);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("pCvA")))

/***/ }),

/***/ "io9E":
/***/ (function(module, exports, __webpack_require__) {

var _indexOf = __webpack_require__("Gv4w");

module.exports = function _contains(a, list) {
  return _indexOf(list, a, 0) >= 0;
};

/***/ }),

/***/ "it7j":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__("X6VK");
var $find = __webpack_require__("1wfo")(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__("OfmW")(KEY);


/***/ }),

/***/ "iur1":
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__("GGqZ") && /./g.flags != 'g') __webpack_require__("U1KF").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__("MBcE")
});


/***/ }),

/***/ "j/vf":
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__("zIds");
var gOPS = __webpack_require__("0oPD");
var anObject = __webpack_require__("PAFS");
var Reflect = __webpack_require__("P56o").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ "jCf+":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var _xfBase = __webpack_require__("K8HH");

module.exports = function () {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;

  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return _curry2(function _xfilter(f, xf) {
    return new XFilter(f, xf);
  });
}();

/***/ }),

/***/ "jEou":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("Bsg+");
var setPrototypeOf = __webpack_require__("3ydu").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "jLVx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _SearchOutlined = _interopRequireDefault(__webpack_require__("NyDw"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _SearchOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "jPEw":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("U1KF").f;
var has = __webpack_require__("ezc+");
var TAG = __webpack_require__("9dxi")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "jWh4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("PAbq");

__webpack_require__("ACU4");

__webpack_require__("3y5y");

__webpack_require__("d3/y");

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------
// --[ Dependencies ]---------------------------------------------------


var _require = __webpack_require__("vgDc"),
    tagSymbol = _require.tagSymbol,
    typeSymbol = _require.typeSymbol;

var mapValues = __webpack_require__("3AxU");

var values = __webpack_require__("qXhx");

var extend = __webpack_require__("0ONX"); // --[ Constants ]------------------------------------------------------


var typeJsonKey = '@@type';
var tagJsonKey = '@@tag';
var valueJsonKey = '@@value'; // --[ Helpers ]--------------------------------------------------------

/*~
 * type: ((Object 'a) => 'b) => ([Object 'a]) => Object 'b  
 */

var arrayToObject = function arrayToObject(extractKey) {
  return function (array) {
    return array.reduce(function (object, element) {
      object[extractKey(element)] = element;
      return object;
    }, {});
  };
};
/*~
 * type: (String) => (Object 'a) => 'a | None 
 */


var property = function property(propertyName) {
  return function (object) {
    return object[propertyName];
  };
};
/*~
 * type: ([Object 'a]) => Object 'a 
 */


var indexByType = arrayToObject(property(typeSymbol));
/*~
 * type: (String, String) => Bool
 */

var assertType = function assertType(given, expected) {
  if (expected !== given) {
    throw new TypeError('\n       The JSON structure was generated from ' + expected + '.\n       You are trying to parse it as ' + given + '. \n    ');
  }
};
/*~
 * type: |
 *   type JSONSerialisation = {
 *     "@@type":  String,
 *     "@@tag":   String,
 *     "@@value": Object Any
 *   }
 *   type JSONParser = {
 *     fromJSON: (JSONSerialisation, Array JSONParser) => Variant
 *   }
 * 
 *   (Object JSONParser) => (JSONSerialisation) => Any
 */


var parseValue = function parseValue(parsers) {
  return function (value) {
    if (value !== null && typeof value[typeJsonKey] === 'string') {
      var type = value[typeJsonKey];

      if (parsers[type]) {
        return parsers[type].fromJSON(value, parsers, true);
      } else {
        return value;
      }
    } else {
      return value;
    }
  };
};
/*~
 * type: ('a) => JSON
 */


var serializeValue = function serializeValue(value) {
  return value === undefined ? null : value !== null && typeof value.toJSON === 'function' ? value.toJSON() :
  /* otherwise */
  value;
}; // --[ Implementation ]-------------------------------------------------

/*~
 * stability: experimental
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   (Variant, ADT) => Void 
 */


var serialization = function serialization(variant, adt) {
  var typeName = adt[typeSymbol];
  var tagName = variant.prototype[tagSymbol];
  /*~
   * stability: experimental
   * module: null
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   type JSONSerialisation = {
   *     "@@type":  String,
   *     "@@tag":   String,
   *     "@@value": Object Any
   *   }
   * 
   *   Variant . () => JSONSerialisation
   */

  variant.prototype.toJSON = function () {
    var _ref;

    return _ref = {}, _defineProperty(_ref, typeJsonKey, typeName), _defineProperty(_ref, tagJsonKey, tagName), _defineProperty(_ref, valueJsonKey, mapValues(this, serializeValue)), _ref;
  };
  /*~
   * stability: experimental
   * module: null
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   type JSONSerialisation = {
   *     "@@type":  String,
   *     "@@tag":   String,
   *     "@@value": Object Any
   *   }
   *   type JSONParser = {
   *     fromJSON: (JSONSerialisation, Array JSONParser) => Variant
   *   }
   * 
   *   (JSONSerialisation, Array JSONParser) => Variant
   */


  adt.fromJSON = function (value) {
    var parsers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defineProperty({}, typeName, adt);
    var keysIndicateType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var valueTypeName = value[typeJsonKey];
    var valueTagName = value[tagJsonKey];
    var valueContents = value[valueJsonKey];
    assertType(typeName, valueTypeName);
    var parsersByType = keysIndicateType ? parsers :
    /*otherwise*/
    indexByType(values(parsers));
    var parsedValue = mapValues(valueContents, parseValue(parsersByType));
    return extend(Object.create(adt[valueTagName].prototype), parsedValue);
  };
}; // --[ Exports ]--------------------------------------------------------


module.exports = serialization;

/***/ }),

/***/ "k/kI":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("Cs9m");
var global = __webpack_require__("41F1");
var hide = __webpack_require__("PPkd");
var Iterators = __webpack_require__("N9zW");
var TO_STRING_TAG = __webpack_require__("0Sp3")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "kBaS":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "kEto":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var BarsOutlined = {
  "name": "bars",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z"
      }
    }]
  }
};
exports["default"] = BarsOutlined;

/***/ }),

/***/ "kFsC":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");
/**
 * A function that returns the `!` of its argument. It will return `true` when
 * passed false-y value, and `false` when passed a truth-y one.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig * -> Boolean
 * @param {*} a any value
 * @return {Boolean} the logical inverse of passed argument.
 * @see R.complement
 * @example
 *
 *      R.not(true); //=> false
 *      R.not(false); //=> true
 *      R.not(0); //=> true
 *      R.not(1); //=> false
 */


module.exports = _curry1(function not(a) {
  return !a;
});

/***/ }),

/***/ "kMo5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _possibleConstructorReturn; });
/* harmony import */ var _helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("J1LG");
/* harmony import */ var _assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0942");


function _possibleConstructorReturn(self, call) {
  if (call && (Object(_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Object(_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(self);
}

/***/ }),

/***/ "kcW2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _BarsOutlined = _interopRequireDefault(__webpack_require__("kEto"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var BarsOutlined = function BarsOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _BarsOutlined["default"]
  }));
};

BarsOutlined.displayName = 'BarsOutlined';

var _default = _react["default"].forwardRef(BarsOutlined);

exports["default"] = _default;

/***/ }),

/***/ "khIB":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("PAFS");
var isObject = __webpack_require__("Bsg+");
var newPromiseCapability = __webpack_require__("gtO+");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "kku+":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("asZ9");

var _curry1 = __webpack_require__("AN6r");

var _isString = __webpack_require__("74ju");
/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */


module.exports = _curry1(function reverse(list) {
  return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
});

/***/ }),

/***/ "kluZ":
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "l5BI":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _startsWith = __webpack_require__("cpHF");

var _startsWith2 = _interopRequireDefault(_startsWith);

var _filter = __webpack_require__("LOD0");

var _filter2 = _interopRequireDefault(_filter);

var _isNil = __webpack_require__("CL0D");

var _isNil2 = _interopRequireDefault(_isNil);

var _curry = __webpack_require__("NU6T");

var _curry2 = _interopRequireDefault(_curry);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Get valid langKey in langs or return defaultLangKey
 * @func
 * @param {[String]} langs allowed lang keys ['en', 'fr', 'pt']
 * @param {String} defaultLangKey default browser language key
 * @returns {String} valid langKey
 */


var getValidLangKey = (0, _curry2["default"])(function (langs, defaultLangKey, langKey) {
  if ((0, _isNil2["default"])(langKey)) {
    return defaultLangKey;
  }

  var currentLangKey = (0, _filter2["default"])(function (l) {
    return (0, _startsWith2["default"])(l, langKey);
  }, langs);
  return currentLangKey[0] || defaultLangKey;
});
exports["default"] = getValidLangKey;

/***/ }),

/***/ "l8sR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ExclamationCircleFilled = _interopRequireDefault(__webpack_require__("deSU"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _ExclamationCircleFilled;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "lAKj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__("MBcE");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "lBnu":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("/Vl9")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "lQyR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("uRBY")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("Jww/")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "lphy":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__("P/oo");

__webpack_require__("Z8gF");

__webpack_require__("asZ9");

/*! https://mths.be/punycode v1.4.1 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof global == 'object' && global;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw new RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;;
          /* no condition */
          k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.4.1',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("RoC8")(module), __webpack_require__("pCvA")))

/***/ }),

/***/ "ltS6":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("LuBU");
var gOPS = __webpack_require__("0oPD");
var pIE = __webpack_require__("IdFN");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "lw3w":
/***/ (function(module, exports, __webpack_require__) {

var preferDefault=function preferDefault(m){return m&&m.default||m;};if(false){}else if(true){module.exports=preferDefault(__webpack_require__("rzlk"));}else{}

/***/ }),

/***/ "m/Uw":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("fGh/");
var document = __webpack_require__("41F1").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "m1Dn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__("XQta");
var validate = __webpack_require__("SsG5");
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__("AkS8")(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),

/***/ "m8zh":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__("hGr/")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),

/***/ "mK0O":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "mPTt":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: generateTrigger

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.now.js
var es6_date_now = __webpack_require__("7t+O");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-properties.js
var es6_object_define_properties = __webpack_require__("6/FK");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("2Tod");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ../node_modules/rc-util/es/Dom/contains.js
var contains = __webpack_require__("p82W");

// EXTERNAL MODULE: ../node_modules/rc-util/es/Dom/findDOMNode.js
var findDOMNode = __webpack_require__("vXvS");

// CONCATENATED MODULE: ../node_modules/rc-util/es/ref.js




function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function fillRef(ref, node) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (_typeof(ref) === 'object' && ref && 'current' in ref) {
    ref.current = node;
  }
}
/**
 * Merge refs into one ref function to support ref passing.
 */

function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }

  return function (node) {
    refs.forEach(function (ref) {
      fillRef(ref, node);
    });
  };
}
function supportRef(nodeOrComponent) {
  // Function component node
  if (nodeOrComponent.type && nodeOrComponent.type.prototype && !nodeOrComponent.type.prototype.render) {
    return false;
  } // Class component


  if (typeof nodeOrComponent === 'function' && nodeOrComponent.prototype && !nodeOrComponent.prototype.render) {
    return false;
  }

  return true;
}
/* eslint-enable */
// EXTERNAL MODULE: ../node_modules/rc-util/es/Dom/addEventListener.js
var addEventListener = __webpack_require__("4Alm");

// EXTERNAL MODULE: ../node_modules/rc-util/es/Portal.js
var Portal = __webpack_require__("LKC9");

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// CONCATENATED MODULE: ../node_modules/rc-trigger/es/utils/alignUtil.js











function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }

  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread({}, baseAlign, {}, align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements = Object.keys(builtinPlacements);

  for (var i = 0; i < placements.length; i += 1) {
    var placement = placements[i];

    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }

  return '';
}
// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__("oMRA");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __webpack_require__("6d4m");

// EXTERNAL MODULE: ../node_modules/raf/index.js
var raf = __webpack_require__("rQBY");
var raf_default = /*#__PURE__*/__webpack_require__.n(raf);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.is-array.js
var es6_array_is_array = __webpack_require__("+3V6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.to-string.js
var es6_date_to_string = __webpack_require__("M/4x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.number.constructor.js
var es6_number_constructor = __webpack_require__("e2Kn");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.constructor.js
var es6_regexp_constructor = __webpack_require__("J8hF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.match.js
var es6_regexp_match = __webpack_require__("9ovy");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.replace.js
var es6_regexp_replace = __webpack_require__("Z8gF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__("asZ9");

// CONCATENATED MODULE: ../node_modules/dom-align/dist-web/index.js



















function dist_web_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    dist_web_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    dist_web_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return dist_web_typeof(obj);
}

function dist_web_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function dist_web_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      dist_web_ownKeys(source, true).forEach(function (key) {
        dist_web_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      dist_web_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var vendorPrefix;
var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};

function getVendorPrefix() {
  if (vendorPrefix !== undefined) {
    return vendorPrefix;
  }

  vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      vendorPrefix = key;
    }
  }

  return vendorPrefix;
}

function getTransitionName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : 'transitionProperty';
}

function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : 'transform';
}

function setTransitionProperty(node, value) {
  var name = getTransitionName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}

function setTransform(node, value) {
  var name = getTransformName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}

function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName()];
}

function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }

  return {
    x: 0,
    y: 0
  };
}

var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;

function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var arr;
    var match2d = transform.match(matrix2d);

    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(','), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(','), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX; // https://stackoverflow.com/a/3485654/3040605

function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line

  elem.style.display = originalStyle;
}

function css(el, name, v) {
  var value = v;

  if (dist_web_typeof(name) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }

    return undefined;
  }

  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = "".concat(value, "px");
    }

    el.style[name] = value;
    return undefined;
  }

  return getComputedStyleX(el, name);
}

function getClientPosition(elem) {
  var box;
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement; // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式

  box = elem.getBoundingClientRect(); // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top; // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.
  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.
  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document; // ie6,7,8 standard mode

    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }

  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
/**
 * A crude way of determining if an object is a window
 * @member util
 */


function isWindow(obj) {
  // must use == for ie8

  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}

function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }

  if (node.nodeType === 9) {
    return node;
  }

  return node.ownerDocument;
}

function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = getDocument(elem);
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null); // https://github.com/kissyteam/kissy/issues/61

  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), 'i');

var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name]; // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了
  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity

  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT]; // prevent flashing of content

    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT]; // Put in the new values to get a computed value out

    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX; // Revert the changed values

    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }

  return ret === '' ? 'auto' : ret;
}

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }

  return option.useCssBottom ? 'bottom' : dir;
}

function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
} // 设置 elem 相对 elem.ownerDocument 的坐标


function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

  if (horizontalProperty !== 'left') {
    presetH = 999;
  }

  if (verticalProperty !== 'top') {
    presetV = 999;
  }

  var originalTransition = '';
  var originalOffset = getOffset(elem);

  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
  }

  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }

  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = "".concat(presetV, "px");
  } // force relayout


  forceRelayout(elem);
  var old = getOffset(elem);
  var originalStyle = {};

  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];

      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }

  css(elem, originalStyle); // force relayout

  forceRelayout(elem);

  if ('left' in offset || 'top' in offset) {
    setTransitionProperty(elem, originalTransition);
  }

  var ret = {};

  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);

      var _off = offset[_key] - originalOffset[_key];

      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }

  css(elem, ret);
}

function setTransform$1(elem, offset) {
  var originalOffset = getOffset(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };

  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }

  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }

  setTransformXY(elem, resultXY);
}

function setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset.left.toFixed(0);
    var tTop = offset.top.toFixed(0);

    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }

  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset);
  } else {
    setLeftTop(elem, offset, option);
  }
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name; // Remember the old values, and insert the new ones

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem); // Revert the old values

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j;
  var i;

  for (j = 0; j < props.length; j++) {
    prop = props[j];

    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;

        if (prop === 'border') {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }

        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }

  return value;
}

var domUtils = {
  getParent: function getParent(element) {
    var parent = element;

    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);

    return parent;
  }
};
each(['Width', 'Height'], function (name) {
  domUtils["doc".concat(name)] = function (refWin) {
    var d = refWin.document;
    return Math.max( // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement["scroll".concat(name)], // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
  };

  domUtils["viewport".concat(name)] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop]; // 标准模式取 documentElement
    // backcompat 取 body

    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});
/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */

function getWH(elem, name, ex) {
  var extra = ex;

  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.getBoundingClientRect().width : elem.getBoundingClientRect().height;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;

  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined; // Fall back to computed then un computed css if necessary

    cssBoxValue = getComputedStyleX(elem, name);

    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    } // Normalize '', auto, and prepare for extra


    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }

  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }

  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;

  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }

    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }

    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }

  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
}; // fix #119 : https://github.com/kissyteam/kissy/issues/119

function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var val;
  var elem = args[0]; // in case elem is window
  // elem.offsetWidth === undefined

  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }

  return val;
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);

  domUtils["outer".concat(first)] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, v) {
    var val = v;

    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);

        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which);
        }

        return css(elem, name, val);
      }

      return undefined;
    }

    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }

  return to;
}

var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }

    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i;
    var ret = {};

    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }

    var overflow = obj.overflow;

    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }

    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};

    for (var i = 0; i < arguments.length; i++) {
      utils.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }

    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);
/**
 * 得到会导致元素显示不全的祖先元素
 */

var getParent = utils.getParent;

function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  } // ie 这个也不是完全可行

  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法


  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils.css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
  }

  for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
    positionStyle = utils.css(parent, 'position');

    if (positionStyle !== 'static') {
      return parent;
    }
  }

  return null;
}

var getParent$1 = utils.getParent;

function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }

  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent = null;

  for (parent = getParent$1(element); parent && parent !== body; parent = getParent$1(parent)) {
    var positionStyle = utils.css(parent, 'position');

    if (positionStyle === 'fixed') {
      return true;
    }
  }

  return false;
}
/**
 * 获得元素的显示部分的区域
 */


function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement; // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.

  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {
      var pos = utils.offset(el); // add border

      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right, // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }

    el = getOffsetParent(el);
  } // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601


  var originalPosition = null;

  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils.css(element, 'position');

    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }

  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight; // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.

  var bodyStyle = window.getComputedStyle(body);

  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }

  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  } // Reset element position after calculate the visible area


  if (element.style) {
    element.style.position = originalPosition;
  }

  if (alwaysByViewport || isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }

  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };

  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  } // Left edge inside and right edge outside viewport, try to resize it.


  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  } // Right edge outside viewport, try to move it.


  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 保证左边界和可视区域左边界对齐
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  } // Top edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  } // Top edge inside and bottom edge outside viewport, try to resize it.


  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  } // Bottom edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 保证上边界和可视区域上边界对齐
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }

  return utils.mix(pos, size);
}

function getRegion(node) {
  var offset;
  var w;
  var h;

  if (!utils.isWindow(node) && node.nodeType !== 9) {
    offset = utils.offset(node);
    w = utils.outerWidth(node);
    h = utils.outerHeight(node);
  } else {
    var win = utils.getWindow(node);
    offset = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w = utils.viewportWidth(win);
    h = utils.viewportHeight(win);
  }

  offset.width = w;
  offset.height = h;
  return offset;
}
/**
 * 获取 node 上的 align 对齐点 相对于页面的坐标
 */


function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = region.left;
  var y = region.top;

  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }

  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }

  return {
    left: x,
    top: y
  };
}

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset[0]),
    top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset[1])
  };
}
/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */


function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}

function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}

function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}

function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}

function flip(points, reg, map) {
  var ret = [];
  utils.each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}

function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}

function convertOffset(str, offsetLen) {
  var n;

  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }

  return n || 0;
}

function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}
/**
 * @param el
 * @param tgtRegion 参照节点所占的区域: { left, top, width, height }
 * @param align
 */


function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport); // 当前节点可以被放置的显示区域

  var visibleRect = getVisibleRectForElement(source, alwaysByViewport); // 当前节点所占的区域, left/top/width/height

  var elRegion = getRegion(source); // 将 offset 转换成数值，支持百分比

  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, tgtRegion); // 当前节点将要被放置的位置

  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset); // 当前节点将要所处的区域

  var newElRegion = utils.merge(elRegion, elFuturePos); // 如果可视区域不能完全放置当前节点时允许调整

  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        }); // 偏移量也反下

        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);

        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    if (overflow.adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var _newPoints = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        }); // 偏移量也反下


        var _newOffset = flipOffset(offset, 1);

        var _newTargetOffset = flipOffset(targetOffset, 1);

        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);

        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    } // 如果失败，重新计算当前节点将要被放置的位置


    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
      utils.mix(newElRegion, elFuturePos);
    }

    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect); // 检查反下后的位置是否可以放下了，如果仍然放不下：
    // 1. 复原修改过的定位参数

    if (isStillFailX || isStillFailY) {
      points = align.points;
      offset = align.offset || [0, 0];
      targetOffset = align.targetOffset || [0, 0];
    } // 2. 只有指定了可以调整当前方向才调整


    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY; // 确实要调整，甚至可能会调整高度宽度

    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  } // need judge to in case set fixed with in css on height auto element


  if (newElRegion.width !== elRegion.width) {
    utils.css(source, 'width', utils.width(source) + newElRegion.width - elRegion.width);
  }

  if (newElRegion.height !== elRegion.height) {
    utils.css(source, 'height', utils.height(source) + newElRegion.height - elRegion.height);
  } // https://github.com/kissyteam/kissy/issues/190
  // 相对于屏幕位置没变，而 left/top 变了
  // 例如 <div 'relative'><el absolute></div>


  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 优化智能对齐算法
 *   - 慎用 resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 增加智能对齐，以及大小调整选项
 **/


function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}

function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}

alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
/**
 * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
 * If client position provided, will internal convert to page position.
 */

function dist_web_alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);

  if ('pageX' in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }

  if ('pageY' in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }

  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight; // Provide default target point

  var points = [align.points[0], 'cc'];
  return doAlign(el, tgtRegion, _objectSpread2({}, align, {
    points: points
  }), pointInView);
}

/* harmony default export */ var dist_web = (alignElement);

// EXTERNAL MODULE: ../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__("iXzu");

// CONCATENATED MODULE: ../node_modules/rc-align/es/util.js








function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}



function isSamePoint(prev, next) {
  if (prev === next) return true;
  if (!prev || !next) return false;

  if ('pageX' in next && 'pageY' in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }

  if ('clientX' in next && 'clientY' in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }

  return false;
}
function restoreFocus(activeElement, container) {
  // Focus back if is in the container
  if (activeElement !== document.activeElement && Object(contains["a" /* default */])(container, activeElement)) {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;

  function onResize(_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        target = _ref2[0].target;

    var _target$getBoundingCl = target.getBoundingClientRect(),
        width = _target$getBoundingCl.width,
        height = _target$getBoundingCl.height;

    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);

    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      callback({
        width: fixedWidth,
        height: fixedHeight
      });
    }

    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }

  var resizeObserver = new ResizeObserver_es["default"](onResize);

  if (element) {
    resizeObserver.observe(element);
  }

  return function () {
    resizeObserver.disconnect();
  };
}
// CONCATENATED MODULE: ../node_modules/rc-align/es/hooks/useBuffer.js

/* harmony default export */ var useBuffer = (function (callback, buffer) {
  var calledRef = react_default.a.useRef(false);
  var timeoutRef = react_default.a.useRef(null);

  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }

  function trigger(force) {
    if (!calledRef.current || force === true) {
      if (callback() === false) {
        // Not delay since callback cancelled self
        return;
      }

      calledRef.current = true;
      cancelTrigger();
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
      }, buffer);
    } else {
      cancelTrigger();
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
        trigger();
      }, buffer);
    }
  }

  return [trigger, function () {
    calledRef.current = false;
    cancelTrigger();
  }];
});
// CONCATENATED MODULE: ../node_modules/rc-align/es/Align.js








function Align_slicedToArray(arr, i) {
  return Align_arrayWithHoles(arr) || Align_iterableToArrayLimit(arr, i) || Align_nonIterableRest();
}

function Align_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function Align_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function Align_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function Align_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    Align_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    Align_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return Align_typeof(obj);
}
/**
 * Removed props:
 *  - childrenProps
 */









function getElement(func) {
  if (typeof func !== 'function') return null;
  return func();
}

function getPoint(point) {
  if (Align_typeof(point) !== 'object' || !point) return null;
  return point;
}

var Align_Align = function Align(_ref, ref) {
  var children = _ref.children,
      disabled = _ref.disabled,
      target = _ref.target,
      align = _ref.align,
      onAlign = _ref.onAlign,
      monitorWindowResize = _ref.monitorWindowResize,
      _ref$monitorBufferTim = _ref.monitorBufferTime,
      monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = react_default.a.useRef({});
  var nodeRef = react_default.a.useRef();
  var childNode = react_default.a.Children.only(children); // ===================== Align ======================
  // We save the props here to avoid closure makes props ood

  var forceAlignPropsRef = react_default.a.useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.onAlign = onAlign;

  var _useBuffer = useBuffer(function () {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current,
        latestDisabled = _forceAlignPropsRef$c.disabled,
        latestTarget = _forceAlignPropsRef$c.target;

    if (!latestDisabled && latestTarget) {
      var source = nodeRef.current;
      var result;
      var element = getElement(latestTarget);
      var point = getPoint(latestTarget);
      cacheRef.current.element = element;
      cacheRef.current.point = point; // IE lose focus after element realign
      // We should record activeElement and restore later

      var _document = document,
          activeElement = _document.activeElement;

      if (element) {
        result = alignElement(source, element, align);
      } else if (point) {
        result = dist_web_alignPoint(source, point, align);
      }

      restoreFocus(activeElement, source);

      if (onAlign) {
        onAlign(source, result);
      }

      return true;
    }

    return false;
  }, monitorBufferTime),
      _useBuffer2 = Align_slicedToArray(_useBuffer, 2),
      _forceAlign = _useBuffer2[0],
      cancelForceAlign = _useBuffer2[1]; // ===================== Effect =====================
  // Listen for target updated


  var resizeMonitor = react_default.a.useRef({
    cancel: function cancel() {}
  }); // Listen for source updated

  var sourceResizeMonitor = react_default.a.useRef({
    cancel: function cancel() {}
  });
  react_default.a.useEffect(function () {
    var element = getElement(target);
    var point = getPoint(target);

    if (nodeRef.current !== sourceResizeMonitor.current.element) {
      sourceResizeMonitor.current.cancel();
      sourceResizeMonitor.current.element = nodeRef.current;
      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);
    }

    if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point)) {
      _forceAlign(); // Add resize observer


      if (resizeMonitor.current.element !== element) {
        resizeMonitor.current.cancel();
        resizeMonitor.current.element = element;
        resizeMonitor.current.cancel = monitorResize(element, _forceAlign);
      }
    }
  }); // Listen for disabled change

  react_default.a.useEffect(function () {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]); // Listen for window resize

  var winResizeRef = react_default.a.useRef(null);
  react_default.a.useEffect(function () {
    if (monitorWindowResize) {
      if (!winResizeRef.current) {
        winResizeRef.current = Object(addEventListener["a" /* default */])(window, 'resize', _forceAlign);
      }
    } else if (winResizeRef.current) {
      winResizeRef.current.remove();
      winResizeRef.current = null;
    }
  }, [monitorWindowResize]); // Clear all if unmount

  react_default.a.useEffect(function () {
    return function () {
      resizeMonitor.current.cancel();
      sourceResizeMonitor.current.cancel();
      if (winResizeRef.current) winResizeRef.current.remove();
      cancelForceAlign();
    };
  }, []); // ====================== Ref =======================

  react_default.a.useImperativeHandle(ref, function () {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  }); // ===================== Render =====================

  if (react_default.a.isValidElement(childNode)) {
    childNode = react_default.a.cloneElement(childNode, {
      ref: composeRef(childNode.ref, nodeRef)
    });
  }

  return childNode;
};

var RefAlign = react_default.a.forwardRef(Align_Align);
RefAlign.displayName = 'Align';
/* harmony default export */ var es_Align = (RefAlign);
// CONCATENATED MODULE: ../node_modules/rc-align/es/index.js
// export this package's api

/* harmony default export */ var es = (es_Align);
// EXTERNAL MODULE: ../node_modules/rc-animate/es/CSSMotion.js
var CSSMotion = __webpack_require__("67vp");

// CONCATENATED MODULE: ../node_modules/rc-trigger/es/PopupInner.js



var PopupInner_PopupInner = function PopupInner(props, ref) {
  var prefixCls = props.prefixCls,
      className = props.className,
      visible = props.visible,
      style = props.style,
      children = props.children,
      onMouseEnter = props.onMouseEnter,
      onMouseLeave = props.onMouseLeave,
      onMouseDown = props.onMouseDown,
      onTouchStart = props.onTouchStart;
  var childNode = children;

  if (react_default.a.Children.count(children) > 1) {
    childNode = react_default.a.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }

  return react_default.a.createElement("div", {
    ref: ref,
    className: classnames_default()(className, !visible && "".concat(props.hiddenClassName)),
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onMouseDown: onMouseDown,
    onTouchStart: onTouchStart,
    style: style
  }, childNode);
};

var RefPopupInner = react_default.a.forwardRef(PopupInner_PopupInner);
RefPopupInner.displayName = 'PopupInner';
/* harmony default export */ var es_PopupInner = (RefPopupInner);
// CONCATENATED MODULE: ../node_modules/rc-trigger/es/utils/legacyUtil.js
function getMotion(_ref) {
  var prefixCls = _ref.prefixCls,
      motion = _ref.motion,
      animation = _ref.animation,
      transitionName = _ref.transitionName;

  if (motion) {
    return motion;
  }

  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }

  if (transitionName) {
    return {
      motionName: transitionName
    };
  }

  return null;
}
// CONCATENATED MODULE: ../node_modules/rc-trigger/es/Popup.js


















function Popup_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    Popup_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    Popup_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return Popup_typeof(obj);
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function Popup_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function Popup_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      Popup_ownKeys(source, true).forEach(function (key) {
        Popup_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      Popup_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function Popup_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (Popup_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
/* eslint-disable no-param-reassign */










var Popup_CSSMotion = CSSMotion["b" /* default */];

function supportMotion(motion) {
  return motion && motion.motionName;
}

var Popup_Popup = /*#__PURE__*/function (_Component) {
  _inherits(Popup, _Component);

  function Popup() {
    var _this;

    _classCallCheck(this, Popup);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Popup).apply(this, arguments));
    _this.state = {
      targetWidth: undefined,
      targetHeight: undefined,
      status: null,
      prevVisible: null,
      alignClassName: null
    };
    _this.popupRef = react_default.a.createRef();
    _this.alignRef = react_default.a.createRef();
    _this.nextFrameState = null;
    _this.nextFrameId = null;

    _this.onAlign = function (popupDomNode, align) {
      var status = _this.state.status;
      var _this$props = _this.props,
          getClassNameFromAlign = _this$props.getClassNameFromAlign,
          onAlign = _this$props.onAlign;
      var alignClassName = getClassNameFromAlign(align);

      if (status === 'align') {
        _this.setState({
          alignClassName: alignClassName,
          status: 'aligned'
        }, function () {
          _this.alignRef.current.forceAlign();
        });
      } else if (status === 'aligned') {
        _this.setState({
          alignClassName: alignClassName,
          status: 'afterAlign'
        });

        onAlign(popupDomNode, align);
      } else {
        _this.setState({
          alignClassName: alignClassName
        });
      }
    };

    _this.onMotionEnd = function () {
      var visible = _this.props.visible;

      _this.setState({
        status: visible ? 'AfterMotion' : 'stable'
      });
    };

    _this.setStateOnNextFrame = function (state) {
      _this.cancelFrameState();

      _this.nextFrameState = Popup_objectSpread({}, _this.nextFrameState, {}, state);
      _this.nextFrameId = raf_default()(function () {
        var submitState = Popup_objectSpread({}, _this.nextFrameState);

        _this.nextFrameState = null;

        _this.setState(submitState);
      });
    };

    _this.getMotion = function () {
      return Popup_objectSpread({}, getMotion(_this.props));
    }; // `target` on `rc-align` can accept as a function to get the bind element or a point.
    // ref: https://www.npmjs.com/package/rc-align


    _this.getAlignTarget = function () {
      var _this$props2 = _this.props,
          point = _this$props2.point,
          getRootDomNode = _this$props2.getRootDomNode;

      if (point) {
        return point;
      }

      return getRootDomNode;
    };

    _this.cancelFrameState = function () {
      raf_default.a.cancel(_this.nextFrameId);
    };

    _this.renderPopupElement = function () {
      var _this$state = _this.state,
          status = _this$state.status,
          targetHeight = _this$state.targetHeight,
          targetWidth = _this$state.targetWidth,
          alignClassName = _this$state.alignClassName;
      var _this$props3 = _this.props,
          prefixCls = _this$props3.prefixCls,
          className = _this$props3.className,
          style = _this$props3.style,
          stretch = _this$props3.stretch,
          visible = _this$props3.visible,
          align = _this$props3.align,
          destroyPopupOnHide = _this$props3.destroyPopupOnHide,
          onMouseEnter = _this$props3.onMouseEnter,
          onMouseLeave = _this$props3.onMouseLeave,
          onMouseDown = _this$props3.onMouseDown,
          onTouchStart = _this$props3.onTouchStart,
          children = _this$props3.children;
      var mergedClassName = classnames_default()(prefixCls, className, alignClassName);
      var hiddenClassName = "".concat(prefixCls, "-hidden"); // ================== Style ==================

      var sizeStyle = {};

      if (stretch) {
        // Stretch with target
        if (stretch.indexOf('height') !== -1) {
          sizeStyle.height = targetHeight;
        } else if (stretch.indexOf('minHeight') !== -1) {
          sizeStyle.minHeight = targetHeight;
        }

        if (stretch.indexOf('width') !== -1) {
          sizeStyle.width = targetWidth;
        } else if (stretch.indexOf('minWidth') !== -1) {
          sizeStyle.minWidth = targetWidth;
        }
      }

      var mergedStyle = Popup_objectSpread({}, sizeStyle, {}, _this.getZIndexStyle(), {}, style, {
        opacity: status === 'stable' || !visible ? undefined : 0
      }); // ================= Motions =================


      var mergedMotion = _this.getMotion();

      var mergedMotionVisible = visible;

      if (visible && status !== 'beforeMotion' && status !== 'motion' && status !== 'stable') {
        mergedMotion.motionAppear = false;
        mergedMotion.motionEnter = false;
        mergedMotion.motionLeave = false;
      }

      if (status === 'afterAlign' || status === 'beforeMotion') {
        mergedMotionVisible = false;
      } // ================== Align ==================


      var mergedAlignDisabled = !visible || status !== 'align' && status !== 'aligned' && status !== 'stable'; // ================== Popup ==================

      var mergedPopupVisible = true;

      if (status === 'stable') {
        mergedPopupVisible = visible;
      } // Only remove popup since mask may still need animation


      if (destroyPopupOnHide && !mergedPopupVisible) {
        return null;
      }

      return react_default.a.createElement(Popup_CSSMotion, Object.assign({
        visible: mergedMotionVisible
      }, mergedMotion, {
        removeOnLeave: false,
        onEnterEnd: _this.onMotionEnd,
        onLeaveEnd: _this.onMotionEnd
      }), function (_ref, motionRef) {
        var motionStyle = _ref.style,
            motionClassName = _ref.className;
        return react_default.a.createElement(es, {
          target: _this.getAlignTarget(),
          key: "popup",
          ref: _this.alignRef,
          monitorWindowResize: true,
          disabled: mergedAlignDisabled,
          align: align,
          onAlign: _this.onAlign
        }, react_default.a.createElement(es_PopupInner, {
          prefixCls: prefixCls,
          visible: mergedPopupVisible,
          hiddenClassName: hiddenClassName,
          className: classnames_default()(mergedClassName, motionClassName),
          ref: composeRef(motionRef, _this.popupRef),
          onMouseEnter: onMouseEnter,
          onMouseLeave: onMouseLeave,
          onMouseDown: onMouseDown,
          onTouchStart: onTouchStart,
          style: Popup_objectSpread({}, mergedStyle, {}, motionStyle)
        }, children));
      });
    };

    _this.renderMaskElement = function () {
      var _this$props4 = _this.props,
          mask = _this$props4.mask,
          maskMotion = _this$props4.maskMotion,
          maskTransitionName = _this$props4.maskTransitionName,
          maskAnimation = _this$props4.maskAnimation,
          prefixCls = _this$props4.prefixCls,
          visible = _this$props4.visible;

      if (!mask) {
        return null;
      }

      var motion = {};

      if (maskMotion && maskMotion.motionName) {
        motion = Popup_objectSpread({
          motionAppear: true
        }, getMotion({
          motion: maskMotion,
          prefixCls: prefixCls,
          transitionName: maskTransitionName,
          animation: maskAnimation
        }));
      }

      return react_default.a.createElement(Popup_CSSMotion, Object.assign({}, motion, {
        visible: visible,
        removeOnLeave: true
      }), function (_ref2) {
        var className = _ref2.className;
        return react_default.a.createElement("div", {
          style: _this.getZIndexStyle(),
          key: "mask",
          className: classnames_default()("".concat(prefixCls, "-mask"), className)
        });
      });
    };

    return _this;
  }

  _createClass(Popup, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.componentDidUpdate();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var status = this.state.status;
      var _this$props5 = this.props,
          getRootDomNode = _this$props5.getRootDomNode,
          visible = _this$props5.visible,
          stretch = _this$props5.stretch; // If there is a pending state update, cancel it, a new one will be set if necessary

      this.cancelFrameState();

      if (visible && status !== 'stable') {
        switch (status) {
          case null:
            {
              this.setStateOnNextFrame({
                status: stretch ? 'measure' : 'align'
              });
              break;
            }

          case 'afterAlign':
            {
              this.setStateOnNextFrame({
                status: supportMotion(this.getMotion()) ? 'beforeMotion' : 'stable'
              });
              break;
            }

          case 'AfterMotion':
            {
              this.setStateOnNextFrame({
                status: 'stable'
              });
              break;
            }

          default:
            {
              // Go to next status
              var queue = ['measure', 'align', null, 'beforeMotion', 'motion'];
              var index = queue.indexOf(status);
              var nextStatus = queue[index + 1];

              if (index !== -1 && nextStatus) {
                this.setStateOnNextFrame({
                  status: nextStatus
                });
              }
            }
        }
      } // Measure stretch size


      if (status === 'measure') {
        var $ele = getRootDomNode();

        if ($ele) {
          this.setStateOnNextFrame({
            targetHeight: $ele.offsetHeight,
            targetWidth: $ele.offsetWidth
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelFrameState();
    }
  }, {
    key: "getZIndexStyle",
    value: function getZIndexStyle() {
      var zIndex = this.props.zIndex;
      return {
        zIndex: zIndex
      };
    }
  }, {
    key: "render",
    value: function render() {
      return react_default.a.createElement("div", null, this.renderMaskElement(), this.renderPopupElement());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(_ref3, _ref4) {
      var visible = _ref3.visible,
          props = _objectWithoutProperties(_ref3, ["visible"]);

      var prevVisible = _ref4.prevVisible,
          status = _ref4.status;
      var newState = {
        prevVisible: visible,
        status: status
      };
      var mergedMotion = getMotion(props);

      if (prevVisible === null && visible === false) {
        // Init render should always be stable
        newState.status = 'stable';
      } else if (visible !== prevVisible) {
        if (visible || supportMotion(mergedMotion) && ['motion', 'AfterMotion', 'stable'].includes(status)) {
          newState.status = null;
        } else {
          newState.status = 'stable';
        }

        if (visible) {
          newState.alignClassName = null;
        }
      }

      return newState;
    }
  }]);

  return Popup;
}(react["Component"]);

/* harmony default export */ var es_Popup = (Popup_Popup);
/* eslint-enable */
// CONCATENATED MODULE: ../node_modules/rc-trigger/es/context.js

var TriggerContext = react_default.a.createContext(null);
/* harmony default export */ var context = (TriggerContext);
// CONCATENATED MODULE: ../node_modules/rc-trigger/es/index.js

















function es_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    es_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    es_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return es_typeof(obj);
}

function es_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function es_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      es_ownKeys(source, true).forEach(function (key) {
        es_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      es_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function es_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function es_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function es_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function es_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) es_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) es_defineProperties(Constructor, staticProps);
  return Constructor;
}

function es_possibleConstructorReturn(self, call) {
  if (call && (es_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return es_assertThisInitialized(self);
}

function es_getPrototypeOf(o) {
  es_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return es_getPrototypeOf(o);
}

function es_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function es_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) es_setPrototypeOf(subClass, superClass);
}

function es_setPrototypeOf(o, p) {
  es_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return es_setPrototypeOf(o, p);
}













function noop() {}

function returnEmptyString() {
  return '';
}

function returnDocument() {
  return window.document;
}

var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur', 'onContextMenu'];
/**
 * Internal usage. Do not use in your code since this will be removed.
 */

function generateTrigger(PortalComponent) {
  var Trigger = /*#__PURE__*/function (_React$Component) {
    es_inherits(Trigger, _React$Component);

    function Trigger(props) {
      var _this;

      es_classCallCheck(this, Trigger);

      _this = es_possibleConstructorReturn(this, es_getPrototypeOf(Trigger).call(this, props));
      _this.popupRef = react_default.a.createRef();
      _this.triggerRef = react_default.a.createRef();

      _this.onMouseEnter = function (e) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;

        _this.fireEvents('onMouseEnter', e);

        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
      };

      _this.onMouseMove = function (e) {
        _this.fireEvents('onMouseMove', e);

        _this.setPoint(e);
      };

      _this.onMouseLeave = function (e) {
        _this.fireEvents('onMouseLeave', e);

        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };

      _this.onPopupMouseEnter = function () {
        _this.clearDelayTimer();
      };

      _this.onPopupMouseLeave = function (e) {
        // https://github.com/react-component/trigger/pull/13
        // react bug?
        if (e.relatedTarget && !e.relatedTarget.setTimeout && _this.popupRef.current && _this.popupRef.current.popupRef.current && Object(contains["a" /* default */])(_this.popupRef.current.popupRef.current, e.relatedTarget)) {
          return;
        }

        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };

      _this.onFocus = function (e) {
        _this.fireEvents('onFocus', e); // incase focusin and focusout


        _this.clearDelayTimer();

        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();

          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      };

      _this.onMouseDown = function (e) {
        _this.fireEvents('onMouseDown', e);

        _this.preClickTime = Date.now();
      };

      _this.onTouchStart = function (e) {
        _this.fireEvents('onTouchStart', e);

        _this.preTouchTime = Date.now();
      };

      _this.onBlur = function (e) {
        _this.fireEvents('onBlur', e);

        _this.clearDelayTimer();

        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      };

      _this.onContextMenu = function (e) {
        e.preventDefault();

        _this.fireEvents('onContextMenu', e);

        _this.setPopupVisible(true, e);
      };

      _this.onContextMenuClose = function () {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      };

      _this.onClick = function (event) {
        _this.fireEvents('onClick', event); // focus will trigger click


        if (_this.focusTime) {
          var preTime;

          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }

          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }

          _this.focusTime = 0;
        }

        _this.preClickTime = 0;
        _this.preTouchTime = 0; // Only prevent default when all the action is click.
        // https://github.com/ant-design/ant-design/issues/17043
        // https://github.com/ant-design/ant-design/issues/17291

        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }

        var nextVisible = !_this.state.popupVisible;

        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      };

      _this.onPopupMouseDown = function () {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function () {
          _this.hasPopupMouseDown = false;
        }, 0);

        if (_this.context) {
          var _this$context;

          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      };

      _this.onDocumentClick = function (event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }

        var target = event.target;

        var root = _this.getRootDomNode();

        var popupNode = _this.getPopupDomNode();

        if (!Object(contains["a" /* default */])(root, target) && !Object(contains["a" /* default */])(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      };

      _this.getRootDomNode = function () {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;

        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }

        try {
          var domNode = Object(findDOMNode["a" /* default */])(_this.triggerRef.current);

          if (domNode) {
            return domNode;
          }
        } catch (err) {// Do nothing
        }

        return react_dom_default.a.findDOMNode(es_assertThisInitialized(_this));
      };

      _this.getPopupClassNameFromAlign = function (align) {
        var className = [];
        var _this$props = _this.props,
            popupPlacement = _this$props.popupPlacement,
            builtinPlacements = _this$props.builtinPlacements,
            prefixCls = _this$props.prefixCls,
            alignPoint = _this$props.alignPoint,
            getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;

        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
        }

        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }

        return className.join(' ');
      };

      _this.getComponent = function () {
        var _this$props2 = _this.props,
            prefixCls = _this$props2.prefixCls,
            destroyPopupOnHide = _this$props2.destroyPopupOnHide,
            popupClassName = _this$props2.popupClassName,
            onPopupAlign = _this$props2.onPopupAlign,
            popupMotion = _this$props2.popupMotion,
            popupAnimation = _this$props2.popupAnimation,
            popupTransitionName = _this$props2.popupTransitionName,
            popupStyle = _this$props2.popupStyle,
            mask = _this$props2.mask,
            maskAnimation = _this$props2.maskAnimation,
            maskTransitionName = _this$props2.maskTransitionName,
            maskMotion = _this$props2.maskMotion,
            zIndex = _this$props2.zIndex,
            popup = _this$props2.popup,
            stretch = _this$props2.stretch,
            alignPoint = _this$props2.alignPoint;
        var _this$state = _this.state,
            popupVisible = _this$state.popupVisible,
            point = _this$state.point;

        var align = _this.getPopupAlign();

        var mouseProps = {};

        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }

        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }

        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return react_default.a.createElement(es_Popup, Object.assign({
          prefixCls: prefixCls,
          destroyPopupOnHide: destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint && point,
          className: popupClassName,
          align: align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch: stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask: mask,
          zIndex: zIndex,
          transitionName: popupTransitionName,
          maskAnimation: maskAnimation,
          maskTransitionName: maskTransitionName,
          maskMotion: maskMotion,
          ref: _this.popupRef,
          motion: popupMotion
        }), typeof popup === 'function' ? popup() : popup);
      };

      _this.getContainer = function () {
        var _assertThisInitialize = es_assertThisInitialized(_this),
            props = _assertThisInitialize.props;

        var popupContainer = document.createElement('div'); // Make sure default popup container will never cause scrollbar appearing
        // https://github.com/react-component/trigger/issues/41

        popupContainer.style.position = 'absolute';
        popupContainer.style.top = '0';
        popupContainer.style.left = '0';
        popupContainer.style.width = '100%';
        var mountNode = props.getPopupContainer ? props.getPopupContainer(_this.getRootDomNode()) : props.getDocument().body;
        mountNode.appendChild(popupContainer);
        return popupContainer;
      };

      _this.setPoint = function (point) {
        var alignPoint = _this.props.alignPoint;
        if (!alignPoint || !point) return;

        _this.setState({
          point: {
            pageX: point.pageX,
            pageY: point.pageY
          }
        });
      };

      _this.handlePortalUpdate = function () {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      };

      var popupVisible;

      if ('popupVisible' in props) {
        popupVisible = !!props.popupVisible;
      } else {
        popupVisible = !!props.defaultPopupVisible;
      }

      _this.state = {
        prevPopupVisible: popupVisible,
        popupVisible: popupVisible
      };
      ALL_HANDLERS.forEach(function (h) {
        _this["fire".concat(h)] = function (e) {
          _this.fireEvents(h, e);
        };
      });
      return _this;
    }

    es_createClass(Trigger, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state; // We must listen to `mousedown` or `touchstart`, edge case:
        // https://github.com/ant-design/ant-design/issues/5804
        // https://github.com/react-component/calendar/issues/250
        // https://github.com/react-component/trigger/issues/50

        if (state.popupVisible) {
          var currentDocument;

          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument();
            this.clickOutsideHandler = Object(addEventListener["a" /* default */])(currentDocument, 'mousedown', this.onDocumentClick);
          } // always hide on mobile


          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument();
            this.touchOutsideHandler = Object(addEventListener["a" /* default */])(currentDocument, 'touchstart', this.onDocumentClick);
          } // close popup when trigger type contains 'onContextMenu' and document is scrolling.


          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument();
            this.contextMenuOutsideHandler1 = Object(addEventListener["a" /* default */])(currentDocument, 'scroll', this.onContextMenuClose);
          } // close popup when trigger type contains 'onContextMenu' and window is blur.


          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = Object(addEventListener["a" /* default */])(window, 'blur', this.onContextMenuClose);
          }

          return;
        }

        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        // for test
        if (this.popupRef.current && this.popupRef.current.popupRef.current) {
          return this.popupRef.current.popupRef.current;
        }

        return null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement,
            popupAlign = props.popupAlign,
            builtinPlacements = props.builtinPlacements;

        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }

        return popupAlign;
      }
      /**
       * @param popupVisible    Show or not the popup element
       * @param event           SyntheticEvent, used for `pointAlign`
       */

    }, {
      key: "setPopupVisible",
      value: function setPopupVisible(popupVisible, event) {
        var alignPoint = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();

        if (prevPopupVisible !== popupVisible) {
          if (!('popupVisible' in this.props)) {
            this.setState({
              popupVisible: popupVisible,
              prevPopupVisible: prevPopupVisible
            });
          }

          this.props.onPopupVisibleChange(popupVisible);
        } // Always record the point position since mouseEnterDelay will delay the show


        if (alignPoint && event) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;

        var delay = delayS * 1000;
        this.clearDelayTimer();

        if (delay) {
          var point = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function () {
            _this2.setPopupVisible(visible, point);

            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }

        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }

        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }

        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;

        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }

        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props3 = this.props,
            action = _this$props3.action,
            showAction = _this$props3.showAction;
        return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props4 = this.props,
            action = _this$props4.action,
            showAction = _this$props4.showAction;
        return action.indexOf('contextMenu') !== -1 || showAction.indexOf('contextMenu') !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props5 = this.props,
            action = _this$props5.action,
            hideAction = _this$props5.hideAction;
        return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props6 = this.props,
            action = _this$props6.action,
            showAction = _this$props6.showAction;
        return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props7 = this.props,
            action = _this$props7.action,
            hideAction = _this$props7.hideAction;
        return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props8 = this.props,
            action = _this$props8.action,
            showAction = _this$props8.showAction;
        return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props9 = this.props,
            action = _this$props9.action,
            hideAction = _this$props9.hideAction;
        return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible && this.popupRef.current && this.popupRef.current.alignRef.current) {
          this.popupRef.current.alignRef.current.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type, e) {
        var childCallback = this.props.children.props[type];

        if (childCallback) {
          childCallback(e);
        }

        var callback = this.props[type];

        if (callback) {
          callback(e);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render() {
        var popupVisible = this.state.popupVisible;
        var _this$props10 = this.props,
            children = _this$props10.children,
            forceRender = _this$props10.forceRender,
            alignPoint = _this$props10.alignPoint,
            className = _this$props10.className;
        var child = react_default.a.Children.only(children);
        var newChildProps = {
          key: 'trigger'
        };

        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains('onContextMenu');
        }

        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains('onClick');
          newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
          newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
        }

        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter;

          if (alignPoint) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains('onMouseEnter');
        }

        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains('onMouseLeave');
        }

        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains('onFocus');
          newChildProps.onBlur = this.createTwoChains('onBlur');
        }

        var childrenClassName = classnames_default()(child && child.props && child.props.className, className);

        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }

        var cloneProps = es_objectSpread({}, newChildProps);

        if (supportRef(child)) {
          cloneProps.ref = composeRef(this.triggerRef, child.ref);
        }

        var trigger = react_default.a.cloneElement(child, cloneProps);
        var portal; // prevent unmounting after it's rendered

        if (popupVisible || this.popupRef.current || forceRender) {
          portal = react_default.a.createElement(PortalComponent, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          }, this.getComponent());
        }

        return react_default.a.createElement(context.Provider, {
          value: {
            onPopupMouseDown: this.onPopupMouseDown
          }
        }, trigger, portal);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, prevState) {
        var popupVisible = _ref.popupVisible;
        var newState = {};

        if (popupVisible !== undefined && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }

        return newState;
      }
    }]);

    return Trigger;
  }(react_default.a.Component);

  Trigger.contextType = context;
  Trigger.defaultProps = {
    prefixCls: 'rc-trigger-popup',
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop,
    afterPopupVisibleChange: noop,
    onPopupAlign: noop,
    popupClassName: '',
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: []
  };
  return Trigger;
}
/* harmony default export */ var rc_trigger_es = __webpack_exports__["a"] = (generateTrigger(Portal["a" /* default */]));

/***/ }),

/***/ "mTAF":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return wrapperRaf; });
/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("rQBY");
/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(raf__WEBPACK_IMPORTED_MODULE_0__);

var id = 0;
var ids = {}; // Support call raf with delay specified frame

function wrapperRaf(callback) {
  var delayFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var myId = id++;
  var restFrames = delayFrames;

  function internalCallback() {
    restFrames -= 1;

    if (restFrames <= 0) {
      callback();
      delete ids[myId];
    } else {
      ids[myId] = raf__WEBPACK_IMPORTED_MODULE_0___default()(internalCallback);
    }
  }

  ids[myId] = raf__WEBPACK_IMPORTED_MODULE_0___default()(internalCallback);
  return myId;
}

wrapperRaf.cancel = function cancel(pid) {
  if (pid === undefined) return;
  raf__WEBPACK_IMPORTED_MODULE_0___default.a.cancel(ids[pid]);
  delete ids[pid];
};

wrapperRaf.ids = ids; // export this for test usage

/***/ }),

/***/ "mWFu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("yIlq");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isEmpty = __webpack_require__("zFdY");

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _not = __webpack_require__("kFsC");

var _not2 = _interopRequireDefault(_not);

var _compose = __webpack_require__("+yb+");

var _compose2 = _interopRequireDefault(_compose);

var _contains = __webpack_require__("893G");

var _contains2 = _interopRequireDefault(_contains);

var _filter = __webpack_require__("LOD0");

var _filter2 = _interopRequireDefault(_filter);

var _getPagesPaths = __webpack_require__("aOS5");

var _getPagesPaths2 = _interopRequireDefault(_getPagesPaths);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/*
 * Checks if a path is in options.pagesPaths
 * @sig Options -> String -> Boolean
 * @param {{pagesPaths: string[]}} options plugin options
 * @param {String} path path to check
 * @return {Result<Boolean>} is in
 */


var isInPagesPaths = function isInPagesPaths(options, path) {
  return (0, _getPagesPaths2["default"])(options).map((0, _filter2["default"])(function (pagePath) {
    return (0, _contains2["default"])(pagePath, path);
  })).map((0, _compose2["default"])(_not2["default"], _isEmpty2["default"]));
};

exports["default"] = isInPagesPaths;

/***/ }),

/***/ "mbwt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("+jjx");

__webpack_require__("ABKx");

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
}; //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------


module.exports = function (method, maybeObject) {
  if ((typeof maybeObject === 'undefined' ? 'undefined' : _typeof(maybeObject)) !== 'object') {
    throw new TypeError(method + ' expects an Object, but was given ' + maybeObject + '.');
  }
};

/***/ }),

/***/ "mggL":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("Bsg+");
var document = __webpack_require__("P56o").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "miGZ":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "ml72":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("Cmsx");
var defined = __webpack_require__("GCOZ");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "mthV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("5hJT");

__webpack_require__("yIlq");

var assertType = __webpack_require__("yCBR");

var assertFunction = __webpack_require__("nAPr");

var _require = __webpack_require__("sMOp"),
    union = _require.union,
    derivations = _require.derivations;

var provideAliases = __webpack_require__("JiyH");

var adtMethods = __webpack_require__("cl25");

var extend = __webpack_require__("0ONX");

var warnDeprecation = __webpack_require__("GFZo");

var equality = derivations.equality,
    debugRepresentation = derivations.debugRepresentation,
    serialization = derivations.serialization;
/*~ stability: stable */

var Validation = union('folktale:Validation', {
  /*~
   * type: |
   *   forall a, b: (a) => Validation a b
   */
  Failure: function Failure(value) {
    return {
      value: value
    };
  },

  /*~
   * type: |
   *   forall a, b: (b) => Validation a b
   */
  Success: function Success(value) {
    return {
      value: value
    };
  }
}).derive(equality, debugRepresentation, serialization);
var Success = Validation.Success,
    Failure = Validation.Failure;
var assertValidation = assertType(Validation);
extend(Failure.prototype, {
  /*~
   * isRequired: true
   * type: |
   *   forall a, b: get (Validation a b) => a
   */
  get value() {
    throw new TypeError('`value` can’t be accessed in an abstract instance of Validation.Failure');
  }

});
extend(Success.prototype, {
  /*~
   * isRequired: true
   * type: |
   *   forall a, b: get (Validation a b) => b
   */
  get value() {
    throw new TypeError('`value` can’t be accessed in an abstract instance of Validation.Success');
  }

});
/*~~belongsTo: Validation */

adtMethods(Validation, {
  /*~
   * type: |
   *   forall a, b, c: (Validation a b).((b) => c) => Validation a c
   */
  map: {
    /*~*/
    Failure: function map(transformation) {
      assertFunction('Validation.Failure#map', transformation);
      return this;
    },

    /*~*/
    Success: function map(transformation) {
      assertFunction('Validation.Success#map', transformation);
      return Success(transformation(this.value));
    }
  },

  /*~
   * type: |
   *   forall a, b, c: (Validation (b) => c).(Validation a b) => Validation a c
   */
  apply: {
    /*~*/
    Failure: function apply(aValidation) {
      assertValidation('Failure#apply', aValidation);
      return Failure.hasInstance(aValidation) ? Failure(this.value.concat(aValidation.value)) :
      /* otherwise */
      this;
    },

    /*~*/
    Success: function apply(aValidation) {
      assertValidation('Success#apply', aValidation);
      return Failure.hasInstance(aValidation) ? aValidation :
      /* otherwise */
      aValidation.map(this.value);
    }
  },

  /*~
   * type: |
   *   forall a, b: (Validation a b).() => b :: throws TypeError
   */
  unsafeGet: {
    /*~*/
    Failure: function unsafeGet() {
      throw new TypeError('Can\'t extract the value of a Failure.\n\n    Failure does not contain a normal value - it contains an error.\n    You might consider switching from Validation#get to Validation#getOrElse, or some other method\n    that is not partial.\n      ');
    },

    /*~*/
    Success: function unsafeGet() {
      return this.value;
    }
  },

  /*~
   * type: |
   *   forall a, b: (Validation a b).(b) => b
   */
  getOrElse: {
    /*~*/
    Failure: function getOrElse(_default) {
      return _default;
    },

    /*~*/
    Success: function getOrElse(_default) {
      return this.value;
    }
  },

  /*~
   * type: |
   *   forall a, b, c:
   *     (Validation a b).((a) => Validation c b) => Validation c b
   */
  orElse: {
    /*~*/
    Failure: function orElse(handler) {
      assertFunction('Validation.Failure#orElse', handler);
      return handler(this.value);
    },

    /*~*/
    Success: function orElse(handler) {
      assertFunction('Validation.Success#orElse', handler);
      return this;
    }
  },

  /*~
   * type: |
   *   forall a, b:
   *     (Validation a b).(Validation a b) => Validation a b
   *   where a is Semigroup
   */
  concat: {
    /*~*/
    Failure: function concat(aValidation) {
      assertValidation('Validation.Failure#concat', aValidation);

      if (Failure.hasInstance(aValidation)) {
        return Failure(this.value.concat(aValidation.value));
      } else {
        return this;
      }
    },

    /*~*/
    Success: function concat(aValidation) {
      assertValidation('Validation.Success#concat', aValidation);
      return aValidation;
    }
  },

  /*~
   * type: |
   *   forall a, b, c:
   *     (Validation a b).((a) => c, (b) => c) => c
   */
  fold: {
    /*~*/
    Failure: function fold(failureTransformation, successTransformation) {
      assertFunction('Validation.Failure#fold', failureTransformation);
      assertFunction('Validation.Failure#fold', successTransformation);
      return failureTransformation(this.value);
    },

    /*~*/
    Success: function fold(failureTransformation, successTransformation) {
      assertFunction('Validation.Success#fold', failureTransformation);
      assertFunction('Validation.Success#fold', successTransformation);
      return successTransformation(this.value);
    }
  },

  /*~
   * type: |
   *   forall a, b: (Validation a b).() => Validation b a
   */
  swap: {
    /*~*/
    Failure: function swap() {
      return Success(this.value);
    },

    /*~*/
    Success: function swap() {
      return Failure(this.value);
    }
  },

  /*~
   * type: |
   *   forall a, b, c, d:
   *     (Validation a b).((a) => c, (b) => d) => Validation c d
   */
  bimap: {
    /*~*/
    Failure: function bimap(failureTransformation, successTransformation) {
      assertFunction('Validation.Failure#fold', failureTransformation);
      assertFunction('Validation.Failure#fold', successTransformation);
      return Failure(failureTransformation(this.value));
    },

    /*~*/
    Success: function bimap(failureTransformation, successTransformation) {
      assertFunction('Validation.Success#fold', failureTransformation);
      assertFunction('Validation.Success#fold', successTransformation);
      return Success(successTransformation(this.value));
    }
  },

  /*~
   * type: |
   *   forall a, b, c:
   *     (Validation a b).((a) => c) Validation c b
   */
  mapFailure: {
    /*~*/
    Failure: function mapFailure(transformation) {
      assertFunction('Validation.Failure#mapFailure', transformation);
      return Failure(transformation(this.value));
    },

    /*~*/
    Success: function mapFailure(transformation) {
      assertFunction('Validation.Failure#mapFailure', transformation);
      return this;
    }
  }
});
Object.assign(Validation, {
  /*~
   * type: |
   *   forall a, b: (b) => Validation a b
   */
  of: function of(value) {
    return Success(value);
  },

  /*~
   * type: |
   *   forall a, b: (Validation a b).() => b :: throws TypeError
   */
  'get': function get() {
    warnDeprecation('`.get()` is deprecated, and has been renamed to `.unsafeGet()`.');
    return this.unsafeGet();
  },

  /*~
   * type: |
   *   forall a, b: (Validation a b).() => a or b
   */
  merge: function merge() {
    return this.value;
  },

  /*~
   * type: |
   *   forall a, b: (Validation a b).() => Result a b
   */
  toResult: function toResult() {
    return __webpack_require__("f7TZ")(this);
  },

  /*~
   * type: |
   *   forall a, b: (Validation a b).() => Maybe b
   */
  toMaybe: function toMaybe() {
    return __webpack_require__("ByO0")(this);
  }
});
provideAliases(Success.prototype);
provideAliases(Failure.prototype);
provideAliases(Validation);
module.exports = Validation;

/***/ }),

/***/ "mvii":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "n+VH":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "n6P+":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("eOWL");
var anObject = __webpack_require__("ADe/");
var getKeys = __webpack_require__("/Lgp");

module.exports = __webpack_require__("lBnu") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "nAPr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = function (method, transformation) {
  if (typeof transformation !== 'function') {
    throw new TypeError(method + ' expects a function, but was given ' + transformation + '.');
  }
};

/***/ }),

/***/ "nd6X":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("b01t")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "nl0c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = {
  equals: 'fantasy-land/equals',
  concat: 'fantasy-land/concat',
  empty: 'fantasy-land/empty',
  map: 'fantasy-land/map',
  ap: 'fantasy-land/ap',
  of: 'fantasy-land/of',
  alt: 'fantasy-land/alt',
  reduce: 'fantasy-land/reduce',
  traverse: 'fantasy-land/traverse',
  chain: 'fantasy-land/chain',
  chainRec: 'fantasy-land/chainRec',
  extend: 'fantasy-land/extend',
  extract: 'fantasy-land/extract',
  bimap: 'fantasy-land/bimap',
  promap: 'fantasy-land/promap'
};

/***/ }),

/***/ "nsWf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pipe = __webpack_require__("IycE");

var _pipe2 = _interopRequireDefault(_pipe);

var _getBrowserLanguage = __webpack_require__("ylPP");

var _getBrowserLanguage2 = _interopRequireDefault(_getBrowserLanguage);

var _getValidLangKey = __webpack_require__("l5BI");

var _getValidLangKey2 = _interopRequireDefault(_getValidLangKey);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Get user browser valid langKey
 * @param {[String]} langs allowed lang keys ['en', 'fr', 'pt']
 * @param {String} defaultLangKey default browser language key
 * @return {string} valid langKey
 */


var getUserLangKey = function getUserLangKey(langs, defaultLangKey) {
  return (0, _pipe2["default"])(_getBrowserLanguage2["default"], (0, _getValidLangKey2["default"])(langs, defaultLangKey))();
};

exports["default"] = getUserLangKey;

/***/ }),

/***/ "nsbO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__("PAFS");
var sameValue = __webpack_require__("Nu7b");
var regExpExec = __webpack_require__("Fu0I");

// @@search logic
__webpack_require__("Wifh")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "ntCI":
/***/ (function(module, exports) {

module.exports = function () {
  function XWrap(fn) {
    this.f = fn;
  }

  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };

  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };

  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return function _xwrap(fn) {
    return new XWrap(fn);
  };
}();

/***/ }),

/***/ "nw12":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var LeftOutlined = {
  "name": "left",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"
      }
    }]
  }
};
exports["default"] = LeftOutlined;

/***/ }),

/***/ "nxTg":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__("+3YS");

var iterableToArrayLimit = __webpack_require__("S411");

var unsupportedIterableToArray = __webpack_require__("Zhxd");

var nonIterableRest = __webpack_require__("+bRE");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "o/3r":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ExclamationCircleOutlined = {
  "name": "exclamation-circle",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z"
      }
    }]
  }
};
exports["default"] = ExclamationCircleOutlined;

/***/ }),

/***/ "o2D/":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("3y5y");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

var _isArrayLike = __webpack_require__("xCUo");

var _xwrap = __webpack_require__("ntCI");

var bind = __webpack_require__("CZpP");

module.exports = function () {
  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      idx += 1;
    }

    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();

    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      step = iter.next();
    }

    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
  return function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }

    if (_isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }

    if (typeof list['fantasy-land/reduce'] === 'function') {
      return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
    }

    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }

    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }

    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list, 'reduce');
    }

    throw new TypeError('reduce: list must be array or iterable');
  };
}();

/***/ }),

/***/ "o3C2":
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "o6jA":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("X6VK");
$export($export.G + $export.W + $export.F * !__webpack_require__("tW8y").ABV, {
  DataView: __webpack_require__("Dhml").DataView
});


/***/ }),

/***/ "o7PZ":
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__("X6VK");

$export($export.P, 'Function', { bind: __webpack_require__("oAuq") });


/***/ }),

/***/ "o7mQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isMobileSafari = isMobileSafari;

function isMobileSafari() {
  return /iPad|iPhone|iPod/.test(window.navigator.platform) && /^((?!CriOS).)*Safari/.test(window.navigator.userAgent);
}

/***/ }),

/***/ "oAuq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("b8Rm");
var isObject = __webpack_require__("Bsg+");
var invoke = __webpack_require__("KFSm");
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),

/***/ "oLHe":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("dtzt");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  "use strict";

  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";
  CodeMirror.defineOption("styleActiveLine", false, function (cm, val, old) {
    var prev = old == CodeMirror.Init ? false : old;
    if (val == prev) return;

    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }

    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });

  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }

  function sameArray(a, b) {
    if (a.length != b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }

    return true;
  }

  function updateActiveLines(cm, ranges) {
    var active = [];

    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty()) continue;
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }

    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function () {
      clearActiveLines(cm);

      for (var i = 0; i < active.length; i++) {
        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i], "background", BACK_CLASS);
        cm.addLineClass(active[i], "gutter", GUTT_CLASS);
      }

      cm.state.activeLines = active;
    });
  }

  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});

/***/ }),

/***/ "oMRA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__("X6VK");
var $includes = __webpack_require__("sdkr")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__("OfmW")('includes');


/***/ }),

/***/ "oRxD":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _BarsOutlined = _interopRequireDefault(__webpack_require__("kcW2"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _BarsOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "oV81":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getChinaMirrorHost; });
/* harmony import */ var core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9ovy");
/* harmony import */ var core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_0__);

var ping = function ping(callback) {
  var url = 'https://private-a' + 'lipay' + 'objects.alip' + 'ay.com/alip' + 'ay-rmsdeploy-image/rmsportal/RKuAiriJqrUhyqW.png';
  var img = new Image();
  var done = false;

  var finish = function finish(status) {
    if (!done) {
      done = true;
      img.src = '';
      callback(status);
    }
  };

  img.onload = function () {
    return finish('responded');
  };

  img.onerror = function () {
    return finish('error');
  };

  img.src = url;
  return setTimeout(function () {
    return finish('timeout');
  }, 1500);
};
var capitalize = function capitalize(s) {
  if (typeof s !== 'string') {
    return '';
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
};
var getChinaMirrorHost = function getChinaMirrorHost(host) {
  var hostString = typeof host === 'undefined' ? window.location.host : host; // antv.vision => antv.gitee.io

  if (hostString === 'antv.vision') {
    return 'antv.gitee.io';
  } // g2plot.antv.vision => antv-g2plot.gitee.io


  var match = hostString.match(/(.*)\.antv\.vision/);

  if (match && match[1]) {
    return "antv-" + match[1] + ".gitee.io";
  }

  return hostString;
};

/***/ }),

/***/ "orKN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("P56o");
var each = __webpack_require__("1wfo")(0);
var redefine = __webpack_require__("sU/p");
var meta = __webpack_require__("zIP/");
var assign = __webpack_require__("NR3o");
var weak = __webpack_require__("s14n");
var isObject = __webpack_require__("Bsg+");
var validate = __webpack_require__("SsG5");
var NATIVE_WEAK_MAP = __webpack_require__("SsG5");
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__("AkS8")(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),

/***/ "p1Jl":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__("mvii");
var defined = __webpack_require__("GCOZ");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),

/***/ "p82W":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return contains; });
function contains(root, n) {
  var node = n;

  while (node) {
    if (node === root) {
      return true;
    }

    node = node.parentNode;
  }

  return false;
}

/***/ }),

/***/ "pB2m":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("OFVL");
var ITERATOR = __webpack_require__("9dxi")('iterator');
var Iterators = __webpack_require__("Ibj2");
module.exports = __webpack_require__("R5TD").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "pCP8":
/***/ (function(module, exports, __webpack_require__) {

// prefer default export if available
var preferDefault=function preferDefault(m){return m&&m.default||m;};exports.components={"component---cache-caches-gatsby-plugin-offline-app-shell-js":function componentCacheCachesGatsbyPluginOfflineAppShellJs(){return __webpack_require__.e(/* import() | component---cache-caches-gatsby-plugin-offline-app-shell-js */ 7).then(__webpack_require__.t.bind(null, "zXQ9", 7));},"component---antv-gatsby-theme-antv-site-templates-document-tsx":function componentAntvGatsbyThemeAntvSiteTemplatesDocumentTsx(){return Promise.all(/* import() | component---antv-gatsby-theme-antv-site-templates-document-tsx */[__webpack_require__.e(0), __webpack_require__.e(5)]).then(__webpack_require__.bind(null, "+loJ"));},"component---antv-gatsby-theme-antv-site-templates-example-tsx":function componentAntvGatsbyThemeAntvSiteTemplatesExampleTsx(){return Promise.all(/* import() | component---antv-gatsby-theme-antv-site-templates-example-tsx */[__webpack_require__.e(0), __webpack_require__.e(6)]).then(__webpack_require__.bind(null, "Rvvu"));},"component---antv-gatsby-theme-antv-site-pages-index-tsx":function componentAntvGatsbyThemeAntvSitePagesIndexTsx(){return __webpack_require__.e(/* import() | component---antv-gatsby-theme-antv-site-pages-index-tsx */ 4).then(__webpack_require__.bind(null, "KByP"));},"component---antv-gatsby-theme-antv-site-pages-404-tsx":function componentAntvGatsbyThemeAntvSitePages404Tsx(){return Promise.all(/* import() | component---antv-gatsby-theme-antv-site-pages-404-tsx */[__webpack_require__.e(0), __webpack_require__.e(3)]).then(__webpack_require__.bind(null, "EVqs"));},"component---site-pages-independent-en-tsx":function componentSitePagesIndependentEnTsx(){return __webpack_require__.e(/* import() | component---site-pages-independent-en-tsx */ 8).then(__webpack_require__.bind(null, "tOJG"));},"component---site-pages-independent-zh-tsx":function componentSitePagesIndependentZhTsx(){return __webpack_require__.e(/* import() | component---site-pages-independent-zh-tsx */ 9).then(__webpack_require__.bind(null, "BxFN"));},"component---site-pages-index-en-tsx":function componentSitePagesIndexEnTsx(){return Promise.all(/* import() | component---site-pages-index-en-tsx */[__webpack_require__.e(0), __webpack_require__.e(10)]).then(__webpack_require__.bind(null, "ug36"));},"component---site-pages-index-zh-tsx":function componentSitePagesIndexZhTsx(){return Promise.all(/* import() | component---site-pages-index-zh-tsx */[__webpack_require__.e(0), __webpack_require__.e(11)]).then(__webpack_require__.bind(null, "jAeI"));}};

/***/ }),

/***/ "pCvA":
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "pGW6":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("GGqZ");
var getKeys = __webpack_require__("LuBU");
var toIObject = __webpack_require__("ml72");
var isEnum = __webpack_require__("IdFN").f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};


/***/ }),

/***/ "pS6Z":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("sfhO"),
    Error = _require.Error,
    Ok = _require.Ok;
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   forall a, b:
 *     (Maybe a, b) => Result b a
 */


var maybeToResult = function maybeToResult(aMaybe, failureValue) {
  return aMaybe.matchWith({
    Nothing: function Nothing() {
      return Error(failureValue);
    },
    Just: function Just(_ref) {
      var value = _ref.value;
      return Ok(value);
    }
  });
};

module.exports = maybeToResult;

/***/ }),

/***/ "pU1/":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("U1KF");
var anObject = __webpack_require__("PAFS");
var getKeys = __webpack_require__("LuBU");

module.exports = __webpack_require__("GGqZ") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "papw":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var rc_util_es_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("IFhY");


/* harmony default export */ __webpack_exports__["a"] = (function (valid, component, message) {
  Object(rc_util_es_warning__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(valid, "[antd: ".concat(component, "] ").concat(message));
});

/***/ }),

/***/ "phsM":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "puZ4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("Vx+c");
var descriptor = __webpack_require__("WWmS");
var setToStringTag = __webpack_require__("jPEw");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("tjmq")(IteratorPrototype, __webpack_require__("9dxi")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "q7lU":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // This icon file is generated automatically.
// tslint:disable

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var LoadingOutlined = {
  "name": "loading",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"
      }
    }]
  }
};
exports["default"] = LoadingOutlined;

/***/ }),

/***/ "qA3Z":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "qXhx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * stability : stable
 * authors:
 *   - Quildreen Motta
 *
 * complexity : O(n), n is the number of own enumerable properties.
 * type: |
 *   (Object 'a) => Array 'a
 */

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("yIlq");

var values = function values(object) {
  return Object.keys(object).map(function (k) {
    return object[k];
  });
}; // --[ Exports ]-------------------------------------------------------


module.exports = values;

/***/ }),

/***/ "qbl3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _CloseCircleFilled = _interopRequireDefault(__webpack_require__("OeCt"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var CloseCircleFilled = function CloseCircleFilled(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _CloseCircleFilled["default"]
  }));
};

CloseCircleFilled.displayName = 'CloseCircleFilled';

var _default = _react["default"].forwardRef(CloseCircleFilled);

exports["default"] = _default;

/***/ }),

/***/ "qtgu":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.bind.js
var es6_function_bind = __webpack_require__("o7PZ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.iterator.js
var es6_string_iterator = __webpack_require__("lQyR");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.map.js
var es6_map = __webpack_require__("zx98");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.now.js
var es6_date_now = __webpack_require__("7t+O");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-properties.js
var es6_object_define_properties = __webpack_require__("6/FK");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("2Tod");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ../node_modules/rc-animate/es/Animate.js + 5 modules
var Animate = __webpack_require__("YSJY");

// EXTERNAL MODULE: ../node_modules/rc-util/es/createChainedFunction.js
var createChainedFunction = __webpack_require__("eDOA");

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ../node_modules/rc-notification/es/Notice.js
var Notice = __webpack_require__("w37R");

// EXTERNAL MODULE: ../node_modules/rc-notification/es/useNotification.js
var es_useNotification = __webpack_require__("bIG9");

// CONCATENATED MODULE: ../node_modules/rc-notification/es/Notification.js





















function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}








var seed = 0;
var now = Date.now();

function getUuid() {
  var id = seed;
  seed += 1;
  return "rcNotification_".concat(now, "_").concat(id);
}

var Notification_Notification = /*#__PURE__*/function (_Component) {
  _inherits(Notification, _Component);

  function Notification() {
    var _this;

    _classCallCheck(this, Notification);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Notification).apply(this, arguments));
    _this.state = {
      notices: []
    };
    _this.hookRefs = new Map();

    _this.add = function (notice, holderCallback) {
      notice.key = notice.key || getUuid();
      var key = notice.key;
      var maxCount = _this.props.maxCount;

      _this.setState(function (previousState) {
        var notices = previousState.notices;
        var noticeIndex = notices.map(function (v) {
          return v.notice.key;
        }).indexOf(key);
        var updatedNotices = notices.concat();

        if (noticeIndex !== -1) {
          updatedNotices.splice(noticeIndex, 1, {
            notice: notice,
            holderCallback: holderCallback
          });
        } else {
          if (maxCount && notices.length >= maxCount) {
            // XXX, use key of first item to update new added (let React to move exsiting
            // instead of remove and mount). Same key was used before for both a) external
            // manual control and b) internal react 'key' prop , which is not that good.
            notice.updateKey = updatedNotices[0].notice.updateKey || updatedNotices[0].notice.key;
            updatedNotices.shift();
          }

          updatedNotices.push({
            notice: notice,
            holderCallback: holderCallback
          });
        }

        return {
          notices: updatedNotices
        };
      });
    };

    _this.remove = function (key) {
      _this.setState(function (previousState) {
        return {
          notices: previousState.notices.filter(function (_ref) {
            var notice = _ref.notice;
            return notice.key !== key;
          })
        };
      });
    };

    return _this;
  }

  _createClass(Notification, [{
    key: "getTransitionName",
    value: function getTransitionName() {
      var _this$props = this.props,
          prefixCls = _this$props.prefixCls,
          animation = _this$props.animation;
      var transitionName = this.props.transitionName;

      if (!transitionName && animation) {
        transitionName = "".concat(prefixCls, "-").concat(animation);
      }

      return transitionName;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var notices = this.state.notices;
      var _this$props2 = this.props,
          prefixCls = _this$props2.prefixCls,
          className = _this$props2.className,
          closeIcon = _this$props2.closeIcon,
          style = _this$props2.style;
      var noticeNodes = notices.map(function (_ref2, index) {
        var notice = _ref2.notice,
            holderCallback = _ref2.holderCallback;
        var update = Boolean(index === notices.length - 1 && notice.updateKey);
        var key = notice.updateKey ? notice.updateKey : notice.key;
        var onClose = Object(createChainedFunction["a" /* default */])(_this2.remove.bind(_this2, notice.key), notice.onClose);

        var noticeProps = _objectSpread({
          prefixCls: prefixCls,
          closeIcon: closeIcon
        }, notice, {
          key: key,
          update: update,
          onClose: onClose,
          onClick: notice.onClick,
          children: notice.content
        });

        if (holderCallback) {
          return react_default.a.createElement("div", {
            key: key,
            className: "".concat(prefixCls, "-hook-holder"),
            ref: function ref(div) {
              if (div) {
                _this2.hookRefs.set(key, div);

                holderCallback(div, noticeProps);
              } else {
                _this2.hookRefs["delete"](key);
              }
            }
          });
        }

        return react_default.a.createElement(Notice["a" /* default */], Object.assign({}, noticeProps));
      });
      return react_default.a.createElement("div", {
        className: classnames_default()(prefixCls, className),
        style: style
      }, react_default.a.createElement(Animate["a" /* default */], {
        transitionName: this.getTransitionName()
      }, noticeNodes));
    }
  }]);

  return Notification;
}(react["Component"]);

Notification_Notification.defaultProps = {
  prefixCls: 'rc-notification',
  animation: 'fade',
  style: {
    top: 65,
    left: '50%'
  }
};

Notification_Notification.newInstance = function newNotificationInstance(properties, callback) {
  var _ref3 = properties || {},
      getContainer = _ref3.getContainer,
      props = _objectWithoutProperties(_ref3, ["getContainer"]);

  var div = document.createElement('div');

  if (getContainer) {
    var root = getContainer();
    root.appendChild(div);
  } else {
    document.body.appendChild(div);
  }

  var called = false;

  function ref(notification) {
    if (called) {
      return;
    }

    called = true;
    callback({
      notice: function notice(noticeProps) {
        notification.add(noticeProps);
      },
      removeNotice: function removeNotice(key) {
        notification.remove(key);
      },
      component: notification,
      destroy: function destroy() {
        react_dom_default.a.unmountComponentAtNode(div);
        div.parentNode.removeChild(div);
      },
      // Hooks
      useNotification: function useNotification() {
        return Object(es_useNotification["a" /* default */])(notification);
      }
    });
  } // Only used for test case usage


  if (false) {}

  react_dom_default.a.render(react_default.a.createElement(Notification_Notification, Object.assign({}, props, {
    ref: ref
  })), div);
};

/* harmony default export */ var es_Notification = (Notification_Notification);
// CONCATENATED MODULE: ../node_modules/rc-notification/es/index.js

/* harmony default export */ var es = __webpack_exports__["a"] = (es_Notification);

/***/ }),

/***/ "r/sL":
/***/ (function(module, exports) {

module.exports = function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };

    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };

    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };

    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };

    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };

    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };

    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };

    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };

    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };

    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };

    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };

    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
};

/***/ }),

/***/ "r8tM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _InfoCircleOutlined = _interopRequireDefault(__webpack_require__("USUc"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var InfoCircleOutlined = function InfoCircleOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _InfoCircleOutlined["default"]
  }));
};

InfoCircleOutlined.displayName = 'InfoCircleOutlined';

var _default = _react["default"].forwardRef(InfoCircleOutlined);

exports["default"] = _default;

/***/ }),

/***/ "rIjD":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("LPDj"), __esModule: true };

/***/ }),

/***/ "rQBY":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__("TGEZ"),
    root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
} // Some versions of FF have rAF but not cAF


if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));

      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0); // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue

        queue.length = 0;

        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }

    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

module.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};

module.exports.cancel = function () {
  caf.apply(root, arguments);
};

module.exports.polyfill = function (object) {
  if (!object) {
    object = root;
  }

  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("pCvA")))

/***/ }),

/***/ "rpsq":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("J8hF");

__webpack_require__("9ovy");

__webpack_require__("nsbO");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"), __webpack_require__("KvMB"), __webpack_require__("Bi0q"), __webpack_require__("I2ZI"));else {}
})(function (CodeMirror) {
  "use strict";

  var defaultTags = {
    script: [["lang", /(javascript|babel)/i, "javascript"], ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"], ["type", /./, "text/plain"], [null, null, "javascript"]],
    style: [["lang", /^css$/i, "css"], ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"], ["type", /./, "text/plain"], [null, null, "css"]]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(),
        close = cur.search(pat);

    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }

    return style;
  }

  var attrRegexpCache = {};

  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr));
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : "";
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];

      for (var i = source.length - 1; i >= 0; i--) {
        dest.unshift(source[i]);
      }
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
    });
    var tags = {};
    var configTags = parserConfig && parserConfig.tags,
        configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--) {
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);
    }

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState),
          tag = /\btag\b/.test(style),
          tagName;

      if (tag && !/[<>\s\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " ";
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag);
        state.inTag = null;
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
        var mode = CodeMirror.getMode(config, modeSpec);
        var endTagA = getTagRegexp(inTag[1], true),
            endTag = getTagRegexp(inTag[1], false);

        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }

          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };

        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
      } else if (state.inTag) {
        state.inTag += stream.current();
        if (stream.eol()) state.inTag += " ";
      }

      return style;
    }

    ;
    return {
      startState: function startState() {
        var state = CodeMirror.startState(htmlMode);
        return {
          token: html,
          inTag: null,
          localMode: null,
          localState: null,
          htmlState: state
        };
      },
      copyState: function copyState(state) {
        var local;

        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }

        return {
          token: state.token,
          inTag: state.inTag,
          localMode: state.localMode,
          localState: local,
          htmlState: CodeMirror.copyState(htmlMode, state.htmlState)
        };
      },
      token: function token(stream, state) {
        return state.token(stream, state);
      },
      indent: function indent(state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter)) return htmlMode.indent(state.htmlState, textAfter, line);else if (state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line);else return CodeMirror.Pass;
      },
      innerMode: function innerMode(state) {
        return {
          state: state.localState || state.htmlState,
          mode: state.localMode || htmlMode
        };
      }
    };
  }, "xml", "javascript", "css");
  CodeMirror.defineMIME("text/html", "htmlmixed");
});

/***/ }),

/***/ "rwvH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _RightOutlined = _interopRequireDefault(__webpack_require__("8rx3"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _RightOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "rzlk":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5hJT");
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _page_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("IOVJ");
var ProdPageRenderer=function ProdPageRenderer(_ref){var location=_ref.location,pageResources=_ref.pageResources;if(!pageResources){return null;}return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_page_renderer__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],Object.assign({location:location,pageResources:pageResources},pageResources.json));};/* harmony default export */ __webpack_exports__["default"] = (ProdPageRenderer);

/***/ }),

/***/ "s14n":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__("+edc");
var getWeak = __webpack_require__("zIP/").getWeak;
var anObject = __webpack_require__("PAFS");
var isObject = __webpack_require__("Bsg+");
var anInstance = __webpack_require__("EusA");
var forOf = __webpack_require__("HqX2");
var createArrayMethod = __webpack_require__("1wfo");
var $has = __webpack_require__("ezc+");
var validate = __webpack_require__("SsG5");
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),

/***/ "sMOp":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * stability: experimental
 * name: module folktale/adt/union
 */

module.exports = {
  union: __webpack_require__("vgDc"),
  derivations: __webpack_require__("foH5")
};

/***/ }),

/***/ "sU/p":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("P56o");
var hide = __webpack_require__("tjmq");
var has = __webpack_require__("ezc+");
var SRC = __webpack_require__("1Alt")('src');
var $toString = __webpack_require__("JGfN");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__("R5TD").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "sWB5":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("eOWL").f;
var has = __webpack_require__("qA3Z");
var TAG = __webpack_require__("0Sp3")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "sZHf":
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__("mXGw");

function ExternalLink (props) {
    return React.createElement("svg",props,React.createElement("path",{"d":"M 5 3 C 3.9069372 3 3 3.9069372 3 5 L 3 19 C 3 20.093063 3.9069372 21 5 21 L 19 21 C 20.093063 21 21 20.093063 21 19 L 21 12 L 19 12 L 19 19 L 5 19 L 5 5 L 12 5 L 12 3 L 5 3 z M 14 3 L 14 5 L 17.585938 5 L 8.2929688 14.292969 L 9.7070312 15.707031 L 19 6.4140625 L 19 10 L 21 10 L 21 3 L 14 3 z"}));
}

ExternalLink.defaultProps = {"width":"24","height":"24","fill":"#000","viewBox":"0 0 24 24"};

module.exports = ExternalLink;

ExternalLink.default = ExternalLink;


/***/ }),

/***/ "sbMj":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("SwVN");
/* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_index_less__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("2jw+");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);



/***/ }),

/***/ "sdkr":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("ml72");
var toLength = __webpack_require__("Sp5b");
var toAbsoluteIndex = __webpack_require__("BUlT");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "sfhO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("5hJT");

__webpack_require__("yIlq");

var assertType = __webpack_require__("yCBR");

var assertFunction = __webpack_require__("nAPr");

var _require = __webpack_require__("sMOp"),
    union = _require.union,
    derivations = _require.derivations;

var provideAliases = __webpack_require__("JiyH");

var adtMethods = __webpack_require__("cl25");

var extend = __webpack_require__("0ONX");

var warnDeprecation = __webpack_require__("GFZo");

var equality = derivations.equality,
    debugRepresentation = derivations.debugRepresentation,
    serialization = derivations.serialization;
/*~ stability: stable */

var Result = union('folktale:Result', {
  /*~
   * stability: stable
   * type: |
   *   forall a, b: (a) => Result a b
   */
  Error: function Error(value) {
    return {
      value: value
    };
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (b) => Result a b
   */
  Ok: function Ok(value) {
    return {
      value: value
    };
  }
}).derive(equality, debugRepresentation, serialization);
var Error = Result.Error,
    Ok = Result.Ok;
var assertResult = assertType(Result);
extend(Error.prototype, {
  /*~
   * isRequired: true
   * type: |
   *   forall a, b: get (Result a b) => a
   */
  get value() {
    throw new TypeError('`value` can’t be accessed in an abstract instance of Result.Error');
  }

});
extend(Ok.prototype, {
  /*~
   * isRequired: true
   * type: |
   *   forall a, b: get (Result a b) => b
   */
  get value() {
    throw new TypeError('`value` can’t be accessed in an abstract instance of Result.Ok');
  }

});
/*~
 * ~belongsTo: Result
 */

adtMethods(Result, {
  /*~
   * stability: stable
   * type: |
   *   forall a, b, c:
   *     (Result a b).((b) => c) => Result a c
   */
  map: {
    /*~*/
    Error: function map(f) {
      assertFunction('Result.Error#map', f);
      return this;
    },

    /*~*/
    Ok: function map(f) {
      assertFunction('Result.Ok#map', f);
      return Ok(f(this.value));
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b, c:
   *     (Result a ((b) => c)).(Result a b) => Result a c
   */
  apply: {
    /*~*/
    Error: function apply(anResult) {
      assertResult('Result.Error#apply', anResult);
      return this;
    },

    /*~*/
    Ok: function apply(anResult) {
      assertResult('Result.Ok#apply', anResult);
      return anResult.map(this.value);
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b, c:
   *     (Result a b).((b) => Result a c) => Result a c
   */
  chain: {
    /*~*/
    Error: function chain(f) {
      assertFunction('Result.Error#chain', f);
      return this;
    },

    /*~*/
    Ok: function chain(f) {
      assertFunction('Result.Ok#chain', f);
      return f(this.value);
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Result a b).() => b :: throws TypeError
   */
  unsafeGet: {
    /*~*/
    Error: function unsafeGet() {
      throw new TypeError('Can\'t extract the value of an Error.\n\nError does not contain a normal value - it contains an error.\nYou might consider switching from Result#unsafeGet to Result#getOrElse,\nor some other method that is not partial.\n      ');
    },

    /*~*/
    Ok: function unsafeGet() {
      return this.value;
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Result a b).(b) => b
   */
  getOrElse: {
    /*~*/
    Error: function getOrElse(_default) {
      return _default;
    },

    /*~*/
    Ok: function getOrElse(_default) {
      return this.value;
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b, c:
   *     (Result a b).((a) => Result c b) => Result c b
   */
  orElse: {
    /*~*/
    Error: function orElse(handler) {
      assertFunction('Result.Error#orElse', handler);
      return handler(this.value);
    },

    /*~*/
    Ok: function orElse(handler) {
      assertFunction('Result.Ok#orElse', handler);
      return this;
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Result a b).(Result a b) => Result a b
   *   where b is Semigroup
   */
  concat: {
    /*~*/
    Error: function concat(aResult) {
      assertResult('Result.Error#concat', aResult);
      return this;
    },

    /*~*/
    Ok: function concat(aResult) {
      var _this = this;

      assertResult('Result.Ok#concat', aResult);
      return aResult.map(function (xs) {
        return _this.value.concat(xs);
      });
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b, c:
   *     (Result a b).((a) => c, (b) => c) => c
   */
  fold: {
    /*~*/
    Error: function fold(f, g) {
      assertFunction('Result.Error#fold', f);
      assertFunction('Result.Error#fold', g);
      return f(this.value);
    },

    /*~*/
    Ok: function fold(f, g) {
      assertFunction('Result.Ok#fold', f);
      assertFunction('Result.Ok#fold', g);
      return g(this.value);
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Result a b).() => Result b a
   */
  swap: {
    /*~*/
    Error: function swap() {
      return Ok(this.value);
    },

    /*~*/
    Ok: function swap() {
      return Error(this.value);
    }
  },

  /*~
   * stability: stable
   * type: |
   *   (Result a b).((a) => c, (b) => d) => Result c d
   */
  bimap: {
    /*~*/
    Error: function bimap(f, g) {
      assertFunction('Result.Error#bimap', f);
      assertFunction('Result.Error#bimap', g);
      return Error(f(this.value));
    },

    /*~*/
    Ok: function bimap(f, g) {
      assertFunction('Result.Ok#bimap', f);
      assertFunction('Result.Ok#bimap', g);
      return Ok(g(this.value));
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b, c:
   *     (Result a b).((a) => c) => Result c b
   */
  mapError: {
    /*~*/
    Error: function mapError(f) {
      assertFunction('Result.Error#mapError', f);
      return Error(f(this.value));
    },

    /*~*/
    Ok: function mapError(f) {
      assertFunction('Result.Ok#mapError', f);
      return this;
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a: (Maybe a).((a) => Boolean) => Maybe a
   */
  filter: {
    /*~*/
    Error: function filter(predicate) {
      assertFunction('Result.Error#filter', predicate);
      return this;
    },

    /*~*/
    Ok: function filter(predicate) {
      assertFunction('Result.Ok#filter', predicate);
      return predicate(this.value) ? this : Error(this.value);
    }
  }
});
Object.assign(Result, {
  /*~
   * stability: stable
   * type: |
   *   forall a, b: (b) => Result a b
   */
  of: function of(value) {
    return Ok(value);
  },

  /*~
   * deprecated:
   *   since: 2.0.0
   *   replacedBy: .unsafeGet()
   * type: |
   *   forall a, b: (Result a b).() => b :: (throws TypeError)
   */
  'get': function get() {
    warnDeprecation('`.get()` is deprecated, and has been renamed to `.unsafeGet()`.');
    return this.unsafeGet();
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Result a b).() => a or b
   */
  merge: function merge() {
    return this.value;
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Result a b).() => Validation a b
   */
  toValidation: function toValidation() {
    return __webpack_require__("vmge")(this);
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Result a b).() => Maybe b
   */
  toMaybe: function toMaybe() {
    return __webpack_require__("/l6L")(this);
  }
});
provideAliases(Error.prototype);
provideAliases(Ok.prototype);
provideAliases(Result);
module.exports = Result;

/***/ }),

/***/ "so/P":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("P/oo");

__webpack_require__("9ovy");

__webpack_require__("m8zh");

__webpack_require__("Z8gF");

__webpack_require__("asZ9");

__webpack_require__("V7cS");

__webpack_require__("nsbO");

var punycode = __webpack_require__("lphy");

var util = __webpack_require__("wjI5");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__("UKnr");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift())) {
        ;
      }

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "sqS1":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("Qqke");
var hiddenKeys = __webpack_require__("miGZ").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "t91x":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__("OFVL");
var test = {};
test[__webpack_require__("9dxi")('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__("sU/p")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),

/***/ "tW8y":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("P56o");
var hide = __webpack_require__("tjmq");
var uid = __webpack_require__("1Alt");
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ "tWFn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _LeftOutlined = _interopRequireDefault(__webpack_require__("nw12"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var LeftOutlined = function LeftOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _LeftOutlined["default"]
  }));
};

LeftOutlined.displayName = 'LeftOutlined';

var _default = _react["default"].forwardRef(LeftOutlined);

exports["default"] = _default;

/***/ }),

/***/ "tbIA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__("lBnu");
var getKeys = __webpack_require__("/Lgp");
var gOPS = __webpack_require__("phsM");
var pIE = __webpack_require__("kBaS");
var toObject = __webpack_require__("dCrc");
var IObject = __webpack_require__("6wgB");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("/Vl9")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "tj/o":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("+3V6");

__webpack_require__("VNvs");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("7lGJ");

__webpack_require__("1qKx");

__webpack_require__("PAbq");

__webpack_require__("V7cS");

__webpack_require__("d3/y");

__webpack_require__("5hJT");

exports.__esModule = true;
exports.Helmet = undefined;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("W0B4");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactSideEffect = __webpack_require__("WiT8");

var _reactSideEffect2 = _interopRequireDefault(_reactSideEffect);

var _reactFastCompare = __webpack_require__("2Hgx");

var _reactFastCompare2 = _interopRequireDefault(_reactFastCompare);

var _HelmetUtils = __webpack_require__("hRGL");

var _HelmetConstants = __webpack_require__("doOt");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _objectWithoutProperties(obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Helmet = function Helmet(Component) {
  var _class, _temp;

  return _temp = _class = function (_React$Component) {
    _inherits(HelmetWrapper, _React$Component);

    function HelmetWrapper() {
      _classCallCheck(this, HelmetWrapper);

      return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    HelmetWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return !(0, _reactFastCompare2["default"])(this.props, nextProps);
    };

    HelmetWrapper.prototype.mapNestedChildrenToProps = function mapNestedChildrenToProps(child, nestedChildren) {
      if (!nestedChildren) {
        return null;
      }

      switch (child.type) {
        case _HelmetConstants.TAG_NAMES.SCRIPT:
        case _HelmetConstants.TAG_NAMES.NOSCRIPT:
          return {
            innerHTML: nestedChildren
          };

        case _HelmetConstants.TAG_NAMES.STYLE:
          return {
            cssText: nestedChildren
          };
      }

      throw new Error("<" + child.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
    };

    HelmetWrapper.prototype.flattenArrayTypeChildren = function flattenArrayTypeChildren(_ref) {
      var _extends2;

      var child = _ref.child,
          arrayTypeChildren = _ref.arrayTypeChildren,
          newChildProps = _ref.newChildProps,
          nestedChildren = _ref.nestedChildren;
      return _extends({}, arrayTypeChildren, (_extends2 = {}, _extends2[child.type] = [].concat(arrayTypeChildren[child.type] || [], [_extends({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]), _extends2));
    };

    HelmetWrapper.prototype.mapObjectTypeChildren = function mapObjectTypeChildren(_ref2) {
      var _extends3, _extends4;

      var child = _ref2.child,
          newProps = _ref2.newProps,
          newChildProps = _ref2.newChildProps,
          nestedChildren = _ref2.nestedChildren;

      switch (child.type) {
        case _HelmetConstants.TAG_NAMES.TITLE:
          return _extends({}, newProps, (_extends3 = {}, _extends3[child.type] = nestedChildren, _extends3.titleAttributes = _extends({}, newChildProps), _extends3));

        case _HelmetConstants.TAG_NAMES.BODY:
          return _extends({}, newProps, {
            bodyAttributes: _extends({}, newChildProps)
          });

        case _HelmetConstants.TAG_NAMES.HTML:
          return _extends({}, newProps, {
            htmlAttributes: _extends({}, newChildProps)
          });
      }

      return _extends({}, newProps, (_extends4 = {}, _extends4[child.type] = _extends({}, newChildProps), _extends4));
    };

    HelmetWrapper.prototype.mapArrayTypeChildrenToProps = function mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
      var newFlattenedProps = _extends({}, newProps);

      Object.keys(arrayTypeChildren).forEach(function (arrayChildName) {
        var _extends5;

        newFlattenedProps = _extends({}, newFlattenedProps, (_extends5 = {}, _extends5[arrayChildName] = arrayTypeChildren[arrayChildName], _extends5));
      });
      return newFlattenedProps;
    };

    HelmetWrapper.prototype.warnOnInvalidChildren = function warnOnInvalidChildren(child, nestedChildren) {
      if (false) {}

      return true;
    };

    HelmetWrapper.prototype.mapChildrenToProps = function mapChildrenToProps(children, newProps) {
      var _this2 = this;

      var arrayTypeChildren = {};

      _react2["default"].Children.forEach(children, function (child) {
        if (!child || !child.props) {
          return;
        }

        var _child$props = child.props,
            nestedChildren = _child$props.children,
            childProps = _objectWithoutProperties(_child$props, ["children"]);

        var newChildProps = (0, _HelmetUtils.convertReactPropstoHtmlAttributes)(childProps);

        _this2.warnOnInvalidChildren(child, nestedChildren);

        switch (child.type) {
          case _HelmetConstants.TAG_NAMES.LINK:
          case _HelmetConstants.TAG_NAMES.META:
          case _HelmetConstants.TAG_NAMES.NOSCRIPT:
          case _HelmetConstants.TAG_NAMES.SCRIPT:
          case _HelmetConstants.TAG_NAMES.STYLE:
            arrayTypeChildren = _this2.flattenArrayTypeChildren({
              child: child,
              arrayTypeChildren: arrayTypeChildren,
              newChildProps: newChildProps,
              nestedChildren: nestedChildren
            });
            break;

          default:
            newProps = _this2.mapObjectTypeChildren({
              child: child,
              newProps: newProps,
              newChildProps: newChildProps,
              nestedChildren: nestedChildren
            });
            break;
        }
      });

      newProps = this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
      return newProps;
    };

    HelmetWrapper.prototype.render = function render() {
      var _props = this.props,
          children = _props.children,
          props = _objectWithoutProperties(_props, ["children"]);

      var newProps = _extends({}, props);

      if (children) {
        newProps = this.mapChildrenToProps(children, newProps);
      }

      return _react2["default"].createElement(Component, newProps);
    };

    _createClass(HelmetWrapper, null, [{
      key: "canUseDOM",
      // Component.peek comes from react-side-effect:
      // For testing, you may use a static peek() method available on the returned component.
      // It lets you get the current state without resetting the mounted instance stack.
      // Don’t use it for anything other than testing.

      /**
       * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
       * @param {Object} bodyAttributes: {"className": "root"}
       * @param {String} defaultTitle: "Default Title"
       * @param {Boolean} defer: true
       * @param {Boolean} encodeSpecialCharacters: true
       * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
       * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
       * @param {Array} meta: [{"name": "description", "content": "Test description"}]
       * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
       * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
       * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
       * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
       * @param {String} title: "Title"
       * @param {Object} titleAttributes: {"itemprop": "name"}
       * @param {String} titleTemplate: "MySite.com - %s"
       */
      set: function set(canUseDOM) {
        Component.canUseDOM = canUseDOM;
      }
    }]);

    return HelmetWrapper;
  }(_react2["default"].Component), _class.propTypes = {
    base: _propTypes2["default"].object,
    bodyAttributes: _propTypes2["default"].object,
    children: _propTypes2["default"].oneOfType([_propTypes2["default"].arrayOf(_propTypes2["default"].node), _propTypes2["default"].node]),
    defaultTitle: _propTypes2["default"].string,
    defer: _propTypes2["default"].bool,
    encodeSpecialCharacters: _propTypes2["default"].bool,
    htmlAttributes: _propTypes2["default"].object,
    link: _propTypes2["default"].arrayOf(_propTypes2["default"].object),
    meta: _propTypes2["default"].arrayOf(_propTypes2["default"].object),
    noscript: _propTypes2["default"].arrayOf(_propTypes2["default"].object),
    onChangeClientState: _propTypes2["default"].func,
    script: _propTypes2["default"].arrayOf(_propTypes2["default"].object),
    style: _propTypes2["default"].arrayOf(_propTypes2["default"].object),
    title: _propTypes2["default"].string,
    titleAttributes: _propTypes2["default"].object,
    titleTemplate: _propTypes2["default"].string
  }, _class.defaultProps = {
    defer: true,
    encodeSpecialCharacters: true
  }, _class.peek = Component.peek, _class.rewind = function () {
    var mappedState = Component.rewind();

    if (!mappedState) {
      // provide fallback if mappedState is undefined
      mappedState = (0, _HelmetUtils.mapStateOnServer)({
        baseTag: [],
        bodyAttributes: {},
        encodeSpecialCharacters: true,
        htmlAttributes: {},
        linkTags: [],
        metaTags: [],
        noscriptTags: [],
        scriptTags: [],
        styleTags: [],
        title: "",
        titleAttributes: {}
      });
    }

    return mappedState;
  }, _temp;
};

var NullComponent = function NullComponent() {
  return null;
};

var HelmetSideEffects = (0, _reactSideEffect2["default"])(_HelmetUtils.reducePropsToState, _HelmetUtils.handleClientStateChange, _HelmetUtils.mapStateOnServer)(NullComponent);
var HelmetExport = Helmet(HelmetSideEffects);
HelmetExport.renderStatic = HelmetExport.rewind;
exports.Helmet = HelmetExport;
exports["default"] = HelmetExport;

/***/ }),

/***/ "tjmq":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("U1KF");
var createDesc = __webpack_require__("WWmS");
module.exports = __webpack_require__("GGqZ") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "trMS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

exports.__esModule = true;
exports["default"] = void 0;

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _inheritsLoose2 = _interopRequireDefault(__webpack_require__("QKC2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _scrollBehavior = _interopRequireDefault(__webpack_require__("/sSm"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _history = __webpack_require__("ELdr");

var _StateStorage = _interopRequireDefault(__webpack_require__("T9om"));

var propTypes = {
  shouldUpdateScroll: _propTypes["default"].func,
  children: _propTypes["default"].element.isRequired,
  location: _propTypes["default"].object.isRequired
};
var childContextTypes = {
  scrollBehavior: _propTypes["default"].object.isRequired
};

var ScrollContext = /*#__PURE__*/function (_React$Component) {
  (0, _inheritsLoose2["default"])(ScrollContext, _React$Component);

  function ScrollContext(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "shouldUpdateScroll", function (prevRouterProps, routerProps) {
      var shouldUpdateScroll = _this.props.shouldUpdateScroll;

      if (!shouldUpdateScroll) {
        return true;
      } // Hack to allow accessing scrollBehavior._stateStorage.


      return shouldUpdateScroll.call(_this.scrollBehavior, prevRouterProps, routerProps);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "registerElement", function (key, element, shouldUpdateScroll) {
      _this.scrollBehavior.registerElement(key, element, shouldUpdateScroll, _this.getRouterProps());
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "unregisterElement", function (key) {
      _this.scrollBehavior.unregisterElement(key);
    });
    _this.scrollBehavior = new _scrollBehavior["default"]({
      addTransitionHook: _history.globalHistory.listen,
      stateStorage: new _StateStorage["default"](),
      getCurrentLocation: function getCurrentLocation() {
        return _this.props.location;
      },
      shouldUpdateScroll: _this.shouldUpdateScroll
    });
    return _this;
  }

  var _proto = ScrollContext.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      scrollBehavior: this
    };
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var location = this.props.location;
    var prevLocation = prevProps.location;

    if (location === prevLocation) {
      return;
    }

    var prevRouterProps = {
      location: prevProps.location
    };
    this.scrollBehavior.updateScroll(prevRouterProps, {
      history: _history.globalHistory,
      location: location
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.scrollBehavior.stop();
  };

  _proto.getRouterProps = function getRouterProps() {
    var location = this.props.location;
    return {
      location: location,
      history: _history.globalHistory
    };
  };

  _proto.render = function render() {
    return _react["default"].Children.only(this.props.children);
  };

  return ScrollContext;
}(_react["default"].Component);

ScrollContext.propTypes = propTypes;
ScrollContext.childContextTypes = childContextTypes;
var _default = ScrollContext;
exports["default"] = _default;

/***/ }),

/***/ "tvu5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LayoutContext; });
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9p7t");
/* harmony import */ var core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_filter__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("V7cS");
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("PAbq");
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1qKx");
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("5hJT");
/* harmony import */ var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("d3/y");
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("+3V6");
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("lQyR");
/* harmony import */ var core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_iterator__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("YhIr");
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("4aJ6");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es6_date_to_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("M/4x");
/* harmony import */ var core_js_modules_es6_date_to_string__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_date_to_string__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("W1QL");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("+jjx");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("ABKx");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("8Jek");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _config_provider__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("Bfez");
















function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var LayoutContext = react__WEBPACK_IMPORTED_MODULE_15__["createContext"]({
  siderHook: {
    addSider: function addSider() {
      return null;
    },
    removeSider: function removeSider() {
      return null;
    }
  }
});

function generator(_ref) {
  var suffixCls = _ref.suffixCls,
      tagName = _ref.tagName,
      displayName = _ref.displayName;
  return function (BasicComponent) {
    var _a;

    return _a = /*#__PURE__*/function (_React$Component) {
      _inherits(Adapter, _React$Component);

      function Adapter() {
        var _this;

        _classCallCheck(this, Adapter);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Adapter).apply(this, arguments));

        _this.renderComponent = function (_ref2) {
          var getPrefixCls = _ref2.getPrefixCls;
          var customizePrefixCls = _this.props.prefixCls;
          var prefixCls = getPrefixCls(suffixCls, customizePrefixCls);
          return react__WEBPACK_IMPORTED_MODULE_15__["createElement"](BasicComponent, _extends({
            prefixCls: prefixCls,
            tagName: tagName
          }, _this.props));
        };

        return _this;
      }

      _createClass(Adapter, [{
        key: "render",
        value: function render() {
          return react__WEBPACK_IMPORTED_MODULE_15__["createElement"](_config_provider__WEBPACK_IMPORTED_MODULE_17__[/* ConfigConsumer */ "a"], null, this.renderComponent);
        }
      }]);

      return Adapter;
    }(react__WEBPACK_IMPORTED_MODULE_15__["Component"]), _a.displayName = displayName, _a;
  };
}

var Basic = function Basic(props) {
  var prefixCls = props.prefixCls,
      className = props.className,
      children = props.children,
      tagName = props.tagName,
      others = __rest(props, ["prefixCls", "className", "children", "tagName"]);

  var classString = classnames__WEBPACK_IMPORTED_MODULE_16___default()(prefixCls, className);
  return react__WEBPACK_IMPORTED_MODULE_15__["createElement"](tagName, _extends({
    className: classString
  }, others), children);
};

var BasicLayout = /*#__PURE__*/function (_React$Component2) {
  _inherits(BasicLayout, _React$Component2);

  function BasicLayout() {
    var _this2;

    _classCallCheck(this, BasicLayout);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(BasicLayout).apply(this, arguments));
    _this2.state = {
      siders: []
    };

    _this2.renderComponent = function (_ref3) {
      var _classNames;

      var direction = _ref3.direction;

      var _a = _this2.props,
          prefixCls = _a.prefixCls,
          className = _a.className,
          children = _a.children,
          hasSider = _a.hasSider,
          Tag = _a.tagName,
          others = __rest(_a, ["prefixCls", "className", "children", "hasSider", "tagName"]);

      var classString = classnames__WEBPACK_IMPORTED_MODULE_16___default()(prefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-has-sider"), typeof hasSider === 'boolean' ? hasSider : _this2.state.siders.length > 0), _defineProperty(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames), className);
      return react__WEBPACK_IMPORTED_MODULE_15__["createElement"](LayoutContext.Provider, {
        value: {
          siderHook: _this2.getSiderHook()
        }
      }, react__WEBPACK_IMPORTED_MODULE_15__["createElement"](Tag, _extends({
        className: classString
      }, others), children));
    };

    return _this2;
  }

  _createClass(BasicLayout, [{
    key: "getSiderHook",
    value: function getSiderHook() {
      var _this3 = this;

      return {
        addSider: function addSider(id) {
          _this3.setState(function (state) {
            return {
              siders: [].concat(_toConsumableArray(state.siders), [id])
            };
          });
        },
        removeSider: function removeSider(id) {
          _this3.setState(function (state) {
            return {
              siders: state.siders.filter(function (currentId) {
                return currentId !== id;
              })
            };
          });
        }
      };
    }
  }, {
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_15__["createElement"](_config_provider__WEBPACK_IMPORTED_MODULE_17__[/* ConfigConsumer */ "a"], null, this.renderComponent);
    }
  }]);

  return BasicLayout;
}(react__WEBPACK_IMPORTED_MODULE_15__["Component"]);

var Layout = generator({
  suffixCls: 'layout',
  tagName: 'section',
  displayName: 'Layout'
})(BasicLayout);
var Header = generator({
  suffixCls: 'layout-header',
  tagName: 'header',
  displayName: 'Header'
})(Basic);
var Footer = generator({
  suffixCls: 'layout-footer',
  tagName: 'footer',
  displayName: 'Footer'
})(Basic);
var Content = generator({
  suffixCls: 'layout-content',
  tagName: 'main',
  displayName: 'Content'
})(Basic);
Layout.Header = Header;
Layout.Footer = Footer;
Layout.Content = Content;
/* harmony default export */ __webpack_exports__["b"] = (Layout);

/***/ }),

/***/ "uLh5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // do not edit .js files directly - edit src/index.jst

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("75LO");

__webpack_require__("4aJ6");

__webpack_require__("M/4x");

__webpack_require__("t91x");

__webpack_require__("iur1");

__webpack_require__("J8hF");

__webpack_require__("+3V6");

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;
    var length, i, keys;

    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!equal(a[i], b[i])) return false;
      }

      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    }

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (key === '_owner' && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner.
        //  _owner contains circular references
        // and is not needed when comparing the actual elements (and not their owners)
        continue;
      }

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  } // true if both NaN, false otherwise


  return a !== a && b !== b;
};

/***/ }),

/***/ "uRBY":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("mvii");
var defined = __webpack_require__("GCOZ");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "uSgx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storeShape = undefined;

var _propTypes = __webpack_require__("W0B4");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var storeShape = exports.storeShape = _propTypes2["default"].shape({
  subscribe: _propTypes2["default"].func.isRequired,
  setState: _propTypes2["default"].func.isRequired,
  getState: _propTypes2["default"].func.isRequired
});

/***/ }),

/***/ "uUP6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

__webpack_require__("5hJT");

__webpack_require__("yIlq");

var assertType = __webpack_require__("yCBR");

var assertFunction = __webpack_require__("nAPr");

var _require = __webpack_require__("sMOp"),
    union = _require.union,
    derivations = _require.derivations;

var provideAliases = __webpack_require__("JiyH");

var warnDeprecation = __webpack_require__("GFZo");

var adtMethods = __webpack_require__("cl25");

var extend = __webpack_require__("0ONX");

var equality = derivations.equality,
    debugRepresentation = derivations.debugRepresentation,
    serialization = derivations.serialization;
/*~ stability: stable */

var Maybe = union('folktale:Maybe', {
  /*~
   * type: |
   *   forall a: () => Maybe a
   */
  Nothing: function Nothing() {},

  /*~
   * type: |
   *   forall a: (a) => Maybe a
   */
  Just: function Just(value) {
    return {
      value: value
    };
  }
}).derive(equality, debugRepresentation, serialization);
var Nothing = Maybe.Nothing,
    _Just = Maybe.Just;
var assertMaybe = assertType(Maybe);
extend(_Just.prototype, {
  /*~
   * isRequired: true
   * type: |
   *   forall a: get (Maybe a) => a
   */
  get value() {
    throw new TypeError('`value` can’t be accessed in an abstract instance of Maybe.Just');
  }

});
/*~~belongsTo: Maybe */

adtMethods(Maybe, {
  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Maybe a).((a) => b) => Maybe b
   */
  map: {
    /*~*/
    Nothing: function map(transformation) {
      assertFunction('Maybe.Nothing#map', transformation);
      return this;
    },

    /*~*/
    Just: function map(transformation) {
      assertFunction('Maybe.Just#map', transformation);
      return _Just(transformation(this.value));
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Maybe (a) => b).(Maybe a) => Maybe b
   */
  apply: {
    /*~*/
    Nothing: function apply(aMaybe) {
      assertMaybe('Maybe.Nothing#apply', aMaybe);
      return this;
    },

    /*~*/
    Just: function apply(aMaybe) {
      assertMaybe('Maybe.Just#apply', aMaybe);
      return aMaybe.map(this.value);
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Maybe a).((a) => Maybe b) => Maybe b
   */
  chain: {
    /*~*/
    Nothing: function chain(transformation) {
      assertFunction('Maybe.Nothing#chain', transformation);
      return this;
    },

    /*~*/
    Just: function chain(transformation) {
      assertFunction('Maybe.Just#chain', transformation);
      return transformation(this.value);
    }
  },

  /*~
   * type: |
   *   forall a: (Maybe a).() => a :: (throws TypeError)
   */
  unsafeGet: {
    /*~*/
    Nothing: function unsafeGet() {
      throw new TypeError('Can\'t extract the value of a Nothing.\n\n    Since Nothing holds no values, it\'s not possible to extract one from them.\n    You might consider switching from Maybe#get to Maybe#getOrElse, or some other method\n    that is not partial.\n      ');
    },

    /*~*/
    Just: function unsafeGet() {
      return this.value;
    }
  },

  /*~
   * type: |
   *   forall a: (Maybe a).(a) => a
   */
  getOrElse: {
    /*~*/
    Nothing: function getOrElse(_default) {
      return _default;
    },

    /*~*/
    Just: function getOrElse(_default) {
      return this.value;
    }
  },

  /*~
   * type: |
   *   forall a: (Maybe a).((a) => Maybe a) => Maybe a
   */
  orElse: {
    /*~*/
    Nothing: function orElse(handler) {
      assertFunction('Maybe.Nothing#orElse', handler);
      return handler(this.value);
    },

    /*~*/
    Just: function orElse(handler) {
      assertFunction('Maybe.Nothing#orElse', handler);
      return this;
    }
  },

  /*~
   * authors:
   *   - "@diasbruno"
   * type: |
   *   forall a: (Maybe a).(Maybe a) => Maybe a
   *   where a is Semigroup
   */
  concat: {
    /*~*/
    Nothing: function concat(aMaybe) {
      assertMaybe('Maybe.Nothing#concat', aMaybe);
      return aMaybe;
    },

    /*~*/
    Just: function concat(aMaybe) {
      var _this = this;

      assertMaybe('Maybe.Just#concat', aMaybe);
      return aMaybe.matchWith({
        Nothing: function Nothing() {
          return _Just(_this.value);
        },
        Just: function Just(a) {
          return _Just(_this.value.concat(a.value));
        }
      });
    }
  },

  /*~
   * deprecated:
   *   since: 2.0.0
   *   replacedBy: .matchWith(pattern)
   *
   * type: |
   *   forall a, b:
   *     (Maybe a).({
   *       Nothing: () => b,
   *       Just: (a) => b
   *     }) => b
   */
  cata: {
    /*~*/
    Nothing: function cata(pattern) {
      warnDeprecation('`.cata(pattern)` is deprecated. Use `.matchWith(pattern)` instead.');
      return pattern.Nothing();
    },

    /*~*/
    Just: function cata(pattern) {
      warnDeprecation('`.cata(pattern)` is deprecated. Use `.matchWith(pattern)` instead.');
      return pattern.Just(this.value);
    }
  },

  /*~
   * type: |
   *   forall a, b: (Maybe a).(() => b, (a) => b) => b
   */
  fold: {
    /*~*/
    Nothing: function Nothing(transformNothing, transformJust) {
      assertFunction('Maybe.Nothing#fold', transformNothing);
      assertFunction('Maybe.Nothing#fold', transformJust);
      return transformNothing();
    },

    /*~*/
    Just: function Just(transformNothing, transformJust) {
      assertFunction('Maybe.Just#fold', transformNothing);
      assertFunction('Maybe.Just#fold', transformJust);
      return transformJust(this.value);
    }
  },

  /*~
   * stability: stable
   * type: |
   *   forall a: (Maybe a).((a) => Boolean) => Maybe a
   */
  filter: {
    /*~*/
    Nothing: function filter(predicate) {
      assertFunction('Maybe.Nothing#filter', predicate);
      return this;
    },

    /*~*/
    Just: function filter(predicate) {
      assertFunction('Maybe.Just#filter', predicate);
      return predicate(this.value) ? this : Nothing();
    }
  },

  /*~
   * authors:
   *   - "@joshmili"
   * type: |
   *   forall a: (Maybe a).(Maybe a) => Maybe a
   */
  or: {
    /*~*/
    Nothing: function alt(aMaybe) {
      assertMaybe('Maybe.Nothing#or', aMaybe);
      return aMaybe;
    },

    /*~*/
    Just: function alt(aMaybe) {
      assertMaybe('Maybe.Just#or', aMaybe);
      return this;
    }
  }
});
Object.assign(Maybe, {
  /*~
   * stability: stable
   * type: |
   *   forall a: (a) => Maybe a
   */
  of: function of(value) {
    return _Just(value);
  },

  /*~
   * authors:
   *   - "@diasbruno"
   * type: |
   *   forall a: () => Maybe a
   */
  empty: function empty() {
    return Nothing();
  },

  /*~
   * deprecated:
   *   since: 2.0.0
   *   replacedBy: .unsafeGet()
   * type: |
   *   forall a: (Maybe a).() => a :: (throws TypeError)
   */
  'get': function get() {
    warnDeprecation('`.get()` is deprecated, and has been renamed to `.unsafeGet()`.');
    return this.unsafeGet();
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Maybe a).(b) => Result b a
   */
  toResult: function toResult(fallbackValue) {
    return __webpack_require__("pS6Z")(this, fallbackValue);
  },

  /*~
   * stability: stable
   * type: |
   *   forall a, b: (Maybe a).(b) => Result b a
   */
  toValidation: function toValidation(fallbackValue) {
    return __webpack_require__("3PM6")(this, fallbackValue);
  }
});
provideAliases(_Just.prototype);
provideAliases(Nothing.prototype);
provideAliases(Maybe);
module.exports = Maybe;

/***/ }),

/***/ "uoK5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__("GkPX");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.is-array.js
var es6_array_is_array = __webpack_require__("+3V6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.to-string.js
var es6_date_to_string = __webpack_require__("M/4x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-properties.js
var es6_object_define_properties = __webpack_require__("6/FK");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("2Tod");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/es/utils.js
var utils = __webpack_require__("Y8EE");

// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/components/IconBase.js













function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var twoToneColorPalette = {
  primaryColor: '#333',
  secondaryColor: '#E6E6E6',
  calculated: false
};

function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor,
      secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || Object(utils["b" /* getSecondaryColor */])(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}

function getTwoToneColors() {
  return _objectSpread({}, twoToneColorPalette);
}

var IconBase_IconBase = function IconBase(props) {
  var icon = props.icon,
      className = props.className,
      onClick = props.onClick,
      style = props.style,
      primaryColor = props.primaryColor,
      secondaryColor = props.secondaryColor,
      restProps = _objectWithoutProperties(props, ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"]);

  var colors = twoToneColorPalette;

  if (primaryColor) {
    colors = {
      primaryColor: primaryColor,
      secondaryColor: secondaryColor || Object(utils["b" /* getSecondaryColor */])(primaryColor)
    };
  }

  Object(utils["f" /* useInsertStyles */])();
  Object(utils["g" /* warning */])(Object(utils["c" /* isIconDefinition */])(icon), "icon should be icon definiton, but got ".concat(icon));

  if (!Object(utils["c" /* isIconDefinition */])(icon)) {
    return null;
  }

  var target = icon;

  if (target && typeof target.icon === 'function') {
    target = _objectSpread({}, target, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }

  return Object(utils["a" /* generate */])(target.icon, "svg-".concat(target.name), _objectSpread({
    className: className,
    onClick: onClick,
    style: style,
    'data-icon': target.name,
    width: '1em',
    height: '1em',
    fill: 'currentColor',
    'aria-hidden': 'true'
  }, restProps));
};

IconBase_IconBase.displayName = 'IconReact';
IconBase_IconBase.getTwoToneColors = getTwoToneColors;
IconBase_IconBase.setTwoToneColors = setTwoToneColors;
/* harmony default export */ var components_IconBase = (IconBase_IconBase);
// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/components/twoTonePrimaryColor.js








function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}



function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = Object(utils["d" /* normalizeTwoToneColors */])(twoToneColor),
      _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
      primaryColor = _normalizeTwoToneColo2[0],
      secondaryColor = _normalizeTwoToneColo2[1];

  return components_IconBase.setTwoToneColors({
    primaryColor: primaryColor,
    secondaryColor: secondaryColor
  });
}
function getTwoToneColor() {
  var colors = components_IconBase.getTwoToneColors();

  if (!colors.calculated) {
    return colors.primaryColor;
  }

  return [colors.primaryColor, colors.secondaryColor];
}
// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/components/AntdIcon.js














function AntdIcon_slicedToArray(arr, i) {
  return AntdIcon_arrayWithHoles(arr) || AntdIcon_iterableToArrayLimit(arr, i) || AntdIcon_nonIterableRest();
}

function AntdIcon_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function AntdIcon_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function AntdIcon_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function AntdIcon_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function AntdIcon_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = AntdIcon_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function AntdIcon_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}





 // Initial setting
// should move it to antd main repo?

setTwoToneColor('#1890ff');
var Icon = react_default.a.forwardRef(function (props, ref) {
  var className = props.className,
      icon = props.icon,
      spin = props.spin,
      rotate = props.rotate,
      tabIndex = props.tabIndex,
      onClick = props.onClick,
      twoToneColor = props.twoToneColor,
      restProps = AntdIcon_objectWithoutProperties(props, ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"]);

  var classString = classnames_default()('anticon', AntdIcon_defineProperty({}, "anticon-".concat(icon.name), Boolean(icon.name)), className);
  var svgClassString = classnames_default()({
    'anticon-spin': !!spin || icon.name === 'loading'
  });
  var iconTabIndex = tabIndex;

  if (iconTabIndex === undefined && onClick) {
    iconTabIndex = -1;
  }

  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : undefined;

  var _normalizeTwoToneColo = Object(utils["d" /* normalizeTwoToneColors */])(twoToneColor),
      _normalizeTwoToneColo2 = AntdIcon_slicedToArray(_normalizeTwoToneColo, 2),
      primaryColor = _normalizeTwoToneColo2[0],
      secondaryColor = _normalizeTwoToneColo2[1];

  return react_default.a.createElement("span", Object.assign({
    role: "img",
    "aria-label": icon.name
  }, restProps, {
    ref: ref,
    tabIndex: iconTabIndex,
    onClick: onClick,
    className: classString
  }), react_default.a.createElement(components_IconBase, {
    className: svgClassString,
    icon: icon,
    primaryColor: primaryColor,
    secondaryColor: secondaryColor,
    style: svgStyle
  }));
});
Icon.displayName = 'AntdIcon';
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
/* harmony default export */ var AntdIcon = __webpack_exports__["a"] = (Icon);

/***/ }),

/***/ "v5c9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ menu_Menu; });

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.to-string.js
var es6_date_to_string = __webpack_require__("M/4x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.is-array.js
var es6_array_is_array = __webpack_require__("+3V6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-properties.js
var es6_object_define_properties = __webpack_require__("6/FK");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("2Tod");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/mini-store/lib/index.js
var lib = __webpack_require__("zSCU");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.bind.js
var es6_function_bind = __webpack_require__("o7PZ");

// EXTERNAL MODULE: ../node_modules/rc-util/es/KeyCode.js
var KeyCode = __webpack_require__("zAXs");

// EXTERNAL MODULE: ../node_modules/rc-util/es/createChainedFunction.js
var createChainedFunction = __webpack_require__("eDOA");

// EXTERNAL MODULE: ../node_modules/shallowequal/index.js
var shallowequal = __webpack_require__("F56x");
var shallowequal_default = /*#__PURE__*/__webpack_require__.n(shallowequal);

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.find.js
var es6_array_find = __webpack_require__("it7j");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__("asZ9");

// CONCATENATED MODULE: ../node_modules/rc-menu/es/utils/isMobile.js
















function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
} // MIT License from https://github.com/kaimallea/isMobile


var applePhone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i; // Match 'Android' AND 'Mobile'

var androidTablet = /Android/i;
var amazonPhone = /\bAndroid(?:.+)SD4930UR\b/i;
var amazonTablet = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i; // Match 'Windows' AND 'ARM'

var otherBlackberry = /BlackBerry/i;
var otherBlackberry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i; // Match 'Mobile' AND 'Firefox'

function match(regex, userAgent) {
  return regex.test(userAgent);
}

function isMobile(userAgent) {
  var ua = userAgent || (typeof navigator !== 'undefined' ? navigator.userAgent : ''); // Facebook mobile app's integrated browser adds a bunch of strings that
  // match everything. Strip it out if it exists.

  var tmp = ua.split('[FBAN');

  if (typeof tmp[1] !== 'undefined') {
    var _tmp = tmp;

    var _tmp2 = _slicedToArray(_tmp, 1);

    ua = _tmp2[0];
  } // Twitter mobile app's integrated browser on iPad adds a "Twitter for
  // iPhone" string. Same probably happens on other tablet platforms.
  // This will confuse detection so strip it out if it exists.


  tmp = ua.split('Twitter');

  if (typeof tmp[1] !== 'undefined') {
    var _tmp3 = tmp;

    var _tmp4 = _slicedToArray(_tmp3, 1);

    ua = _tmp4[0];
  }

  var result = {
    apple: {
      phone: match(applePhone, ua) && !match(windowsPhone, ua),
      ipod: match(appleIpod, ua),
      tablet: !match(applePhone, ua) && match(appleTablet, ua) && !match(windowsPhone, ua),
      device: (match(applePhone, ua) || match(appleIpod, ua) || match(appleTablet, ua)) && !match(windowsPhone, ua)
    },
    amazon: {
      phone: match(amazonPhone, ua),
      tablet: !match(amazonPhone, ua) && match(amazonTablet, ua),
      device: match(amazonPhone, ua) || match(amazonTablet, ua)
    },
    android: {
      phone: !match(windowsPhone, ua) && match(amazonPhone, ua) || !match(windowsPhone, ua) && match(androidPhone, ua),
      tablet: !match(windowsPhone, ua) && !match(amazonPhone, ua) && !match(androidPhone, ua) && (match(amazonTablet, ua) || match(androidTablet, ua)),
      device: !match(windowsPhone, ua) && (match(amazonPhone, ua) || match(amazonTablet, ua) || match(androidPhone, ua) || match(androidTablet, ua)) || match(/\bokhttp\b/i, ua)
    },
    windows: {
      phone: match(windowsPhone, ua),
      tablet: match(windowsTablet, ua),
      device: match(windowsPhone, ua) || match(windowsTablet, ua)
    },
    other: {
      blackberry: match(otherBlackberry, ua),
      blackberry10: match(otherBlackberry10, ua),
      opera: match(otherOpera, ua),
      firefox: match(otherFirefox, ua),
      chrome: match(otherChrome, ua),
      device: match(otherBlackberry, ua) || match(otherBlackberry10, ua) || match(otherOpera, ua) || match(otherFirefox, ua) || match(otherChrome, ua)
    },
    // Additional
    any: null,
    phone: null,
    tablet: null
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device; // excludes 'other' devices and ipods, targeting touchscreen phones

  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}

var defaultResult = _objectSpread({}, isMobile(), {
  isMobile: isMobile
});

/* harmony default export */ var utils_isMobile = (defaultResult);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/util.js






function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}



function noop() {}
function getKeyFromChildrenIndex(child, menuEventKey, index) {
  var prefix = menuEventKey || '';
  return child.key || "".concat(prefix, "item_").concat(index);
}
function getMenuIdFromSubMenuEventKey(eventKey) {
  return "".concat(eventKey, "-menu-");
}
function loopMenuItem(children, cb) {
  var index = -1;
  react_default.a.Children.forEach(children, function (c) {
    index += 1;

    if (c && c.type && c.type.isMenuItemGroup) {
      react_default.a.Children.forEach(c.props.children, function (c2) {
        index += 1;
        cb(c2, index);
      });
    } else {
      cb(c, index);
    }
  });
}
function loopMenuItemRecursively(children, keys, ret) {
  /* istanbul ignore if */
  if (!children || ret.find) {
    return;
  }

  react_default.a.Children.forEach(children, function (c) {
    if (c) {
      var construct = c.type;

      if (!construct || !(construct.isSubMenu || construct.isMenuItem || construct.isMenuItemGroup)) {
        return;
      }

      if (keys.indexOf(c.key) !== -1) {
        ret.find = true;
      } else if (c.props.children) {
        loopMenuItemRecursively(c.props.children, keys, ret);
      }
    }
  });
}
var menuAllProps = ['defaultSelectedKeys', 'selectedKeys', 'defaultOpenKeys', 'openKeys', 'mode', 'getPopupContainer', 'onSelect', 'onDeselect', 'onDestroy', 'openTransitionName', 'openAnimation', 'subMenuOpenDelay', 'subMenuCloseDelay', 'forceSubMenuRender', 'triggerSubMenuAction', 'level', 'selectable', 'multiple', 'onOpenChange', 'visible', 'focusable', 'defaultActiveFirst', 'prefixCls', 'inlineIndent', 'parentMenu', 'title', 'rootPrefixCls', 'eventKey', 'active', 'onItemHover', 'onTitleMouseEnter', 'onTitleMouseLeave', 'onTitleClick', 'popupAlign', 'popupOffset', 'isOpen', 'renderMenuItem', 'manualRef', 'subMenuKey', 'disabled', 'index', 'isSelected', 'store', 'activeKey', 'builtinPlacements', 'overflowedIndicator', 'motion', // the following keys found need to be removed from test regression
'attribute', 'value', 'popupClassName', 'inlineCollapsed', 'menu', 'theme', 'itemIcon', 'expandIcon']; // ref: https://github.com/ant-design/ant-design/issues/14007
// ref: https://bugs.chromium.org/p/chromium/issues/detail?id=360889
// getBoundingClientRect return the full precision value, which is
// not the same behavior as on chrome. Set the precision to 6 to
// unify their behavior

var getWidth = function getWidth(elem) {
  var width = elem && typeof elem.getBoundingClientRect === 'function' && elem.getBoundingClientRect().width;

  if (width) {
    width = +width.toFixed(6);
  }

  return width || 0;
};
var setStyle = function setStyle(elem, styleProperty, value) {
  if (elem && _typeof(elem.style) === 'object') {
    elem.style[styleProperty] = value;
  }
};
var util_isMobileDevice = function isMobileDevice() {
  return utils_isMobile.any;
};
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.reduce.js
var es6_array_reduce = __webpack_require__("3y5y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.iterator.js
var es6_string_iterator = __webpack_require__("lQyR");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.from.js
var es6_array_from = __webpack_require__("YhIr");

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__("iXzu");

// EXTERNAL MODULE: ../node_modules/rc-trigger/es/index.js + 11 modules
var es = __webpack_require__("mPTt");

// EXTERNAL MODULE: ../node_modules/rc-animate/es/CSSMotion.js
var CSSMotion = __webpack_require__("67vp");

// CONCATENATED MODULE: ../node_modules/rc-menu/es/placements.js
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  rightTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  leftTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
/* harmony default export */ var es_placements = (placements);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/SubMenu.js
















function SubMenu_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    SubMenu_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    SubMenu_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return SubMenu_typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (SubMenu_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function SubMenu_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function SubMenu_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      SubMenu_ownKeys(Object(source), true).forEach(function (key) {
        SubMenu_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      SubMenu_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function SubMenu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}











var guid = 0;
var popupPlacementMap = {
  horizontal: 'bottomLeft',
  vertical: 'rightTop',
  'vertical-left': 'rightTop',
  'vertical-right': 'leftTop'
};

var SubMenu_updateDefaultActiveFirst = function updateDefaultActiveFirst(store, eventKey, defaultActiveFirst) {
  var menuId = getMenuIdFromSubMenuEventKey(eventKey);
  var state = store.getState();
  store.setState({
    defaultActiveFirst: SubMenu_objectSpread({}, state.defaultActiveFirst, SubMenu_defineProperty({}, menuId, defaultActiveFirst))
  });
};

var SubMenu_SubMenu = /*#__PURE__*/function (_React$Component) {
  _inherits(SubMenu, _React$Component);

  function SubMenu(props) {
    var _this;

    _classCallCheck(this, SubMenu);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SubMenu).call(this, props));

    _this.onDestroy = function (key) {
      _this.props.onDestroy(key);
    };
    /**
     * note:
     *  This legacy code that `onKeyDown` is called by parent instead of dom self.
     *  which need return code to check if this event is handled
     */


    _this.onKeyDown = function (e) {
      var keyCode = e.keyCode;
      var menu = _this.menuInstance;
      var _this$props = _this.props,
          isOpen = _this$props.isOpen,
          store = _this$props.store;

      if (keyCode === KeyCode["a" /* default */].ENTER) {
        _this.onTitleClick(e);

        SubMenu_updateDefaultActiveFirst(store, _this.props.eventKey, true);
        return true;
      }

      if (keyCode === KeyCode["a" /* default */].RIGHT) {
        if (isOpen) {
          menu.onKeyDown(e);
        } else {
          _this.triggerOpenChange(true); // need to update current menu's defaultActiveFirst value


          SubMenu_updateDefaultActiveFirst(store, _this.props.eventKey, true);
        }

        return true;
      }

      if (keyCode === KeyCode["a" /* default */].LEFT) {
        var handled;

        if (isOpen) {
          handled = menu.onKeyDown(e);
        } else {
          return undefined;
        }

        if (!handled) {
          _this.triggerOpenChange(false);

          handled = true;
        }

        return handled;
      }

      if (isOpen && (keyCode === KeyCode["a" /* default */].UP || keyCode === KeyCode["a" /* default */].DOWN)) {
        return menu.onKeyDown(e);
      }

      return undefined;
    };

    _this.onOpenChange = function (e) {
      _this.props.onOpenChange(e);
    };

    _this.onPopupVisibleChange = function (visible) {
      _this.triggerOpenChange(visible, visible ? 'mouseenter' : 'mouseleave');
    };

    _this.onMouseEnter = function (e) {
      var _this$props2 = _this.props,
          key = _this$props2.eventKey,
          onMouseEnter = _this$props2.onMouseEnter,
          store = _this$props2.store;
      SubMenu_updateDefaultActiveFirst(store, _this.props.eventKey, false);
      onMouseEnter({
        key: key,
        domEvent: e
      });
    };

    _this.onMouseLeave = function (e) {
      var _this$props3 = _this.props,
          parentMenu = _this$props3.parentMenu,
          eventKey = _this$props3.eventKey,
          onMouseLeave = _this$props3.onMouseLeave;
      parentMenu.subMenuInstance = _assertThisInitialized(_this);
      onMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    _this.onTitleMouseEnter = function (domEvent) {
      var _this$props4 = _this.props,
          key = _this$props4.eventKey,
          onItemHover = _this$props4.onItemHover,
          onTitleMouseEnter = _this$props4.onTitleMouseEnter;
      onItemHover({
        key: key,
        hover: true
      });
      onTitleMouseEnter({
        key: key,
        domEvent: domEvent
      });
    };

    _this.onTitleMouseLeave = function (e) {
      var _this$props5 = _this.props,
          parentMenu = _this$props5.parentMenu,
          eventKey = _this$props5.eventKey,
          onItemHover = _this$props5.onItemHover,
          onTitleMouseLeave = _this$props5.onTitleMouseLeave;
      parentMenu.subMenuInstance = _assertThisInitialized(_this);
      onItemHover({
        key: eventKey,
        hover: false
      });
      onTitleMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    _this.onTitleClick = function (e) {
      var _assertThisInitialize = _assertThisInitialized(_this),
          props = _assertThisInitialize.props;

      props.onTitleClick({
        key: props.eventKey,
        domEvent: e
      });

      if (props.triggerSubMenuAction === 'hover') {
        return;
      }

      _this.triggerOpenChange(!props.isOpen, 'click');

      SubMenu_updateDefaultActiveFirst(props.store, _this.props.eventKey, false);
    };

    _this.onSubMenuClick = function (info) {
      // in the case of overflowed submenu
      // onClick is not copied over
      if (typeof _this.props.onClick === 'function') {
        _this.props.onClick(_this.addKeyPath(info));
      }
    };

    _this.onSelect = function (info) {
      _this.props.onSelect(info);
    };

    _this.onDeselect = function (info) {
      _this.props.onDeselect(info);
    };

    _this.getPrefixCls = function () {
      return "".concat(_this.props.rootPrefixCls, "-submenu");
    };

    _this.getActiveClassName = function () {
      return "".concat(_this.getPrefixCls(), "-active");
    };

    _this.getDisabledClassName = function () {
      return "".concat(_this.getPrefixCls(), "-disabled");
    };

    _this.getSelectedClassName = function () {
      return "".concat(_this.getPrefixCls(), "-selected");
    };

    _this.getOpenClassName = function () {
      return "".concat(_this.props.rootPrefixCls, "-submenu-open");
    };

    _this.saveMenuInstance = function (c) {
      // children menu instance
      _this.menuInstance = c;
    };

    _this.addKeyPath = function (info) {
      return SubMenu_objectSpread({}, info, {
        keyPath: (info.keyPath || []).concat(_this.props.eventKey)
      });
    };

    _this.triggerOpenChange = function (open, type) {
      var key = _this.props.eventKey;

      var openChange = function openChange() {
        _this.onOpenChange({
          key: key,
          item: _assertThisInitialized(_this),
          trigger: type,
          open: open
        });
      };

      if (type === 'mouseenter') {
        // make sure mouseenter happen after other menu item's mouseleave
        _this.mouseenterTimeout = setTimeout(function () {
          openChange();
        }, 0);
      } else {
        openChange();
      }
    };

    _this.isChildrenSelected = function () {
      var ret = {
        find: false
      };
      loopMenuItemRecursively(_this.props.children, _this.props.selectedKeys, ret);
      return ret.find;
    };

    _this.isOpen = function () {
      return _this.props.openKeys.indexOf(_this.props.eventKey) !== -1;
    };

    _this.adjustWidth = function () {
      /* istanbul ignore if */
      if (!_this.subMenuTitle || !_this.menuInstance) {
        return;
      }

      var popupMenu = react_dom_default.a.findDOMNode(_this.menuInstance);

      if (popupMenu.offsetWidth >= _this.subMenuTitle.offsetWidth) {
        return;
      }
      /* istanbul ignore next */


      popupMenu.style.minWidth = "".concat(_this.subMenuTitle.offsetWidth, "px");
    };

    _this.saveSubMenuTitle = function (subMenuTitle) {
      _this.subMenuTitle = subMenuTitle;
    };

    _this.getBaseProps = function () {
      var _assertThisInitialize2 = _assertThisInitialized(_this),
          props = _assertThisInitialize2.props;

      return {
        mode: props.mode === 'horizontal' ? 'vertical' : props.mode,
        visible: _this.props.isOpen,
        level: props.level + 1,
        inlineIndent: props.inlineIndent,
        focusable: false,
        onClick: _this.onSubMenuClick,
        onSelect: _this.onSelect,
        onDeselect: _this.onDeselect,
        onDestroy: _this.onDestroy,
        selectedKeys: props.selectedKeys,
        eventKey: "".concat(props.eventKey, "-menu-"),
        openKeys: props.openKeys,
        motion: props.motion,
        onOpenChange: _this.onOpenChange,
        subMenuOpenDelay: props.subMenuOpenDelay,
        parentMenu: _assertThisInitialized(_this),
        subMenuCloseDelay: props.subMenuCloseDelay,
        forceSubMenuRender: props.forceSubMenuRender,
        triggerSubMenuAction: props.triggerSubMenuAction,
        builtinPlacements: props.builtinPlacements,
        defaultActiveFirst: props.store.getState().defaultActiveFirst[getMenuIdFromSubMenuEventKey(props.eventKey)],
        multiple: props.multiple,
        prefixCls: props.rootPrefixCls,
        id: _this.internalMenuId,
        manualRef: _this.saveMenuInstance,
        itemIcon: props.itemIcon,
        expandIcon: props.expandIcon,
        direction: props.direction
      };
    };

    _this.getMotion = function (mode, visible) {
      var _assertThisInitialize3 = _assertThisInitialized(_this),
          haveRendered = _assertThisInitialize3.haveRendered;

      var _this$props6 = _this.props,
          motion = _this$props6.motion,
          rootPrefixCls = _this$props6.rootPrefixCls; // don't show transition on first rendering (no animation for opened menu)
      // show appear transition if it's not visible (not sure why)
      // show appear transition if it's not inline mode

      var mergedMotion = SubMenu_objectSpread({}, motion, {
        leavedClassName: "".concat(rootPrefixCls, "-hidden"),
        removeOnLeave: false,
        motionAppear: haveRendered || !visible || mode !== 'inline'
      });

      return mergedMotion;
    };

    var store = props.store,
        eventKey = props.eventKey;

    var _store$getState = store.getState(),
        defaultActiveFirst = _store$getState.defaultActiveFirst;

    _this.isRootMenu = false;
    var value = false;

    if (defaultActiveFirst) {
      value = defaultActiveFirst[eventKey];
    }

    SubMenu_updateDefaultActiveFirst(store, eventKey, value);
    return _this;
  }

  _createClass(SubMenu, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.componentDidUpdate();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;

      var _this$props7 = this.props,
          mode = _this$props7.mode,
          parentMenu = _this$props7.parentMenu,
          manualRef = _this$props7.manualRef; // invoke customized ref to expose component to mixin

      if (manualRef) {
        manualRef(this);
      }

      if (mode !== 'horizontal' || !parentMenu.isRootMenu || !this.props.isOpen) {
        return;
      }

      this.minWidthTimeout = setTimeout(function () {
        return _this2.adjustWidth();
      }, 0);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props8 = this.props,
          onDestroy = _this$props8.onDestroy,
          eventKey = _this$props8.eventKey;

      if (onDestroy) {
        onDestroy(eventKey);
      }
      /* istanbul ignore if */


      if (this.minWidthTimeout) {
        clearTimeout(this.minWidthTimeout);
      }
      /* istanbul ignore if */


      if (this.mouseenterTimeout) {
        clearTimeout(this.mouseenterTimeout);
      }
    }
  }, {
    key: "renderChildren",
    value: function renderChildren(children) {
      var _this3 = this;

      var baseProps = this.getBaseProps(); // [Legacy] getMotion must be called before `haveRendered`

      var mergedMotion = this.getMotion(baseProps.mode, baseProps.visible);
      this.haveRendered = true;
      this.haveOpened = this.haveOpened || baseProps.visible || baseProps.forceSubMenuRender; // never rendered not planning to, don't render

      if (!this.haveOpened) {
        return react_default.a.createElement("div", null);
      }

      var direction = baseProps.direction;
      return react_default.a.createElement(CSSMotion["b" /* default */], Object.assign({
        visible: baseProps.visible
      }, mergedMotion), function (_ref) {
        var className = _ref.className,
            style = _ref.style;
        var mergedClassName = classnames_default()("".concat(baseProps.prefixCls, "-sub"), className, SubMenu_defineProperty({}, "".concat(baseProps.prefixCls, "-rtl"), direction === 'rtl'));
        return react_default.a.createElement(es_SubPopupMenu, Object.assign({}, baseProps, {
          id: _this3.internalMenuId,
          className: mergedClassName,
          style: style
        }), children);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames2;

      var props = SubMenu_objectSpread({}, this.props);

      var isOpen = props.isOpen;
      var prefixCls = this.getPrefixCls();
      var isInlineMode = props.mode === 'inline';
      var className = classnames_default()(prefixCls, "".concat(prefixCls, "-").concat(props.mode), (_classNames2 = {}, SubMenu_defineProperty(_classNames2, props.className, !!props.className), SubMenu_defineProperty(_classNames2, this.getOpenClassName(), isOpen), SubMenu_defineProperty(_classNames2, this.getActiveClassName(), props.active || isOpen && !isInlineMode), SubMenu_defineProperty(_classNames2, this.getDisabledClassName(), props.disabled), SubMenu_defineProperty(_classNames2, this.getSelectedClassName(), this.isChildrenSelected()), _classNames2));

      if (!this.internalMenuId) {
        if (props.eventKey) {
          this.internalMenuId = "".concat(props.eventKey, "$Menu");
        } else {
          guid += 1;
          this.internalMenuId = "$__$".concat(guid, "$Menu");
        }
      }

      var mouseEvents = {};
      var titleClickEvents = {};
      var titleMouseEvents = {};

      if (!props.disabled) {
        mouseEvents = {
          onMouseLeave: this.onMouseLeave,
          onMouseEnter: this.onMouseEnter
        }; // only works in title, not outer li

        titleClickEvents = {
          onClick: this.onTitleClick
        };
        titleMouseEvents = {
          onMouseEnter: this.onTitleMouseEnter,
          onMouseLeave: this.onTitleMouseLeave
        };
      }

      var style = {};
      var direction = props.direction;

      if (isInlineMode) {
        if (direction === 'rtl') {
          style.paddingRight = props.inlineIndent * props.level;
        } else {
          style.paddingLeft = props.inlineIndent * props.level;
        }
      }

      var ariaOwns = {}; // only set aria-owns when menu is open
      // otherwise it would be an invalid aria-owns value
      // since corresponding node cannot be found

      if (this.props.isOpen) {
        ariaOwns = {
          'aria-owns': this.internalMenuId
        };
      } // expand custom icon should NOT be displayed in menu with horizontal mode.


      var icon = null;

      if (props.mode !== 'horizontal') {
        icon = this.props.expandIcon; // ReactNode

        if (typeof this.props.expandIcon === 'function') {
          icon = react_default.a.createElement(this.props.expandIcon, SubMenu_objectSpread({}, this.props));
        }
      }

      var title = react_default.a.createElement("div", Object.assign({
        ref: this.saveSubMenuTitle,
        style: style,
        className: "".concat(prefixCls, "-title"),
        role: "button"
      }, titleMouseEvents, titleClickEvents, {
        "aria-expanded": isOpen
      }, ariaOwns, {
        "aria-haspopup": "true",
        title: typeof props.title === 'string' ? props.title : undefined
      }), props.title, icon || react_default.a.createElement("i", {
        className: "".concat(prefixCls, "-arrow")
      }));
      var children = this.renderChildren(props.children);
      var getPopupContainer = props.parentMenu.isRootMenu ? props.parentMenu.props.getPopupContainer : function (triggerNode) {
        return triggerNode.parentNode;
      };
      var popupPlacement = popupPlacementMap[props.mode];
      var popupAlign = props.popupOffset ? {
        offset: props.popupOffset
      } : {};
      var popupClassName = props.mode === 'inline' ? '' : props.popupClassName;
      popupClassName += direction === 'rtl' ? " ".concat(prefixCls, "-rtl") : '';
      var disabled = props.disabled,
          triggerSubMenuAction = props.triggerSubMenuAction,
          subMenuOpenDelay = props.subMenuOpenDelay,
          forceSubMenuRender = props.forceSubMenuRender,
          subMenuCloseDelay = props.subMenuCloseDelay,
          builtinPlacements = props.builtinPlacements;
      menuAllProps.forEach(function (key) {
        return delete props[key];
      }); // Set onClick to null, to ignore propagated onClick event

      delete props.onClick;
      var placement = direction === 'rtl' ? Object.assign({}, placementsRtl, builtinPlacements) : Object.assign({}, placements, builtinPlacements);
      delete props.direction;
      return react_default.a.createElement("li", Object.assign({}, props, mouseEvents, {
        className: className,
        role: "menuitem"
      }), isInlineMode && title, isInlineMode && children, !isInlineMode && react_default.a.createElement(es["a" /* default */], {
        prefixCls: prefixCls,
        popupClassName: classnames_default()("".concat(prefixCls, "-popup"), popupClassName),
        getPopupContainer: getPopupContainer,
        builtinPlacements: placement,
        popupPlacement: popupPlacement,
        popupVisible: isOpen,
        popupAlign: popupAlign,
        popup: children,
        action: disabled ? [] : [triggerSubMenuAction],
        mouseEnterDelay: subMenuOpenDelay,
        mouseLeaveDelay: subMenuCloseDelay,
        onPopupVisibleChange: this.onPopupVisibleChange,
        forceRender: forceSubMenuRender
      }, title));
    }
  }]);

  return SubMenu;
}(react_default.a.Component);
SubMenu_SubMenu.defaultProps = {
  onMouseEnter: noop,
  onMouseLeave: noop,
  onTitleMouseEnter: noop,
  onTitleMouseLeave: noop,
  onTitleClick: noop,
  manualRef: noop,
  mode: 'vertical',
  title: ''
};
var connected = Object(lib["connect"])(function (_ref2, _ref3) {
  var openKeys = _ref2.openKeys,
      activeKey = _ref2.activeKey,
      selectedKeys = _ref2.selectedKeys;
  var eventKey = _ref3.eventKey,
      subMenuKey = _ref3.subMenuKey;
  return {
    isOpen: openKeys.indexOf(eventKey) > -1,
    active: activeKey[subMenuKey] === eventKey,
    selectedKeys: selectedKeys
  };
})(SubMenu_SubMenu);
connected.isSubMenu = true;
/* harmony default export */ var es_SubMenu = (connected);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/DOMWrap.js
























function DOMWrap_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    DOMWrap_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    DOMWrap_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return DOMWrap_typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function DOMWrap_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function DOMWrap_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      DOMWrap_ownKeys(Object(source), true).forEach(function (key) {
        DOMWrap_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      DOMWrap_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function DOMWrap_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function DOMWrap_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function DOMWrap_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function DOMWrap_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) DOMWrap_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) DOMWrap_defineProperties(Constructor, staticProps);
  return Constructor;
}

function DOMWrap_possibleConstructorReturn(self, call) {
  if (call && (DOMWrap_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return DOMWrap_assertThisInitialized(self);
}

function DOMWrap_getPrototypeOf(o) {
  DOMWrap_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return DOMWrap_getPrototypeOf(o);
}

function DOMWrap_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function DOMWrap_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) DOMWrap_setPrototypeOf(subClass, superClass);
}

function DOMWrap_setPrototypeOf(o, p) {
  DOMWrap_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return DOMWrap_setPrototypeOf(o, p);
}






var MENUITEM_OVERFLOWED_CLASSNAME = 'menuitem-overflowed';
var FLOAT_PRECISION_ADJUST = 0.5;

var DOMWrap_DOMWrap = /*#__PURE__*/function (_React$Component) {
  DOMWrap_inherits(DOMWrap, _React$Component);

  function DOMWrap() {
    var _this;

    DOMWrap_classCallCheck(this, DOMWrap);

    _this = DOMWrap_possibleConstructorReturn(this, DOMWrap_getPrototypeOf(DOMWrap).apply(this, arguments));
    _this.resizeObserver = null;
    _this.mutationObserver = null; // original scroll size of the list

    _this.originalTotalWidth = 0; // copy of overflowed items

    _this.overflowedItems = []; // cache item of the original items (so we can track the size and order)

    _this.menuItemSizes = [];
    _this.state = {
      lastVisibleIndex: undefined
    }; // get all valid menuItem nodes

    _this.getMenuItemNodes = function () {
      var prefixCls = _this.props.prefixCls;
      var ul = react_dom_default.a.findDOMNode(DOMWrap_assertThisInitialized(_this));

      if (!ul) {
        return [];
      } // filter out all overflowed indicator placeholder


      return [].slice.call(ul.children).filter(function (node) {
        return node.className.split(' ').indexOf("".concat(prefixCls, "-overflowed-submenu")) < 0;
      });
    };

    _this.getOverflowedSubMenuItem = function (keyPrefix, overflowedItems, renderPlaceholder) {
      var _this$props = _this.props,
          overflowedIndicator = _this$props.overflowedIndicator,
          level = _this$props.level,
          mode = _this$props.mode,
          prefixCls = _this$props.prefixCls,
          theme = _this$props.theme;

      if (level !== 1 || mode !== 'horizontal') {
        return null;
      } // put all the overflowed item inside a submenu
      // with a title of overflow indicator ('...')


      var copy = _this.props.children[0];

      var _copy$props = copy.props,
          throwAway = _copy$props.children,
          title = _copy$props.title,
          propStyle = _copy$props.style,
          rest = _objectWithoutProperties(_copy$props, ["children", "title", "style"]);

      var style = DOMWrap_objectSpread({}, propStyle);

      var key = "".concat(keyPrefix, "-overflowed-indicator");
      var eventKey = "".concat(keyPrefix, "-overflowed-indicator");

      if (overflowedItems.length === 0 && renderPlaceholder !== true) {
        style = DOMWrap_objectSpread({}, style, {
          display: 'none'
        });
      } else if (renderPlaceholder) {
        style = DOMWrap_objectSpread({}, style, {
          visibility: 'hidden',
          // prevent from taking normal dom space
          position: 'absolute'
        });
        key = "".concat(key, "-placeholder");
        eventKey = "".concat(eventKey, "-placeholder");
      }

      var popupClassName = theme ? "".concat(prefixCls, "-").concat(theme) : '';
      var props = {};
      menuAllProps.forEach(function (k) {
        if (rest[k] !== undefined) {
          props[k] = rest[k];
        }
      });
      return react_default.a.createElement(es_SubMenu, Object.assign({
        title: overflowedIndicator,
        className: "".concat(prefixCls, "-overflowed-submenu"),
        popupClassName: popupClassName
      }, props, {
        key: key,
        eventKey: eventKey,
        disabled: false,
        style: style
      }), overflowedItems);
    }; // memorize rendered menuSize


    _this.setChildrenWidthAndResize = function () {
      if (_this.props.mode !== 'horizontal') {
        return;
      }

      var ul = react_dom_default.a.findDOMNode(DOMWrap_assertThisInitialized(_this));

      if (!ul) {
        return;
      }

      var ulChildrenNodes = ul.children;

      if (!ulChildrenNodes || ulChildrenNodes.length === 0) {
        return;
      }

      var lastOverflowedIndicatorPlaceholder = ul.children[ulChildrenNodes.length - 1]; // need last overflowed indicator for calculating length;

      setStyle(lastOverflowedIndicatorPlaceholder, 'display', 'inline-block');

      var menuItemNodes = _this.getMenuItemNodes(); // reset display attribute for all hidden elements caused by overflow to calculate updated width
      // and then reset to original state after width calculation


      var overflowedItems = menuItemNodes.filter(function (c) {
        return c.className.split(' ').indexOf(MENUITEM_OVERFLOWED_CLASSNAME) >= 0;
      });
      overflowedItems.forEach(function (c) {
        setStyle(c, 'display', 'inline-block');
      });
      _this.menuItemSizes = menuItemNodes.map(function (c) {
        return getWidth(c);
      });
      overflowedItems.forEach(function (c) {
        setStyle(c, 'display', 'none');
      });
      _this.overflowedIndicatorWidth = getWidth(ul.children[ul.children.length - 1]);
      _this.originalTotalWidth = _this.menuItemSizes.reduce(function (acc, cur) {
        return acc + cur;
      }, 0);

      _this.handleResize(); // prevent the overflowed indicator from taking space;


      setStyle(lastOverflowedIndicatorPlaceholder, 'display', 'none');
    };

    _this.handleResize = function () {
      if (_this.props.mode !== 'horizontal') {
        return;
      }

      var ul = react_dom_default.a.findDOMNode(DOMWrap_assertThisInitialized(_this));

      if (!ul) {
        return;
      }

      var width = getWidth(ul);
      _this.overflowedItems = [];
      var currentSumWidth = 0; // index for last visible child in horizontal mode

      var lastVisibleIndex; // float number comparison could be problematic
      // e.g. 0.1 + 0.2 > 0.3 =====> true
      // thus using FLOAT_PRECISION_ADJUST as buffer to help the situation

      if (_this.originalTotalWidth > width + FLOAT_PRECISION_ADJUST) {
        lastVisibleIndex = -1;

        _this.menuItemSizes.forEach(function (liWidth) {
          currentSumWidth += liWidth;

          if (currentSumWidth + _this.overflowedIndicatorWidth <= width) {
            lastVisibleIndex += 1;
          }
        });
      }

      _this.setState({
        lastVisibleIndex: lastVisibleIndex
      });
    };

    return _this;
  }

  DOMWrap_createClass(DOMWrap, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.setChildrenWidthAndResize();

      if (this.props.level === 1 && this.props.mode === 'horizontal') {
        var menuUl = react_dom_default.a.findDOMNode(this);

        if (!menuUl) {
          return;
        }

        this.resizeObserver = new ResizeObserver_es["default"](function (entries) {
          entries.forEach(_this2.setChildrenWidthAndResize);
        });
        [].slice.call(menuUl.children).concat(menuUl).forEach(function (el) {
          _this2.resizeObserver.observe(el);
        });

        if (typeof MutationObserver !== 'undefined') {
          this.mutationObserver = new MutationObserver(function () {
            _this2.resizeObserver.disconnect();

            [].slice.call(menuUl.children).concat(menuUl).forEach(function (el) {
              _this2.resizeObserver.observe(el);
            });

            _this2.setChildrenWidthAndResize();
          });
          this.mutationObserver.observe(menuUl, {
            attributes: false,
            childList: true,
            subTree: false
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }

      if (this.mutationObserver) {
        this.mutationObserver.disconnect();
      }
    }
  }, {
    key: "renderChildren",
    value: function renderChildren(children) {
      var _this3 = this; // need to take care of overflowed items in horizontal mode


      var lastVisibleIndex = this.state.lastVisibleIndex;
      return (children || []).reduce(function (acc, childNode, index) {
        var item = childNode;

        if (_this3.props.mode === 'horizontal') {
          var overflowed = _this3.getOverflowedSubMenuItem(childNode.props.eventKey, []);

          if (lastVisibleIndex !== undefined && _this3.props.className.indexOf("".concat(_this3.props.prefixCls, "-root")) !== -1) {
            if (index > lastVisibleIndex) {
              item = react_default.a.cloneElement(childNode, // 这里修改 eventKey 是为了防止隐藏状态下还会触发 openkeys 事件
              {
                style: {
                  display: 'none'
                },
                eventKey: "".concat(childNode.props.eventKey, "-hidden"),

                /**
                 * Legacy code. Here `className` never used:
                 * https://github.com/react-component/menu/commit/4cd6b49fce9d116726f4ea00dda85325d6f26500#diff-e2fa48f75c2dd2318295cde428556a76R240
                 */
                className: "".concat(MENUITEM_OVERFLOWED_CLASSNAME)
              });
            }

            if (index === lastVisibleIndex + 1) {
              _this3.overflowedItems = children.slice(lastVisibleIndex + 1).map(function (c) {
                return react_default.a.cloneElement(c, // children[index].key will become '.$key' in clone by default,
                // we have to overwrite with the correct key explicitly
                {
                  key: c.props.eventKey,
                  mode: 'vertical-left'
                });
              });
              overflowed = _this3.getOverflowedSubMenuItem(childNode.props.eventKey, _this3.overflowedItems);
            }
          }

          var ret = [].concat(_toConsumableArray(acc), [overflowed, item]);

          if (index === children.length - 1) {
            // need a placeholder for calculating overflowed indicator width
            ret.push(_this3.getOverflowedSubMenuItem(childNode.props.eventKey, [], true));
          }

          return ret;
        }

        return [].concat(_toConsumableArray(acc), [item]);
      }, []);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          visible = _this$props2.visible,
          prefixCls = _this$props2.prefixCls,
          overflowedIndicator = _this$props2.overflowedIndicator,
          mode = _this$props2.mode,
          level = _this$props2.level,
          tag = _this$props2.tag,
          children = _this$props2.children,
          theme = _this$props2.theme,
          rest = _objectWithoutProperties(_this$props2, ["visible", "prefixCls", "overflowedIndicator", "mode", "level", "tag", "children", "theme"]);

      var Tag = tag;
      return react_default.a.createElement(Tag, Object.assign({}, rest), this.renderChildren(children));
    }
  }]);

  return DOMWrap;
}(react_default.a.Component);

DOMWrap_DOMWrap.defaultProps = {
  tag: 'div',
  className: ''
};
/* harmony default export */ var es_DOMWrap = (DOMWrap_DOMWrap);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/SubPopupMenu.js



















function SubPopupMenu_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    SubPopupMenu_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    SubPopupMenu_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return SubPopupMenu_typeof(obj);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function SubPopupMenu_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function SubPopupMenu_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function SubPopupMenu_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) SubPopupMenu_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) SubPopupMenu_defineProperties(Constructor, staticProps);
  return Constructor;
}

function SubPopupMenu_possibleConstructorReturn(self, call) {
  if (call && (SubPopupMenu_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return SubPopupMenu_assertThisInitialized(self);
}

function SubPopupMenu_getPrototypeOf(o) {
  SubPopupMenu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return SubPopupMenu_getPrototypeOf(o);
}

function SubPopupMenu_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function SubPopupMenu_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) SubPopupMenu_setPrototypeOf(subClass, superClass);
}

function SubPopupMenu_setPrototypeOf(o, p) {
  SubPopupMenu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return SubPopupMenu_setPrototypeOf(o, p);
}

function SubPopupMenu_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function SubPopupMenu_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      SubPopupMenu_ownKeys(Object(source), true).forEach(function (key) {
        SubPopupMenu_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      SubPopupMenu_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function SubPopupMenu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}










function allDisabled(arr) {
  if (!arr.length) {
    return true;
  }

  return arr.every(function (c) {
    return !!c.props.disabled;
  });
}

function updateActiveKey(store, menuId, activeKey) {
  var state = store.getState();
  store.setState({
    activeKey: SubPopupMenu_objectSpread({}, state.activeKey, SubPopupMenu_defineProperty({}, menuId, activeKey))
  });
}

function getEventKey(props) {
  // when eventKey not available ,it's menu and return menu id '0-menu-'
  return props.eventKey || '0-menu-';
}

function getActiveKey(props, originalActiveKey) {
  var activeKey = originalActiveKey;
  var children = props.children,
      eventKey = props.eventKey;

  if (activeKey) {
    var found;
    loopMenuItem(children, function (c, i) {
      if (c && c.props && !c.props.disabled && activeKey === getKeyFromChildrenIndex(c, eventKey, i)) {
        found = true;
      }
    });

    if (found) {
      return activeKey;
    }
  }

  activeKey = null;

  if (props.defaultActiveFirst) {
    loopMenuItem(children, function (c, i) {
      if (!activeKey && c && !c.props.disabled) {
        activeKey = getKeyFromChildrenIndex(c, eventKey, i);
      }
    });
    return activeKey;
  }

  return activeKey;
}
function saveRef(c) {
  if (c) {
    var index = this.instanceArray.indexOf(c);

    if (index !== -1) {
      // update component if it's already inside instanceArray
      this.instanceArray[index] = c;
    } else {
      // add component if it's not in instanceArray yet;
      this.instanceArray.push(c);
    }
  }
}
var SubPopupMenu_SubPopupMenu = /*#__PURE__*/function (_React$Component) {
  SubPopupMenu_inherits(SubPopupMenu, _React$Component);

  function SubPopupMenu(props) {
    var _this;

    SubPopupMenu_classCallCheck(this, SubPopupMenu);

    _this = SubPopupMenu_possibleConstructorReturn(this, SubPopupMenu_getPrototypeOf(SubPopupMenu).call(this, props));
    /**
     * all keyboard events callbacks run from here at first
     *
     * note:
     *  This legacy code that `onKeyDown` is called by parent instead of dom self.
     *  which need return code to check if this event is handled
     */

    _this.onKeyDown = function (e, callback) {
      var keyCode = e.keyCode;
      var handled;

      _this.getFlatInstanceArray().forEach(function (obj) {
        if (obj && obj.props.active && obj.onKeyDown) {
          handled = obj.onKeyDown(e);
        }
      });

      if (handled) {
        return 1;
      }

      var activeItem = null;

      if (keyCode === KeyCode["a" /* default */].UP || keyCode === KeyCode["a" /* default */].DOWN) {
        activeItem = _this.step(keyCode === KeyCode["a" /* default */].UP ? -1 : 1);
      }

      if (activeItem) {
        e.preventDefault();
        updateActiveKey(_this.props.store, getEventKey(_this.props), activeItem.props.eventKey);

        if (typeof callback === 'function') {
          callback(activeItem);
        }

        return 1;
      }

      return undefined;
    };

    _this.onItemHover = function (e) {
      var key = e.key,
          hover = e.hover;
      updateActiveKey(_this.props.store, getEventKey(_this.props), hover ? key : null);
    };

    _this.onDeselect = function (selectInfo) {
      _this.props.onDeselect(selectInfo);
    };

    _this.onSelect = function (selectInfo) {
      _this.props.onSelect(selectInfo);
    };

    _this.onClick = function (e) {
      _this.props.onClick(e);
    };

    _this.onOpenChange = function (e) {
      _this.props.onOpenChange(e);
    };

    _this.onDestroy = function (key) {
      /* istanbul ignore next */
      _this.props.onDestroy(key);
    };

    _this.getFlatInstanceArray = function () {
      return _this.instanceArray;
    };

    _this.step = function (direction) {
      var children = _this.getFlatInstanceArray();

      var activeKey = _this.props.store.getState().activeKey[getEventKey(_this.props)];

      var len = children.length;

      if (!len) {
        return null;
      }

      if (direction < 0) {
        children = children.concat().reverse();
      } // find current activeIndex


      var activeIndex = -1;
      children.every(function (c, ci) {
        if (c && c.props.eventKey === activeKey) {
          activeIndex = ci;
          return false;
        }

        return true;
      });

      if (!_this.props.defaultActiveFirst && activeIndex !== -1 && allDisabled(children.slice(activeIndex, len - 1))) {
        return undefined;
      }

      var start = (activeIndex + 1) % len;
      var i = start;

      do {
        var child = children[i];

        if (!child || child.props.disabled) {
          i = (i + 1) % len;
        } else {
          return child;
        }
      } while (i !== start);

      return null;
    };

    _this.renderCommonMenuItem = function (child, i, extraProps) {
      var state = _this.props.store.getState();

      var _assertThisInitialize = SubPopupMenu_assertThisInitialized(_this),
          props = _assertThisInitialize.props;

      var key = getKeyFromChildrenIndex(child, props.eventKey, i);
      var childProps = child.props; // https://github.com/ant-design/ant-design/issues/11517#issuecomment-477403055

      if (!childProps || typeof child.type === 'string') {
        return child;
      }

      var isActive = key === state.activeKey;

      var newChildProps = SubPopupMenu_objectSpread({
        mode: childProps.mode || props.mode,
        level: props.level,
        inlineIndent: props.inlineIndent,
        renderMenuItem: _this.renderMenuItem,
        rootPrefixCls: props.prefixCls,
        index: i,
        parentMenu: props.parentMenu,
        // customized ref function, need to be invoked manually in child's componentDidMount
        manualRef: childProps.disabled ? undefined : Object(createChainedFunction["a" /* default */])(child.ref, saveRef.bind(SubPopupMenu_assertThisInitialized(_this))),
        eventKey: key,
        active: !childProps.disabled && isActive,
        multiple: props.multiple,
        onClick: function onClick(e) {
          (childProps.onClick || noop)(e);

          _this.onClick(e);
        },
        onItemHover: _this.onItemHover,
        motion: props.motion,
        subMenuOpenDelay: props.subMenuOpenDelay,
        subMenuCloseDelay: props.subMenuCloseDelay,
        forceSubMenuRender: props.forceSubMenuRender,
        onOpenChange: _this.onOpenChange,
        onDeselect: _this.onDeselect,
        onSelect: _this.onSelect,
        builtinPlacements: props.builtinPlacements,
        itemIcon: childProps.itemIcon || _this.props.itemIcon,
        expandIcon: childProps.expandIcon || _this.props.expandIcon
      }, extraProps, {
        direction: props.direction
      }); // ref: https://github.com/ant-design/ant-design/issues/13943


      if (props.mode === 'inline' || util_isMobileDevice()) {
        newChildProps.triggerSubMenuAction = 'click';
      }

      return react_default.a.cloneElement(child, newChildProps);
    };

    _this.renderMenuItem = function (c, i, subMenuKey) {
      /* istanbul ignore if */
      if (!c) {
        return null;
      }

      var state = _this.props.store.getState();

      var extraProps = {
        openKeys: state.openKeys,
        selectedKeys: state.selectedKeys,
        triggerSubMenuAction: _this.props.triggerSubMenuAction,
        subMenuKey: subMenuKey
      };
      return _this.renderCommonMenuItem(c, i, extraProps);
    };

    props.store.setState({
      activeKey: SubPopupMenu_objectSpread({}, props.store.getState().activeKey, SubPopupMenu_defineProperty({}, props.eventKey, getActiveKey(props, props.activeKey)))
    });
    _this.instanceArray = [];
    return _this;
  }

  SubPopupMenu_createClass(SubPopupMenu, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // invoke customized ref to expose component to mixin
      if (this.props.manualRef) {
        this.props.manualRef(this);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return this.props.visible || nextProps.visible || this.props.className !== nextProps.className || !shallowequal_default()(this.props.style, nextProps.style);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var props = this.props;
      var originalActiveKey = 'activeKey' in props ? props.activeKey : props.store.getState().activeKey[getEventKey(props)];
      var activeKey = getActiveKey(props, originalActiveKey);

      if (activeKey !== originalActiveKey) {
        updateActiveKey(props.store, getEventKey(props), activeKey);
      } else if ('activeKey' in prevProps) {
        // If prev activeKey is not same as current activeKey,
        // we should set it.
        var prevActiveKey = getActiveKey(prevProps, prevProps.activeKey);

        if (activeKey !== prevActiveKey) {
          updateActiveKey(props.store, getEventKey(props), activeKey);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var props = _extends({}, this.props);

      this.instanceArray = [];
      var className = classnames_default()(props.prefixCls, props.className, "".concat(props.prefixCls, "-").concat(props.mode));
      var domProps = {
        className: className,
        // role could be 'select' and by default set to menu
        role: props.role || 'menu'
      };

      if (props.id) {
        domProps.id = props.id;
      }

      if (props.focusable) {
        domProps.tabIndex = 0;
        domProps.onKeyDown = this.onKeyDown;
      }

      var prefixCls = props.prefixCls,
          eventKey = props.eventKey,
          visible = props.visible,
          level = props.level,
          mode = props.mode,
          overflowedIndicator = props.overflowedIndicator,
          theme = props.theme;
      menuAllProps.forEach(function (key) {
        return delete props[key];
      }); // Otherwise, the propagated click event will trigger another onClick

      delete props.onClick;
      return react_default.a.createElement(es_DOMWrap, Object.assign({}, props, {
        prefixCls: prefixCls,
        mode: mode,
        tag: "ul",
        level: level,
        theme: theme,
        visible: visible,
        overflowedIndicator: overflowedIndicator
      }, domProps), react_default.a.Children.map(props.children, function (c, i) {
        return _this2.renderMenuItem(c, i, eventKey || '0-menu-');
      }));
    }
  }]);

  return SubPopupMenu;
}(react_default.a.Component);
SubPopupMenu_SubPopupMenu.defaultProps = {
  prefixCls: 'rc-menu',
  className: '',
  mode: 'vertical',
  level: 1,
  inlineIndent: 24,
  visible: true,
  focusable: true,
  style: {},
  manualRef: noop
};
var SubPopupMenu_connected = Object(lib["connect"])()(SubPopupMenu_SubPopupMenu);
/* harmony default export */ var es_SubPopupMenu = (SubPopupMenu_connected);
// EXTERNAL MODULE: ../node_modules/rc-util/es/warning.js
var warning = __webpack_require__("IFhY");

// CONCATENATED MODULE: ../node_modules/rc-menu/es/utils/legacyUtil.js



function legacyUtil_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    legacyUtil_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    legacyUtil_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return legacyUtil_typeof(obj);
}


function getMotion(_ref) {
  var prefixCls = _ref.prefixCls,
      motion = _ref.motion,
      openAnimation = _ref.openAnimation,
      openTransitionName = _ref.openTransitionName;

  if (motion) {
    return motion;
  }

  if (legacyUtil_typeof(openAnimation) === 'object' && openAnimation) {
    Object(warning["a" /* default */])(false, 'Object type of `openAnimation` is removed. Please use `motion` instead.');
  } else if (typeof openAnimation === 'string') {
    return {
      motionName: "".concat(prefixCls, "-open-").concat(openAnimation)
    };
  }

  if (openTransitionName) {
    return {
      motionName: openTransitionName
    };
  }

  return null;
}
// CONCATENATED MODULE: ../node_modules/rc-menu/es/Menu.js

















function Menu_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    Menu_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    Menu_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return Menu_typeof(obj);
}

function Menu_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function Menu_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      Menu_ownKeys(Object(source), true).forEach(function (key) {
        Menu_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      Menu_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function Menu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function Menu_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function Menu_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function Menu_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) Menu_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) Menu_defineProperties(Constructor, staticProps);
  return Constructor;
}

function Menu_possibleConstructorReturn(self, call) {
  if (call && (Menu_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Menu_assertThisInitialized(self);
}

function Menu_getPrototypeOf(o) {
  Menu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return Menu_getPrototypeOf(o);
}

function Menu_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function Menu_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Menu_setPrototypeOf(subClass, superClass);
}

function Menu_setPrototypeOf(o, p) {
  Menu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return Menu_setPrototypeOf(o, p);
}







var Menu_Menu = /*#__PURE__*/function (_React$Component) {
  Menu_inherits(Menu, _React$Component);

  function Menu(props) {
    var _this;

    Menu_classCallCheck(this, Menu);

    _this = Menu_possibleConstructorReturn(this, Menu_getPrototypeOf(Menu).call(this, props));

    _this.onSelect = function (selectInfo) {
      var _assertThisInitialize = Menu_assertThisInitialized(_this),
          props = _assertThisInitialize.props;

      if (props.selectable) {
        // root menu
        var _this$store$getState = _this.store.getState(),
            _selectedKeys = _this$store$getState.selectedKeys;

        var selectedKey = selectInfo.key;

        if (props.multiple) {
          _selectedKeys = _selectedKeys.concat([selectedKey]);
        } else {
          _selectedKeys = [selectedKey];
        }

        if (!('selectedKeys' in props)) {
          _this.store.setState({
            selectedKeys: _selectedKeys
          });
        }

        props.onSelect(Menu_objectSpread({}, selectInfo, {
          selectedKeys: _selectedKeys
        }));
      }
    };

    _this.onClick = function (e) {
      _this.props.onClick(e);
    }; // onKeyDown needs to be exposed as a instance method
    // e.g., in rc-select, we need to navigate menu item while
    // current active item is rc-select input box rather than the menu itself


    _this.onKeyDown = function (e, callback) {
      _this.innerMenu.getWrappedInstance().onKeyDown(e, callback);
    };

    _this.onOpenChange = function (event) {
      var _assertThisInitialize2 = Menu_assertThisInitialized(_this),
          props = _assertThisInitialize2.props;

      var openKeys = _this.store.getState().openKeys.concat();

      var changed = false;

      var processSingle = function processSingle(e) {
        var oneChanged = false;

        if (e.open) {
          oneChanged = openKeys.indexOf(e.key) === -1;

          if (oneChanged) {
            openKeys.push(e.key);
          }
        } else {
          var index = openKeys.indexOf(e.key);
          oneChanged = index !== -1;

          if (oneChanged) {
            openKeys.splice(index, 1);
          }
        }

        changed = changed || oneChanged;
      };

      if (Array.isArray(event)) {
        // batch change call
        event.forEach(processSingle);
      } else {
        processSingle(event);
      }

      if (changed) {
        if (!('openKeys' in _this.props)) {
          _this.store.setState({
            openKeys: openKeys
          });
        }

        props.onOpenChange(openKeys);
      }
    };

    _this.onDeselect = function (selectInfo) {
      var _assertThisInitialize3 = Menu_assertThisInitialized(_this),
          props = _assertThisInitialize3.props;

      if (props.selectable) {
        var _selectedKeys2 = _this.store.getState().selectedKeys.concat();

        var selectedKey = selectInfo.key;

        var index = _selectedKeys2.indexOf(selectedKey);

        if (index !== -1) {
          _selectedKeys2.splice(index, 1);
        }

        if (!('selectedKeys' in props)) {
          _this.store.setState({
            selectedKeys: _selectedKeys2
          });
        }

        props.onDeselect(Menu_objectSpread({}, selectInfo, {
          selectedKeys: _selectedKeys2
        }));
      }
    };

    _this.getOpenTransitionName = function () {
      var _assertThisInitialize4 = Menu_assertThisInitialized(_this),
          props = _assertThisInitialize4.props;

      var transitionName = props.openTransitionName;
      var animationName = props.openAnimation;

      if (!transitionName && typeof animationName === 'string') {
        transitionName = "".concat(props.prefixCls, "-open-").concat(animationName);
      }

      return transitionName;
    };

    _this.setInnerMenu = function (node) {
      _this.innerMenu = node;
    };

    _this.isRootMenu = true;
    var selectedKeys = props.defaultSelectedKeys;
    var openKeys = props.defaultOpenKeys;

    if ('selectedKeys' in props) {
      selectedKeys = props.selectedKeys || [];
    }

    if ('openKeys' in props) {
      openKeys = props.openKeys || [];
    }

    _this.store = Object(lib["create"])({
      selectedKeys: selectedKeys,
      openKeys: openKeys,
      activeKey: {
        '0-menu-': getActiveKey(props, props.activeKey)
      }
    });
    return _this;
  }

  Menu_createClass(Menu, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateMiniStore();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.updateMiniStore();
    }
  }, {
    key: "updateMiniStore",
    value: function updateMiniStore() {
      if ('selectedKeys' in this.props) {
        this.store.setState({
          selectedKeys: this.props.selectedKeys || []
        });
      }

      if ('openKeys' in this.props) {
        this.store.setState({
          openKeys: this.props.openKeys || []
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var props = Menu_objectSpread({}, this.props);

      props.className += " ".concat(props.prefixCls, "-root");

      if (props.direction === 'rtl') {
        props.className += " ".concat(props.prefixCls, "-rtl");
      }

      props = Menu_objectSpread({}, props, {
        onClick: this.onClick,
        onOpenChange: this.onOpenChange,
        onDeselect: this.onDeselect,
        onSelect: this.onSelect,
        parentMenu: this,
        motion: getMotion(this.props)
      });
      delete props.openAnimation;
      delete props.openTransitionName;
      return react_default.a.createElement(lib["Provider"], {
        store: this.store
      }, react_default.a.createElement(es_SubPopupMenu, Object.assign({}, props, {
        ref: this.setInnerMenu
      }), this.props.children));
    }
  }]);

  return Menu;
}(react_default.a.Component);

Menu_Menu.defaultProps = {
  selectable: true,
  onClick: noop,
  onSelect: noop,
  onOpenChange: noop,
  onDeselect: noop,
  defaultSelectedKeys: [],
  defaultOpenKeys: [],
  subMenuOpenDelay: 0.1,
  subMenuCloseDelay: 0.1,
  triggerSubMenuAction: 'hover',
  prefixCls: 'rc-menu',
  className: '',
  mode: 'vertical',
  style: {},
  builtinPlacements: {},
  overflowedIndicator: react_default.a.createElement("span", null, "\xB7\xB7\xB7")
};
/* harmony default export */ var es_Menu = (Menu_Menu);
// CONCATENATED MODULE: ../node_modules/compute-scroll-into-view/es/index.js
function isElement(el) {
  return el != null && typeof el === 'object' && el.nodeType === 1;
}

function canOverflow(overflow, skipOverflowHiddenElements) {
  if (skipOverflowHiddenElements && overflow === 'hidden') {
    return false;
  }

  return overflow !== 'visible' && overflow !== 'clip';
}

function getFrameElement(el) {
  if (!el.ownerDocument || !el.ownerDocument.defaultView) {
    return null;
  }

  return el.ownerDocument.defaultView.frameElement;
}

function isHiddenByFrame(el) {
  var frame = getFrameElement(el);

  if (!frame) {
    return false;
  }

  return frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth;
}

function isScrollable(el, skipOverflowHiddenElements) {
  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {
    var style = getComputedStyle(el, null);
    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements) || isHiddenByFrame(el);
  }

  return false;
}

function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
    return 0;
  }

  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {
    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
  }

  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
  }

  return 0;
}

/* harmony default export */ var compute_scroll_into_view_es = (function (target, options) {
  var scrollMode = options.scrollMode,
      block = options.block,
      inline = options.inline,
      boundary = options.boundary,
      skipOverflowHiddenElements = options.skipOverflowHiddenElements;
  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {
    return node !== boundary;
  };

  if (!isElement(target)) {
    throw new TypeError('Invalid target');
  }

  var scrollingElement = document.scrollingElement || document.documentElement;
  var frames = [];
  var cursor = target;

  while (isElement(cursor) && checkBoundary(cursor)) {
    cursor = cursor.parentNode;

    if (cursor === scrollingElement) {
      frames.push(cursor);
      break;
    }

    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {
      continue;
    }

    if (isScrollable(cursor, skipOverflowHiddenElements)) {
      frames.push(cursor);
    }
  }

  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;
  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;
  var viewportX = window.scrollX || pageXOffset;
  var viewportY = window.scrollY || pageYOffset;

  var _target$getBoundingCl = target.getBoundingClientRect(),
      targetHeight = _target$getBoundingCl.height,
      targetWidth = _target$getBoundingCl.width,
      targetTop = _target$getBoundingCl.top,
      targetRight = _target$getBoundingCl.right,
      targetBottom = _target$getBoundingCl.bottom,
      targetLeft = _target$getBoundingCl.left;

  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;
  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;
  var computations = [];

  for (var index = 0; index < frames.length; index++) {
    var frame = frames[index];

    var _frame$getBoundingCli = frame.getBoundingClientRect(),
        height = _frame$getBoundingCli.height,
        width = _frame$getBoundingCli.width,
        top = _frame$getBoundingCli.top,
        right = _frame$getBoundingCli.right,
        bottom = _frame$getBoundingCli.bottom,
        left = _frame$getBoundingCli.left;

    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= top && targetBottom <= bottom && targetLeft >= left && targetRight <= right) {
      return computations;
    }

    var frameStyle = getComputedStyle(frame);
    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
    var borderTop = parseInt(frameStyle.borderTopWidth, 10);
    var borderRight = parseInt(frameStyle.borderRightWidth, 10);
    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
    var blockScroll = 0;
    var inlineScroll = 0;
    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;
    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;

    if (scrollingElement === frame) {
      if (block === 'start') {
        blockScroll = targetBlock;
      } else if (block === 'end') {
        blockScroll = targetBlock - viewportHeight;
      } else if (block === 'nearest') {
        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - viewportHeight / 2;
      }

      if (inline === 'start') {
        inlineScroll = targetInline;
      } else if (inline === 'center') {
        inlineScroll = targetInline - viewportWidth / 2;
      } else if (inline === 'end') {
        inlineScroll = targetInline - viewportWidth;
      } else {
        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
      }

      blockScroll = Math.max(0, blockScroll + viewportY);
      inlineScroll = Math.max(0, inlineScroll + viewportX);
    } else {
      if (block === 'start') {
        blockScroll = targetBlock - top - borderTop;
      } else if (block === 'end') {
        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
      } else if (block === 'nearest') {
        blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
      }

      if (inline === 'start') {
        inlineScroll = targetInline - left - borderLeft;
      } else if (inline === 'center') {
        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
      } else if (inline === 'end') {
        inlineScroll = targetInline - right + borderRight + scrollbarWidth;
      } else {
        inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
      }

      var scrollLeft = frame.scrollLeft,
          scrollTop = frame.scrollTop;
      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - height + scrollbarHeight));
      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - width + scrollbarWidth));
      targetBlock += scrollTop - blockScroll;
      targetInline += scrollLeft - inlineScroll;
    }

    computations.push({
      el: frame,
      top: blockScroll,
      left: inlineScroll
    });
  }

  return computations;
});
// CONCATENATED MODULE: ../node_modules/scroll-into-view-if-needed/es/index.js







function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}

function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = 'auto';
  }

  var canSmoothScroll = ('scrollBehavior' in document.body.style);
  actions.forEach(function (_ref) {
    var el = _ref.el,
        top = _ref.top,
        left = _ref.left;

    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top: top,
        left: left,
        behavior: behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}

function getOptions(options) {
  if (options === false) {
    return {
      block: 'end',
      inline: 'nearest'
    };
  }

  if (isOptionsObject(options)) {
    return options;
  }

  return {
    block: 'start',
    inline: 'nearest'
  };
}

function scrollIntoView(target, options) {
  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);

  if (isOptionsObject(options) && typeof options.behavior === 'function') {
    return options.behavior(targetIsDetached ? [] : compute_scroll_into_view_es(target, options));
  }

  if (targetIsDetached) {
    return;
  }

  var computeOptions = getOptions(options);
  return defaultBehavior(compute_scroll_into_view_es(target, computeOptions), computeOptions.behavior);
}

/* harmony default export */ var scroll_into_view_if_needed_es = (scrollIntoView);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/MenuItem.js
















function MenuItem_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    MenuItem_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    MenuItem_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return MenuItem_typeof(obj);
}

function MenuItem_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function MenuItem_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      MenuItem_ownKeys(Object(source), true).forEach(function (key) {
        MenuItem_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      MenuItem_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function MenuItem_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function MenuItem_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function MenuItem_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function MenuItem_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) MenuItem_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) MenuItem_defineProperties(Constructor, staticProps);
  return Constructor;
}

function MenuItem_possibleConstructorReturn(self, call) {
  if (call && (MenuItem_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return MenuItem_assertThisInitialized(self);
}

function MenuItem_getPrototypeOf(o) {
  MenuItem_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return MenuItem_getPrototypeOf(o);
}

function MenuItem_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function MenuItem_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) MenuItem_setPrototypeOf(subClass, superClass);
}

function MenuItem_setPrototypeOf(o, p) {
  MenuItem_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return MenuItem_setPrototypeOf(o, p);
}








var MenuItem_MenuItem = /*#__PURE__*/function (_React$Component) {
  MenuItem_inherits(MenuItem, _React$Component);

  function MenuItem() {
    var _this;

    MenuItem_classCallCheck(this, MenuItem);

    _this = MenuItem_possibleConstructorReturn(this, MenuItem_getPrototypeOf(MenuItem).apply(this, arguments));

    _this.onKeyDown = function (e) {
      var keyCode = e.keyCode;

      if (keyCode === KeyCode["a" /* default */].ENTER) {
        _this.onClick(e);

        return true;
      }

      return undefined;
    };

    _this.onMouseLeave = function (e) {
      var _this$props = _this.props,
          eventKey = _this$props.eventKey,
          onItemHover = _this$props.onItemHover,
          onMouseLeave = _this$props.onMouseLeave;
      onItemHover({
        key: eventKey,
        hover: false
      });
      onMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    _this.onMouseEnter = function (e) {
      var _this$props2 = _this.props,
          eventKey = _this$props2.eventKey,
          onItemHover = _this$props2.onItemHover,
          onMouseEnter = _this$props2.onMouseEnter;
      onItemHover({
        key: eventKey,
        hover: true
      });
      onMouseEnter({
        key: eventKey,
        domEvent: e
      });
    };

    _this.onClick = function (e) {
      var _this$props3 = _this.props,
          eventKey = _this$props3.eventKey,
          multiple = _this$props3.multiple,
          onClick = _this$props3.onClick,
          onSelect = _this$props3.onSelect,
          onDeselect = _this$props3.onDeselect,
          isSelected = _this$props3.isSelected;
      var info = {
        key: eventKey,
        keyPath: [eventKey],
        item: MenuItem_assertThisInitialized(_this),
        domEvent: e
      };
      onClick(info);

      if (multiple) {
        if (isSelected) {
          onDeselect(info);
        } else {
          onSelect(info);
        }
      } else if (!isSelected) {
        onSelect(info);
      }
    };

    _this.saveNode = function (node) {
      _this.node = node;
    };

    return _this;
  }

  MenuItem_createClass(MenuItem, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // invoke customized ref to expose component to mixin
      this.callRef();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props4 = this.props,
          active = _this$props4.active,
          parentMenu = _this$props4.parentMenu,
          eventKey = _this$props4.eventKey; // 在 parentMenu 上层保存滚动状态，避免重复的 MenuItem key 导致滚动跳动
      // https://github.com/ant-design/ant-design/issues/16181

      if (!prevProps.active && active && (!parentMenu || !parentMenu["scrolled-".concat(eventKey)])) {
        if (this.node) {
          scroll_into_view_if_needed_es(this.node, {
            scrollMode: 'if-needed',
            // eslint-disable-next-line react/no-find-dom-node
            boundary: react_dom_default.a.findDOMNode(parentMenu),
            block: 'nearest'
          });
          parentMenu["scrolled-".concat(eventKey)] = true;
        }
      } else if (parentMenu && parentMenu["scrolled-".concat(eventKey)]) {
        delete parentMenu["scrolled-".concat(eventKey)];
      }

      this.callRef();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var props = this.props;

      if (props.onDestroy) {
        props.onDestroy(props.eventKey);
      }
    }
  }, {
    key: "getPrefixCls",
    value: function getPrefixCls() {
      return "".concat(this.props.rootPrefixCls, "-item");
    }
  }, {
    key: "getActiveClassName",
    value: function getActiveClassName() {
      return "".concat(this.getPrefixCls(), "-active");
    }
  }, {
    key: "getSelectedClassName",
    value: function getSelectedClassName() {
      return "".concat(this.getPrefixCls(), "-selected");
    }
  }, {
    key: "getDisabledClassName",
    value: function getDisabledClassName() {
      return "".concat(this.getPrefixCls(), "-disabled");
    }
  }, {
    key: "callRef",
    value: function callRef() {
      if (this.props.manualRef) {
        this.props.manualRef(this);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames;

      var props = MenuItem_objectSpread({}, this.props);

      var className = classnames_default()(this.getPrefixCls(), props.className, (_classNames = {}, MenuItem_defineProperty(_classNames, this.getActiveClassName(), !props.disabled && props.active), MenuItem_defineProperty(_classNames, this.getSelectedClassName(), props.isSelected), MenuItem_defineProperty(_classNames, this.getDisabledClassName(), props.disabled), _classNames));

      var attrs = MenuItem_objectSpread({}, props.attribute, {
        title: props.title,
        className: className,
        // set to menuitem by default
        role: props.role || 'menuitem',
        'aria-disabled': props.disabled
      });

      if (props.role === 'option') {
        // overwrite to option
        attrs = MenuItem_objectSpread({}, attrs, {
          role: 'option',
          'aria-selected': props.isSelected
        });
      } else if (props.role === null || props.role === 'none') {
        // sometimes we want to specify role inside <li/> element
        // <li><a role='menuitem'>Link</a></li> would be a good example
        // in this case the role on <li/> should be "none" to
        // remove the implied listitem role.
        // https://www.w3.org/TR/wai-aria-practices-1.1/examples/menubar/menubar-1/menubar-1.html
        attrs.role = 'none';
      } // In case that onClick/onMouseLeave/onMouseEnter is passed down from owner


      var mouseEvent = {
        onClick: props.disabled ? null : this.onClick,
        onMouseLeave: props.disabled ? null : this.onMouseLeave,
        onMouseEnter: props.disabled ? null : this.onMouseEnter
      };

      var style = MenuItem_objectSpread({}, props.style);

      if (props.mode === 'inline') {
        if (props.direction === 'rtl') {
          style.paddingRight = props.inlineIndent * props.level;
        } else {
          style.paddingLeft = props.inlineIndent * props.level;
        }
      }

      menuAllProps.forEach(function (key) {
        return delete props[key];
      });
      delete props.direction;
      var icon = this.props.itemIcon;

      if (typeof this.props.itemIcon === 'function') {
        // TODO: This is a bug which should fixed after TS refactor
        icon = react_default.a.createElement(this.props.itemIcon, this.props);
      }

      return react_default.a.createElement("li", Object.assign({}, props, attrs, mouseEvent, {
        style: style,
        ref: this.saveNode
      }), props.children, icon);
    }
  }]);

  return MenuItem;
}(react_default.a.Component);
MenuItem_MenuItem.isMenuItem = true;
MenuItem_MenuItem.defaultProps = {
  onSelect: noop,
  onMouseEnter: noop,
  onMouseLeave: noop,
  manualRef: noop
};
var MenuItem_connected = Object(lib["connect"])(function (_ref, _ref2) {
  var activeKey = _ref.activeKey,
      selectedKeys = _ref.selectedKeys;
  var eventKey = _ref2.eventKey,
      subMenuKey = _ref2.subMenuKey;
  return {
    active: activeKey[subMenuKey] === eventKey,
    isSelected: selectedKeys.indexOf(eventKey) !== -1
  };
})(MenuItem_MenuItem);
/* harmony default export */ var es_MenuItem = (MenuItem_connected);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/MenuItemGroup.js









function MenuItemGroup_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    MenuItemGroup_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    MenuItemGroup_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return MenuItemGroup_typeof(obj);
}

function MenuItemGroup_extends() {
  MenuItemGroup_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return MenuItemGroup_extends.apply(this, arguments);
}

function MenuItemGroup_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function MenuItemGroup_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function MenuItemGroup_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) MenuItemGroup_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) MenuItemGroup_defineProperties(Constructor, staticProps);
  return Constructor;
}

function MenuItemGroup_possibleConstructorReturn(self, call) {
  if (call && (MenuItemGroup_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return MenuItemGroup_assertThisInitialized(self);
}

function MenuItemGroup_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function MenuItemGroup_getPrototypeOf(o) {
  MenuItemGroup_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return MenuItemGroup_getPrototypeOf(o);
}

function MenuItemGroup_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) MenuItemGroup_setPrototypeOf(subClass, superClass);
}

function MenuItemGroup_setPrototypeOf(o, p) {
  MenuItemGroup_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return MenuItemGroup_setPrototypeOf(o, p);
}




var MenuItemGroup_MenuItemGroup = /*#__PURE__*/function (_React$Component) {
  MenuItemGroup_inherits(MenuItemGroup, _React$Component);

  function MenuItemGroup() {
    var _this;

    MenuItemGroup_classCallCheck(this, MenuItemGroup);

    _this = MenuItemGroup_possibleConstructorReturn(this, MenuItemGroup_getPrototypeOf(MenuItemGroup).apply(this, arguments));

    _this.renderInnerMenuItem = function (item) {
      var _this$props = _this.props,
          renderMenuItem = _this$props.renderMenuItem,
          index = _this$props.index;
      return renderMenuItem(item, index, _this.props.subMenuKey);
    };

    return _this;
  }

  MenuItemGroup_createClass(MenuItemGroup, [{
    key: "render",
    value: function render() {
      var props = MenuItemGroup_extends({}, this.props);

      var _props$className = props.className,
          className = _props$className === void 0 ? '' : _props$className,
          rootPrefixCls = props.rootPrefixCls;
      var titleClassName = "".concat(rootPrefixCls, "-item-group-title");
      var listClassName = "".concat(rootPrefixCls, "-item-group-list");
      var title = props.title,
          children = props.children;
      menuAllProps.forEach(function (key) {
        return delete props[key];
      }); // Set onClick to null, to ignore propagated onClick event

      delete props.onClick;
      delete props.direction;
      return react_default.a.createElement("li", Object.assign({}, props, {
        className: "".concat(className, " ").concat(rootPrefixCls, "-item-group")
      }), react_default.a.createElement("div", {
        className: titleClassName,
        title: typeof title === 'string' ? title : undefined
      }, title), react_default.a.createElement("ul", {
        className: listClassName
      }, react_default.a.Children.map(children, this.renderInnerMenuItem)));
    }
  }]);

  return MenuItemGroup;
}(react_default.a.Component);

MenuItemGroup_MenuItemGroup.isMenuItemGroup = true;
MenuItemGroup_MenuItemGroup.defaultProps = {
  disabled: true
};
/* harmony default export */ var es_MenuItemGroup = (MenuItemGroup_MenuItemGroup);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/Divider.js


var Divider_Divider = function Divider(_ref) {
  var className = _ref.className,
      rootPrefixCls = _ref.rootPrefixCls,
      style = _ref.style;
  return react_default.a.createElement("li", {
    className: "".concat(className, " ").concat(rootPrefixCls, "-item-divider"),
    style: style
  });
};

Divider_Divider.defaultProps = {
  // To fix keyboard UX.
  disabled: true,
  className: '',
  style: {}
};
/* harmony default export */ var es_Divider = (Divider_Divider);
// CONCATENATED MODULE: ../node_modules/rc-menu/es/index.js






/* harmony default export */ var rc_menu_es = (es_Menu);
// EXTERNAL MODULE: ../node_modules/omit.js/es/index.js
var omit_js_es = __webpack_require__("x9u5");

// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");

// CONCATENATED MODULE: ../node_modules/antd/es/menu/MenuContext.js

var MenuContext = Object(react["createContext"])({
  inlineCollapsed: false
});
/* harmony default export */ var menu_MenuContext = (MenuContext);
// CONCATENATED MODULE: ../node_modules/antd/es/menu/SubMenu.js







function menu_SubMenu_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    menu_SubMenu_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    menu_SubMenu_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return menu_SubMenu_typeof(obj);
}

function SubMenu_extends() {
  SubMenu_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return SubMenu_extends.apply(this, arguments);
}

function SubMenu_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function SubMenu_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function SubMenu_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) SubMenu_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) SubMenu_defineProperties(Constructor, staticProps);
  return Constructor;
}

function SubMenu_possibleConstructorReturn(self, call) {
  if (call && (menu_SubMenu_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return SubMenu_assertThisInitialized(self);
}

function SubMenu_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function SubMenu_getPrototypeOf(o) {
  SubMenu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return SubMenu_getPrototypeOf(o);
}

function SubMenu_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) SubMenu_setPrototypeOf(subClass, superClass);
}

function SubMenu_setPrototypeOf(o, p) {
  SubMenu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return SubMenu_setPrototypeOf(o, p);
}







var menu_SubMenu_SubMenu = /*#__PURE__*/function (_React$Component) {
  SubMenu_inherits(SubMenu, _React$Component);

  function SubMenu() {
    var _this;

    SubMenu_classCallCheck(this, SubMenu);

    _this = SubMenu_possibleConstructorReturn(this, SubMenu_getPrototypeOf(SubMenu).apply(this, arguments));

    _this.onKeyDown = function (e) {
      _this.subMenu.onKeyDown(e);
    };

    _this.saveSubMenu = function (subMenu) {
      _this.subMenu = subMenu;
    };

    return _this;
  }

  SubMenu_createClass(SubMenu, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          rootPrefixCls = _this$props.rootPrefixCls,
          popupClassName = _this$props.popupClassName;
      return react["createElement"](menu_MenuContext.Consumer, null, function (_ref) {
        var antdMenuTheme = _ref.antdMenuTheme;
        return react["createElement"](es_SubMenu, SubMenu_extends({}, _this2.props, {
          ref: _this2.saveSubMenu,
          popupClassName: classnames_default()("".concat(rootPrefixCls, "-").concat(antdMenuTheme), popupClassName)
        }));
      });
    }
  }]);

  return SubMenu;
}(react["Component"]);

menu_SubMenu_SubMenu.contextTypes = {
  antdMenuTheme: prop_types["string"]
}; // fix issue:https://github.com/ant-design/ant-design/issues/8666

menu_SubMenu_SubMenu.isSubMenu = 1;
/* harmony default export */ var menu_SubMenu = (menu_SubMenu_SubMenu);
// EXTERNAL MODULE: ../node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__("xTM7");

// EXTERNAL MODULE: ../node_modules/antd/es/tooltip/index.js + 5 modules
var tooltip = __webpack_require__("DGR3");

// EXTERNAL MODULE: ../node_modules/antd/es/layout/Sider.js + 1 modules
var Sider = __webpack_require__("znB+");

// CONCATENATED MODULE: ../node_modules/antd/es/menu/MenuItem.js








function menu_MenuItem_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    menu_MenuItem_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    menu_MenuItem_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return menu_MenuItem_typeof(obj);
}

function MenuItem_extends() {
  MenuItem_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return MenuItem_extends.apply(this, arguments);
}

function menu_MenuItem_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function menu_MenuItem_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function menu_MenuItem_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function menu_MenuItem_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) menu_MenuItem_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) menu_MenuItem_defineProperties(Constructor, staticProps);
  return Constructor;
}

function menu_MenuItem_possibleConstructorReturn(self, call) {
  if (call && (menu_MenuItem_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return menu_MenuItem_assertThisInitialized(self);
}

function menu_MenuItem_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function menu_MenuItem_getPrototypeOf(o) {
  menu_MenuItem_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return menu_MenuItem_getPrototypeOf(o);
}

function menu_MenuItem_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) menu_MenuItem_setPrototypeOf(subClass, superClass);
}

function menu_MenuItem_setPrototypeOf(o, p) {
  menu_MenuItem_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return menu_MenuItem_setPrototypeOf(o, p);
}

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};









var menu_MenuItem_MenuItem = /*#__PURE__*/function (_React$Component) {
  menu_MenuItem_inherits(MenuItem, _React$Component);

  function MenuItem() {
    var _this;

    menu_MenuItem_classCallCheck(this, MenuItem);

    _this = menu_MenuItem_possibleConstructorReturn(this, menu_MenuItem_getPrototypeOf(MenuItem).apply(this, arguments));

    _this.onKeyDown = function (e) {
      _this.menuItem.onKeyDown(e);
    };

    _this.saveMenuItem = function (menuItem) {
      _this.menuItem = menuItem;
    };

    _this.renderItem = function (_ref) {
      var siderCollapsed = _ref.siderCollapsed;
      var _this$props = _this.props,
          level = _this$props.level,
          className = _this$props.className,
          children = _this$props.children,
          rootPrefixCls = _this$props.rootPrefixCls;

      var _a = _this.props,
          title = _a.title,
          rest = __rest(_a, ["title"]);

      return react["createElement"](menu_MenuContext.Consumer, null, function (_ref2) {
        var inlineCollapsed = _ref2.inlineCollapsed,
            direction = _ref2.direction;
        var tooltipProps = {
          title: title || (level === 1 ? children : '')
        };

        if (!siderCollapsed && !inlineCollapsed) {
          tooltipProps.title = null; // Reset `visible` to fix control mode tooltip display not correct
          // ref: https://github.com/ant-design/ant-design/issues/16742

          tooltipProps.visible = false;
        }

        return react["createElement"](tooltip["a" /* default */], MenuItem_extends({}, tooltipProps, {
          placement: direction === 'rtl' ? 'left' : 'right',
          overlayClassName: "".concat(rootPrefixCls, "-inline-collapsed-tooltip")
        }), react["createElement"](es_MenuItem, MenuItem_extends({}, rest, {
          className: classnames_default()(className, menu_MenuItem_defineProperty({}, "".concat(rootPrefixCls, "-item-only-child"), Object(toArray["a" /* default */])(children).length === 1)),
          title: title,
          ref: _this.saveMenuItem
        })));
      });
    };

    return _this;
  }

  menu_MenuItem_createClass(MenuItem, [{
    key: "render",
    value: function render() {
      return react["createElement"](Sider["a" /* SiderContext */].Consumer, null, this.renderItem);
    }
  }]);

  return MenuItem;
}(react["Component"]);


menu_MenuItem_MenuItem.isMenuItem = true;
// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/context.js + 4 modules
var config_provider_context = __webpack_require__("Bfez");

// EXTERNAL MODULE: ../node_modules/antd/es/_util/warning.js
var _util_warning = __webpack_require__("papw");

// EXTERNAL MODULE: ../node_modules/antd/es/_util/raf.js
var raf = __webpack_require__("mTAF");

// CONCATENATED MODULE: ../node_modules/antd/es/_util/motion.js
// ================== Collapse Motion ==================
var getCollapsedHeight = function getCollapsedHeight() {
  return {
    height: 0,
    opacity: 0
  };
};

var getRealHeight = function getRealHeight(node) {
  return {
    height: node.scrollHeight,
    opacity: 1
  };
};

var getCurrentHeight = function getCurrentHeight(node) {
  return {
    height: node.offsetHeight
  };
};

var collapseMotion = {
  motionName: 'ant-motion-collapse',
  onAppearStart: getCollapsedHeight,
  onEnterStart: getCollapsedHeight,
  onAppearActive: getRealHeight,
  onEnterActive: getRealHeight,
  onLeaveStart: getCurrentHeight,
  onLeaveActive: getCollapsedHeight
};
/* harmony default export */ var _util_motion = (collapseMotion);
// CONCATENATED MODULE: ../node_modules/antd/es/menu/index.js











function menu_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    menu_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    menu_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return menu_typeof(obj);
}

function menu_extends() {
  menu_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return menu_extends.apply(this, arguments);
}

function menu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function menu_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function menu_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function menu_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) menu_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) menu_defineProperties(Constructor, staticProps);
  return Constructor;
}

function menu_possibleConstructorReturn(self, call) {
  if (call && (menu_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return menu_assertThisInitialized(self);
}

function menu_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function menu_getPrototypeOf(o) {
  menu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return menu_getPrototypeOf(o);
}

function menu_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) menu_setPrototypeOf(subClass, superClass);
}

function menu_setPrototypeOf(o, p) {
  menu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return menu_setPrototypeOf(o, p);
}














var menu_InternalMenu = /*#__PURE__*/function (_React$Component) {
  menu_inherits(InternalMenu, _React$Component);

  function InternalMenu(props) {
    var _this;

    menu_classCallCheck(this, InternalMenu);

    _this = menu_possibleConstructorReturn(this, menu_getPrototypeOf(InternalMenu).call(this, props)); // Restore vertical mode when menu is collapsed responsively when mounted
    // https://github.com/ant-design/ant-design/issues/13104
    // TODO: not a perfect solution, looking a new way to avoid setting switchingModeFromInline in this situation

    _this.handleMouseEnter = function (e) {
      _this.restoreModeVerticalFromInline();

      var onMouseEnter = _this.props.onMouseEnter;

      if (onMouseEnter) {
        onMouseEnter(e);
      }
    };

    _this.handleTransitionEnd = function (e) {
      // when inlineCollapsed menu width animation finished
      // https://github.com/ant-design/ant-design/issues/12864
      var widthCollapsed = e.propertyName === 'width' && e.target === e.currentTarget; // Fix SVGElement e.target.className.indexOf is not a function
      // https://github.com/ant-design/ant-design/issues/15699

      var className = e.target.className; // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during an animation.

      var classNameValue = Object.prototype.toString.call(className) === '[object SVGAnimatedString]' ? className.animVal : className; // Fix for <Menu style={{ width: '100%' }} />, the width transition won't trigger when menu is collapsed
      // https://github.com/ant-design/ant-design-pro/issues/2783

      var iconScaled = e.propertyName === 'font-size' && classNameValue.indexOf('anticon') >= 0;

      if (widthCollapsed || iconScaled) {
        _this.restoreModeVerticalFromInline();
      }
    };

    _this.handleClick = function (e) {
      _this.handleOpenChange([]);

      var onClick = _this.props.onClick;

      if (onClick) {
        onClick(e);
      }
    };

    _this.handleOpenChange = function (openKeys) {
      _this.setOpenKeys(openKeys);

      var onOpenChange = _this.props.onOpenChange;

      if (onOpenChange) {
        onOpenChange(openKeys);
      }
    };

    _this.renderMenu = function (_ref) {
      var getPopupContainer = _ref.getPopupContainer,
          getPrefixCls = _ref.getPrefixCls,
          direction = _ref.direction;
      var _this$props = _this.props,
          customizePrefixCls = _this$props.prefixCls,
          className = _this$props.className,
          theme = _this$props.theme,
          collapsedWidth = _this$props.collapsedWidth;
      var passProps = Object(omit_js_es["a" /* default */])(_this.props, ['collapsedWidth', 'siderCollapsed']);

      var menuMode = _this.getRealMenuMode();

      var menuOpenMotion = _this.getOpenMotionProps(menuMode);

      var prefixCls = getPrefixCls('menu', customizePrefixCls);
      var menuClassName = classnames_default()(className, "".concat(prefixCls, "-").concat(theme), menu_defineProperty({}, "".concat(prefixCls, "-inline-collapsed"), _this.getInlineCollapsed()));

      var menuProps = menu_extends({
        openKeys: _this.state.openKeys,
        onOpenChange: _this.handleOpenChange,
        className: menuClassName,
        mode: menuMode
      }, menuOpenMotion);

      if (menuMode !== 'inline') {
        // closing vertical popup submenu after click it
        menuProps.onClick = _this.handleClick;
      } // https://github.com/ant-design/ant-design/issues/8587


      var hideMenu = _this.getInlineCollapsed() && (collapsedWidth === 0 || collapsedWidth === '0' || collapsedWidth === '0px');

      if (hideMenu) {
        menuProps.openKeys = [];
      }

      return react["createElement"](menu_MenuContext.Provider, {
        value: {
          inlineCollapsed: _this.getInlineCollapsed() || false,
          antdMenuTheme: _this.props.theme,
          direction: direction
        }
      }, react["createElement"](rc_menu_es, menu_extends({
        getPopupContainer: getPopupContainer
      }, passProps, menuProps, {
        prefixCls: prefixCls,
        onTransitionEnd: _this.handleTransitionEnd,
        onMouseEnter: _this.handleMouseEnter,
        direction: direction
      })));
    };

    Object(_util_warning["a" /* default */])(!('inlineCollapsed' in props && props.mode !== 'inline'), 'Menu', '`inlineCollapsed` should only be used when `mode` is inline.');
    Object(_util_warning["a" /* default */])(!(props.siderCollapsed !== undefined && 'inlineCollapsed' in props), 'Menu', '`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.');
    var openKeys;

    if ('openKeys' in props) {
      openKeys = props.openKeys;
    } else if ('defaultOpenKeys' in props) {
      openKeys = props.defaultOpenKeys;
    }

    _this.state = {
      openKeys: openKeys || [],
      switchingModeFromInline: false,
      inlineOpenKeys: [],
      prevProps: props
    };
    return _this;
  }

  menu_createClass(InternalMenu, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      raf["a" /* default */].cancel(this.mountRafId);
    }
  }, {
    key: "setOpenKeys",
    value: function setOpenKeys(openKeys) {
      if (!('openKeys' in this.props)) {
        this.setState({
          openKeys: openKeys
        });
      }
    }
  }, {
    key: "getRealMenuMode",
    value: function getRealMenuMode() {
      var inlineCollapsed = this.getInlineCollapsed();

      if (this.state.switchingModeFromInline && inlineCollapsed) {
        return 'inline';
      }

      var mode = this.props.mode;
      return inlineCollapsed ? 'vertical' : mode;
    }
  }, {
    key: "getInlineCollapsed",
    value: function getInlineCollapsed() {
      var inlineCollapsed = this.props.inlineCollapsed;

      if (this.props.siderCollapsed !== undefined) {
        return this.props.siderCollapsed;
      }

      return inlineCollapsed;
    }
  }, {
    key: "getOpenMotionProps",
    value: function getOpenMotionProps(menuMode) {
      var _this$props2 = this.props,
          openTransitionName = _this$props2.openTransitionName,
          openAnimation = _this$props2.openAnimation,
          motion = _this$props2.motion; // Provides by user

      if (motion) {
        return {
          motion: motion
        };
      }

      if (openAnimation) {
        Object(_util_warning["a" /* default */])(typeof openAnimation === 'string', 'Menu', '`openAnimation` do not support object. Please use `motion` instead.');
        return {
          openAnimation: openAnimation
        };
      }

      if (openTransitionName) {
        return {
          openTransitionName: openTransitionName
        };
      } // Default logic


      if (menuMode === 'horizontal') {
        return {
          motion: {
            motionName: 'slide-up'
          }
        };
      }

      if (menuMode === 'inline') {
        return {
          motion: _util_motion
        };
      } // When mode switch from inline
      // submenu should hide without animation


      return {
        motion: {
          motionName: this.state.switchingModeFromInline ? '' : 'zoom-big'
        }
      };
    }
  }, {
    key: "restoreModeVerticalFromInline",
    value: function restoreModeVerticalFromInline() {
      var switchingModeFromInline = this.state.switchingModeFromInline;

      if (switchingModeFromInline) {
        this.setState({
          switchingModeFromInline: false
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      return react["createElement"](config_provider_context["a" /* ConfigConsumer */], null, this.renderMenu);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var prevProps = prevState.prevProps;
      var newState = {
        prevProps: nextProps
      };

      if (prevProps.mode === 'inline' && nextProps.mode !== 'inline') {
        newState.switchingModeFromInline = true;
      }

      if ('openKeys' in nextProps) {
        newState.openKeys = nextProps.openKeys;
      } else {
        // [Legacy] Old code will return after `openKeys` changed.
        // Not sure the reason, we should keep this logic still.
        if (nextProps.inlineCollapsed && !prevProps.inlineCollapsed || nextProps.siderCollapsed && !prevProps.siderCollapsed) {
          newState.switchingModeFromInline = true;
          newState.inlineOpenKeys = prevState.openKeys;
          newState.openKeys = [];
        }

        if (!nextProps.inlineCollapsed && prevProps.inlineCollapsed || !nextProps.siderCollapsed && prevProps.siderCollapsed) {
          newState.openKeys = prevState.inlineOpenKeys;
          newState.inlineOpenKeys = [];
        }
      }

      return newState;
    }
  }]);

  return InternalMenu;
}(react["Component"]);

menu_InternalMenu.defaultProps = {
  className: '',
  theme: 'light',
  focusable: false
}; // We should keep this as ref-able

var menu_Menu = /*#__PURE__*/function (_React$Component2) {
  menu_inherits(Menu, _React$Component2);

  function Menu() {
    menu_classCallCheck(this, Menu);

    return menu_possibleConstructorReturn(this, menu_getPrototypeOf(Menu).apply(this, arguments));
  }

  menu_createClass(Menu, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return react["createElement"](Sider["a" /* SiderContext */].Consumer, null, function (context) {
        return react["createElement"](menu_InternalMenu, menu_extends({}, _this2.props, context));
      });
    }
  }]);

  return Menu;
}(react["Component"]);


menu_Menu.Divider = es_Divider;
menu_Menu.Item = menu_MenuItem_MenuItem;
menu_Menu.SubMenu = menu_SubMenu;
menu_Menu.ItemGroup = es_MenuItemGroup;

/***/ }),

/***/ "vTVJ":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.constructor.js
var es6_regexp_constructor = __webpack_require__("J8hF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.replace.js
var es6_regexp_replace = __webpack_require__("Z8gF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__("oMRA");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __webpack_require__("6d4m");

// EXTERNAL MODULE: ./public/static/d/1099894806.json
var _1099894806 = __webpack_require__("Tl5h");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./.cache/gatsby-browser-entry.js
var gatsby_browser_entry = __webpack_require__("Wbzz");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.bind.js
var es6_function_bind = __webpack_require__("o7PZ");

// EXTERNAL MODULE: ../node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("W1QL");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("K/PF");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("75LO");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.trim.js
var es6_string_trim = __webpack_require__("m8zh");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.number.constructor.js
var es6_number_constructor = __webpack_require__("e2Kn");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.map.js
var es6_array_map = __webpack_require__("yIlq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.is-array.js
var es6_array_is_array = __webpack_require__("+3V6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__("GkPX");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("4aJ6");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.date.to-string.js
var es6_date_to_string = __webpack_require__("M/4x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__("DbwS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("t91x");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.filter.js
var es6_array_filter = __webpack_require__("9p7t");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__("asZ9");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.for-each.js
var es6_array_for_each = __webpack_require__("7lGJ");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("J1LG");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__("mK0O");

// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/objectSpread.js

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      Object(defineProperty["a" /* default */])(target, key, source[key]);
    });
  }

  return target;
}
// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__("hisu");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__("yBJb");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__("kMo5");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("P+uj");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
var assertThisInitialized = __webpack_require__("0942");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/inherits.js + 1 modules
var inherits = __webpack_require__("CHlC");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules
var toConsumableArray = __webpack_require__("6CzD");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules
var slicedToArray = __webpack_require__("aNYv");

// CONCATENATED MODULE: ../node_modules/i18next/dist/esm/i18next.js





























var consoleLogger = {
  type: 'logger',
  log: function log(args) {
    this.output('log', args);
  },
  warn: function warn(args) {
    this.output('warn', args);
  },
  error: function error(args) {
    this.output('error', args);
  },
  output: function output(type, args) {
    var _console;
    /* eslint no-console: 0 */


    if (console && console[type]) (_console = console)[type].apply(_console, Object(toConsumableArray["a" /* default */])(args));
  }
};

var i18next_Logger = /*#__PURE__*/function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, Logger);

    this.init(concreteLogger, options);
  }

  Object(createClass["a" /* default */])(Logger, [{
    key: "init",
    value: function init(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.prefix = options.prefix || 'i18next:';
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.forward(args, 'log', '', true);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.forward(args, 'warn', '', true);
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.forward(args, 'error', '');
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger(this.logger, _objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);

  return Logger;
}();

var baseLogger = new i18next_Logger();

var i18next_EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    Object(classCallCheck["a" /* default */])(this, EventEmitter);

    this.observers = {};
  }

  Object(createClass["a" /* default */])(EventEmitter, [{
    key: "on",
    value: function on(events, listener) {
      var _this = this;

      events.split(' ').forEach(function (event) {
        _this.observers[event] = _this.observers[event] || [];

        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;

      if (!listener) {
        delete this.observers[event];
        return;
      }

      this.observers[event] = this.observers[event].filter(function (l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function (observer) {
          observer.apply(void 0, args);
        });
      }

      if (this.observers['*']) {
        var _cloned = [].concat(this.observers['*']);

        _cloned.forEach(function (observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);

  return EventEmitter;
}(); // http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/


function defer() {
  var res;
  var rej;
  var promise = new Promise(function (resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}

function makeString(object) {
  if (object == null) return '';
  /* eslint prefer-template: 0 */

  return '' + object;
}

function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}

function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}

function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}

function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);

  if (value !== undefined) {
    return value;
  } // Fallback to default values


  return getPath(defaultData, key);
}

function deepExtend(target, source, overwrite) {
  /* eslint no-restricted-syntax: 0 */
  for (var prop in source) {
    if (prop in target) {
      // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
      if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
        if (overwrite) target[prop] = source[prop];
      } else {
        deepExtend(target[prop], source[prop], overwrite);
      }
    } else {
      target[prop] = source[prop];
    }
  }

  return target;
}

function regexEscape(str) {
  /* eslint no-useless-escape: 0 */
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
/* eslint-disable */


var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};
/* eslint-enable */

function i18next_escape(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  }

  return data;
}

var i18next_ResourceStore = /*#__PURE__*/function (_EventEmitter) {
  Object(inherits["a" /* default */])(ResourceStore, _EventEmitter);

  function ResourceStore(data) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };

    Object(classCallCheck["a" /* default */])(this, ResourceStore);

    _this = Object(possibleConstructorReturn["a" /* default */])(this, Object(getPrototypeOf["a" /* default */])(ResourceStore).call(this));
    i18next_EventEmitter.call(Object(assertThisInitialized["a" /* default */])(_this)); // <=IE10 fix (unable to call parent constructor)

    _this.data = data || {};
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    return _this;
  }

  Object(createClass["a" /* default */])(ResourceStore, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);

      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var path = [lng, ns];
      if (key && typeof key !== 'string') path = path.concat(key);
      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
      }

      return getPath(this.data, path);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === undefined) keySeparator = '.';
      var path = [lng, ns];
      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        value = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent) this.emit('added', lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        silent: false
      };
      /* eslint no-restricted-syntax: 0 */

      for (var m in resources) {
        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
      }

      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        deep = resources;
        resources = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};

      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread({}, pack, resources);
      }

      setPath(this.data, path, pack);
      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }

      this.removeNamespaces(ns);
      this.emit('removed', lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== undefined;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS; // COMPATIBILITY: remove extend in v2.1.0

      if (this.options.compatibilityAPI === 'v1') return _objectSpread({}, {}, this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);

  return ResourceStore;
}(i18next_EventEmitter);

var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;

    processors.forEach(function (processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};

var i18next_Translator = /*#__PURE__*/function (_EventEmitter) {
  Object(inherits["a" /* default */])(Translator, _EventEmitter);

  function Translator(services) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, Translator);

    _this = Object(possibleConstructorReturn["a" /* default */])(this, Object(getPrototypeOf["a" /* default */])(Translator).call(this));
    i18next_EventEmitter.call(Object(assertThisInitialized["a" /* default */])(_this)); // <=IE10 fix (unable to call parent constructor)

    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, Object(assertThisInitialized["a" /* default */])(_this));
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    _this.logger = baseLogger.create('translator');
    return _this;
  }

  Object(createClass["a" /* default */])(Translator, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== undefined;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator || this.options.nsSeparator;
      if (nsSeparator === undefined) nsSeparator = ':';
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS;

      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }

      if (typeof namespaces === 'string') namespaces = [namespaces];
      return {
        key: key,
        namespaces: namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options) {
      var _this2 = this;

      if (Object(esm_typeof["a" /* default */])(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
        /* eslint prefer-rest-params: 0 */
        options = this.options.overloadTranslationOptionHandler(arguments);
      }

      if (!options) options = {}; // non valid keys handling

      if (keys === undefined || keys === null
      /* || keys === ''*/
      ) return '';
      if (!Array.isArray(keys)) keys = [String(keys)]; // separators

      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator; // get namespace(s)

      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
          key = _this$extractFromKey.key,
          namespaces = _this$extractFromKey.namespaces;

      var namespace = namespaces[namespaces.length - 1]; // return key on CIMode

      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

      if (lng && lng.toLowerCase() === 'cimode') {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }

        return key;
      } // resolve from store


      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays; // object

      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
        if (!options.returnObjects && !this.options.returnObjects) {
          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        } // if we got a separator we loop over children - else we just return object as is
        // as having it set to false means no hierarchy so no lookup for nested values


        if (keySeparator) {
          var resTypeIsArray = resType === '[object Array]';
          var copy$$1 = resTypeIsArray ? [] : {}; // apply child translation on a copy

          /* eslint no-restricted-syntax: 0 */

          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy$$1[m] = this.translate(deepKey, _objectSpread({}, options, {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy$$1[m] === deepKey) copy$$1[m] = res[m]; // if nothing found use orginal value as fallback
            }
          }

          res = copy$$1;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
        // array special treatment
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options);
      } else {
        // string, empty or null
        var usedDefault = false;
        var usedKey = false; // fallback value

        if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
          usedDefault = true;

          if (options.count !== undefined) {
            var suffix = this.pluralResolver.getSuffix(lng, options.count);
            res = options["defaultValue".concat(suffix)];
          }

          if (!res) res = options.defaultValue;
        }

        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        } // save missing


        var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;

        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === 'all') {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }

          var send = function send(l, k) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
            }

            _this2.emit('missingKey', l, namespace, k, res);
          };

          if (this.options.saveMissing) {
            var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function (l) {
                var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

                plurals.forEach(function (p) {
                  return send([l], p);
                });
              });
            } else {
              send(lngs, key);
            }
          }
        } // extend


        res = this.extendTranslation(res, keys, options, resolved); // append namespace if still key

        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key); // parseMissingKeyHandler

        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
      } // return


      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved) {
      var _this3 = this;

      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved: resolved
        });
      } else if (!options.skipInterpolation) {
        // i18next.parsing
        if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
          interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
        })); // interpolate

        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
        if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options); // nesting

        if (options.nest !== false) res = this.interpolator.nest(res, function () {
          return _this3.translate.apply(_this3, arguments);
        }, options);
        if (options.interpolation) this.interpolator.reset();
      } // post process


      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
          i18nResolved: resolved
        }, options) : options, this);
      }

      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var found;
      var usedKey; // plain key

      var exactUsedKey; // key with context / plural

      var usedLng;
      var usedNS;
      if (typeof keys === 'string') keys = [keys]; // forEach possible key

      keys.forEach(function (k) {
        if (_this4.isValidLookup(found)) return;

        var extracted = _this4.extractFromKey(k, options);

        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
        var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function (ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;

          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;

            _this4.logger.warn("key \"".concat(usedKey, "\" for namespace \"").concat(usedNS, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace was not yet loaded"), 'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
          }

          codes.forEach(function (code) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code;
            var finalKey = key;
            var finalKeys = [finalKey];

            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count); // fallback for plural if context not found

              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix); // get key for context if needed

              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context)); // get key for plural if needed

              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
            } // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only


            var possibleKey;
            /* eslint no-cond-assign: 0 */

            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey: usedKey,
        exactUsedKey: exactUsedKey,
        usedLng: usedLng,
        usedNS: usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }]);

  return Translator;
}(i18next_EventEmitter);

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var i18next_LanguageUtil = /*#__PURE__*/function () {
  function LanguageUtil(options) {
    Object(classCallCheck["a" /* default */])(this, LanguageUtil);

    this.options = options;
    this.whitelist = this.options.whitelist || false;
    this.logger = baseLogger.create('languageUtils');
  }

  Object(createClass["a" /* default */])(LanguageUtil, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return null;
      var p = code.split('-');
      if (p.length === 2) return null;
      p.pop();
      return this.formatLanguageCode(p.join('-'));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return code;
      var p = code.split('-');
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      // http://www.iana.org/assignments/language-tags/language-tags.xhtml
      if (typeof code === 'string' && code.indexOf('-') > -1) {
        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
        var p = code.split('-');

        if (this.options.lowerCaseLng) {
          p = p.map(function (part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase(); // if lenght 2 guess it's a country

          if (p[1].length === 2) p[1] = p[1].toUpperCase();
          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
        }

        return p.join('-');
      }

      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code) {
      if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) {
        code = this.getLanguagePartFromCode(code);
      }

      return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks) return [];
      if (typeof fallbacks === 'string') fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
      if (!code) return fallbacks["default"] || []; // asume we have an object defining fallbacks

      var found = fallbacks[code];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found) found = fallbacks[this.formatLanguageCode(code)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this = this;

      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];

      var addCode = function addCode(c) {
        if (!c) return;

        if (_this.isWhitelisted(c)) {
          codes.push(c);
        } else {
          _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
        }
      };

      if (typeof code === 'string' && code.indexOf('-') > -1) {
        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === 'string') {
        addCode(this.formatLanguageCode(code));
      }

      fallbackCodes.forEach(function (fc) {
        if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);

  return LanguageUtil;
}();
/* eslint-disable */


var sets = [{
  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
  nr: [1],
  fc: 3
}, {
  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ['ar'],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ['cs', 'sk'],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ['csb', 'pl'],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ['cy'],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ['fr'],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ['ga'],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ['gd'],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ['is'],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ['jv'],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ['kw'],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ['lt'],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ['lv'],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ['mk'],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ['mnk'],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ['mt'],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ['or'],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ['ro'],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ['sl'],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ['he'],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _(n) {
    return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
/* eslint-enable */

function createRules() {
  var rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var i18next_PluralResolver = /*#__PURE__*/function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, PluralResolver);

    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');
    this.rules = createRules();
  }

  Object(createClass["a" /* default */])(PluralResolver, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var rule = this.getRule(code);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var _this = this;

      var ret = [];
      var rule = this.getRule(code);
      if (!rule) return ret;
      rule.numbers.forEach(function (n) {
        var suffix = _this.getSuffix(code, n);

        ret.push("".concat(key).concat(suffix));
      });
      return ret;
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var _this2 = this;

      var rule = this.getRule(code);

      if (rule) {
        // if (rule.numbers.length === 1) return ''; // only singular
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx]; // special treatment for lngs only having singular and plural

        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = 'plural';
          } else if (suffix === 1) {
            suffix = '';
          }
        }

        var returnSuffix = function returnSuffix() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        }; // COMPATIBILITY JSON
        // v1


        if (this.options.compatibilityJSON === 'v1') {
          if (suffix === 1) return '';
          if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (
        /* v2 */
        this.options.compatibilityJSON === 'v2') {
          return returnSuffix();
        } else if (
        /* v3 - gettext index */
        this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }

        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }

      this.logger.warn("no plural rule found for: ".concat(code));
      return '';
    }
  }]);

  return PluralResolver;
}();

var i18next_Interpolator = /*#__PURE__*/function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, Interpolator);

    this.logger = baseLogger.create('interpolator');
    this.options = options;

    this.format = options.interpolation && options.interpolation.format || function (value) {
      return value;
    };

    this.init(options);
  }
  /* eslint no-param-reassign: 0 */


  Object(createClass["a" /* default */])(Interpolator, [{
    key: "init",
    value: function init() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!options.interpolation) options.interpolation = {
        escapeValue: true
      };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== undefined ? iOpts.escape : i18next_escape;
      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false; // the regexp

      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      // the regexp
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, 'g');
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;

      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

      function regexSafe(val) {
        return val.replace(/\$/g, '$$$$');
      }

      var handleFormat = function handleFormat(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, undefined, lng) : path;
        }

        var p = key.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, options);
      };

      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      replaces = 0; // unescape if has unescapePrefix/Suffix

      /* eslint no-cond-assign: 0 */

      while (match = this.regexpUnescape.exec(str)) {
        value = handleFormat(match[1].trim());

        if (value === undefined) {
          if (typeof missingInterpolationHandler === 'function') {
            var temp = missingInterpolationHandler(str, match, options);
            value = typeof temp === 'string' ? temp : '';
          } else {
            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
            value = '';
          }
        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
          value = makeString(value);
        }

        str = str.replace(match[0], regexSafe(value));
        this.regexpUnescape.lastIndex = 0;
        replaces++;

        if (replaces >= this.maxReplaces) {
          break;
        }
      }

      replaces = 0; // regular escape on demand

      while (match = this.regexp.exec(str)) {
        value = handleFormat(match[1].trim());

        if (value === undefined) {
          if (typeof missingInterpolationHandler === 'function') {
            var _temp = missingInterpolationHandler(str, match, options);

            value = typeof _temp === 'string' ? _temp : '';
          } else {
            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
            value = '';
          }
        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
          value = makeString(value);
        }

        value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
        replaces++;

        if (replaces >= this.maxReplaces) {
          break;
        }
      }

      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var match;
      var value;

      var clonedOptions = _objectSpread({}, options);

      clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup

      delete clonedOptions.defaultValue; // assert we do not get a endless loop on interpolating defaultValue again and again
      // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"

      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');

        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        } // assert we do not get a endless loop on interpolating defaultValue again and again


        delete clonedOptions.defaultValue;
        return key;
      } // regular escape on demand


      while (match = this.nestingRegexp.exec(str)) {
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify

        if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty

        if (typeof value !== 'string') value = makeString(value);

        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = '';
        } // Nested keys should not be escaped by default #854
        // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);


        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }

      return str;
    }
  }]);

  return Interpolator;
}();

function remove(arr, what) {
  var found = arr.indexOf(what);

  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}

var i18next_Connector = /*#__PURE__*/function (_EventEmitter) {
  Object(inherits["a" /* default */])(Connector, _EventEmitter);

  function Connector(backend, store, services) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    Object(classCallCheck["a" /* default */])(this, Connector);

    _this = Object(possibleConstructorReturn["a" /* default */])(this, Object(getPrototypeOf["a" /* default */])(Connector).call(this));
    i18next_EventEmitter.call(Object(assertThisInitialized["a" /* default */])(_this)); // <=IE10 fix (unable to call parent constructor)

    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create('backendConnector');
    _this.state = {};
    _this.queue = [];

    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }

    return _this;
  }

  Object(createClass["a" /* default */])(Connector, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this; // find what needs to be loaded


      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function (lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function (ns) {
          var name = "".concat(lng, "|").concat(ns);

          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2; // loaded
          } else if (_this2.state[name] < 0) ;else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0) pending.push(name);
          } else {
            _this2.state[name] = 1; // pending

            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0) pending.push(name);
            if (toLoad.indexOf(name) < 0) toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
          }
        });
        if (!hasAllNamespaces) toLoadLanguages.push(lng);
      });

      if (toLoad.length || pending.length) {
        this.queue.push({
          pending: pending,
          loaded: {},
          errors: [],
          callback: callback
        });
      }

      return {
        toLoad: toLoad,
        pending: pending,
        toLoadLanguages: toLoadLanguages,
        toLoadNamespaces: toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var _name$split = name.split('|'),
          _name$split2 = Object(slicedToArray["a" /* default */])(_name$split, 2),
          lng = _name$split2[0],
          ns = _name$split2[1];

      if (err) this.emit('failedLoading', lng, ns, err);

      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      } // set loaded


      this.state[name] = err ? -1 : 2; // consolidated loading done in this run - only emit once for a loaded namespace

      var loaded = {}; // callback if ready

      this.queue.forEach(function (q) {
        pushPath(q.loaded, [lng], ns);
        remove(q.pending, name);
        if (err) q.errors.push(err);

        if (q.pending.length === 0 && !q.done) {
          // only do once per loaded -> this.emit('loaded', q.loaded);
          Object.keys(q.loaded).forEach(function (l) {
            if (!loaded[l]) loaded[l] = [];

            if (q.loaded[l].length) {
              q.loaded[l].forEach(function (ns) {
                if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
              });
            }
          });
          /* eslint no-param-reassign: 0 */

          q.done = true;

          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      }); // emit consolidated loaded event

      this.emit('loaded', loaded); // remove done load requests

      this.queue = this.queue.filter(function (q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;

      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : undefined;
      if (!lng.length) return callback(null, {}); // noting to load

      return this.backend[fcName](lng, ns, function (err, data) {
        if (err && data
        /* = retryFlag */
        && tried < 5) {
          setTimeout(function () {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }

        callback(err, data);
      });
    }
    /* eslint consistent-return: 0 */

  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;

      if (!this.backend) {
        this.logger.warn('No backend was added via i18next.use. Will not load resources.');
        return callback && callback();
      }

      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === 'string') namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);

      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now

        return null; // pendings will trigger callback
      }

      toLoad.toLoad.forEach(function (name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;

      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var _name$split3 = name.split('|'),
          _name$split4 = Object(slicedToArray["a" /* default */])(_name$split3, 2),
          lng = _name$split4[0],
          ns = _name$split4[1];

      this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn("did not save key \"".concat(key, "\" for namespace \"").concat(namespace, "\" as the namespace was not yet loaded"), 'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        return;
      } // ignore non valid keys


      if (key === undefined || key === null || key === '') return;

      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null
        /* unused callback */
        , _objectSpread({}, options, {
          isUpdate: isUpdate
        }));
      } // write to store to avoid resending


      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);

  return Connector;
}(i18next_EventEmitter);

function i18next_get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false,
    // string or array of namespaces
    whitelist: false,
    // array with whitelisted languages
    nonExplicitWhitelist: false,
    load: 'all',
    // | currentOnly | languageOnly
    preload: false,
    // array with preload languages
    simplifyPluralSuffix: true,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: false,
    // allow bundling certain languages that are not remotely fetched
    saveMissing: false,
    // enable to send missing values
    updateMissing: false,
    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: 'fallback',
    // 'current' || 'all'
    saveMissingPlurals: true,
    // will save all forms not only singular key
    missingKeyHandler: false,
    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: false,
    // function(str, match)
    postProcess: false,
    // string or array of postProcessor names
    postProcessPassResolved: false,
    // pass resolved object into 'options.i18nResolved' for postprocessor
    returnNull: true,
    // allows null value as valid translation
    returnEmptyString: true,
    // allows empty string value as valid translation
    returnObjects: false,
    joinArrays: false,
    // or string to join array
    returnedObjectHandler: false,
    // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: false,
    // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (Object(esm_typeof["a" /* default */])(args[1]) === 'object') ret = args[1];
      if (typeof args[1] === 'string') ret.defaultValue = args[1];
      if (typeof args[2] === 'string') ret.tDescription = args[2];

      if (Object(esm_typeof["a" /* default */])(args[2]) === 'object' || Object(esm_typeof["a" /* default */])(args[3]) === 'object') {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function (key) {
          ret[key] = options[key];
        });
      }

      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      nestingOptionsSeparator: ',',
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1000 // max replaces to prevent endless loop

    }
  };
}
/* eslint no-param-reassign: 0 */


function transformOptions(options) {
  // create namespace object if namespace is passed in as string
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS]; // extend whitelist with cimode

  if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
    options.whitelist = options.whitelist.concat(['cimode']);
  }

  return options;
}

function noop() {}

var i18next_I18n = /*#__PURE__*/function (_EventEmitter) {
  Object(inherits["a" /* default */])(I18n, _EventEmitter);

  function I18n() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;

    Object(classCallCheck["a" /* default */])(this, I18n);

    _this = Object(possibleConstructorReturn["a" /* default */])(this, Object(getPrototypeOf["a" /* default */])(I18n).call(this));
    i18next_EventEmitter.call(Object(assertThisInitialized["a" /* default */])(_this)); // <=IE10 fix (unable to call parent constructor)

    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };

    if (callback && !_this.isInitialized && !options.isClone) {
      // https://github.com/i18next/i18next/issues/879
      if (!_this.options.initImmediate) {
        _this.init(options, callback);

        return Object(possibleConstructorReturn["a" /* default */])(_this, Object(assertThisInitialized["a" /* default */])(_this));
      }

      setTimeout(function () {
        _this.init(options, callback);
      }, 0);
    }

    return _this;
  }

  Object(createClass["a" /* default */])(I18n, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      this.options = _objectSpread({}, i18next_get(), this.options, transformOptions(options));
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop;

      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === 'function') return new ClassOrObject();
        return ClassOrObject;
      } // init services


      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }

        var lu = new i18next_LanguageUtil(this.options);
        this.store = new i18next_ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new i18next_PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s.interpolator = new i18next_Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new i18next_Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options); // pipe events from backendConnector

        s.backendConnector.on('*', function (event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });

        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }

        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }

        this.translator = new i18next_Translator(this.services, this.options); // pipe events from translator

        this.translator.on('*', function (event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function (m) {
          if (m.init) m.init(_this2);
        });
      }

      if (!this.modules.languageDetector && !this.options.lng) {
        this.logger.warn('init: no languageDetector is used and no lng is defined');
      } // append api


      var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
      storeApi.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store;

          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var deferred = defer();

      var load = function load() {
        _this2.changeLanguage(_this2.options.lng, function (err, t) {
          _this2.isInitialized = true;

          _this2.logger.log('initialized', _this2.options);

          _this2.emit('initialized', _this2.options);

          deferred.resolve(t); // not rejecting on err (as err is only a loading translation failed warning)

          callback(err, t);
        });
      };

      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }

      return deferred;
    }
    /* eslint consistent-return: 0 */

  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === 'string' ? language : this.language;
      if (typeof language === 'function') usedCallback = language;

      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback(); // avoid loading resources for cimode

        var toLoad = [];

        var append = function append(lng) {
          if (!lng) return;

          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

          lngs.forEach(function (l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };

        if (!usedLng) {
          // at least load fallbacks in this case
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function (l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }

        if (this.options.preload) {
          this.options.preload.forEach(function (l) {
            return append(l);
          });
        }

        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop;
      this.services.backendConnector.reload(lngs, ns, function (err) {
        deferred.resolve(); // not rejecting on err (as err is only a loading translation failed warning)

        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (module.type === 'backend') {
        this.modules.backend = module;
      }

      if (module.type === 'logger' || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }

      if (module.type === 'languageDetector') {
        this.modules.languageDetector = module;
      }

      if (module.type === 'i18nFormat') {
        this.modules.i18nFormat = module;
      }

      if (module.type === 'postProcessor') {
        postProcessor.addPostProcessor(module);
      }

      if (module.type === '3rdParty') {
        this.modules.external.push(module);
      }

      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;

      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit('languageChanging', lng);

      var done = function done(err, l) {
        if (l) {
          _this4.language = l;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);

          _this4.translator.changeLanguage(l);

          _this4.isLanguageChangingTo = undefined;

          _this4.emit('languageChanged', l);

          _this4.logger.log('languageChanged', l);
        } else {
          _this4.isLanguageChangingTo = undefined;
        }

        deferred.resolve(function () {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err, function () {
          return _this4.t.apply(_this4, arguments);
        });
      };

      var setLng = function setLng(l) {
        if (l) {
          if (!_this4.language) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          }

          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }

        _this4.loadResources(l, function (err) {
          done(err, l);
        });
      };

      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }

      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns) {
      var _this5 = this;

      var fixedT = function fixedT(key, opts) {
        var options;

        if (Object(esm_typeof["a" /* default */])(opts) !== 'object') {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }

          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread({}, opts);
        }

        options.lng = options.lng || fixedT.lng;
        options.lngs = options.lngs || fixedT.lngs;
        options.ns = options.ns || fixedT.ns;
        return _this5.t(key, options);
      };

      if (typeof lng === 'string') {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }

      fixedT.ns = ns;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;

      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;

      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;

      if (!this.isInitialized) {
        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
        return false;
      }

      if (!this.languages || !this.languages.length) {
        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
        return false;
      }

      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1]; // we're in cimode so this shall pass

      if (lng.toLowerCase() === 'cimode') return true;

      var loadNotPending = function loadNotPending(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];

        return loadState === -1 || loadState === 2;
      }; // loaded -> SUCCESS


      if (this.hasResourceBundle(lng, ns)) return true; // were not loading at all -> SEMI SUCCESS

      if (!this.services.backendConnector.backend) return true; // failed loading ns - but at least fallback is not pending -> SEMI SUCCESS

      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;

      var deferred = defer();

      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }

      if (typeof ns === 'string') ns = [ns];
      ns.forEach(function (n) {
        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
      });
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === 'string') lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function (lng) {
        return preloaded.indexOf(lng) < 0;
      }); // Exit early if all given languages are already preloaded

      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }

      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng) return 'rtl';
      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
    }
    /* eslint class-methods-use-this: 0 */

  }, {
    key: "createInstance",
    value: function createInstance() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;
      return new I18n(options, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

      var mergedOptions = _objectSpread({}, this.options, options, {
        isClone: true
      });

      var clone = new I18n(mergedOptions);
      var membersToCopy = ['store', 'services', 'language'];
      membersToCopy.forEach(function (m) {
        clone[m] = _this8[m];
      });
      clone.translator = new i18next_Translator(clone.services, clone.options);
      clone.translator.on('*', function (event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options; // sync options

      return clone;
    }
  }]);

  return I18n;
}(i18next_EventEmitter);

var i18next = new i18next_I18n();
/* harmony default export */ var esm_i18next = (i18next);
// EXTERNAL MODULE: ../node_modules/react-i18next/dist/es/index.js + 9 modules
var es = __webpack_require__("CE6G");

// EXTERNAL MODULE: ../node_modules/ptz-i18n/dist/index.js
var dist = __webpack_require__("wc+d");

// EXTERNAL MODULE: ../node_modules/react-helmet/lib/Helmet.js
var Helmet = __webpack_require__("tj/o");
var Helmet_default = /*#__PURE__*/__webpack_require__.n(Helmet);

// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/components/Seo.tsx
var Seo = __webpack_require__("MlAH");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.fixed.js
var es6_string_fixed = __webpack_require__("BTfu");

// EXTERNAL MODULE: ../node_modules/antd/es/style/index.less
var es_style = __webpack_require__("SwVN");

// EXTERNAL MODULE: ../node_modules/antd/es/dropdown/style/index.less
var dropdown_style = __webpack_require__("mHqD");

// EXTERNAL MODULE: ../node_modules/antd/es/button/style/index.js
var button_style = __webpack_require__("sbMj");

// CONCATENATED MODULE: ../node_modules/antd/es/dropdown/style/index.js

 // style dependencies


// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/rc-trigger/es/index.js + 11 modules
var rc_trigger_es = __webpack_require__("mPTt");

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// CONCATENATED MODULE: ../node_modules/rc-dropdown/es/placements.js
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements_placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  topCenter: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  bottomCenter: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  }
};
/* harmony default export */ var es_placements = (placements_placements);
// CONCATENATED MODULE: ../node_modules/rc-dropdown/es/Dropdown.js












function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}






function Dropdown_Dropdown(props, ref) {
  var _props$prefixCls = props.prefixCls,
      prefixCls = _props$prefixCls === void 0 ? 'rc-dropdown' : _props$prefixCls,
      transitionName = props.transitionName,
      animation = props.animation,
      align = props.align,
      _props$placement = props.placement,
      placement = _props$placement === void 0 ? 'bottomLeft' : _props$placement,
      _props$placements = props.placements,
      placements = _props$placements === void 0 ? es_placements : _props$placements,
      getPopupContainer = props.getPopupContainer,
      showAction = props.showAction,
      hideAction = props.hideAction,
      overlayClassName = props.overlayClassName,
      overlayStyle = props.overlayStyle,
      visible = props.visible,
      _props$trigger = props.trigger,
      trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
      otherProps = _objectWithoutProperties(props, ["prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger"]);

  var _React$useState = react["useState"](),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      triggerVisible = _React$useState2[0],
      setTriggerVisible = _React$useState2[1];

  var mergedVisible = 'visible' in props ? visible : triggerVisible;
  var triggerRef = react["useRef"](null);
  react["useImperativeHandle"](ref, function () {
    return triggerRef.current;
  });

  var getOverlayElement = function getOverlayElement() {
    var overlay = props.overlay;
    var overlayElement;

    if (typeof overlay === 'function') {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }

    return overlayElement;
  };

  var onClick = function onClick(e) {
    var onOverlayClick = props.onOverlayClick;
    var overlayProps = getOverlayElement().props;
    setTriggerVisible(false);

    if (onOverlayClick) {
      onOverlayClick(e);
    }

    if (overlayProps.onClick) {
      overlayProps.onClick(e);
    }
  };

  var onVisibleChange = function onVisibleChange(visible) {
    var onVisibleChange = props.onVisibleChange;
    setTriggerVisible(visible);

    if (typeof onVisibleChange === 'function') {
      onVisibleChange(visible);
    }
  };

  var getMenuElement = function getMenuElement() {
    var overlayElement = getOverlayElement();
    var extraOverlayProps = {
      prefixCls: "".concat(prefixCls, "-menu"),
      onClick: onClick
    };

    if (typeof overlayElement.type === 'string') {
      delete extraOverlayProps.prefixCls;
    }

    return react["cloneElement"](overlayElement, extraOverlayProps);
  };

  var getMenuElementOrLambda = function getMenuElementOrLambda() {
    var overlay = props.overlay;

    if (typeof overlay === 'function') {
      return getMenuElement;
    }

    return getMenuElement();
  };

  var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger,
        alignPoint = props.alignPoint;

    if ('minOverlayWidthMatchTrigger' in props) {
      return minOverlayWidthMatchTrigger;
    }

    return !alignPoint;
  };

  var getOpenClassName = function getOpenClassName() {
    var openClassName = props.openClassName;

    if (openClassName !== undefined) {
      return openClassName;
    }

    return "".concat(prefixCls, "-open");
  };

  var renderChildren = function renderChildren() {
    var children = props.children;
    var childrenProps = children.props ? children.props : {};
    var childClassName = classnames_default()(childrenProps.className, getOpenClassName());
    return triggerVisible && children ? react["cloneElement"](children, {
      className: childClassName
    }) : children;
  };

  var triggerHideAction = hideAction;

  if (!triggerHideAction && trigger.indexOf('contextMenu') !== -1) {
    triggerHideAction = ['click'];
  }

  return react["createElement"](rc_trigger_es["a" /* default */], Object.assign({}, otherProps, {
    prefixCls: prefixCls,
    ref: triggerRef,
    popupClassName: overlayClassName,
    popupStyle: overlayStyle,
    builtinPlacements: placements,
    action: trigger,
    showAction: showAction,
    hideAction: triggerHideAction || [],
    popupPlacement: placement,
    popupAlign: align,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? 'minWidth' : '',
    popup: getMenuElementOrLambda(),
    onPopupVisibleChange: onVisibleChange,
    getPopupContainer: getPopupContainer
  }), renderChildren());
}

/* harmony default export */ var es_Dropdown = (react["forwardRef"](Dropdown_Dropdown));
// CONCATENATED MODULE: ../node_modules/rc-dropdown/es/index.js

/* harmony default export */ var rc_dropdown_es = (es_Dropdown);
// EXTERNAL MODULE: ../node_modules/@ant-design/icons/RightOutlined.js
var RightOutlined = __webpack_require__("rwvH");
var RightOutlined_default = /*#__PURE__*/__webpack_require__.n(RightOutlined);

// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/context.js + 4 modules
var context = __webpack_require__("Bfez");

// EXTERNAL MODULE: ../node_modules/antd/es/_util/warning.js
var warning = __webpack_require__("papw");

// EXTERNAL MODULE: ../node_modules/antd/es/_util/type.js
var _util_type = __webpack_require__("UyNX");

// CONCATENATED MODULE: ../node_modules/antd/es/dropdown/dropdown.js








function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}








var Placements = Object(_util_type["a" /* tuple */])('topLeft', 'topCenter', 'topRight', 'bottomLeft', 'bottomCenter', 'bottomRight');

var dropdown_Dropdown = /*#__PURE__*/function (_React$Component) {
  _inherits(Dropdown, _React$Component);

  function Dropdown() {
    var _this;

    _classCallCheck(this, Dropdown);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Dropdown).apply(this, arguments));

    _this.renderOverlay = function (prefixCls) {
      // rc-dropdown already can process the function of overlay, but we have check logic here.
      // So we need render the element to check and pass back to rc-dropdown.
      var overlay = _this.props.overlay;
      var overlayNode;

      if (typeof overlay === 'function') {
        overlayNode = overlay();
      } else {
        overlayNode = overlay;
      }

      overlayNode = react["Children"].only(overlayNode);
      var overlayProps = overlayNode.props; // Warning if use other mode

      Object(warning["a" /* default */])(!overlayProps.mode || overlayProps.mode === 'vertical', 'Dropdown', "mode=\"".concat(overlayProps.mode, "\" is not supported for Dropdown's Menu.")); // menu cannot be selectable in dropdown defaultly
      // menu should be focusable in dropdown defaultly

      var _overlayProps$selecta = overlayProps.selectable,
          selectable = _overlayProps$selecta === void 0 ? false : _overlayProps$selecta,
          _overlayProps$focusab = overlayProps.focusable,
          focusable = _overlayProps$focusab === void 0 ? true : _overlayProps$focusab;
      var expandIcon = react["createElement"]("span", {
        className: "".concat(prefixCls, "-menu-submenu-arrow")
      }, react["createElement"](RightOutlined_default.a, {
        className: "".concat(prefixCls, "-menu-submenu-arrow-icon")
      }));
      var fixedModeOverlay = typeof overlayNode.type === 'string' ? overlay : react["cloneElement"](overlayNode, {
        mode: 'vertical',
        selectable: selectable,
        focusable: focusable,
        expandIcon: expandIcon
      });
      return fixedModeOverlay;
    };

    _this.renderDropDown = function (_ref) {
      var getContextPopupContainer = _ref.getPopupContainer,
          getPrefixCls = _ref.getPrefixCls,
          direction = _ref.direction;
      var _this$props = _this.props,
          customizePrefixCls = _this$props.prefixCls,
          children = _this$props.children,
          trigger = _this$props.trigger,
          disabled = _this$props.disabled,
          getPopupContainer = _this$props.getPopupContainer,
          overlayClassName = _this$props.overlayClassName;
      var prefixCls = getPrefixCls('dropdown', customizePrefixCls);
      var child = react["Children"].only(children);
      var dropdownTrigger = react["cloneElement"](child, {
        className: classnames_default()(child.props.className, "".concat(prefixCls, "-trigger"), _defineProperty({}, "".concat(prefixCls, "-rtl"), direction === 'rtl')),
        disabled: disabled
      });
      var overlayClassNameCustomized = classnames_default()(overlayClassName, _defineProperty({}, "".concat(prefixCls, "-rtl"), direction === 'rtl'));
      var triggerActions = disabled ? [] : trigger;
      var alignPoint;

      if (triggerActions && triggerActions.indexOf('contextMenu') !== -1) {
        alignPoint = true;
      }

      return react["createElement"](rc_dropdown_es, _extends({
        alignPoint: alignPoint
      }, _this.props, {
        overlayClassName: overlayClassNameCustomized,
        prefixCls: prefixCls,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        transitionName: _this.getTransitionName(),
        trigger: triggerActions,
        overlay: function overlay() {
          return _this.renderOverlay(prefixCls);
        },
        placement: _this.getPlacement(direction)
      }), dropdownTrigger);
    };

    return _this;
  }

  _createClass(Dropdown, [{
    key: "getTransitionName",
    value: function getTransitionName() {
      var _this$props2 = this.props,
          _this$props2$placemen = _this$props2.placement,
          placement = _this$props2$placemen === void 0 ? '' : _this$props2$placemen,
          transitionName = _this$props2.transitionName;

      if (transitionName !== undefined) {
        return transitionName;
      }

      if (placement.indexOf('top') >= 0) {
        return 'slide-down';
      }

      return 'slide-up';
    }
  }, {
    key: "getPlacement",
    value: function getPlacement() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ltr';
      var placement = this.props.placement;

      if (placement !== undefined) {
        return placement;
      }

      return direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
    }
  }, {
    key: "render",
    value: function render() {
      return react["createElement"](context["a" /* ConfigConsumer */], null, this.renderDropDown);
    }
  }]);

  return Dropdown;
}(react["Component"]);


dropdown_Dropdown.defaultProps = {
  mouseEnterDelay: 0.15,
  mouseLeaveDelay: 0.1
};
// EXTERNAL MODULE: ../node_modules/@ant-design/icons/EllipsisOutlined.js
var EllipsisOutlined = __webpack_require__("VW18");
var EllipsisOutlined_default = /*#__PURE__*/__webpack_require__.n(EllipsisOutlined);

// EXTERNAL MODULE: ../node_modules/antd/es/button/index.js + 2 modules
var es_button = __webpack_require__("H4M2");

// CONCATENATED MODULE: ../node_modules/antd/es/dropdown/dropdown-button.js













function dropdown_button_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    dropdown_button_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    dropdown_button_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return dropdown_button_typeof(obj);
}

function dropdown_button_extends() {
  dropdown_button_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return dropdown_button_extends.apply(this, arguments);
}

function dropdown_button_slicedToArray(arr, i) {
  return dropdown_button_arrayWithHoles(arr) || dropdown_button_iterableToArrayLimit(arr, i) || dropdown_button_nonIterableRest();
}

function dropdown_button_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function dropdown_button_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function dropdown_button_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function dropdown_button_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function dropdown_button_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function dropdown_button_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) dropdown_button_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) dropdown_button_defineProperties(Constructor, staticProps);
  return Constructor;
}

function dropdown_button_possibleConstructorReturn(self, call) {
  if (call && (dropdown_button_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return dropdown_button_assertThisInitialized(self);
}

function dropdown_button_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function dropdown_button_getPrototypeOf(o) {
  dropdown_button_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return dropdown_button_getPrototypeOf(o);
}

function dropdown_button_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) dropdown_button_setPrototypeOf(subClass, superClass);
}

function dropdown_button_setPrototypeOf(o, p) {
  dropdown_button_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return dropdown_button_setPrototypeOf(o, p);
}

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







var ButtonGroup = es_button["a" /* default */].Group;

var dropdown_button_DropdownButton = /*#__PURE__*/function (_React$Component) {
  dropdown_button_inherits(DropdownButton, _React$Component);

  function DropdownButton() {
    var _this;

    dropdown_button_classCallCheck(this, DropdownButton);

    _this = dropdown_button_possibleConstructorReturn(this, dropdown_button_getPrototypeOf(DropdownButton).apply(this, arguments));

    _this.renderButton = function (_ref) {
      var getContextPopupContainer = _ref.getPopupContainer,
          getPrefixCls = _ref.getPrefixCls;

      var _a = _this.props,
          customizePrefixCls = _a.prefixCls,
          type = _a.type,
          disabled = _a.disabled,
          onClick = _a.onClick,
          htmlType = _a.htmlType,
          children = _a.children,
          className = _a.className,
          overlay = _a.overlay,
          trigger = _a.trigger,
          align = _a.align,
          visible = _a.visible,
          onVisibleChange = _a.onVisibleChange,
          placement = _a.placement,
          getPopupContainer = _a.getPopupContainer,
          href = _a.href,
          _a$icon = _a.icon,
          icon = _a$icon === void 0 ? react["createElement"](EllipsisOutlined_default.a, null) : _a$icon,
          title = _a.title,
          buttonsRender = _a.buttonsRender,
          restProps = __rest(_a, ["prefixCls", "type", "disabled", "onClick", "htmlType", "children", "className", "overlay", "trigger", "align", "visible", "onVisibleChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender"]);

      var prefixCls = getPrefixCls('dropdown-button', customizePrefixCls);
      var dropdownProps = {
        align: align,
        overlay: overlay,
        disabled: disabled,
        trigger: disabled ? [] : trigger,
        onVisibleChange: onVisibleChange,
        placement: placement,
        getPopupContainer: getPopupContainer || getContextPopupContainer
      };

      if ('visible' in _this.props) {
        dropdownProps.visible = visible;
      }

      var leftButton = react["createElement"](es_button["a" /* default */], {
        type: type,
        disabled: disabled,
        onClick: onClick,
        htmlType: htmlType,
        href: href,
        title: title
      }, children);
      var rightButton = react["createElement"](es_button["a" /* default */], {
        type: type
      }, icon);

      var _buttonsRender = buttonsRender([leftButton, rightButton]),
          _buttonsRender2 = dropdown_button_slicedToArray(_buttonsRender, 2),
          leftButtonToRender = _buttonsRender2[0],
          rightButtonToRender = _buttonsRender2[1];

      return react["createElement"](ButtonGroup, dropdown_button_extends({}, restProps, {
        className: classnames_default()(prefixCls, className)
      }), leftButtonToRender, react["createElement"](dropdown_Dropdown, dropdownProps, rightButtonToRender));
    };

    return _this;
  }

  dropdown_button_createClass(DropdownButton, [{
    key: "render",
    value: function render() {
      return react["createElement"](context["a" /* ConfigConsumer */], null, this.renderButton);
    }
  }]);

  return DropdownButton;
}(react["Component"]);


dropdown_button_DropdownButton.__ANT_BUTTON = true;
dropdown_button_DropdownButton.defaultProps = {
  placement: 'bottomRight',
  type: 'default',
  buttonsRender: function buttonsRender(buttons) {
    return buttons;
  }
};
// CONCATENATED MODULE: ../node_modules/antd/es/dropdown/index.js


dropdown_Dropdown.Button = dropdown_button_DropdownButton;
/* harmony default export */ var dropdown = (dropdown_Dropdown);
// EXTERNAL MODULE: ../node_modules/antd/es/menu/style/index.js
var menu_style = __webpack_require__("XfXe");

// EXTERNAL MODULE: ../node_modules/antd/es/menu/index.js + 18 modules
var es_menu = __webpack_require__("v5c9");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.ends-with.js
var es6_string_ends_with = __webpack_require__("BDzi");

// EXTERNAL MODULE: ../node_modules/antd/es/popover/style/index.less
var popover_style = __webpack_require__("nNvC");

// CONCATENATED MODULE: ../node_modules/antd/es/popover/style/index.js

 // style dependencies
// deps-lint-skip: tooltip
// EXTERNAL MODULE: ../node_modules/antd/es/tooltip/index.js + 5 modules
var tooltip = __webpack_require__("DGR3");

// CONCATENATED MODULE: ../node_modules/antd/es/popover/index.js








function popover_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    popover_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    popover_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return popover_typeof(obj);
}

function popover_extends() {
  popover_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return popover_extends.apply(this, arguments);
}

function popover_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function popover_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function popover_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) popover_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) popover_defineProperties(Constructor, staticProps);
  return Constructor;
}

function popover_possibleConstructorReturn(self, call) {
  if (call && (popover_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return popover_assertThisInitialized(self);
}

function popover_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function popover_getPrototypeOf(o) {
  popover_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return popover_getPrototypeOf(o);
}

function popover_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) popover_setPrototypeOf(subClass, superClass);
}

function popover_setPrototypeOf(o, p) {
  popover_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return popover_setPrototypeOf(o, p);
}

var popover_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





var popover_Popover = /*#__PURE__*/function (_React$Component) {
  popover_inherits(Popover, _React$Component);

  function Popover() {
    var _this;

    popover_classCallCheck(this, Popover);

    _this = popover_possibleConstructorReturn(this, popover_getPrototypeOf(Popover).apply(this, arguments));

    _this.saveTooltip = function (node) {
      _this.tooltip = node;
    };

    _this.renderPopover = function (_ref) {
      var getPrefixCls = _ref.getPrefixCls;

      var _a = _this.props,
          customizePrefixCls = _a.prefixCls,
          props = popover_rest(_a, ["prefixCls"]);

      delete props.title;
      var prefixCls = getPrefixCls('popover', customizePrefixCls);
      return react["createElement"](tooltip["a" /* default */], popover_extends({}, props, {
        prefixCls: prefixCls,
        ref: _this.saveTooltip,
        overlay: _this.getOverlay(prefixCls)
      }));
    };

    return _this;
  }

  popover_createClass(Popover, [{
    key: "getPopupDomNode",
    value: function getPopupDomNode() {
      return this.tooltip.getPopupDomNode();
    }
  }, {
    key: "getOverlay",
    value: function getOverlay(prefixCls) {
      var _this$props = this.props,
          title = _this$props.title,
          content = _this$props.content;
      return react["createElement"]("div", null, title && react["createElement"]("div", {
        className: "".concat(prefixCls, "-title")
      }, title), react["createElement"]("div", {
        className: "".concat(prefixCls, "-inner-content")
      }, content));
    }
  }, {
    key: "render",
    value: function render() {
      return react["createElement"](context["a" /* ConfigConsumer */], null, this.renderPopover);
    }
  }]);

  return Popover;
}(react["Component"]);


popover_Popover.defaultProps = {
  placement: 'top',
  transitionName: 'zoom-big',
  trigger: 'hover',
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  overlayStyle: {}
};
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.link.js
var es6_string_link = __webpack_require__("ScpY");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.starts-with.js
var es6_string_starts_with = __webpack_require__("FEHE");

// EXTERNAL MODULE: ../node_modules/antd/es/message/style/index.less
var message_style = __webpack_require__("zYiv");

// CONCATENATED MODULE: ../node_modules/antd/es/message/style/index.js


// EXTERNAL MODULE: ../node_modules/rc-notification/es/index.js + 1 modules
var rc_notification_es = __webpack_require__("qtgu");

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/LoadingOutlined.js
var LoadingOutlined = __webpack_require__("yRvC");
var LoadingOutlined_default = /*#__PURE__*/__webpack_require__.n(LoadingOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/ExclamationCircleFilled.js
var ExclamationCircleFilled = __webpack_require__("l8sR");
var ExclamationCircleFilled_default = /*#__PURE__*/__webpack_require__.n(ExclamationCircleFilled);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/CloseCircleFilled.js
var CloseCircleFilled = __webpack_require__("g4/d");
var CloseCircleFilled_default = /*#__PURE__*/__webpack_require__.n(CloseCircleFilled);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/CheckCircleFilled.js
var CheckCircleFilled = __webpack_require__("Awoh");
var CheckCircleFilled_default = /*#__PURE__*/__webpack_require__.n(CheckCircleFilled);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/InfoCircleFilled.js
var InfoCircleFilled = __webpack_require__("zqvS");
var InfoCircleFilled_default = /*#__PURE__*/__webpack_require__.n(InfoCircleFilled);

// CONCATENATED MODULE: ../node_modules/antd/es/message/index.js







function message_extends() {
  message_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return message_extends.apply(this, arguments);
}








var defaultDuration = 3;
var defaultTop;
var messageInstance;
var message_key = 1;
var message_prefixCls = 'ant-message';
var message_transitionName = 'move-up';
var getContainer;
var maxCount;

function getMessageInstance(callback) {
  if (messageInstance) {
    callback(messageInstance);
    return;
  }

  rc_notification_es["a" /* default */].newInstance({
    prefixCls: message_prefixCls,
    transitionName: message_transitionName,
    style: {
      top: defaultTop
    },
    getContainer: getContainer,
    maxCount: maxCount
  }, function (instance) {
    if (messageInstance) {
      callback(messageInstance);
      return;
    }

    messageInstance = instance;
    callback(instance);
  });
}

var iconMap = {
  info: InfoCircleFilled_default.a,
  success: CheckCircleFilled_default.a,
  error: CloseCircleFilled_default.a,
  warning: ExclamationCircleFilled_default.a,
  loading: LoadingOutlined_default.a
};

function notice(args) {
  var duration = args.duration !== undefined ? args.duration : defaultDuration;
  var IconComponent = iconMap[args.type];
  var target = args.key || message_key++;
  var closePromise = new Promise(function (resolve) {
    var callback = function callback() {
      if (typeof args.onClose === 'function') {
        args.onClose();
      }

      return resolve(true);
    };

    getMessageInstance(function (instance) {
      instance.notice({
        key: target,
        duration: duration,
        style: {},
        content: react["createElement"]("div", {
          className: "".concat(message_prefixCls, "-custom-content").concat(args.type ? " ".concat(message_prefixCls, "-").concat(args.type) : '')
        }, args.icon || IconComponent && react["createElement"](IconComponent, null), react["createElement"]("span", null, args.content)),
        onClose: callback
      });
    });
  });

  var result = function result() {
    if (messageInstance) {
      messageInstance.removeNotice(target);
    }
  };

  result.then = function (filled, rejected) {
    return closePromise.then(filled, rejected);
  };

  result.promise = closePromise;
  return result;
}

function isArgsProps(content) {
  return Object.prototype.toString.call(content) === '[object Object]' && !!content.content;
}

var api = {
  open: notice,
  config: function config(options) {
    if (options.top !== undefined) {
      defaultTop = options.top;
      messageInstance = null; // delete messageInstance for new defaultTop
    }

    if (options.duration !== undefined) {
      defaultDuration = options.duration;
    }

    if (options.prefixCls !== undefined) {
      message_prefixCls = options.prefixCls;
    }

    if (options.getContainer !== undefined) {
      getContainer = options.getContainer;
    }

    if (options.transitionName !== undefined) {
      message_transitionName = options.transitionName;
      messageInstance = null; // delete messageInstance for new transitionName
    }

    if (options.maxCount !== undefined) {
      maxCount = options.maxCount;
      messageInstance = null;
    }
  },
  destroy: function destroy() {
    if (messageInstance) {
      messageInstance.destroy();
      messageInstance = null;
    }
  }
};
['success', 'info', 'warning', 'error', 'loading'].forEach(function (type) {
  api[type] = function (content, duration, onClose) {
    if (isArgsProps(content)) {
      return api.open(message_extends(message_extends({}, content), {
        type: type
      }));
    }

    if (typeof duration === 'function') {
      onClose = duration;
      duration = undefined;
    }

    return api.open({
      content: content,
      duration: duration,
      type: type,
      onClose: onClose
    });
  };
});
api.warn = api.warning;
/* harmony default export */ var message = (api);
// EXTERNAL MODULE: ../node_modules/antd/es/select/style/index.less
var select_style = __webpack_require__("ov/p");

// EXTERNAL MODULE: ../node_modules/antd/es/empty/style/index.less
var empty_style = __webpack_require__("GFpW");

// CONCATENATED MODULE: ../node_modules/antd/es/empty/style/index.js


// CONCATENATED MODULE: ../node_modules/antd/es/select/style/index.js

 // style dependencies


// EXTERNAL MODULE: ../node_modules/omit.js/es/index.js
var omit_js_es = __webpack_require__("x9u5");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.find-index.js
var es6_array_find_index = __webpack_require__("2UZ+");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.string.iterator.js
var es6_string_iterator = __webpack_require__("lQyR");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.from.js
var es6_array_from = __webpack_require__("YhIr");

// EXTERNAL MODULE: ../node_modules/rc-util/es/KeyCode.js
var KeyCode = __webpack_require__("zAXs");

// CONCATENATED MODULE: ../node_modules/rc-util/es/hooks/useMemo.js

function useMemo(getValue, condition, shouldUpdate) {
  var cacheRef = react["useRef"]({});

  if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue();
    cacheRef.current.condition = condition;
  }

  return cacheRef.current.value;
}
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-properties.js
var es6_object_define_properties = __webpack_require__("6/FK");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("2Tod");

// CONCATENATED MODULE: ../node_modules/rc-virtual-list/es/Filler.js











function Filler_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function Filler_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      Filler_ownKeys(Object(source), true).forEach(function (key) {
        Filler_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      Filler_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function Filler_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



/**
 * Fill component to provided the scroll content real height.
 */

var Filler_Filler = function Filler(_ref) {
  var height = _ref.height,
      offset = _ref.offset,
      children = _ref.children,
      prefixCls = _ref.prefixCls;
  var outerStyle = {};
  var innerStyle = {
    display: 'flex',
    flexDirection: 'column'
  };

  if (offset !== undefined) {
    outerStyle = {
      height: height,
      position: 'relative',
      overflow: 'hidden'
    };
    innerStyle = Filler_objectSpread({}, innerStyle, {
      transform: "translateY(".concat(offset, "px)"),
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0
    });
  }

  return react["createElement"]("div", {
    style: outerStyle
  }, react["createElement"]("div", {
    style: innerStyle,
    className: classnames_default()(Filler_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls))
  }, children));
};

/* harmony default export */ var es_Filler = (Filler_Filler);
// EXTERNAL MODULE: ../node_modules/rc-util/es/Dom/findDOMNode.js
var findDOMNode = __webpack_require__("vXvS");

// CONCATENATED MODULE: ../node_modules/rc-virtual-list/es/utils/itemUtil.js







function itemUtil_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = itemUtil_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function itemUtil_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}


/**
 * Our algorithm have additional one ghost item
 * whose index as `data.length` to simplify the calculation
 */

var GHOST_ITEM_KEY = '__rc_ghost_item__';
/**
 * Get location item and its align percentage with the scroll percentage.
 * We should measure current scroll position to decide which item is the location item.
 * And then fill the top count and bottom count with the base of location item.
 *
 * `total` should be the real count instead of `total - 1` in calculation.
 */

function getLocationItem(scrollPtg, total) {
  var itemIndex = Math.floor(scrollPtg * total);
  var itemTopPtg = itemIndex / total;
  var itemBottomPtg = (itemIndex + 1) / total;
  var itemOffsetPtg = (scrollPtg - itemTopPtg) / (itemBottomPtg - itemTopPtg);
  return {
    index: itemIndex,
    offsetPtg: itemOffsetPtg
  };
}
/**
 * Safari has the elasticity effect which provides negative `scrollTop` value.
 * We should ignore it since will make scroll animation shake.
 */


function alignScrollTop(scrollTop, scrollRange) {
  if (scrollTop < 0) {
    return 0;
  }

  if (scrollTop >= scrollRange) {
    return scrollRange;
  }

  return scrollTop;
}
function getScrollPercentage(_ref) {
  var scrollTop = _ref.scrollTop,
      scrollHeight = _ref.scrollHeight,
      clientHeight = _ref.clientHeight;

  if (scrollHeight <= clientHeight) {
    return 0;
  }

  var scrollRange = scrollHeight - clientHeight;
  var alignedScrollTop = alignScrollTop(scrollTop, scrollRange);
  var scrollTopPtg = alignedScrollTop / scrollRange;
  return scrollTopPtg;
}
function getElementScrollPercentage(element) {
  if (!element) {
    return 0;
  }

  return getScrollPercentage(element);
}
/**
 * Get node `offsetHeight`. We prefer node is a dom element directly.
 * But if not provided, downgrade to `findDOMNode` to get the real dom element.
 */

function getNodeHeight(node) {
  var element = Object(findDOMNode["a" /* default */])(node);
  return element ? element.offsetHeight : 0;
}
/**
 * Get display items start, end, located item index. This is pure math calculation
 */

function getRangeIndex(scrollPtg, itemCount, visibleCount) {
  var _getLocationItem = getLocationItem(scrollPtg, itemCount),
      index = _getLocationItem.index,
      offsetPtg = _getLocationItem.offsetPtg;

  var beforeCount = Math.ceil(scrollPtg * visibleCount);
  var afterCount = Math.ceil((1 - scrollPtg) * visibleCount);
  return {
    itemIndex: index,
    itemOffsetPtg: offsetPtg,
    startIndex: Math.max(0, index - beforeCount),
    endIndex: Math.min(itemCount - 1, index + afterCount)
  };
}
/**
 * Calculate the located item related top with current window height
 */

function getItemRelativeTop(_ref2) {
  var itemIndex = _ref2.itemIndex,
      itemOffsetPtg = _ref2.itemOffsetPtg,
      itemElementHeights = _ref2.itemElementHeights,
      scrollPtg = _ref2.scrollPtg,
      clientHeight = _ref2.clientHeight,
      getItemKey = _ref2.getItemKey;
  var locatedItemHeight = itemElementHeights[getItemKey(itemIndex)] || 0;
  var locatedItemTop = scrollPtg * clientHeight;
  var locatedItemOffset = itemOffsetPtg * locatedItemHeight;
  return Math.floor(locatedItemTop - locatedItemOffset);
}
/**
 * Calculate the located item absolute top with whole scroll height
 */

function getItemAbsoluteTop(_ref3) {
  var scrollTop = _ref3.scrollTop,
      rest = itemUtil_objectWithoutProperties(_ref3, ["scrollTop"]);

  return scrollTop + getItemRelativeTop(rest);
}
function getCompareItemRelativeTop(_ref4) {
  var locatedItemRelativeTop = _ref4.locatedItemRelativeTop,
      locatedItemIndex = _ref4.locatedItemIndex,
      compareItemIndex = _ref4.compareItemIndex,
      startIndex = _ref4.startIndex,
      endIndex = _ref4.endIndex,
      getItemKey = _ref4.getItemKey,
      itemElementHeights = _ref4.itemElementHeights;
  var originCompareItemTop = locatedItemRelativeTop;
  var compareItemKey = getItemKey(compareItemIndex);

  if (compareItemIndex <= locatedItemIndex) {
    for (var index = locatedItemIndex; index >= startIndex; index -= 1) {
      var key = getItemKey(index);

      if (key === compareItemKey) {
        break;
      }

      var prevItemKey = getItemKey(index - 1);
      originCompareItemTop -= itemElementHeights[prevItemKey] || 0;
    }
  } else {
    for (var _index = locatedItemIndex; _index <= endIndex; _index += 1) {
      var _key = getItemKey(_index);

      if (_key === compareItemKey) {
        break;
      }

      originCompareItemTop += itemElementHeights[_key] || 0;
    }
  }

  return originCompareItemTop;
}
function requireVirtual(height, itemHeight, count, virtual) {
  return virtual !== false && typeof height === 'number' && count * itemHeight > height;
}
// CONCATENATED MODULE: ../node_modules/rc-virtual-list/es/utils/algorithmUtil.js
/**
 * Get index with specific start index one by one. e.g.
 * min: 3, max: 9, start: 6
 *
 * Return index is:
 * [0]: 6
 * [1]: 7
 * [2]: 5
 * [3]: 8
 * [4]: 4
 * [5]: 9
 * [6]: 3
 */
function getIndexByStartLoc(min, max, start, index) {
  var beforeCount = start - min;
  var afterCount = max - start;
  var balanceCount = Math.min(beforeCount, afterCount) * 2; // Balance

  if (index <= balanceCount) {
    var stepIndex = Math.floor(index / 2);

    if (index % 2) {
      return start + stepIndex + 1;
    }

    return start - stepIndex;
  } // One is out of range


  if (beforeCount > afterCount) {
    return start - (index - afterCount);
  }

  return start + (index - beforeCount);
}
/**
 * We assume that 2 list has only 1 item diff and others keeping the order.
 * So we can use dichotomy algorithm to find changed one.
 */

function findListDiffIndex(originList, targetList, getKey) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;

  if (originLen === 0 && targetLen === 0) {
    return null;
  }

  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }

  var notExistKey = {
    __EMPTY_ITEM__: true
  };

  function getItemKey(item) {
    if (item !== undefined) {
      return getKey(item);
    }

    return notExistKey;
  } // Loop to find diff one


  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;

  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);

    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }

  return diffIndex === null ? null : {
    index: diffIndex,
    multiple: multiple
  };
}
// CONCATENATED MODULE: ../node_modules/rc-virtual-list/es/List.js



















function List_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function List_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      List_ownKeys(Object(source), true).forEach(function (key) {
        List_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      List_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function List_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function List_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = List_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function List_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function List_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    List_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    List_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return List_typeof(obj);
}

function List_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function List_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function List_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) List_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) List_defineProperties(Constructor, staticProps);
  return Constructor;
}

function List_possibleConstructorReturn(self, call) {
  if (call && (List_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return List_assertThisInitialized(self);
}

function List_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function List_getPrototypeOf(o) {
  List_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return List_getPrototypeOf(o);
}

function List_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) List_setPrototypeOf(subClass, superClass);
}

function List_setPrototypeOf(o, p) {
  List_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return List_setPrototypeOf(o, p);
}






var ScrollStyle = {
  overflowY: 'auto',
  overflowAnchor: 'none'
};
var ITEM_SCALE_RATE = 1;
/**
 * We use class component here since typescript can not support generic in function component
 *
 * Virtual list display logic:
 * 1. scroll / initialize trigger measure
 * 2. Get location item of current `scrollTop`
 * 3. [Render] Render visible items
 * 4. Get all the visible items height
 * 5. [Render] Update top item `margin-top` to fit the position
 *
 * Algorithm:
 * We split scroll bar into equal slice. An item with whatever height occupy the same range slice.
 * When `scrollTop` change,
 * it will calculate the item percentage position and move item to the position.
 * Then calculate other item position base on the located item.
 *
 * Concept:
 *
 * # located item
 * The base position item which other items position calculate base on.
 */

var List_List = /*#__PURE__*/function (_React$Component) {
  List_inherits(List, _React$Component);

  function List(props) {
    var _this;

    List_classCallCheck(this, List);

    _this = List_possibleConstructorReturn(this, List_getPrototypeOf(List).call(this, props));
    _this.listRef = react["createRef"]();
    _this.itemElements = {};
    _this.itemElementHeights = {};
    /**
     * Lock scroll process with `onScroll` event.
     * This is used for `data` length change and `scrollTop` restore
     */

    _this.lockScroll = false;
    /**
     * Phase 2: Trigger render since we should re-calculate current position.
     */

    _this.onScroll = function (event) {
      var _this$props = _this.props,
          data = _this$props.data,
          height = _this$props.height,
          itemHeight = _this$props.itemHeight,
          disabled = _this$props.disabled;
      var _this$listRef$current = _this.listRef.current,
          originScrollTop = _this$listRef$current.scrollTop,
          clientHeight = _this$listRef$current.clientHeight,
          scrollHeight = _this$listRef$current.scrollHeight;
      var scrollTop = alignScrollTop(originScrollTop, scrollHeight - clientHeight); // Skip if `scrollTop` not change to avoid shake

      if (scrollTop === _this.state.scrollTop || _this.lockScroll || disabled) {
        return;
      }

      var scrollPtg = getElementScrollPercentage(_this.listRef.current);
      var visibleCount = Math.ceil(height / itemHeight);

      var _getRangeIndex = getRangeIndex(scrollPtg, data.length, visibleCount),
          itemIndex = _getRangeIndex.itemIndex,
          itemOffsetPtg = _getRangeIndex.itemOffsetPtg,
          startIndex = _getRangeIndex.startIndex,
          endIndex = _getRangeIndex.endIndex;

      _this.setState({
        status: 'MEASURE_START',
        scrollTop: scrollTop,
        itemIndex: itemIndex,
        itemOffsetPtg: itemOffsetPtg,
        startIndex: startIndex,
        endIndex: endIndex
      });

      _this.triggerOnScroll(event);
    };

    _this.onRawScroll = function (event) {
      var scrollTop = _this.listRef.current.scrollTop;

      _this.setState({
        scrollTop: scrollTop
      });

      _this.triggerOnScroll(event);
    };

    _this.triggerOnScroll = function (event) {
      var onScroll = _this.props.onScroll;

      if (onScroll && event) {
        onScroll(event);
      }
    };

    _this.getIndexKey = function (index, props) {
      var mergedProps = props || _this.props;
      var _mergedProps$data = mergedProps.data,
          data = _mergedProps$data === void 0 ? [] : _mergedProps$data; // Return ghost key as latest index item

      if (index === data.length) {
        return GHOST_ITEM_KEY;
      }

      var item = data[index];

      if (!item) {
        /* istanbul ignore next */
        console.error('Not find index item. Please report this since it is a bug.');
      }

      return _this.getItemKey(item, mergedProps);
    };

    _this.getItemKey = function (item, props) {
      var _ref = props || _this.props,
          itemKey = _ref.itemKey;

      return typeof itemKey === 'function' ? itemKey(item) : item[itemKey];
    };
    /**
     * Collect current rendered dom element item heights
     */


    _this.collectItemHeights = function (range) {
      var _ref2 = range || _this.state,
          startIndex = _ref2.startIndex,
          endIndex = _ref2.endIndex;

      var data = _this.props.data; // Record here since measure item height will get warning in `render`

      for (var index = startIndex; index <= endIndex; index += 1) {
        var item = data[index]; // Only collect exist item height

        if (item) {
          var eleKey = _this.getItemKey(item);

          _this.itemElementHeights[eleKey] = getNodeHeight(_this.itemElements[eleKey]);
        }
      }
    };

    _this.scrollTo = function (arg0) {
      setTimeout(function () {
        // Number top
        if (List_typeof(arg0) === 'object') {
          var isVirtual = _this.state.isVirtual;
          var _this$props2 = _this.props,
              height = _this$props2.height,
              itemHeight = _this$props2.itemHeight,
              data = _this$props2.data;
          var _arg0$align = arg0.align,
              align = _arg0$align === void 0 ? 'auto' : _arg0$align;
          var index = 0;

          if ('index' in arg0) {
            index = arg0.index;
          } else if ('key' in arg0) {
            var key = arg0.key;
            index = data.findIndex(function (item) {
              return _this.getItemKey(item) === key;
            });
          }

          var visibleCount = Math.ceil(height / itemHeight);
          var item = data[index];

          if (item) {
            var clientHeight = _this.listRef.current.clientHeight;

            if (isVirtual) {
              // Calculate related data
              var _this$state = _this.state,
                  itemIndex = _this$state.itemIndex,
                  itemOffsetPtg = _this$state.itemOffsetPtg;
              var scrollTop = _this.listRef.current.scrollTop;
              var scrollPtg = getElementScrollPercentage(_this.listRef.current);
              var relativeLocatedItemTop = getItemRelativeTop({
                itemIndex: itemIndex,
                itemOffsetPtg: itemOffsetPtg,
                itemElementHeights: _this.itemElementHeights,
                scrollPtg: scrollPtg,
                clientHeight: clientHeight,
                getItemKey: _this.getIndexKey
              }); // We will force render related items to collect height for re-location

              _this.setState({
                startIndex: Math.max(0, index - visibleCount),
                endIndex: Math.min(data.length - 1, index + visibleCount)
              }, function () {
                _this.collectItemHeights(); // Calculate related top


                var relativeTop;
                var mergedAlgin = align;

                if (align === 'auto') {
                  var shouldChange = true; // Check if exist in the visible range

                  if (Math.abs(itemIndex - index) < visibleCount) {
                    var itemTop = relativeLocatedItemTop;

                    if (index < itemIndex) {
                      for (var i = index; i < itemIndex; i += 1) {
                        var eleKey = _this.getIndexKey(i);

                        itemTop -= _this.itemElementHeights[eleKey] || 0;
                      }
                    } else {
                      for (var _i = itemIndex; _i <= index; _i += 1) {
                        var _eleKey = _this.getIndexKey(_i);

                        itemTop += _this.itemElementHeights[_eleKey] || 0;
                      }
                    }

                    shouldChange = itemTop <= 0 || itemTop >= clientHeight;
                  }

                  if (shouldChange) {
                    // Out of range will fall back to position align
                    mergedAlgin = index < itemIndex ? 'top' : 'bottom';
                  } else {
                    var _getRangeIndex2 = getRangeIndex(scrollPtg, data.length, visibleCount),
                        nextIndex = _getRangeIndex2.itemIndex,
                        newOffsetPtg = _getRangeIndex2.itemOffsetPtg,
                        startIndex = _getRangeIndex2.startIndex,
                        endIndex = _getRangeIndex2.endIndex;

                    _this.setState({
                      scrollTop: scrollTop,
                      itemIndex: nextIndex,
                      itemOffsetPtg: newOffsetPtg,
                      startIndex: startIndex,
                      endIndex: endIndex
                    });

                    return;
                  }
                } // Align with position should make scroll happen


                if (mergedAlgin === 'top') {
                  relativeTop = 0;
                } else if (mergedAlgin === 'bottom') {
                  var _eleKey2 = _this.getItemKey(item);

                  relativeTop = clientHeight - _this.itemElementHeights[_eleKey2] || 0;
                }

                _this.internalScrollTo({
                  itemIndex: index,
                  relativeTop: relativeTop
                });
              });
            } else {
              // Raw list without virtual scroll set position directly
              _this.collectItemHeights({
                startIndex: 0,
                endIndex: data.length - 1
              });

              var mergedAlgin = align; // Collection index item position

              var indexItemHeight = _this.itemElementHeights[_this.getIndexKey(index)];

              var itemTop = 0;

              for (var i = 0; i < index; i += 1) {
                var eleKey = _this.getIndexKey(i);

                itemTop += _this.itemElementHeights[eleKey] || 0;
              }

              var itemBottom = itemTop + indexItemHeight;

              if (mergedAlgin === 'auto') {
                if (itemTop < _this.listRef.current.scrollTop) {
                  mergedAlgin = 'top';
                } else if (itemBottom > _this.listRef.current.scrollTop + clientHeight) {
                  mergedAlgin = 'bottom';
                }
              }

              if (mergedAlgin === 'top') {
                _this.listRef.current.scrollTop = itemTop;
              } else if (mergedAlgin === 'bottom') {
                _this.listRef.current.scrollTop = itemTop - (clientHeight - indexItemHeight);
              }
            }
          }
        } else {
          _this.listRef.current.scrollTop = arg0;
        }
      });
    };
    /**
     * Phase 4: Render item and get all the visible items height
     */


    _this.renderChildren = function (list, startIndex, renderFunc) {
      var status = _this.state.status; // We should measure rendered item height

      return list.map(function (item, index) {
        var eleIndex = startIndex + index;
        var node = renderFunc(item, eleIndex, {
          style: status === 'MEASURE_START' ? {
            visibility: 'hidden'
          } : {}
        });

        var eleKey = _this.getIndexKey(eleIndex); // Pass `key` and `ref` for internal measure


        return react["cloneElement"](node, {
          key: eleKey,
          ref: function ref(ele) {
            _this.itemElements[eleKey] = ele;
          }
        });
      });
    };

    _this.cachedProps = props;
    _this.state = {
      status: 'NONE',
      scrollTop: null,
      itemIndex: 0,
      itemOffsetPtg: 0,
      startIndex: 0,
      endIndex: 0,
      startItemTop: 0,
      isVirtual: requireVirtual(props.height, props.itemHeight, props.data.length, props.virtual),
      itemCount: props.data.length
    };
    return _this;
  }

  List_createClass(List, [{
    key: "componentDidMount",

    /**
     * Phase 1: Initial should sync with default scroll top
     */
    value: function componentDidMount() {
      if (this.listRef.current) {
        this.listRef.current.scrollTop = 0;
        this.onScroll(null);
      }
    }
    /**
     * Phase 4: Record used item height
     * Phase 5: Trigger re-render to use correct position
     */

  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;

      var status = this.state.status;
      var _this$props3 = this.props,
          data = _this$props3.data,
          height = _this$props3.height,
          itemHeight = _this$props3.itemHeight,
          disabled = _this$props3.disabled,
          onSkipRender = _this$props3.onSkipRender,
          virtual = _this$props3.virtual;
      var prevData = this.cachedProps.data || [];
      var changedItemIndex = null;

      if (prevData.length !== data.length) {
        var diff = findListDiffIndex(prevData, data, this.getItemKey);
        changedItemIndex = diff ? diff.index : null;
      }

      if (disabled) {
        // Should trigger `onSkipRender` to tell that diff component is not render in the list
        if (data.length > prevData.length) {
          var _this$state2 = this.state,
              startIndex = _this$state2.startIndex,
              endIndex = _this$state2.endIndex;

          if (onSkipRender && (changedItemIndex === null || changedItemIndex < startIndex || endIndex < changedItemIndex)) {
            onSkipRender();
          }
        }

        return;
      }

      var isVirtual = requireVirtual(height, itemHeight, data.length, virtual);
      var nextStatus = status;

      if (this.state.isVirtual !== isVirtual) {
        nextStatus = isVirtual ? 'SWITCH_TO_VIRTUAL' : 'SWITCH_TO_RAW';
        this.setState({
          isVirtual: isVirtual,
          status: nextStatus
        });
        /**
         * We will wait a tick to let list turn to virtual list.
         * And then use virtual list sync logic to adjust the scroll.
         */

        if (nextStatus === 'SWITCH_TO_VIRTUAL') {
          return;
        }
      }

      if (status === 'MEASURE_START') {
        var _this$state3 = this.state,
            _startIndex = _this$state3.startIndex,
            itemIndex = _this$state3.itemIndex,
            itemOffsetPtg = _this$state3.itemOffsetPtg;
        var scrollTop = this.listRef.current.scrollTop; // Record here since measure item height will get warning in `render`

        this.collectItemHeights(); // Calculate top visible item top offset

        var locatedItemTop = getItemAbsoluteTop({
          itemIndex: itemIndex,
          itemOffsetPtg: itemOffsetPtg,
          itemElementHeights: this.itemElementHeights,
          scrollTop: scrollTop,
          scrollPtg: getElementScrollPercentage(this.listRef.current),
          clientHeight: this.listRef.current.clientHeight,
          getItemKey: this.getIndexKey
        });
        var startItemTop = locatedItemTop;

        for (var index = itemIndex - 1; index >= _startIndex; index -= 1) {
          startItemTop -= this.itemElementHeights[this.getIndexKey(index)] || 0;
        }

        this.setState({
          status: 'MEASURE_DONE',
          startItemTop: startItemTop
        });
      }

      if (status === 'SWITCH_TO_RAW') {
        /**
         * After virtual list back to raw list,
         * we update the `scrollTop` to real top instead of percentage top.
         */
        var _this$state$cacheScro = this.state.cacheScroll,
            _itemIndex = _this$state$cacheScro.itemIndex,
            relativeTop = _this$state$cacheScro.relativeTop;
        var rawTop = relativeTop;

        for (var _index = 0; _index < _itemIndex; _index += 1) {
          rawTop -= this.itemElementHeights[this.getIndexKey(_index)] || 0;
        }

        this.lockScroll = true;
        this.listRef.current.scrollTop = -rawTop;
        this.setState({
          status: 'MEASURE_DONE',
          itemIndex: 0
        });
        requestAnimationFrame(function () {
          requestAnimationFrame(function () {
            _this2.lockScroll = false;
          });
        });
      } else if (prevData.length !== data.length && changedItemIndex !== null && height) {
        /**
         * Re-calculate the item position since `data` length changed.
         * [IMPORTANT] We use relative position calculate here.
         */
        var originItemIndex = this.state.itemIndex;
        var _this$state4 = this.state,
            originItemOffsetPtg = _this$state4.itemOffsetPtg,
            originStartIndex = _this$state4.startIndex,
            originEndIndex = _this$state4.endIndex,
            originScrollTop = _this$state4.scrollTop; // 1. Refresh item heights

        this.collectItemHeights(); // 1. Get origin located item top

        var originLocatedItemRelativeTop;

        if (this.state.status === 'SWITCH_TO_VIRTUAL') {
          originItemIndex = 0;
          originLocatedItemRelativeTop = -this.state.scrollTop;
        } else {
          originLocatedItemRelativeTop = getItemRelativeTop({
            itemIndex: originItemIndex,
            itemOffsetPtg: originItemOffsetPtg,
            itemElementHeights: this.itemElementHeights,
            scrollPtg: getScrollPercentage({
              scrollTop: originScrollTop,
              scrollHeight: prevData.length * itemHeight,
              clientHeight: this.listRef.current.clientHeight
            }),
            clientHeight: this.listRef.current.clientHeight,
            getItemKey: function getItemKey(index) {
              return _this2.getIndexKey(index, _this2.cachedProps);
            }
          });
        } // 2. Find the compare item


        var originCompareItemIndex = changedItemIndex - 1; // Use next one since there are not more item before removed

        if (originCompareItemIndex < 0) {
          originCompareItemIndex = 0;
        } // 3. Find the compare item top


        var originCompareItemTop = getCompareItemRelativeTop({
          locatedItemRelativeTop: originLocatedItemRelativeTop,
          locatedItemIndex: originItemIndex,
          compareItemIndex: originCompareItemIndex,
          startIndex: originStartIndex,
          endIndex: originEndIndex,
          getItemKey: function getItemKey(index) {
            return _this2.getIndexKey(index, _this2.cachedProps);
          },
          itemElementHeights: this.itemElementHeights
        });

        if (nextStatus === 'SWITCH_TO_RAW') {
          /**
           * We will record current measure relative item top and apply in raw list after list turned
           */
          this.setState({
            cacheScroll: {
              itemIndex: originCompareItemIndex,
              relativeTop: originCompareItemTop
            }
          });
        } else {
          this.internalScrollTo({
            itemIndex: originCompareItemIndex,
            relativeTop: originCompareItemTop
          });
        }
      } else if (nextStatus === 'SWITCH_TO_RAW') {
        // This is only trigger when height changes that all items can show in raw
        // Let's reset back to top
        this.setState({
          cacheScroll: {
            itemIndex: 0,
            relativeTop: 0
          }
        });
      }

      this.cachedProps = this.props;
    }
  }, {
    key: "internalScrollTo",
    value: function internalScrollTo(relativeScroll) {
      var _this3 = this;

      var compareItemIndex = relativeScroll.itemIndex,
          compareItemRelativeTop = relativeScroll.relativeTop;
      var originScrollTop = this.state.scrollTop;
      var _this$props4 = this.props,
          data = _this$props4.data,
          itemHeight = _this$props4.itemHeight,
          height = _this$props4.height; // 1. Find the best match compare item top

      var bestSimilarity = Number.MAX_VALUE;
      var bestScrollTop = null;
      var bestItemIndex = null;
      var bestItemOffsetPtg = null;
      var bestStartIndex = null;
      var bestEndIndex = null;
      var missSimilarity = 0;
      var scrollHeight = data.length * itemHeight;
      var clientHeight = this.listRef.current.clientHeight;
      var maxScrollTop = scrollHeight - clientHeight;

      for (var i = 0; i < maxScrollTop; i += 1) {
        var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);
        var scrollPtg = getScrollPercentage({
          scrollTop: scrollTop,
          scrollHeight: scrollHeight,
          clientHeight: clientHeight
        });
        var visibleCount = Math.ceil(height / itemHeight);

        var _getRangeIndex3 = getRangeIndex(scrollPtg, data.length, visibleCount),
            itemIndex = _getRangeIndex3.itemIndex,
            itemOffsetPtg = _getRangeIndex3.itemOffsetPtg,
            startIndex = _getRangeIndex3.startIndex,
            endIndex = _getRangeIndex3.endIndex; // No need to check if compare item out of the index to save performance


        if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {
          // 1.1 Get measure located item relative top
          var locatedItemRelativeTop = getItemRelativeTop({
            itemIndex: itemIndex,
            itemOffsetPtg: itemOffsetPtg,
            itemElementHeights: this.itemElementHeights,
            scrollPtg: scrollPtg,
            clientHeight: clientHeight,
            getItemKey: this.getIndexKey
          });
          var compareItemTop = getCompareItemRelativeTop({
            locatedItemRelativeTop: locatedItemRelativeTop,
            locatedItemIndex: itemIndex,
            compareItemIndex: compareItemIndex,
            startIndex: startIndex,
            endIndex: endIndex,
            getItemKey: this.getIndexKey,
            itemElementHeights: this.itemElementHeights
          }); // 1.2 Find best match compare item top

          var similarity = Math.abs(compareItemTop - compareItemRelativeTop);

          if (similarity < bestSimilarity) {
            bestSimilarity = similarity;
            bestScrollTop = scrollTop;
            bestItemIndex = itemIndex;
            bestItemOffsetPtg = itemOffsetPtg;
            bestStartIndex = startIndex;
            bestEndIndex = endIndex;
            missSimilarity = 0;
          } else {
            missSimilarity += 1;
          }
        } // If keeping 10 times not match similarity,
        // check more scrollTop is meaningless.
        // Here boundary is set to 10.


        if (missSimilarity > 10) {
          break;
        }
      } // 2. Re-scroll if has best scroll match


      if (bestScrollTop !== null) {
        this.lockScroll = true;
        this.listRef.current.scrollTop = bestScrollTop;
        this.setState({
          status: 'MEASURE_START',
          scrollTop: bestScrollTop,
          itemIndex: bestItemIndex,
          itemOffsetPtg: bestItemOffsetPtg,
          startIndex: bestStartIndex,
          endIndex: bestEndIndex
        });
        requestAnimationFrame(function () {
          requestAnimationFrame(function () {
            _this3.lockScroll = false;
          });
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state5 = this.state,
          isVirtual = _this$state5.isVirtual,
          itemCount = _this$state5.itemCount;

      var _this$props5 = this.props,
          prefixCls = _this$props5.prefixCls,
          style = _this$props5.style,
          className = _this$props5.className,
          _this$props5$componen = _this$props5.component,
          Component = _this$props5$componen === void 0 ? 'div' : _this$props5$componen,
          height = _this$props5.height,
          itemHeight = _this$props5.itemHeight,
          _this$props5$fullHeig = _this$props5.fullHeight,
          fullHeight = _this$props5$fullHeig === void 0 ? true : _this$props5$fullHeig,
          data = _this$props5.data,
          children = _this$props5.children,
          itemKey = _this$props5.itemKey,
          onSkipRender = _this$props5.onSkipRender,
          disabled = _this$props5.disabled,
          virtual = _this$props5.virtual,
          restProps = List_objectWithoutProperties(_this$props5, ["prefixCls", "style", "className", "component", "height", "itemHeight", "fullHeight", "data", "children", "itemKey", "onSkipRender", "disabled", "virtual"]);

      var mergedClassName = classnames_default()(prefixCls, className); // Render pure list if not set height or height is enough for all items

      if (!isVirtual) {
        /**
         * Virtual list switch is works on component updated.
         * We should double check here if need cut the content.
         */
        var shouldVirtual = requireVirtual(height, itemHeight, data.length, virtual);
        return react["createElement"](Component, Object.assign({
          style: height ? List_objectSpread({}, style, List_defineProperty({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle) : style,
          className: mergedClassName
        }, restProps, {
          onScroll: this.onRawScroll,
          ref: this.listRef
        }), react["createElement"](es_Filler, {
          prefixCls: prefixCls,
          height: height
        }, this.renderChildren(shouldVirtual ? data.slice(0, Math.ceil(height / itemHeight)) : data, 0, children)));
      } // Use virtual list


      var mergedStyle = List_objectSpread({}, style, {
        height: height
      }, ScrollStyle);

      var _this$state6 = this.state,
          status = _this$state6.status,
          startIndex = _this$state6.startIndex,
          endIndex = _this$state6.endIndex,
          startItemTop = _this$state6.startItemTop;
      var contentHeight = itemCount * itemHeight * ITEM_SCALE_RATE;
      return react["createElement"](Component, Object.assign({
        style: mergedStyle,
        className: mergedClassName
      }, restProps, {
        onScroll: this.onScroll,
        ref: this.listRef
      }), react["createElement"](es_Filler, {
        prefixCls: prefixCls,
        height: contentHeight,
        offset: status === 'MEASURE_DONE' ? startItemTop : 0
      }, this.renderChildren(data.slice(startIndex, endIndex + 1), startIndex, children)));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps) {
      if (!nextProps.disabled) {
        return {
          itemCount: nextProps.data.length
        };
      }

      return null;
    }
  }]);

  return List;
}(react["Component"]);

List_List.defaultProps = {
  itemHeight: 15,
  data: []
};
/* harmony default export */ var es_List = (List_List);
// CONCATENATED MODULE: ../node_modules/rc-virtual-list/es/index.js

/* harmony default export */ var rc_virtual_list_es = (es_List);
// CONCATENATED MODULE: ../node_modules/rc-select/es/TransBtn.js





var TransBtn_TransBtn = function TransBtn(_ref) {
  var className = _ref.className,
      customizeIcon = _ref.customizeIcon,
      customizeIconProps = _ref.customizeIconProps,
      _onMouseDown = _ref.onMouseDown,
      onClick = _ref.onClick,
      children = _ref.children;
  var icon;

  if (typeof customizeIcon === 'function') {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }

  return react["createElement"]("span", {
    className: className,
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();

      if (_onMouseDown) {
        _onMouseDown(event);
      }
    },
    style: {
      userSelect: 'none',
      WebkitUserSelect: 'none'
    },
    unselectable: "on",
    onClick: onClick,
    "aria-hidden": true
  }, icon !== undefined ? icon : react["createElement"]("span", {
    className: classnames_default()(className.split(/\s+/).map(function (cls) {
      return "".concat(cls, "-icon");
    }))
  }, children));
};

/* harmony default export */ var es_TransBtn = (TransBtn_TransBtn);
// CONCATENATED MODULE: ../node_modules/rc-select/es/OptionList.js













function OptionList_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function OptionList_slicedToArray(arr, i) {
  return OptionList_arrayWithHoles(arr) || OptionList_iterableToArrayLimit(arr, i) || OptionList_nonIterableRest();
}

function OptionList_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function OptionList_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function OptionList_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}







/**
 * Using virtual list of option display.
 * Will fallback to dom if use customize render.
 */

var OptionList_OptionList = function OptionList(_ref, ref) {
  var prefixCls = _ref.prefixCls,
      id = _ref.id,
      flattenOptions = _ref.flattenOptions,
      childrenAsData = _ref.childrenAsData,
      values = _ref.values,
      searchValue = _ref.searchValue,
      multiple = _ref.multiple,
      defaultActiveFirstOption = _ref.defaultActiveFirstOption,
      height = _ref.height,
      itemHeight = _ref.itemHeight,
      notFoundContent = _ref.notFoundContent,
      open = _ref.open,
      menuItemSelectedIcon = _ref.menuItemSelectedIcon,
      onSelect = _ref.onSelect,
      onToggleOpen = _ref.onToggleOpen,
      onActiveValue = _ref.onActiveValue,
      onScroll = _ref.onScroll;
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var memoFlattenOptions = useMemo(function () {
    return flattenOptions;
  }, [open, flattenOptions], function (prev, next) {
    return next[0] && prev[1] !== next[1];
  }); // =========================== List ===========================

  var listRef = react["useRef"](null);

  var onListMouseDown = function onListMouseDown(event) {
    event.preventDefault();
  };

  var scrollIntoView = function scrollIntoView(index) {
    if (listRef.current) {
      listRef.current.scrollTo({
        index: index
      });
    }
  }; // ========================== Active ==========================


  var getEnabledActiveIndex = function getEnabledActiveIndex(index) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var len = memoFlattenOptions.length;

    for (var i = 0; i < len; i += 1) {
      var current = (index + i * offset + len) % len;
      var _memoFlattenOptions$c = memoFlattenOptions[current],
          group = _memoFlattenOptions$c.group,
          data = _memoFlattenOptions$c.data;

      if (!group && !data.disabled) {
        return current;
      }
    }

    return -1;
  };

  var _React$useState = react["useState"](function () {
    return getEnabledActiveIndex(0);
  }),
      _React$useState2 = OptionList_slicedToArray(_React$useState, 2),
      activeIndex = _React$useState2[0],
      setActiveIndex = _React$useState2[1];

  var setActive = function setActive(index) {
    setActiveIndex(index); // Trigger active event

    var flattenItem = memoFlattenOptions[index];

    if (!flattenItem) {
      onActiveValue(null, -1);
      return;
    }

    onActiveValue(flattenItem.data.value, index);
  }; // Auto active first item when list length or searchValue changed


  react["useEffect"](function () {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]); // Auto scroll to item position in single mode

  react["useEffect"](function () {
    if (!multiple && open && values.size === 1) {
      var value = Array.from(values)[0];
      var index = memoFlattenOptions.findIndex(function (_ref2) {
        var data = _ref2.data;
        return data.value === value;
      });
      setActive(index);
      scrollIntoView(index);
    }
  }, [open]); // ========================== Values ==========================

  var onSelectValue = function onSelectValue(value) {
    if (value !== undefined) {
      onSelect(value, {
        selected: !values.has(value)
      });
    } // Single mode should always close by select


    if (!multiple) {
      onToggleOpen(false);
    }
  }; // ========================= Keyboard =========================


  react["useImperativeHandle"](ref, function () {
    return {
      onKeyDown: function onKeyDown(event) {
        var which = event.which;

        switch (which) {
          // >>> Arrow keys
          case KeyCode["a" /* default */].UP:
          case KeyCode["a" /* default */].DOWN:
            {
              var offset = 0;

              if (which === KeyCode["a" /* default */].UP) {
                offset = -1;
              } else if (which === KeyCode["a" /* default */].DOWN) {
                offset = 1;
              }

              if (offset !== 0) {
                var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset, offset);
                scrollIntoView(nextActiveIndex);
                setActive(nextActiveIndex);
              }

              break;
            }
          // >>> Select

          case KeyCode["a" /* default */].ENTER:
            {
              // value
              var item = memoFlattenOptions[activeIndex];

              if (item && !item.data.disabled) {
                onSelectValue(item.data.value);
              } else {
                onSelectValue(undefined);
              }

              if (open) {
                event.preventDefault();
              }

              break;
            }
          // >>> Close

          case KeyCode["a" /* default */].ESC:
            {
              onToggleOpen(false);
            }
        }
      },
      onKeyUp: function onKeyUp() {}
    };
  }); // ========================== Render ==========================

  if (memoFlattenOptions.length === 0) {
    return react["createElement"]("div", {
      role: "listbox",
      id: "".concat(id, "_list"),
      className: "".concat(itemPrefixCls, "-empty"),
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }

  function renderItem(index) {
    var item = memoFlattenOptions[index];
    var value = item && item.data.value;
    return item ? react["createElement"]("div", {
      key: index,
      role: "option",
      id: "".concat(id, "_list_").concat(index),
      "aria-selected": values.has(value)
    }, value) : null;
  }

  return react["createElement"](react["Fragment"], null, react["createElement"]("div", {
    role: "listbox",
    id: "".concat(id, "_list"),
    style: {
      height: 0,
      overflow: 'hidden'
    }
  }, renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), react["createElement"](rc_virtual_list_es, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: height,
    itemHeight: itemHeight,
    fullHeight: false,
    onMouseDown: onListMouseDown,
    onScroll: onScroll
  }, function (_ref3, itemIndex) {
    var _classNames;

    var group = _ref3.group,
        groupOption = _ref3.groupOption,
        data = _ref3.data;
    var label = data.label,
        key = data.key; // Group

    if (group) {
      return react["createElement"]("div", {
        className: classnames_default()(itemPrefixCls, "".concat(itemPrefixCls, "-group"))
      }, label !== undefined ? label : key);
    }

    var disabled = data.disabled,
        value = data.value,
        title = data.title,
        children = data.children,
        style = data.style,
        className = data.className; // Option

    var selected = values.has(value);
    var optionPrefixCls = "".concat(itemPrefixCls, "-option");
    var optionClassName = classnames_default()(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, OptionList_defineProperty(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), OptionList_defineProperty(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), OptionList_defineProperty(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), OptionList_defineProperty(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
    var mergedLabel = childrenAsData ? children : label;
    var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === 'function' || selected;
    return react["createElement"]("div", {
      "aria-selected": selected,
      className: optionClassName,
      title: title,
      onMouseMove: function onMouseMove() {
        if (activeIndex === itemIndex || disabled) {
          return;
        }

        setActive(itemIndex);
      },
      onClick: function onClick() {
        if (!disabled) {
          onSelectValue(value);
        }
      },
      style: style
    }, react["createElement"]("div", {
      className: "".concat(optionPrefixCls, "-content")
    }, mergedLabel || value), react["isValidElement"](menuItemSelectedIcon) || selected, iconVisible && react["createElement"](es_TransBtn, {
      className: "".concat(itemPrefixCls, "-option-state"),
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        isSelected: selected
      }
    }, selected ? '✓' : null));
  }));
};

var RefOptionList = react["forwardRef"](OptionList_OptionList);
RefOptionList.displayName = 'OptionList';
/* harmony default export */ var es_OptionList = (RefOptionList);
// CONCATENATED MODULE: ../node_modules/rc-select/es/Option.js
/** This is a placeholder, not real render in dom */
var Option = function Option() {
  return null;
};

Option.isSelectOption = true;
/* harmony default export */ var es_Option = (Option);
// CONCATENATED MODULE: ../node_modules/rc-select/es/OptGroup.js
/** This is a placeholder, not real render in dom */
var OptGroup = function OptGroup() {
  return null;
};

OptGroup.isSelectOptGroup = true;
/* harmony default export */ var es_OptGroup = (OptGroup);
// EXTERNAL MODULE: ../node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__("xTM7");

// CONCATENATED MODULE: ../node_modules/rc-select/es/utils/legacyUtil.js













function legacyUtil_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function legacyUtil_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      legacyUtil_ownKeys(Object(source), true).forEach(function (key) {
        legacyUtil_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      legacyUtil_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function legacyUtil_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function legacyUtil_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = legacyUtil_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function legacyUtil_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}




function convertNodeToOption(node) {
  var key = node.key,
      _node$props = node.props,
      children = _node$props.children,
      value = _node$props.value,
      restProps = legacyUtil_objectWithoutProperties(_node$props, ["children", "value"]);

  return legacyUtil_objectSpread({
    key: key,
    value: value !== undefined ? value : key,
    children: children
  }, restProps);
}

function legacyUtil_convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return Object(toArray["a" /* default */])(nodes).map(function (node, index) {
    if (!react["isValidElement"](node) || !node.type) {
      return null;
    }

    var isSelectOptGroup = node.type.isSelectOptGroup,
        key = node.key,
        _node$props2 = node.props,
        children = _node$props2.children,
        restProps = legacyUtil_objectWithoutProperties(_node$props2, ["children"]);

    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }

    return legacyUtil_objectSpread({
      key: "__RC_SELECT_GRP__".concat(key === null ? index : key, "__"),
      label: key
    }, restProps, {
      options: legacyUtil_convertChildrenToData(children)
    });
  }).filter(function (data) {
    return data;
  });
}
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.set.js
var es6_set = __webpack_require__("m1Dn");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.sort.js
var es6_array_sort = __webpack_require__("U8p0");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.reduce.js
var es6_array_reduce = __webpack_require__("3y5y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.find.js
var es6_array_find = __webpack_require__("it7j");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.map.js
var es6_map = __webpack_require__("zx98");

// EXTERNAL MODULE: ../node_modules/rc-util/es/warning.js
var es_warning = __webpack_require__("IFhY");

// CONCATENATED MODULE: ../node_modules/rc-select/es/utils/commonUtil.js











function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function commonUtil_toArray(value) {
  if (Array.isArray(value)) {
    return value;
  }

  return value !== undefined ? [value] : [];
}
/**
 * Convert outer props value into internal value
 */

function toInnerValue(value, _ref) {
  var labelInValue = _ref.labelInValue,
      combobox = _ref.combobox;

  if (value === undefined || value === '' && combobox) {
    return [];
  }

  var values = Array.isArray(value) ? value : [value];

  if (labelInValue) {
    return values.map(function (_ref2) {
      var key = _ref2.key,
          val = _ref2.value;
      return val !== undefined ? val : key;
    });
  }

  return values;
}
/**
 * Convert internal value into out event value
 */

function toOuterValues(valueList, _ref3) {
  var optionLabelProp = _ref3.optionLabelProp,
      labelInValue = _ref3.labelInValue,
      prevValue = _ref3.prevValue,
      options = _ref3.options,
      getLabeledValue = _ref3.getLabeledValue;
  var values = valueList;

  if (labelInValue) {
    values = values.map(function (val) {
      return getLabeledValue(val, {
        options: options,
        prevValue: prevValue,
        labelInValue: labelInValue,
        optionLabelProp: optionLabelProp
      });
    });
  }

  return values;
}
function removeLastEnabledValue(measureValues, values) {
  var newValues = _toConsumableArray(values);

  var removeIndex;

  for (removeIndex = measureValues.length - 1; removeIndex >= 0; removeIndex -= 1) {
    if (!measureValues[removeIndex].disabled) {
      break;
    }
  }

  var removedValue = null;

  if (removeIndex !== -1) {
    removedValue = newValues[removeIndex];
    newValues.splice(removeIndex, 1);
  }

  return {
    values: newValues,
    removedValue: removedValue
  };
}
var isClient = typeof window !== 'undefined' && window.document && window.document.documentElement;
/** Is client side and not jsdom */

var isBrowserClient =  true && isClient;
var uuid = 0;
/** Get unique id for accessibility usage */

function getUUID() {
  var retId; // Test never reach

  /* istanbul ignore if */

  if (isBrowserClient) {
    retId = uuid;
    uuid += 1;
  } else {
    retId = 'TEST_OR_SSR';
  }

  return retId;
}
// CONCATENATED MODULE: ../node_modules/rc-select/es/utils/valueUtil.js



























function valueUtil_toConsumableArray(arr) {
  return valueUtil_arrayWithoutHoles(arr) || valueUtil_iterableToArray(arr) || valueUtil_nonIterableSpread();
}

function valueUtil_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function valueUtil_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _toArray(arr) {
  return valueUtil_arrayWithHoles(arr) || valueUtil_iterableToArray(arr) || valueUtil_nonIterableRest();
}

function valueUtil_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function valueUtil_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function valueUtil_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function valueUtil_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    valueUtil_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    valueUtil_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return valueUtil_typeof(obj);
}

function valueUtil_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function valueUtil_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      valueUtil_ownKeys(Object(source), true).forEach(function (key) {
        valueUtil_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      valueUtil_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function valueUtil_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}




function getKey(data, index) {
  var key = data.key;
  var value;

  if ('value' in data) {
    value = data.value;
  }

  if (key !== null && key !== undefined) {
    return key;
  }

  if (value !== undefined) {
    return value;
  }

  return "rc-index-key-".concat(index);
}
/**
 * Flat options into flatten list.
 * We use `optionOnly` here is aim to avoid user use nested option group.
 * Here is simply set `key` to the index if not provided.
 */


function valueUtil_flattenOptions(options) {
  var flattenList = [];

  function dig(list, isGroupOption) {
    list.forEach(function (data) {
      if (isGroupOption || !('options' in data)) {
        // Option
        flattenList.push({
          key: getKey(data, flattenList.length),
          groupOption: isGroupOption,
          data: data
        });
      } else {
        // Option Group
        flattenList.push({
          key: getKey(data, flattenList.length),
          group: true,
          data: data
        });
        dig(data.options, true);
      }
    });
  }

  dig(options, false);
  return flattenList;
}
/**
 * Inject `props` into `option` for legacy usage
 */

function injectPropsWithOption(option) {
  var newOption = valueUtil_objectSpread({}, option);

  if (!('props' in newOption)) {
    Object.defineProperty(newOption, 'props', {
      get: function get() {
        Object(es_warning["a" /* default */])(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');
        return newOption;
      }
    });
  }

  return newOption;
}

function valueUtil_findValueOption(values, options) {
  var optionMap = new Map();
  options.forEach(function (flattenItem) {
    if (!flattenItem.group) {
      var data = flattenItem.data; // Check if match

      optionMap.set(data.value, data);
    }
  });
  return values.map(function (val) {
    return injectPropsWithOption(optionMap.get(val));
  });
}
var valueUtil_getLabeledValue = function getLabeledValue(value, _ref) {
  var options = _ref.options,
      prevValue = _ref.prevValue,
      labelInValue = _ref.labelInValue,
      optionLabelProp = _ref.optionLabelProp;
  var item = valueUtil_findValueOption([value], options)[0];
  var result = {
    value: value
  };
  var prevValItem;
  var prevValues = commonUtil_toArray(prevValue);

  if (labelInValue) {
    prevValItem = prevValues.find(function (prevItem) {
      if (valueUtil_typeof(prevItem) === 'object' && 'value' in prevItem) {
        return prevItem.value === value;
      } // [Legacy] Support `key` as `value`


      return prevItem.key === value;
    });
  }

  if (prevValItem && valueUtil_typeof(prevValItem) === 'object' && 'label' in prevValItem) {
    result.label = prevValItem.label;

    if (item && typeof prevValItem.label === 'string' && typeof item[optionLabelProp] === 'string' && prevValItem.label.trim() !== item[optionLabelProp].trim()) {
      Object(es_warning["a" /* default */])(false, '`label` of `value` is not same as `label` in Select options.');
    }
  } else if (item && optionLabelProp in item) {
    result.label = item[optionLabelProp];
  } else {
    result.label = value;
  } // [Legacy] We need fill `key` as `value` to compatible old code usage


  result.key = result.value;
  return result;
};

function toRawString(content) {
  return commonUtil_toArray(content).join('');
}
/** Filter single option if match the search text */


function getFilterFunction(optionFilterProp) {
  return function (searchValue, option) {
    var lowerSearchText = searchValue.toLowerCase(); // Group label search

    if ('options' in option) {
      return toRawString(option.label).toLowerCase().includes(lowerSearchText);
    } // Option value search


    var rawValue = option[optionFilterProp];
    var value = toRawString(rawValue).toLowerCase();
    return value.includes(lowerSearchText) && !option.disabled;
  };
}
/** Filter options and return a new options by the search text */


function valueUtil_filterOptions(searchValue, options, _ref2) {
  var optionFilterProp = _ref2.optionFilterProp,
      filterOption = _ref2.filterOption;
  var filteredOptions = [];
  var filterFunc;

  if (filterOption === false) {
    return options;
  }

  if (typeof filterOption === 'function') {
    filterFunc = filterOption;
  } else {
    filterFunc = getFilterFunction(optionFilterProp);
  }

  options.forEach(function (item) {
    // Group should check child options
    if ('options' in item) {
      // Check group first
      var matchGroup = filterFunc(searchValue, item);

      if (matchGroup) {
        filteredOptions.push(item);
      } else {
        // Check option
        var subOptions = item.options.filter(function (subItem) {
          return filterFunc(searchValue, subItem);
        });

        if (subOptions.length) {
          filteredOptions.push(valueUtil_objectSpread({}, item, {
            options: subOptions
          }));
        }
      }

      return;
    }

    if (filterFunc(searchValue, injectPropsWithOption(item))) {
      filteredOptions.push(item);
    }
  });
  return filteredOptions;
}
function getSeparatedContent(text, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }

  var match = false;

  function separate(str, _ref3) {
    var _ref4 = _toArray(_ref3),
        token = _ref4[0],
        restTokens = _ref4.slice(1);

    if (!token) {
      return [str];
    }

    var list = str.split(token);
    match = match || list.length > 1;
    return list.reduce(function (prevList, unitStr) {
      return [].concat(valueUtil_toConsumableArray(prevList), valueUtil_toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function (unit) {
      return unit;
    });
  }

  var list = separate(text, tokens);
  return match ? list : null;
}
function valueUtil_isValueDisabled(value, options) {
  var option = valueUtil_findValueOption([value], options)[0];
  return option.disabled;
}
/**
 * `tags` mode should fill un-list item into the option list
 */

function valueUtil_fillOptionsWithMissingValue(options, value, optionLabelProp, labelInValue) {
  var values = commonUtil_toArray(value).slice().sort();

  var cloneOptions = valueUtil_toConsumableArray(options); // Convert options value to set


  var optionValues = new Set();
  options.forEach(function (opt) {
    if (opt.options) {
      opt.options.forEach(function (subOpt) {
        optionValues.add(subOpt.value);
      });
    } else {
      optionValues.add(opt.value);
    }
  }); // Fill missing value

  values.forEach(function (item) {
    var val = labelInValue ? item.value : item;

    if (!optionValues.has(val)) {
      var _ref5;

      cloneOptions.push(labelInValue ? (_ref5 = {}, valueUtil_defineProperty(_ref5, optionLabelProp, item.label), valueUtil_defineProperty(_ref5, "value", val), _ref5) : {
        value: val
      });
    }
  });
  return cloneOptions;
}
// CONCATENATED MODULE: ../node_modules/rc-util/es/hooks/useMergedState.js








function useMergedState_slicedToArray(arr, i) {
  return useMergedState_arrayWithHoles(arr) || useMergedState_iterableToArrayLimit(arr, i) || useMergedState_nonIterableRest();
}

function useMergedState_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function useMergedState_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function useMergedState_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}


function useControlledState(defaultStateValue, option) {
  var _ref = option || {},
      defaultValue = _ref.defaultValue,
      value = _ref.value,
      onChange = _ref.onChange,
      postState = _ref.postState;

  var _React$useState = react["useState"](function () {
    if (value !== undefined) {
      return value;
    }

    if (defaultValue !== undefined) {
      return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
    }

    return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
  }),
      _React$useState2 = useMergedState_slicedToArray(_React$useState, 2),
      innerValue = _React$useState2[0],
      setInnerValue = _React$useState2[1];

  var mergedValue = value !== undefined ? value : innerValue;

  if (postState) {
    mergedValue = postState(mergedValue);
  }

  function triggerChange(newValue) {
    setInnerValue(newValue);

    if (mergedValue !== newValue && onChange) {
      onChange(newValue, mergedValue);
    }
  }

  return [mergedValue, triggerChange];
}
// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__("wQpU");
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/extends.js
var helpers_extends = __webpack_require__("Kz1y");
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/classCallCheck.js
var helpers_classCallCheck = __webpack_require__("Zv/C");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(helpers_classCallCheck);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/createClass.js
var helpers_createClass = __webpack_require__("2lBV");
var createClass_default = /*#__PURE__*/__webpack_require__.n(helpers_createClass);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/possibleConstructorReturn.js
var helpers_possibleConstructorReturn = __webpack_require__("Dkg+");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(helpers_possibleConstructorReturn);

// EXTERNAL MODULE: ../node_modules/babel-runtime/helpers/inherits.js
var helpers_inherits = __webpack_require__("Gjrs");
var inherits_default = /*#__PURE__*/__webpack_require__.n(helpers_inherits);

// EXTERNAL MODULE: ./.cache/react-lifecycles-compat.js
var react_lifecycles_compat = __webpack_require__("94VI");

// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ../node_modules/rc-animate/es/CSSMotion.js
var es_CSSMotion = __webpack_require__("67vp");

// EXTERNAL MODULE: ../node_modules/rc-animate/es/util/motion.js
var motion = __webpack_require__("vmon");

// CONCATENATED MODULE: ../node_modules/rc-animate/es/util/diff.js








var STATUS_ADD = 'add';
var STATUS_KEEP = 'keep';
var STATUS_REMOVE = 'remove';
var STATUS_REMOVED = 'removed';
function wrapKeyToObject(key) {
  var keyObj = void 0;

  if (key && typeof key === 'object' && 'key' in key) {
    keyObj = key;
  } else {
    keyObj = {
      key: key
    };
  }

  return extends_default()({}, keyObj, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return keys.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys); // Check prev keys to insert or keep

  prevKeyObjects.forEach(function (keyObj) {
    var hit = false;

    for (var i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];

      if (currentKeyObj.key === keyObj.key) {
        // New added keys should add before current key
        if (currentIndex < i) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function (obj) {
            return extends_default()({}, obj, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i;
        }

        list.push(extends_default()({}, currentKeyObj, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    } // If not hit, it means key is removed


    if (!hit) {
      list.push(extends_default()({}, keyObj, {
        status: STATUS_REMOVE
      }));
    }
  }); // Add rest to the list

  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function (obj) {
      return extends_default()({}, obj, {
        status: STATUS_ADD
      });
    }));
  }
  /**
   * Merge same key when it remove and add again:
   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
   */


  var keys = {};
  list.forEach(function (_ref) {
    var key = _ref.key;
    keys[key] = (keys[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys).filter(function (key) {
    return keys[key] > 1;
  });
  duplicatedKeys.forEach(function (matchKey) {
    // Remove `STATUS_REMOVE` node.
    list = list.filter(function (_ref2) {
      var key = _ref2.key,
          status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    }); // Update `STATUS_ADD` to `STATUS_KEEP`

    list.forEach(function (node) {
      if (node.key === matchKey) {
        node.status = STATUS_KEEP;
      }
    });
  });
  return list;
}
// CONCATENATED MODULE: ../node_modules/rc-animate/es/CSSMotionList.js



















var MOTION_PROP_NAMES = Object.keys(es_CSSMotion["a" /* MotionPropTypes */]);
function genCSSMotionList(transitionSupport) {
  var CSSMotion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : es_CSSMotion["b" /* default */];

  var CSSMotionList = function (_React$Component) {
    inherits_default()(CSSMotionList, _React$Component);

    function CSSMotionList() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck_default()(this, CSSMotionList);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn_default()(this, (_ref = CSSMotionList.__proto__ || Object.getPrototypeOf(CSSMotionList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        keyEntities: []
      }, _this.removeKey = function (removeKey) {
        _this.setState(function (_ref2) {
          var keyEntities = _ref2.keyEntities;
          return {
            keyEntities: keyEntities.map(function (entity) {
              if (entity.key !== removeKey) return entity;
              return extends_default()({}, entity, {
                status: STATUS_REMOVED
              });
            })
          };
        });
      }, _temp), possibleConstructorReturn_default()(_this, _ret);
    }

    createClass_default()(CSSMotionList, [{
      key: 'render',
      value: function render() {
        var _this2 = this;

        var keyEntities = this.state.keyEntities;

        var _props = this.props,
            component = _props.component,
            children = _props.children,
            restProps = objectWithoutProperties_default()(_props, ['component', 'children']);

        var Component = component || react_default.a.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function (prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return react_default.a.createElement(Component, restProps, keyEntities.map(function (_ref3) {
          var status = _ref3.status,
              eventProps = objectWithoutProperties_default()(_ref3, ['status']);

          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return react_default.a.createElement(CSSMotion, extends_default()({}, motionProps, {
            key: eventProps.key,
            visible: visible,
            eventProps: eventProps,
            onLeaveEnd: function onLeaveEnd() {
              if (motionProps.onLeaveEnd) {
                motionProps.onLeaveEnd.apply(motionProps, arguments);
              }

              _this2.removeKey(eventProps.key);
            }
          }), children);
        }));
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(_ref4, _ref5) {
        var keys = _ref4.keys;
        var keyEntities = _ref5.keyEntities;
        var parsedKeyObjects = parseKeys(keys); // Always as keep when motion not support

        if (!transitionSupport) {
          return {
            keyEntities: parsedKeyObjects.map(function (obj) {
              return extends_default()({}, obj, {
                status: STATUS_KEEP
              });
            })
          };
        }

        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        var keyEntitiesLen = keyEntities.length;
        return {
          keyEntities: mixedKeyEntities.filter(function (entity) {
            // IE 9 not support Array.prototype.find
            var prevEntity = null;

            for (var i = 0; i < keyEntitiesLen; i += 1) {
              var currentEntity = keyEntities[i];

              if (currentEntity.key === entity.key) {
                prevEntity = currentEntity;
                break;
              }
            } // Remove if already mark as removed


            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }

            return true;
          })
        };
      }
    }]);

    return CSSMotionList;
  }(react_default.a.Component);

  CSSMotionList.propTypes = extends_default()({}, CSSMotion.propTypes, {
    component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool]),
    keys: prop_types_default.a.array
  });
  CSSMotionList.defaultProps = {
    component: 'div'
  };
  Object(react_lifecycles_compat["polyfill"])(CSSMotionList);
  return CSSMotionList;
}
/* harmony default export */ var es_CSSMotionList = (genCSSMotionList(motion["c" /* supportTransition */]));
// CONCATENATED MODULE: ../node_modules/rc-select/es/Selector/Input.js












function Input_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function Input_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      Input_ownKeys(Object(source), true).forEach(function (key) {
        Input_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      Input_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function Input_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function Input_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    Input_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    Input_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return Input_typeof(obj);
}



function fillRef(node, ref) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (ref && Input_typeof(ref) === 'object') {
    ref.current = node;
  }
}

var Input_Input = function Input(_ref, ref) {
  var prefixCls = _ref.prefixCls,
      id = _ref.id,
      inputElement = _ref.inputElement,
      disabled = _ref.disabled,
      tabIndex = _ref.tabIndex,
      autoFocus = _ref.autoFocus,
      editable = _ref.editable,
      accessibilityIndex = _ref.accessibilityIndex,
      value = _ref.value,
      _onKeyDown = _ref.onKeyDown,
      _onMouseDown = _ref.onMouseDown,
      _onChange = _ref.onChange,
      open = _ref.open;
  var inputNode = inputElement || react_default.a.createElement("input", null);
  var _inputNode = inputNode,
      originRef = _inputNode.ref,
      _inputNode$props = _inputNode.props,
      onOriginKeyDown = _inputNode$props.onKeyDown,
      onOriginChange = _inputNode$props.onChange,
      onOriginMouseDown = _inputNode$props.onMouseDown,
      style = _inputNode$props.style;

  function inputRef(node) {
    fillRef(node, ref);
    fillRef(node, originRef);
  }

  inputNode = react_default.a.cloneElement(inputNode, {
    id: id,
    ref: inputRef,
    disabled: disabled,
    tabIndex: tabIndex,
    autoComplete: 'off',
    autoFocus: autoFocus,
    className: "".concat(prefixCls, "-selection-search-input"),
    style: Input_objectSpread({}, style, {
      opacity: editable ? null : 0
    }),
    role: 'combobox',
    'aria-expanded': open,
    'aria-haspopup': 'listbox',
    'aria-owns': "".concat(id, "_list"),
    'aria-autocomplete': 'list',
    'aria-controls': "".concat(id, "_list"),
    'aria-activedescendant': "".concat(id, "_list_").concat(accessibilityIndex),
    value: editable ? value : '',
    readOnly: !editable,
    onKeyDown: function onKeyDown(event) {
      _onKeyDown(event);

      if (onOriginKeyDown) {
        onOriginKeyDown(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      _onMouseDown(event);

      if (onOriginMouseDown) {
        onOriginMouseDown(event);
      }
    },
    onChange: function onChange(event) {
      _onChange(event);

      if (onOriginChange) {
        onOriginChange(event);
      }
    }
  });
  return inputNode;
};

var RefInput = react_default.a.forwardRef(Input_Input);
RefInput.displayName = 'Input';
/* harmony default export */ var Selector_Input = (RefInput);
// CONCATENATED MODULE: ../node_modules/rc-select/es/hooks/useLayoutEffect.js
/* eslint-disable react-hooks/rules-of-hooks */


/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */

function useLayoutEffect(effect, deps) {
  // Never happen in test env
  if (isBrowserClient) {
    /* istanbul ignore next */
    react["useLayoutEffect"](effect, deps);
  } else {
    react["useEffect"](effect, deps);
  }
}
/* eslint-enable */
// CONCATENATED MODULE: ../node_modules/rc-select/es/Selector/MultipleSelector.js

















function MultipleSelector_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function MultipleSelector_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      MultipleSelector_ownKeys(Object(source), true).forEach(function (key) {
        MultipleSelector_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      MultipleSelector_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function MultipleSelector_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function MultipleSelector_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = MultipleSelector_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function MultipleSelector_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function MultipleSelector_slicedToArray(arr, i) {
  return MultipleSelector_arrayWithHoles(arr) || MultipleSelector_iterableToArrayLimit(arr, i) || MultipleSelector_nonIterableRest();
}

function MultipleSelector_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function MultipleSelector_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function MultipleSelector_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}







var REST_TAG_KEY = '__RC_SELECT_MAX_REST_COUNT__';

var MultipleSelector_SelectSelector = function SelectSelector(_ref) {
  var id = _ref.id,
      prefixCls = _ref.prefixCls,
      values = _ref.values,
      open = _ref.open,
      searchValue = _ref.searchValue,
      inputRef = _ref.inputRef,
      placeholder = _ref.placeholder,
      disabled = _ref.disabled,
      mode = _ref.mode,
      showSearch = _ref.showSearch,
      autoFocus = _ref.autoFocus,
      accessibilityIndex = _ref.accessibilityIndex,
      tabIndex = _ref.tabIndex,
      removeIcon = _ref.removeIcon,
      choiceTransitionName = _ref.choiceTransitionName,
      maxTagCount = _ref.maxTagCount,
      maxTagTextLength = _ref.maxTagTextLength,
      _ref$maxTagPlaceholde = _ref.maxTagPlaceholder,
      maxTagPlaceholder = _ref$maxTagPlaceholde === void 0 ? function (omittedValues) {
    return "+ ".concat(omittedValues.length, " ...");
  } : _ref$maxTagPlaceholde,
      tagRender = _ref.tagRender,
      onSelect = _ref.onSelect,
      onInputChange = _ref.onInputChange,
      onInputKeyDown = _ref.onInputKeyDown,
      onInputMouseDown = _ref.onInputMouseDown;

  var _React$useState = react_default.a.useState(false),
      _React$useState2 = MultipleSelector_slicedToArray(_React$useState, 2),
      motionAppear = _React$useState2[0],
      setMotionAppear = _React$useState2[1];

  var measureRef = react_default.a.useRef(null);

  var _React$useState3 = react_default.a.useState(0),
      _React$useState4 = MultipleSelector_slicedToArray(_React$useState3, 2),
      inputWidth = _React$useState4[0],
      setInputWidth = _React$useState4[1]; // ===================== Motion ======================


  react_default.a.useEffect(function () {
    setMotionAppear(true);
  }, []); // ===================== Search ======================

  var inputEditable = mode === 'tags' || open && showSearch; // We measure width and set to the input immediately

  useLayoutEffect(function () {
    setInputWidth(measureRef.current.scrollWidth);
  }, [searchValue]); // ==================== Selection ====================

  var displayValues = values; // Cut by `maxTagCount`

  var restCount;

  if (typeof maxTagCount === 'number') {
    restCount = values.length - maxTagCount;
    displayValues = values.slice(0, maxTagCount);
  } // Update by `maxTagTextLength`


  if (typeof maxTagTextLength === 'number') {
    displayValues = displayValues.map(function (_ref2) {
      var label = _ref2.label,
          rest = MultipleSelector_objectWithoutProperties(_ref2, ["label"]);

      var displayLabel = label;

      if (typeof label === 'string' || typeof label === 'number') {
        var strLabel = String(displayLabel);

        if (strLabel.length > maxTagTextLength) {
          displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
        }
      }

      return MultipleSelector_objectSpread({}, rest, {
        label: displayLabel
      });
    });
  } // Fill rest


  if (restCount > 0) {
    displayValues.push({
      key: REST_TAG_KEY,
      label: typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(values.slice(maxTagCount)) : maxTagPlaceholder
    });
  }

  var selectionNode = react_default.a.createElement(es_CSSMotionList, {
    component: false,
    keys: displayValues,
    motionName: choiceTransitionName,
    motionAppear: motionAppear
  }, function (_ref3) {
    var key = _ref3.key,
        label = _ref3.label,
        value = _ref3.value,
        itemDisabled = _ref3.disabled,
        className = _ref3.className,
        style = _ref3.style;
    var mergedKey = key || value;
    var closable = key !== REST_TAG_KEY && !itemDisabled;

    var onMouseDown = function onMouseDown(event) {
      event.preventDefault();
      event.stopPropagation();
    };

    var onClose = function onClose(event) {
      if (event) event.stopPropagation();
      onSelect(value, {
        selected: false
      });
    };

    return typeof tagRender === 'function' ? react_default.a.createElement("span", {
      key: mergedKey,
      onMouseDown: onMouseDown,
      className: className,
      style: style
    }, tagRender({
      label: label,
      value: value,
      disabled: itemDisabled,
      closable: closable,
      onClose: onClose
    })) : react_default.a.createElement("span", {
      key: mergedKey,
      className: classnames_default()(className, "".concat(prefixCls, "-selection-item"), MultipleSelector_defineProperty({}, "".concat(prefixCls, "-selection-item-disabled"), itemDisabled)),
      style: style
    }, react_default.a.createElement("span", {
      className: "".concat(prefixCls, "-selection-item-content")
    }, label), closable && react_default.a.createElement(es_TransBtn, {
      className: "".concat(prefixCls, "-selection-item-remove"),
      onMouseDown: onMouseDown,
      onClick: onClose,
      customizeIcon: removeIcon
    }, "\xD7"));
  });
  return react_default.a.createElement(react_default.a.Fragment, null, selectionNode, react_default.a.createElement("span", {
    className: "".concat(prefixCls, "-selection-search"),
    style: {
      width: inputWidth
    }
  }, react_default.a.createElement(Selector_Input, {
    ref: inputRef,
    open: open,
    prefixCls: prefixCls,
    id: id,
    inputElement: null,
    disabled: disabled,
    autoFocus: autoFocus,
    editable: inputEditable,
    accessibilityIndex: accessibilityIndex,
    value: searchValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: onInputChange,
    tabIndex: tabIndex
  }), react_default.a.createElement("span", {
    ref: measureRef,
    className: "".concat(prefixCls, "-selection-search-mirror"),
    "aria-hidden": true
  }, searchValue, "\xA0")), !values.length && !searchValue && react_default.a.createElement("span", {
    className: "".concat(prefixCls, "-selection-placeholder")
  }, placeholder));
};

/* harmony default export */ var MultipleSelector = (MultipleSelector_SelectSelector);
// CONCATENATED MODULE: ../node_modules/rc-select/es/Selector/SingleSelector.js






var SingleSelector_SingleSelector = function SingleSelector(_ref) {
  var inputElement = _ref.inputElement,
      prefixCls = _ref.prefixCls,
      id = _ref.id,
      inputRef = _ref.inputRef,
      disabled = _ref.disabled,
      autoFocus = _ref.autoFocus,
      accessibilityIndex = _ref.accessibilityIndex,
      mode = _ref.mode,
      open = _ref.open,
      values = _ref.values,
      placeholder = _ref.placeholder,
      tabIndex = _ref.tabIndex,
      showSearch = _ref.showSearch,
      searchValue = _ref.searchValue,
      activeValue = _ref.activeValue,
      onInputKeyDown = _ref.onInputKeyDown,
      onInputMouseDown = _ref.onInputMouseDown,
      onInputChange = _ref.onInputChange;
  var combobox = mode === 'combobox';
  var inputEditable = combobox || showSearch && open;
  var item = values[0];
  var inputValue = searchValue;

  if (combobox) {
    inputValue = item ? String(item.value) : activeValue || searchValue;
  }

  var hasTextInput = !!inputValue;
  return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("span", {
    className: "".concat(prefixCls, "-selection-search")
  }, react_default.a.createElement(Selector_Input, {
    ref: inputRef,
    prefixCls: prefixCls,
    id: id,
    open: open,
    inputElement: inputElement,
    disabled: disabled,
    autoFocus: autoFocus,
    editable: inputEditable,
    accessibilityIndex: accessibilityIndex,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: onInputChange,
    tabIndex: tabIndex
  })), !combobox && item && !hasTextInput && react_default.a.createElement("span", {
    className: "".concat(prefixCls, "-selection-item")
  }, item.label), !item && !hasTextInput && react_default.a.createElement("span", {
    className: "".concat(prefixCls, "-selection-placeholder")
  }, placeholder));
};

/* harmony default export */ var Selector_SingleSelector = (SingleSelector_SingleSelector);
// CONCATENATED MODULE: ../node_modules/rc-select/es/hooks/useLock.js

/**
 * Locker return cached mark.
 * If set to `true`, will return `true` in a short time even if set `false`.
 * If set to `false` and then set to `true`, will change to `true`.
 * And after time duration, it will back to `null` automatically.
 */

function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;
  var lockRef = react["useRef"](null);
  var timeoutRef = react["useRef"](null); // Clean up

  react["useEffect"](function () {
    return function () {
      window.clearTimeout(timeoutRef.current);
    };
  }, []);

  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }

    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(function () {
      lockRef.current = null;
    }, duration);
  }

  return [function () {
    return lockRef.current;
  }, doLock];
}
// CONCATENATED MODULE: ../node_modules/rc-select/es/Selector/index.js











function Selector_slicedToArray(arr, i) {
  return Selector_arrayWithHoles(arr) || Selector_iterableToArrayLimit(arr, i) || Selector_nonIterableRest();
}

function Selector_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function Selector_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function Selector_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
/**
 * Cursor rule:
 * 1. Only `showSearch` enabled
 * 2. Only `open` is `true`
 * 3. When typing, set `open` to `true` which hit rule of 2
 *
 * Accessibility:
 * - https://www.w3.org/TR/wai-aria-practices/examples/combobox/aria1.1pattern/listbox-combo.html
 */








var Selector_Selector = function Selector(props, ref) {
  var inputRef = react["useRef"](null);
  var prefixCls = props.prefixCls,
      multiple = props.multiple,
      open = props.open,
      mode = props.mode,
      onSearch = props.onSearch,
      onToggleOpen = props.onToggleOpen,
      onInputKeyDown = props.onInputKeyDown,
      domRef = props.domRef; // ======================= Ref =======================

  react["useImperativeHandle"](ref, function () {
    return {
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  }); // ====================== Input ======================

  var _useLock = useLock(0),
      _useLock2 = Selector_slicedToArray(_useLock, 2),
      getInputMouseDown = _useLock2[0],
      setInputMouseDown = _useLock2[1];

  var onInternalInputKeyDown = function onInternalInputKeyDown(event) {
    var which = event.which;

    if (which === KeyCode["a" /* default */].UP || which === KeyCode["a" /* default */].DOWN) {
      event.preventDefault();
    }

    if (onInputKeyDown) {
      onInputKeyDown(event);
    }

    if (![KeyCode["a" /* default */].SHIFT, KeyCode["a" /* default */].TAB, KeyCode["a" /* default */].BACKSPACE, KeyCode["a" /* default */].ESC].includes(which)) {
      onToggleOpen(true);
    }
  };
  /**
   * We can not use `findDOMNode` sine it will get warning,
   * have to use timer to check if is input element.
   */


  var onInternalInputMouseDown = function onInternalInputMouseDown() {
    setInputMouseDown(true);
  };

  var onInputChange = function onInputChange(_ref) {
    var value = _ref.target.value;

    if (onSearch(value) !== false) {
      onToggleOpen(true);
    }
  }; // ====================== Focus ======================
  // Should focus input if click the selector


  var onClick = function onClick(_ref2) {
    var target = _ref2.target;

    if (target !== inputRef.current) {
      inputRef.current.focus();
    }
  };

  var onMouseDown = function onMouseDown(event) {
    if (event.target !== inputRef.current && !getInputMouseDown()) {
      event.preventDefault();
    }

    if (mode !== 'combobox' || !open) {
      onToggleOpen();
    }
  }; // ================= Inner Selector ==================


  var sharedProps = {
    inputRef: inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange: onInputChange
  };
  var selectNode = multiple ? react["createElement"](MultipleSelector, Object.assign({}, props, sharedProps)) : react["createElement"](Selector_SingleSelector, Object.assign({}, props, sharedProps));
  return react["createElement"]("div", {
    ref: domRef,
    className: "".concat(prefixCls, "-selector"),
    onClick: onClick,
    onMouseDown: onMouseDown
  }, selectNode);
};

var ForwardSelector = react["forwardRef"](Selector_Selector);
ForwardSelector.displayName = 'Selector';
/* harmony default export */ var es_Selector = (ForwardSelector);
// CONCATENATED MODULE: ../node_modules/rc-select/es/SelectTrigger.js













function SelectTrigger_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function SelectTrigger_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      SelectTrigger_ownKeys(Object(source), true).forEach(function (key) {
        SelectTrigger_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      SelectTrigger_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function SelectTrigger_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function SelectTrigger_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = SelectTrigger_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function SelectTrigger_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}




var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ['tl', 'bl'],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ['bl', 'tl'],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};

var SelectTrigger_SelectTrigger = function SelectTrigger(props, ref) {
  var prefixCls = props.prefixCls,
      disabled = props.disabled,
      visible = props.visible,
      children = props.children,
      popupElement = props.popupElement,
      containerWidth = props.containerWidth,
      animation = props.animation,
      transitionName = props.transitionName,
      dropdownStyle = props.dropdownStyle,
      dropdownClassName = props.dropdownClassName,
      _props$dropdownMatchS = props.dropdownMatchSelectWidth,
      dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS,
      dropdownRender = props.dropdownRender,
      dropdownAlign = props.dropdownAlign,
      getPopupContainer = props.getPopupContainer,
      empty = props.empty,
      getTriggerDOMNode = props.getTriggerDOMNode,
      restProps = SelectTrigger_objectWithoutProperties(props, ["prefixCls", "disabled", "visible", "children", "popupElement", "containerWidth", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode"]);

  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var popupNode = popupElement;

  if (dropdownRender) {
    popupNode = dropdownRender(popupElement);
  } // ===================== Motion ======================


  var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName; // ======================= Ref =======================

  var popupRef = react["useRef"](null);
  react["useImperativeHandle"](ref, function () {
    return {
      getPopupElement: function getPopupElement() {
        return popupRef.current;
      }
    };
  });
  return react["createElement"](rc_trigger_es["a" /* default */], Object.assign({}, restProps, {
    showAction: [],
    hideAction: [],
    popupPlacement: "bottomLeft",
    builtinPlacements: BUILT_IN_PLACEMENTS,
    prefixCls: dropdownPrefixCls,
    popupTransitionName: mergedTransitionName,
    popup: react["createElement"]("div", {
      ref: popupRef
    }, popupNode),
    popupAlign: dropdownAlign,
    popupVisible: visible,
    getPopupContainer: getPopupContainer,
    popupClassName: classnames_default()(dropdownClassName, SelectTrigger_defineProperty({}, "".concat(dropdownPrefixCls, "-empty"), empty)),
    popupStyle: SelectTrigger_objectSpread({}, dropdownStyle, {
      width: typeof dropdownMatchSelectWidth === 'number' ? dropdownMatchSelectWidth : containerWidth
    }),
    getTriggerDOMNode: getTriggerDOMNode
  }), children);
};

var RefSelectTrigger = react["forwardRef"](SelectTrigger_SelectTrigger);
RefSelectTrigger.displayName = 'SelectTrigger';
/* harmony default export */ var es_SelectTrigger = (RefSelectTrigger);
// CONCATENATED MODULE: ../node_modules/rc-select/es/interface/generator.js
var INTERNAL_PROPS_MARK = 'RC_SELECT_INTERNAL_PROPS_MARK';
// CONCATENATED MODULE: ../node_modules/rc-select/es/hooks/useDelayReset.js








function useDelayReset_slicedToArray(arr, i) {
  return useDelayReset_arrayWithHoles(arr) || useDelayReset_iterableToArrayLimit(arr, i) || useDelayReset_nonIterableRest();
}

function useDelayReset_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function useDelayReset_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function useDelayReset_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}


/**
 * Similar with `useLock`, but this hook will always execute last value.
 * When set to `true`, it will keep `true` for a short time even if `false` is set.
 */

function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

  var _React$useState = react["useState"](false),
      _React$useState2 = useDelayReset_slicedToArray(_React$useState, 2),
      bool = _React$useState2[0],
      setBool = _React$useState2[1];

  var delayRef = react["useRef"](null);

  var cancelLatest = function cancelLatest() {
    window.clearTimeout(delayRef.current);
  };

  react["useEffect"](function () {
    return cancelLatest;
  }, []);

  var delaySetBool = function delaySetBool(value, callback) {
    cancelLatest();
    delayRef.current = window.setTimeout(function () {
      setBool(value);

      if (callback) {
        callback();
      }
    }, timeout);
  };

  return [bool, delaySetBool, cancelLatest];
}
// CONCATENATED MODULE: ../node_modules/rc-select/es/hooks/useSelectTriggerControl.js



function useSelectTriggerControl(elements, open, triggerOpen) {
  var propsRef = react["useRef"](null);
  propsRef.current = {
    elements: elements.filter(function (e) {
      return e;
    }),
    open: open,
    triggerOpen: triggerOpen
  };
  react["useEffect"](function () {
    function onGlobalMouseDown(event) {
      var target = event.target;

      if (propsRef.current.open && propsRef.current.elements.every(function (element) {
        return !element.contains(target) && element !== target;
      })) {
        // Should trigger close
        propsRef.current.triggerOpen(false);
      }
    }

    window.addEventListener('mousedown', onGlobalMouseDown);
    return function () {
      return window.removeEventListener('mousedown', onGlobalMouseDown);
    };
  }, []);
}
// CONCATENATED MODULE: ../node_modules/rc-select/es/generate.js
























function generate_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function generate_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      generate_ownKeys(Object(source), true).forEach(function (key) {
        generate_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      generate_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function generate_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function generate_toConsumableArray(arr) {
  return generate_arrayWithoutHoles(arr) || generate_iterableToArray(arr) || generate_nonIterableSpread();
}

function generate_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function generate_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function generate_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function generate_slicedToArray(arr, i) {
  return generate_arrayWithHoles(arr) || generate_iterableToArrayLimit(arr, i) || generate_nonIterableRest();
}

function generate_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function generate_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function generate_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function generate_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = generate_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function generate_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
/**
 * To match accessibility requirement, we always provide an input in the component.
 * Other element will not set `tabIndex` to avoid `onBlur` sequence problem.
 * For focused select, we set `aria-live="polite"` to update the accessibility content.
 *
 * ref:
 * - keyboard: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role#Keyboard_interactions
 */
















var DEFAULT_OMIT_PROPS = ['removeIcon', 'placeholder', 'autoFocus', 'maxTagCount', 'maxTagTextLength', 'maxTagPlaceholder', 'choiceTransitionName', 'onInputKeyDown'];
/**
 * This function is in internal usage.
 * Do not use it in your prod env since we may refactor this.
 */

function generateSelector(config) {
  var defaultPrefixCls = config.prefixCls,
      OptionList = config.components.optionList,
      convertChildrenToData = config.convertChildrenToData,
      flattenOptions = config.flattenOptions,
      getLabeledValue = config.getLabeledValue,
      filterOptions = config.filterOptions,
      isValueDisabled = config.isValueDisabled,
      findValueOption = config.findValueOption,
      warningProps = config.warningProps,
      fillOptionsWithMissingValue = config.fillOptionsWithMissingValue,
      omitDOMProps = config.omitDOMProps; // Use raw define since `React.FC` not support generic

  function Select(props, ref) {
    var _classNames2;

    var _props$prefixCls = props.prefixCls,
        prefixCls = _props$prefixCls === void 0 ? defaultPrefixCls : _props$prefixCls,
        className = props.className,
        id = props.id,
        open = props.open,
        defaultOpen = props.defaultOpen,
        options = props.options,
        children = props.children,
        mode = props.mode,
        value = props.value,
        defaultValue = props.defaultValue,
        labelInValue = props.labelInValue,
        showSearch = props.showSearch,
        inputValue = props.inputValue,
        searchValue = props.searchValue,
        filterOption = props.filterOption,
        _props$optionFilterPr = props.optionFilterProp,
        optionFilterProp = _props$optionFilterPr === void 0 ? 'value' : _props$optionFilterPr,
        _props$autoClearSearc = props.autoClearSearchValue,
        autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc,
        onSearch = props.onSearch,
        allowClear = props.allowClear,
        clearIcon = props.clearIcon,
        showArrow = props.showArrow,
        inputIcon = props.inputIcon,
        menuItemSelectedIcon = props.menuItemSelectedIcon,
        disabled = props.disabled,
        loading = props.loading,
        defaultActiveFirstOption = props.defaultActiveFirstOption,
        _props$notFoundConten = props.notFoundContent,
        notFoundContent = _props$notFoundConten === void 0 ? 'Not Found' : _props$notFoundConten,
        optionLabelProp = props.optionLabelProp,
        backfill = props.backfill,
        getInputElement = props.getInputElement,
        getPopupContainer = props.getPopupContainer,
        _props$listHeight = props.listHeight,
        listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight,
        _props$listItemHeight = props.listItemHeight,
        listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight,
        animation = props.animation,
        transitionName = props.transitionName,
        dropdownStyle = props.dropdownStyle,
        dropdownClassName = props.dropdownClassName,
        dropdownMatchSelectWidth = props.dropdownMatchSelectWidth,
        dropdownRender = props.dropdownRender,
        dropdownAlign = props.dropdownAlign,
        _props$showAction = props.showAction,
        showAction = _props$showAction === void 0 ? [] : _props$showAction,
        tokenSeparators = props.tokenSeparators,
        tagRender = props.tagRender,
        onPopupScroll = props.onPopupScroll,
        onDropdownVisibleChange = props.onDropdownVisibleChange,
        onFocus = props.onFocus,
        onBlur = props.onBlur,
        onKeyUp = props.onKeyUp,
        onKeyDown = props.onKeyDown,
        onMouseDown = props.onMouseDown,
        onChange = props.onChange,
        onSelect = props.onSelect,
        onDeselect = props.onDeselect,
        _props$internalProps = props.internalProps,
        internalProps = _props$internalProps === void 0 ? {} : _props$internalProps,
        restProps = generate_objectWithoutProperties(props, ["prefixCls", "className", "id", "open", "defaultOpen", "options", "children", "mode", "value", "defaultValue", "labelInValue", "showSearch", "inputValue", "searchValue", "filterOption", "optionFilterProp", "autoClearSearchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "menuItemSelectedIcon", "disabled", "loading", "defaultActiveFirstOption", "notFoundContent", "optionLabelProp", "backfill", "getInputElement", "getPopupContainer", "listHeight", "listItemHeight", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "tokenSeparators", "tagRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown", "onChange", "onSelect", "onDeselect", "internalProps"]);

    var useInternalProps = internalProps.mark === INTERNAL_PROPS_MARK;
    var domProps = omitDOMProps ? omitDOMProps(restProps) : restProps;
    DEFAULT_OMIT_PROPS.forEach(function (prop) {
      delete domProps[prop];
    });
    var containerRef = react["useRef"](null);
    var triggerRef = react["useRef"](null);
    var selectorRef = react["useRef"](null);
    var listRef = react["useRef"](null);
    /** Used for component focused management */

    var _useDelayReset = useDelayReset(),
        _useDelayReset2 = generate_slicedToArray(_useDelayReset, 3),
        mockFocused = _useDelayReset2[0],
        setMockFocused = _useDelayReset2[1],
        cancelSetMockFocused = _useDelayReset2[2]; // Inner id for accessibility usage. Only work in client side


    var _React$useState = react["useState"](),
        _React$useState2 = generate_slicedToArray(_React$useState, 2),
        innerId = _React$useState2[0],
        setInnerId = _React$useState2[1];

    react["useEffect"](function () {
      setInnerId("rc_select_".concat(getUUID()));
    }, []);
    var mergedId = id || innerId; // optionLabelProp

    var mergedOptionLabelProp = optionLabelProp;

    if (mergedOptionLabelProp === undefined) {
      mergedOptionLabelProp = options ? 'label' : 'children';
    } // labelInValue


    var mergedLabelInValue = mode === 'combobox' ? false : labelInValue;
    var isMultiple = mode === 'tags' || mode === 'multiple';
    var mergedShowSearch = showSearch !== undefined ? showSearch : isMultiple || mode === 'combobox'; // ============================== Ref ===============================

    var selectorDomRef = react["useRef"](null);
    react["useImperativeHandle"](ref, function () {
      return {
        focus: selectorRef.current.focus,
        blur: selectorRef.current.blur
      };
    }); // ============================= Value ==============================

    var _React$useState3 = react["useState"](value || defaultValue),
        _React$useState4 = generate_slicedToArray(_React$useState3, 2),
        innerValue = _React$useState4[0],
        setInnerValue = _React$useState4[1];

    var baseValue = value !== undefined ? value : innerValue; // Should reset when controlled to be uncontrolled

    var prevValueRef = react["useRef"](value);
    react["useEffect"](function () {
      if (prevValueRef.current !== value && (value === undefined || value === null)) {
        setInnerValue(undefined);
      }

      prevValueRef.current = value;
    }, [value]);
    /** Unique raw values */

    var mergedRawValue = react["useMemo"](function () {
      return toInnerValue(baseValue, {
        labelInValue: mergedLabelInValue,
        combobox: mode === 'combobox'
      });
    }, [baseValue, mergedLabelInValue]);
    /** We cache a set of raw values to speed up check */

    var rawValues = react["useMemo"](function () {
      return new Set(mergedRawValue);
    }, [mergedRawValue]); // ============================= Option =============================
    // Set by option list active, it will merge into search input when mode is `combobox`

    var _React$useState5 = react["useState"](null),
        _React$useState6 = generate_slicedToArray(_React$useState5, 2),
        activeValue = _React$useState6[0],
        setActiveValue = _React$useState6[1];

    var _React$useState7 = react["useState"](''),
        _React$useState8 = generate_slicedToArray(_React$useState7, 2),
        innerSearchValue = _React$useState8[0],
        setInnerSearchValue = _React$useState8[1];

    var mergedSearchValue = innerSearchValue;

    if (mode === 'combobox' && value !== undefined) {
      mergedSearchValue = value;
    } else if (searchValue !== undefined) {
      mergedSearchValue = searchValue;
    } else if (inputValue) {
      mergedSearchValue = inputValue;
    }

    var mergedOptions = react["useMemo"](function () {
      var newOptions = options;

      if (newOptions === undefined) {
        newOptions = convertChildrenToData(children);
      }
      /**
       * `tags` should fill un-list item.
       * This is not cool here since TreeSelect do not need this
       */


      if (mode === 'tags' && fillOptionsWithMissingValue) {
        newOptions = fillOptionsWithMissingValue(newOptions, baseValue, mergedOptionLabelProp, labelInValue);
      }

      return newOptions || [];
    }, [options, children, mode, baseValue]);
    var mergedFlattenOptions = react["useMemo"](function () {
      return flattenOptions(mergedOptions, props);
    }, [mergedOptions]); // Display options for OptionList

    var displayOptions = react["useMemo"](function () {
      if (!mergedSearchValue || !mergedShowSearch) {
        return generate_toConsumableArray(mergedOptions);
      }

      var filteredOptions = filterOptions(mergedSearchValue, mergedOptions, {
        optionFilterProp: optionFilterProp,
        filterOption: mode === 'combobox' && filterOption === undefined ? function () {
          return true;
        } : filterOption
      });

      if (mode === 'tags' && filteredOptions.every(function (opt) {
        return opt.value !== mergedSearchValue;
      })) {
        filteredOptions.unshift({
          value: mergedSearchValue,
          label: mergedSearchValue,
          key: '__RC_SELECT_TAG_PLACEHOLDER__'
        });
      }

      return filteredOptions;
    }, [mergedOptions, mergedSearchValue, mode, mergedShowSearch]);
    var displayFlattenOptions = react["useMemo"](function () {
      return flattenOptions(displayOptions, props);
    }, [displayOptions]); // ============================ Selector ============================

    var displayValues = react["useMemo"](function () {
      return mergedRawValue.map(function (val) {
        var displayValue = getLabeledValue(val, {
          options: mergedFlattenOptions,
          prevValue: baseValue,
          labelInValue: mergedLabelInValue,
          optionLabelProp: mergedOptionLabelProp
        });
        return generate_objectSpread({}, displayValue, {
          disabled: isValueDisabled(val, mergedFlattenOptions)
        });
      });
    }, [baseValue, mergedOptions]);

    var triggerSelect = function triggerSelect(newValue, isSelect, source) {
      var outOption = findValueOption([newValue], mergedFlattenOptions)[0];

      if (!internalProps.skipTriggerSelect) {
        // Skip trigger `onSelect` or `onDeselect` if configured
        var selectValue = mergedLabelInValue ? getLabeledValue(newValue, {
          options: mergedFlattenOptions,
          prevValue: baseValue,
          labelInValue: mergedLabelInValue,
          optionLabelProp: mergedOptionLabelProp
        }) : newValue;

        if (isSelect && onSelect) {
          onSelect(selectValue, outOption);
        } else if (!isSelect && onDeselect) {
          onDeselect(selectValue, outOption);
        }
      } // Trigger internal event


      if (useInternalProps) {
        if (isSelect && internalProps.onRawSelect) {
          internalProps.onRawSelect(newValue, outOption, source);
        } else if (!isSelect && internalProps.onRawDeselect) {
          internalProps.onRawDeselect(newValue, outOption, source);
        }
      }
    };

    var triggerChange = function triggerChange(newRawValues) {
      if (useInternalProps && internalProps.skipTriggerChange) {
        return;
      }

      var outValues = toOuterValues(Array.from(newRawValues), {
        labelInValue: mergedLabelInValue,
        options: mergedFlattenOptions,
        getLabeledValue: getLabeledValue,
        prevValue: baseValue,
        optionLabelProp: mergedOptionLabelProp
      });
      var outValue = isMultiple ? outValues : outValues[0]; // Skip trigger if prev & current value is both empty

      if (onChange && (mergedRawValue.length !== 0 || outValues.length !== 0)) {
        var outOptions = findValueOption(newRawValues, mergedFlattenOptions);
        onChange(outValue, isMultiple ? outOptions : outOptions[0]);
      }

      setInnerValue(outValue);
    };

    var onInternalSelect = function onInternalSelect(newValue, _ref) {
      var selected = _ref.selected,
          source = _ref.source;

      if (disabled) {
        return;
      }

      var newRawValue;

      if (isMultiple) {
        newRawValue = new Set(mergedRawValue);

        if (selected) {
          newRawValue.add(newValue);
        } else {
          newRawValue["delete"](newValue);
        }
      } else {
        newRawValue = new Set();
        newRawValue.add(newValue);
      } // Multiple always trigger change and single should change if value changed


      if (isMultiple || !isMultiple && Array.from(mergedRawValue)[0] !== newValue) {
        triggerChange(Array.from(newRawValue));
      } // Trigger `onSelect`. Single mode always trigger select


      triggerSelect(newValue, !isMultiple || selected, source); // Clean search value if single or configured

      if (mode === 'combobox') {
        setInnerSearchValue(String(newValue));
        setActiveValue('');
      } else if (!isMultiple || autoClearSearchValue) {
        setInnerSearchValue('');
        setActiveValue('');
      }
    };

    var onInternalOptionSelect = function onInternalOptionSelect(newValue, info) {
      onInternalSelect(newValue, generate_objectSpread({}, info, {
        source: 'option'
      }));
    };

    var onInternalSelectionSelect = function onInternalSelectionSelect(newValue, info) {
      onInternalSelect(newValue, generate_objectSpread({}, info, {
        source: 'selection'
      }));
    }; // ============================= Input ==============================
    // Only works in `combobox`


    var customizeInputElement = mode === 'combobox' && getInputElement && getInputElement() || null; // ============================== Open ==============================

    var _useMergedState = useControlledState(undefined, {
      defaultValue: defaultOpen,
      value: open
    }),
        _useMergedState2 = generate_slicedToArray(_useMergedState, 2),
        innerOpen = _useMergedState2[0],
        setInnerOpen = _useMergedState2[1];

    var mergedOpen = innerOpen; // Not trigger `open` in `combobox` when `notFoundContent` is empty

    var emptyListContent = !notFoundContent && !displayOptions.length;

    if (disabled || emptyListContent && mergedOpen && mode === 'combobox') {
      mergedOpen = false;
    }

    var triggerOpen = emptyListContent ? false : mergedOpen;

    var onToggleOpen = function onToggleOpen(newOpen) {
      var nextOpen = newOpen !== undefined ? newOpen : !mergedOpen;

      if (innerOpen !== nextOpen && !disabled) {
        setInnerOpen(nextOpen);

        if (onDropdownVisibleChange) {
          onDropdownVisibleChange(nextOpen);
        }
      }
    };

    useSelectTriggerControl([containerRef.current, triggerRef.current && triggerRef.current.getPopupElement()], triggerOpen, onToggleOpen); // ============================= Search =============================

    var triggerSearch = function triggerSearch(searchText) {
      var fromTyping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var ret = true;
      var newSearchText = searchText;
      setActiveValue(null); // Check if match the `tokenSeparators`

      var patchLabels = getSeparatedContent(searchText, tokenSeparators);
      var patchRawValues = patchLabels;

      if (mode === 'combobox') {
        // Only typing will trigger onChange
        if (fromTyping) {
          triggerChange([newSearchText]);
        }
      } else if (patchLabels) {
        newSearchText = '';

        if (mode !== 'tags') {
          patchRawValues = patchLabels.map(function (label) {
            var item = mergedFlattenOptions.find(function (_ref2) {
              var data = _ref2.data;
              return data[mergedOptionLabelProp] === label;
            });
            return item ? item.data.value : null;
          }).filter(function (val) {
            return val !== null;
          });
        }

        var newRawValues = Array.from(new Set([].concat(generate_toConsumableArray(mergedRawValue), generate_toConsumableArray(patchRawValues))));
        triggerChange(newRawValues);
        newRawValues.forEach(function (newRawValue) {
          triggerSelect(newRawValue, true, 'input');
        }); // Should close when paste finish

        onToggleOpen(false); // Tell Selector that break next actions

        ret = false;
      }

      setInnerSearchValue(newSearchText);

      if (onSearch && mergedSearchValue !== newSearchText) {
        onSearch(newSearchText);
      }

      return ret;
    }; // Close dropdown when disabled change


    react["useEffect"](function () {
      if (innerOpen && !!disabled) {
        setInnerOpen(false);
      }
    }, [disabled]); // Close will clean up single mode search text

    react["useEffect"](function () {
      if (!mergedOpen && !isMultiple && mode !== 'combobox') {
        triggerSearch('', false);
      }
    }, [mergedOpen]); // ============================ Keyboard ============================

    /**
     * We record input value here to check if can press to clean up by backspace
     * - null: Key is not down, this is reset by key up
     * - true: Search text is empty when first time backspace down
     * - false: Search text is not empty when first time backspace down
     */

    var _useLock = useLock(),
        _useLock2 = generate_slicedToArray(_useLock, 2),
        getClearLock = _useLock2[0],
        setClearLock = _useLock2[1]; // KeyDown


    var onInternalKeyDown = function onInternalKeyDown(event) {
      var clearLock = getClearLock();
      var which = event.which; // We only manage open state here, close logic should handle by list component

      if (!mergedOpen && which === KeyCode["a" /* default */].ENTER) {
        onToggleOpen(true);
      }

      setClearLock(!!mergedSearchValue); // Remove value by `backspace`

      if (which === KeyCode["a" /* default */].BACKSPACE && !clearLock && isMultiple && !mergedSearchValue && mergedRawValue.length) {
        var removeInfo = removeLastEnabledValue(displayValues, mergedRawValue);

        if (removeInfo.removedValue !== null) {
          triggerChange(removeInfo.values);
          triggerSelect(removeInfo.removedValue, false, 'input');
        }
      }

      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      if (mergedOpen && listRef.current) {
        var _listRef$current;

        (_listRef$current = listRef.current).onKeyDown.apply(_listRef$current, [event].concat(rest));
      }

      if (onKeyDown) {
        onKeyDown.apply(void 0, [event].concat(rest));
      }
    }; // KeyUp


    var onInternalKeyUp = function onInternalKeyUp(event) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }

      if (mergedOpen && listRef.current) {
        var _listRef$current2;

        (_listRef$current2 = listRef.current).onKeyUp.apply(_listRef$current2, [event].concat(rest));
      }

      if (onKeyUp) {
        onKeyUp.apply(void 0, [event].concat(rest));
      }
    }; // ========================== Focus / Blur ==========================

    /** Record real focus status */


    var focusRef = react["useRef"](false);

    var onContainerFocus = function onContainerFocus() {
      setMockFocused(true);

      if (!disabled) {
        if (onFocus && !focusRef.current) {
          onFocus.apply(void 0, arguments);
        } // `showAction` should handle `focus` if set


        if (showAction.includes('focus')) {
          onToggleOpen(true);
        }
      }

      focusRef.current = true;
    };

    var onContainerBlur = function onContainerBlur() {
      setMockFocused(false, function () {
        focusRef.current = false;
        onToggleOpen(false);
      });

      if (disabled) {
        return;
      }

      if (mergedSearchValue) {
        // `tags` mode should move `searchValue` into values
        if (mode === 'tags') {
          triggerSearch('', false);
          triggerChange(Array.from(new Set([].concat(generate_toConsumableArray(mergedRawValue), [mergedSearchValue]))));
        } else if (mode === 'multiple') {
          // `multiple` mode only clean the search value but not trigger event
          setInnerSearchValue('');
        }
      }

      if (onBlur) {
        onBlur.apply(void 0, arguments);
      }
    };

    var onInternalMouseDown = function onInternalMouseDown(event) {
      var target = event.target;
      var popupElement = triggerRef.current && triggerRef.current.getPopupElement(); // We should give focus back to selector if clicked item is not focusable

      if (popupElement && popupElement.contains(target)) {
        setTimeout(function () {
          cancelSetMockFocused();

          if (!popupElement.contains(document.activeElement)) {
            selectorRef.current.focus();
          }
        });
      }

      if (onMouseDown) {
        for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          restArgs[_key3 - 1] = arguments[_key3];
        }

        onMouseDown.apply(void 0, [event].concat(restArgs));
      }
    }; // ========================= Accessibility ==========================


    var _React$useState9 = react["useState"](0),
        _React$useState10 = generate_slicedToArray(_React$useState9, 2),
        accessibilityIndex = _React$useState10[0],
        setAccessibilityIndex = _React$useState10[1];

    var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== undefined ? defaultActiveFirstOption : mode !== 'combobox';

    var onActiveValue = function onActiveValue(active, index) {
      setAccessibilityIndex(index);

      if (backfill && mode === 'combobox' && active !== null) {
        setActiveValue(String(active));
      }
    }; // ============================= Popup ==============================


    var _React$useState11 = react["useState"](null),
        _React$useState12 = generate_slicedToArray(_React$useState11, 2),
        containerWidth = _React$useState12[0],
        setContainerWidth = _React$useState12[1];

    useLayoutEffect(function () {
      if (triggerOpen) {
        var newWidth = Math.ceil(containerRef.current.offsetWidth);

        if (containerWidth !== newWidth) {
          setContainerWidth(newWidth);
        }
      }
    }, [triggerOpen]);
    var popupNode = react["createElement"](OptionList, {
      ref: listRef,
      prefixCls: prefixCls,
      id: mergedId,
      open: mergedOpen,
      childrenAsData: !options,
      options: displayOptions,
      flattenOptions: displayFlattenOptions,
      multiple: isMultiple,
      values: rawValues,
      height: listHeight,
      itemHeight: listItemHeight,
      onSelect: onInternalOptionSelect,
      onToggleOpen: onToggleOpen,
      onActiveValue: onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      notFoundContent: notFoundContent,
      onScroll: onPopupScroll,
      searchValue: mergedSearchValue,
      menuItemSelectedIcon: menuItemSelectedIcon
    }); // ============================= Clear ==============================

    var clearNode;

    var onClearMouseDown = function onClearMouseDown() {
      // Trigger internal `onClear` event
      if (useInternalProps && internalProps.onClear) {
        internalProps.onClear();
      }

      triggerChange([]);
      triggerSearch('', false);
    };

    if (!disabled && allowClear && (mergedRawValue.length || mergedSearchValue)) {
      clearNode = react["createElement"](es_TransBtn, {
        className: "".concat(prefixCls, "-clear"),
        onMouseDown: onClearMouseDown,
        customizeIcon: clearIcon
      }, "\xD7");
    } // ============================= Arrow ==============================


    var mergedShowArrow = showArrow !== undefined ? showArrow : loading || !isMultiple && mode !== 'combobox';
    var arrowNode;

    if (mergedShowArrow) {
      arrowNode = react["createElement"](es_TransBtn, {
        className: classnames_default()("".concat(prefixCls, "-arrow"), generate_defineProperty({}, "".concat(prefixCls, "-arrow-loading"), loading)),
        customizeIcon: inputIcon,
        customizeIconProps: {
          loading: loading,
          searchValue: mergedSearchValue,
          open: mergedOpen,
          focused: mockFocused,
          showSearch: mergedShowSearch
        }
      });
    } // ============================ Warning =============================


    if (false) {} // ============================= Render =============================


    var mergedClassName = classnames_default()(prefixCls, className, (_classNames2 = {}, generate_defineProperty(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), generate_defineProperty(_classNames2, "".concat(prefixCls, "-multiple"), isMultiple), generate_defineProperty(_classNames2, "".concat(prefixCls, "-single"), !isMultiple), generate_defineProperty(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), generate_defineProperty(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), generate_defineProperty(_classNames2, "".concat(prefixCls, "-disabled"), disabled), generate_defineProperty(_classNames2, "".concat(prefixCls, "-loading"), loading), generate_defineProperty(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), generate_defineProperty(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), generate_defineProperty(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2));
    return react["createElement"]("div", Object.assign({
      className: mergedClassName
    }, domProps, {
      ref: containerRef,
      onMouseDown: onInternalMouseDown,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onFocus: onContainerFocus,
      onBlur: onContainerBlur
    }), mockFocused && !mergedOpen && react["createElement"]("span", {
      style: {
        width: 0,
        height: 0,
        display: 'flex',
        overflow: 'hidden',
        opacity: 0
      },
      "aria-live": "polite"
    }, "".concat(mergedRawValue.join(', '))), react["createElement"](es_SelectTrigger, {
      ref: triggerRef,
      disabled: disabled,
      prefixCls: prefixCls,
      visible: triggerOpen,
      popupElement: popupNode,
      containerWidth: containerWidth,
      animation: animation,
      transitionName: transitionName,
      dropdownStyle: dropdownStyle,
      dropdownClassName: dropdownClassName,
      dropdownMatchSelectWidth: dropdownMatchSelectWidth,
      dropdownRender: dropdownRender,
      dropdownAlign: dropdownAlign,
      getPopupContainer: getPopupContainer,
      empty: !mergedOptions.length,
      getTriggerDOMNode: function getTriggerDOMNode() {
        return selectorDomRef.current;
      }
    }, react["createElement"](es_Selector, Object.assign({}, props, {
      domRef: selectorDomRef,
      prefixCls: prefixCls,
      inputElement: customizeInputElement,
      ref: selectorRef,
      id: mergedId,
      showSearch: mergedShowSearch,
      mode: mode,
      accessibilityIndex: accessibilityIndex,
      multiple: isMultiple,
      tagRender: tagRender,
      values: displayValues,
      open: mergedOpen,
      onToggleOpen: onToggleOpen,
      searchValue: mergedSearchValue,
      activeValue: activeValue,
      onSearch: triggerSearch,
      onSelect: onInternalSelectionSelect
    }))), arrowNode, clearNode);
  }

  var RefSelect = react["forwardRef"](Select);
  return RefSelect;
}
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.some.js
var es6_array_some = __webpack_require__("VNvs");

// CONCATENATED MODULE: ../node_modules/rc-select/es/utils/warningPropsUtil.js






function warningPropsUtil_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    warningPropsUtil_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    warningPropsUtil_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return warningPropsUtil_typeof(obj);
}







function warningPropsUtil_warningProps(props) {
  var mode = props.mode,
      options = props.options,
      children = props.children,
      backfill = props.backfill,
      allowClear = props.allowClear,
      placeholder = props.placeholder,
      getInputElement = props.getInputElement,
      showSearch = props.showSearch,
      onSearch = props.onSearch,
      defaultOpen = props.defaultOpen,
      autoFocus = props.autoFocus,
      labelInValue = props.labelInValue,
      value = props.value,
      inputValue = props.inputValue,
      optionLabelProp = props.optionLabelProp;
  var multiple = mode === 'multiple' || mode === 'tags';
  var mergedShowSearch = showSearch !== undefined ? showSearch : multiple || mode === 'combobox';
  var mergedOptions = options || legacyUtil_convertChildrenToData(children); // `tags` should not set option as disabled

  Object(es_warning["a" /* default */])(mode !== 'tags' || mergedOptions.every(function (opt) {
    return !opt.disabled;
  }), 'Please avoid setting option to disabled in tags mode since user can always type text as tag.'); // `combobox` & `tags` should option be `string` type

  if (mode === 'tags' || mode === 'combobox') {
    var hasNumberValue = mergedOptions.some(function (item) {
      if (item.options) {
        return item.options.some(function (opt) {
          return typeof ('value' in opt ? opt.value : opt.key) === 'number';
        });
      }

      return typeof ('value' in item ? item.value : item.key) === 'number';
    });
    Object(es_warning["a" /* default */])(!hasNumberValue, '`value` of Option should not use number type when `mode` is `tags` or `combobox`.');
  } // `combobox` should not use `optionLabelProp`


  Object(es_warning["a" /* default */])(mode !== 'combobox' || !optionLabelProp, '`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.'); // Only `combobox` support `backfill`

  Object(es_warning["a" /* default */])(mode === 'combobox' || !backfill, '`backfill` only works with `combobox` mode.'); // Only `combobox` support `getInputElement`

  Object(es_warning["a" /* default */])(mode === 'combobox' || !getInputElement, '`getInputElement` only work with `combobox` mode.'); // Customize `getInputElement` should not use `allowClear` & `placeholder`

  Object(es_warning["b" /* noteOnce */])(mode !== 'combobox' || !getInputElement || !allowClear || !placeholder, 'Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.'); // `onSearch` should use in `combobox` or `showSearch`

  if (onSearch && !mergedShowSearch && mode !== 'combobox' && mode !== 'tags') {
    Object(es_warning["a" /* default */])(false, '`onSearch` should work with `showSearch` instead of use alone.');
  }

  Object(es_warning["b" /* noteOnce */])(!defaultOpen || autoFocus, '`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.');

  if (value !== undefined && value !== null) {
    var values = commonUtil_toArray(value);
    Object(es_warning["a" /* default */])(!labelInValue || values.every(function (val) {
      return warningPropsUtil_typeof(val) === 'object' && ('key' in val || 'value' in val);
    }), '`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`');
    Object(es_warning["a" /* default */])(!multiple || Array.isArray(value), '`value` should be array when `mode` is `multiple` or `tags`');
  } // Syntactic sugar should use correct children type


  if (children) {
    var invalidateChildType = null;
    Object(toArray["a" /* default */])(children).some(function (node) {
      if (!react_default.a.isValidElement(node) || !node.type) {
        return false;
      }

      var type = node.type;

      if (type.isSelectOption) {
        return false;
      }

      if (type.isSelectOptGroup) {
        var allChildrenValid = Object(toArray["a" /* default */])(node.props.children).every(function (subNode) {
          if (!react_default.a.isValidElement(subNode) || !node.type || subNode.type.isSelectOption) {
            return true;
          }

          invalidateChildType = subNode.type;
          return false;
        });

        if (allChildrenValid) {
          return false;
        }

        return true;
      }

      invalidateChildType = type;
      return true;
    });

    if (invalidateChildType) {
      Object(es_warning["a" /* default */])(false, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(invalidateChildType.displayName || invalidateChildType.name || invalidateChildType, "`."));
    }

    Object(es_warning["a" /* default */])(inputValue === undefined, '`inputValue` is deprecated, please use `searchValue` instead.');
  }
}

/* harmony default export */ var warningPropsUtil = (warningPropsUtil_warningProps);
// CONCATENATED MODULE: ../node_modules/rc-select/es/Select.js







function Select_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    Select_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    Select_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return Select_typeof(obj);
}

function Select_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function Select_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function Select_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) Select_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) Select_defineProperties(Constructor, staticProps);
  return Constructor;
}

function Select_possibleConstructorReturn(self, call) {
  if (call && (Select_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Select_assertThisInitialized(self);
}

function Select_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function Select_getPrototypeOf(o) {
  Select_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return Select_getPrototypeOf(o);
}

function Select_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Select_setPrototypeOf(subClass, superClass);
}

function Select_setPrototypeOf(o, p) {
  Select_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return Select_setPrototypeOf(o, p);
}
/**
 * To match accessibility requirement, we always provide an input in the component.
 * Other element will not set `tabIndex` to avoid `onBlur` sequence problem.
 * For focused select, we set `aria-live="polite"` to update the accessibility content.
 *
 * ref:
 * - keyboard: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role#Keyboard_interactions
 *
 * New api:
 * - listHeight
 * - listItemHeight
 * - component
 *
 * Remove deprecated api:
 * - multiple
 * - tags
 * - combobox
 * - firstActiveValue
 * - dropdownMenuStyle
 * - openClassName (Not list in api)
 *
 * Update:
 * - `backfill` only support `combobox` mode
 * - `combobox` mode not support `labelInValue` since it's meaningless
 * - `getInputElement` only support `combobox` mode
 * - `onChange` return OptionData instead of ReactNode
 * - `filterOption` `onChange` `onSelect` accept OptionData instead of ReactNode
 * - `combobox` mode trigger `onChange` will get `undefined` if no `value` match in Option
 * - `combobox` mode not support `optionLabelProp`
 */










var Select_RefSelect = generateSelector({
  prefixCls: 'rc-select',
  components: {
    optionList: es_OptionList
  },
  convertChildrenToData: legacyUtil_convertChildrenToData,
  flattenOptions: valueUtil_flattenOptions,
  getLabeledValue: valueUtil_getLabeledValue,
  filterOptions: valueUtil_filterOptions,
  isValueDisabled: valueUtil_isValueDisabled,
  findValueOption: valueUtil_findValueOption,
  warningProps: warningPropsUtil,
  fillOptionsWithMissingValue: valueUtil_fillOptionsWithMissingValue
});
/**
 * Typescript not support generic with function component,
 * we have to wrap an class component to handle this.
 */

var Select_Select = /*#__PURE__*/function (_React$Component) {
  Select_inherits(Select, _React$Component);

  function Select() {
    var _this;

    Select_classCallCheck(this, Select);

    _this = Select_possibleConstructorReturn(this, Select_getPrototypeOf(Select).apply(this, arguments));
    _this.selectRef = react_default.a.createRef();

    _this.focus = function () {
      _this.selectRef.current.focus();
    };

    _this.blur = function () {
      _this.selectRef.current.blur();
    };

    return _this;
  }

  Select_createClass(Select, [{
    key: "render",
    value: function render() {
      return react_default.a.createElement(Select_RefSelect, Object.assign({
        ref: this.selectRef
      }, this.props));
    }
  }]);

  return Select;
}(react_default.a.Component);

Select_Select.Option = es_Option;
Select_Select.OptGroup = es_OptGroup;
/* harmony default export */ var es_Select = (Select_Select);
// CONCATENATED MODULE: ../node_modules/rc-select/es/index.js




/* harmony default export */ var rc_select_es = (es_Select);
// EXTERNAL MODULE: ../node_modules/@ant-design/icons/DownOutlined.js
var DownOutlined = __webpack_require__("87BP");
var DownOutlined_default = /*#__PURE__*/__webpack_require__.n(DownOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/CheckOutlined.js
var icons_CheckOutlined = __webpack_require__("MMYs");
var CheckOutlined_default = /*#__PURE__*/__webpack_require__.n(icons_CheckOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/CloseOutlined.js
var CloseOutlined = __webpack_require__("EWXb");
var CloseOutlined_default = /*#__PURE__*/__webpack_require__.n(CloseOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/SearchOutlined.js
var icons_SearchOutlined = __webpack_require__("jLVx");
var SearchOutlined_default = /*#__PURE__*/__webpack_require__.n(icons_SearchOutlined);

// CONCATENATED MODULE: ../node_modules/antd/es/select/utils/iconUtil.js







function getIcons(_ref) {
  var suffixIcon = _ref.suffixIcon,
      clearIcon = _ref.clearIcon,
      menuItemSelectedIcon = _ref.menuItemSelectedIcon,
      removeIcon = _ref.removeIcon,
      loading = _ref.loading,
      multiple = _ref.multiple; // Clear Icon

  var mergedClearIcon = clearIcon;

  if (!clearIcon) {
    mergedClearIcon = react_default.a.createElement(CloseCircleFilled_default.a, null);
  } // Arrow item icon


  var mergedSuffixIcon = null;

  if (suffixIcon !== undefined) {
    mergedSuffixIcon = suffixIcon;
  } else if (loading) {
    mergedSuffixIcon = react_default.a.createElement(LoadingOutlined_default.a, {
      spin: true
    });
  } else {
    mergedSuffixIcon = function mergedSuffixIcon(_ref2) {
      var open = _ref2.open,
          showSearch = _ref2.showSearch;

      if (open && showSearch) {
        return react_default.a.createElement(SearchOutlined_default.a, null);
      }

      return react_default.a.createElement(DownOutlined_default.a, null);
    };
  } // Checked item icon


  var mergedItemIcon = null;

  if (menuItemSelectedIcon !== undefined) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = react_default.a.createElement(CheckOutlined_default.a, null);
  } else {
    mergedItemIcon = null;
  }

  var mergedRemoveIcon = null;

  if (removeIcon !== undefined) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = react_default.a.createElement(CloseOutlined_default.a, null);
  }

  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/SizeContext.js
var SizeContext = __webpack_require__("hxuA");

// CONCATENATED MODULE: ../node_modules/antd/es/select/index.js







function select_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    select_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    select_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return select_typeof(obj);
}

function select_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function select_extends() {
  select_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return select_extends.apply(this, arguments);
}

function select_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function select_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function select_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) select_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) select_defineProperties(Constructor, staticProps);
  return Constructor;
}

function select_possibleConstructorReturn(self, call) {
  if (call && (select_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return select_assertThisInitialized(self);
}

function select_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function select_getPrototypeOf(o) {
  select_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return select_getPrototypeOf(o);
}

function select_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) select_setPrototypeOf(subClass, superClass);
}

function select_setPrototypeOf(o, p) {
  select_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return select_setPrototypeOf(o, p);
} // TODO: 4.0 - codemod should help to change `filterOption` to support node props.








 // We still use class here since `forwardRef` not support generic in typescript

var select_Select = /*#__PURE__*/function (_React$Component) {
  select_inherits(Select, _React$Component);

  function Select() {
    var _this;

    select_classCallCheck(this, Select);

    _this = select_possibleConstructorReturn(this, select_getPrototypeOf(Select).apply(this, arguments));
    _this.selectRef = react["createRef"]();

    _this.focus = function () {
      if (_this.selectRef.current) {
        _this.selectRef.current.focus();
      }
    };

    _this.blur = function () {
      if (_this.selectRef.current) {
        _this.selectRef.current.blur();
      }
    };

    _this.getMode = function () {
      var mode = _this.props.mode;

      if (mode === 'combobox') {
        return undefined;
      }

      if (mode === Select.SECRET_COMBOBOX_MODE_DO_NOT_USE) {
        return 'combobox';
      }

      return mode;
    };

    _this.renderSelect = function (_ref) {
      var getContextPopupContainer = _ref.getPopupContainer,
          getPrefixCls = _ref.getPrefixCls,
          renderEmpty = _ref.renderEmpty,
          direction = _ref.direction;
      var _this$props = _this.props,
          customizePrefixCls = _this$props.prefixCls,
          notFoundContent = _this$props.notFoundContent,
          className = _this$props.className,
          customizeSize = _this$props.size,
          _this$props$listHeigh = _this$props.listHeight,
          listHeight = _this$props$listHeigh === void 0 ? 256 : _this$props$listHeigh,
          _this$props$listItemH = _this$props.listItemHeight,
          listItemHeight = _this$props$listItemH === void 0 ? 32 : _this$props$listItemH,
          getPopupContainer = _this$props.getPopupContainer,
          dropdownClassName = _this$props.dropdownClassName,
          bordered = _this$props.bordered;
      var prefixCls = getPrefixCls('select', customizePrefixCls);

      var mode = _this.getMode();

      var isMultiple = mode === 'multiple' || mode === 'tags'; // ===================== Empty =====================

      var mergedNotFound;

      if (notFoundContent !== undefined) {
        mergedNotFound = notFoundContent;
      } else if (mode === 'combobox') {
        mergedNotFound = null;
      } else {
        mergedNotFound = renderEmpty('Select');
      } // ===================== Icons =====================


      var _getIcons = getIcons(select_extends(select_extends({}, _this.props), {
        multiple: isMultiple
      })),
          suffixIcon = _getIcons.suffixIcon,
          itemIcon = _getIcons.itemIcon,
          removeIcon = _getIcons.removeIcon,
          clearIcon = _getIcons.clearIcon;

      var selectProps = Object(omit_js_es["a" /* default */])(_this.props, ['prefixCls', 'suffixIcon', 'itemIcon', 'removeIcon', 'clearIcon', 'size', 'bordered']);
      var rcSelectRtlDropDownClassName = classnames_default()(dropdownClassName, select_defineProperty({}, "".concat(prefixCls, "-dropdown-").concat(direction), direction === 'rtl'));
      return react["createElement"](SizeContext["b" /* default */].Consumer, null, function (size) {
        var _classNames2;

        var mergedSize = customizeSize || size;
        var mergedClassName = classnames_default()(className, (_classNames2 = {}, select_defineProperty(_classNames2, "".concat(prefixCls, "-lg"), mergedSize === 'large'), select_defineProperty(_classNames2, "".concat(prefixCls, "-sm"), mergedSize === 'small'), select_defineProperty(_classNames2, "".concat(prefixCls, "-rtl"), direction === 'rtl'), select_defineProperty(_classNames2, "".concat(prefixCls, "-borderless"), !bordered), _classNames2));
        return react["createElement"](rc_select_es, select_extends({
          ref: _this.selectRef
        }, selectProps, {
          listHeight: listHeight,
          listItemHeight: listItemHeight,
          mode: mode,
          prefixCls: prefixCls,
          inputIcon: suffixIcon,
          menuItemSelectedIcon: itemIcon,
          removeIcon: removeIcon,
          clearIcon: clearIcon,
          notFoundContent: mergedNotFound,
          className: mergedClassName,
          getPopupContainer: getPopupContainer || getContextPopupContainer,
          dropdownClassName: rcSelectRtlDropDownClassName
        }));
      });
    };

    return _this;
  }

  select_createClass(Select, [{
    key: "render",
    value: function render() {
      return react["createElement"](context["a" /* ConfigConsumer */], null, this.renderSelect);
    }
  }]);

  return Select;
}(react["Component"]);

select_Select.Option = es_Option;
select_Select.OptGroup = es_OptGroup;
select_Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = 'SECRET_COMBOBOX_MODE_DO_NOT_USE';
select_Select.defaultProps = {
  transitionName: 'slide-up',
  choiceTransitionName: 'zoom',
  bordered: true
};
/* harmony default export */ var es_select = (select_Select);
// EXTERNAL MODULE: ../node_modules/react-use/esm/useMedia.js + 1 modules
var useMedia = __webpack_require__("K4Ra");

// CONCATENATED MODULE: ../node_modules/@ant-design/icons-svg/es/asn/MenuOutlined.js
// This icon file is generated automatically.
// tslint:disable
var MenuOutlined_MenuOutlined = {
  "name": "menu",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"
      }
    }]
  }
};
/* harmony default export */ var asn_MenuOutlined = (MenuOutlined_MenuOutlined);
// EXTERNAL MODULE: ../node_modules/@ant-design/icons/es/components/AntdIcon.js + 2 modules
var AntdIcon = __webpack_require__("uoK5");

// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/icons/MenuOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var icons_MenuOutlined_MenuOutlined = function MenuOutlined(props, ref) {
  return react_default.a.createElement(AntdIcon["a" /* default */], Object.assign({}, props, {
    ref: ref,
    icon: asn_MenuOutlined
  }));
};

icons_MenuOutlined_MenuOutlined.displayName = 'MenuOutlined';
/* harmony default export */ var icons_MenuOutlined = (react_default.a.forwardRef(icons_MenuOutlined_MenuOutlined));
// CONCATENATED MODULE: ../node_modules/@ant-design/icons-svg/es/asn/CheckOutlined.js
// This icon file is generated automatically.
// tslint:disable
var CheckOutlined_CheckOutlined = {
  "name": "check",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"
      }
    }]
  }
};
/* harmony default export */ var asn_CheckOutlined = (CheckOutlined_CheckOutlined);
// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/icons/CheckOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var icons_CheckOutlined_CheckOutlined = function CheckOutlined(props, ref) {
  return react_default.a.createElement(AntdIcon["a" /* default */], Object.assign({}, props, {
    ref: ref,
    icon: asn_CheckOutlined
  }));
};

icons_CheckOutlined_CheckOutlined.displayName = 'CheckOutlined';
/* harmony default export */ var es_icons_CheckOutlined = (react_default.a.forwardRef(icons_CheckOutlined_CheckOutlined));
// CONCATENATED MODULE: ../node_modules/@ant-design/icons-svg/es/asn/GithubOutlined.js
// This icon file is generated automatically.
// tslint:disable
var GithubOutlined_GithubOutlined = {
  "name": "github",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"
      }
    }]
  }
};
/* harmony default export */ var asn_GithubOutlined = (GithubOutlined_GithubOutlined);
// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/icons/GithubOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var icons_GithubOutlined_GithubOutlined = function GithubOutlined(props, ref) {
  return react_default.a.createElement(AntdIcon["a" /* default */], Object.assign({}, props, {
    ref: ref,
    icon: asn_GithubOutlined
  }));
};

icons_GithubOutlined_GithubOutlined.displayName = 'GithubOutlined';
/* harmony default export */ var icons_GithubOutlined = (react_default.a.forwardRef(icons_GithubOutlined_GithubOutlined));
// EXTERNAL MODULE: ../node_modules/git-url-parse/lib/index.js
var lib = __webpack_require__("XVYZ");
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.regexp.search.js
var es6_regexp_search = __webpack_require__("nsbO");

// CONCATENATED MODULE: ../node_modules/@ant-design/icons-svg/es/asn/SearchOutlined.js
// This icon file is generated automatically.
// tslint:disable
var SearchOutlined_SearchOutlined = {
  "name": "search",
  "theme": "outlined",
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"
      }
    }]
  }
};
/* harmony default export */ var asn_SearchOutlined = (SearchOutlined_SearchOutlined);
// CONCATENATED MODULE: ../node_modules/@ant-design/icons/es/icons/SearchOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var icons_SearchOutlined_SearchOutlined = function SearchOutlined(props, ref) {
  return react_default.a.createElement(AntdIcon["a" /* default */], Object.assign({}, props, {
    ref: ref,
    icon: asn_SearchOutlined
  }));
};

icons_SearchOutlined_SearchOutlined.displayName = 'SearchOutlined';
/* harmony default export */ var es_icons_SearchOutlined = (react_default.a.forwardRef(icons_SearchOutlined_SearchOutlined));
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/components/Search.module.less
var Search_module = __webpack_require__("Bytu");
var Search_module_default = /*#__PURE__*/__webpack_require__.n(Search_module);

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/Search.tsx







function initDocSearch(_ref) {
  var docsearch = _ref.docsearch,
      lang = _ref.lang,
      docsearchOptions = _ref.docsearchOptions;

  var _ref2 = docsearchOptions || {},
      _ref2$apiKey = _ref2.apiKey,
      apiKey = _ref2$apiKey === void 0 ? '194b1be7fb1254c787f4e036912af3eb' : _ref2$apiKey,
      _ref2$indexName = _ref2.indexName,
      indexName = _ref2$indexName === void 0 ? 'antv' : _ref2$indexName;

  docsearch({
    apiKey: apiKey,
    indexName: indexName,
    inputSelector: "." + Search_module_default.a.input,
    algoliaOptions: {
      facetFilters: ["tags:" + lang]
    },
    transformData: function transformData(hits) {
      hits.forEach(function (hit) {
        /* eslint-disable no-param-reassign */
        hit.url = hit.url.replace('g2.antv.vision', window.location.host);
        hit.url = hit.url.replace('g6.antv.vision', window.location.host);
        hit.url = hit.url.replace('f2.antv.vision', window.location.host);
        hit.url = hit.url.replace('l7.antv.vision', window.location.host);
        hit.url = hit.url.replace('g2plot.antv.vision', window.location.host);
        hit.url = hit.url.replace('graphin.antv.vision', window.location.host);
        hit.url = hit.url.replace('https:', window.location.protocol);
        hit.url = hit.url.replace('#gatsby-focus-wrapper', '');
        /* eslint-enable no-param-reassign */
      });
      return hits;
    },
    debug: false // Set debug to true if you want to inspect the dropdown

  });
}

var Search_Search = function Search(_ref3) {
  var docsearchOptions = _ref3.docsearchOptions;

  var _useTranslation = Object(es["b" /* useTranslation */])(),
      t = _useTranslation.t,
      i18n = _useTranslation.i18n;

  Object(react["useEffect"])(function () {
    if (typeof window !== 'undefined') {
      __webpack_require__.e(/* import() */ 13).then(__webpack_require__.t.bind(null, "ZrJC", 7)).then(function (_ref4) {
        var docsearch = _ref4.default;
        initDocSearch({
          docsearch: docsearch,
          lang: i18n.language,
          docsearchOptions: docsearchOptions
        });
      });
    }
  }, []);
  return react_default.a.createElement("label", {
    className: Search_module_default.a.search,
    htmlFor: "search"
  }, react_default.a.createElement(es_icons_SearchOutlined, {
    className: Search_module_default.a.icon
  }), react_default.a.createElement("input", {
    className: Search_module_default.a.input,
    id: "search",
    placeholder: t('搜索…')
  }));
};

/* harmony default export */ var components_Search = (Search_Search);
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/components/Product.module.less
var Product_module = __webpack_require__("j2P5");
var Product_module_default = /*#__PURE__*/__webpack_require__.n(Product_module);

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/Product.tsx







var getTarget = function getTarget(url) {
  return url.startsWith('http') && !url.includes('gitee.io') && !url.includes('antv.vision') ? '_blank' : '_self';
};

var Product_Product = function Product(_ref) {
  var name = _ref.name,
      icon = _ref.icon,
      _ref$url = _ref.url,
      url = _ref$url === void 0 ? '' : _ref$url,
      slogan = _ref.slogan,
      description = _ref.description,
      _ref$links = _ref.links,
      links = _ref$links === void 0 ? [] : _ref$links,
      style = _ref.style,
      language = _ref.language;
  return react_default.a.createElement("li", {
    className: Product_module_default.a.product,
    style: style
  }, react_default.a.createElement("a", {
    href: url,
    target: getTarget(url)
  }, react_default.a.createElement("img", {
    alt: name,
    src: icon
  })), react_default.a.createElement("div", {
    className: Product_module_default.a.productContent
  }, react_default.a.createElement("a", {
    href: url,
    target: getTarget(url)
  }, react_default.a.createElement("h4", null, name, react_default.a.createElement("span", {
    className: Product_module_default.a.productSlogan,
    style: {
      opacity: language === 'en' ? 0.7 : ''
    }
  }, slogan))), react_default.a.createElement("div", {
    className: Product_module_default.a.productDescription
  }, description), react_default.a.createElement("div", {
    className: Product_module_default.a.productLinks
  }, links.slice(0, 2).map(function (item) {
    return react_default.a.createElement("a", {
      href: item.url,
      target: getTarget(item.url || ''),
      key: item.url
    }, item.title);
  }))));
};

/* harmony default export */ var components_Product = (Product_Product);
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/utils.ts
var utils = __webpack_require__("oV81");

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/getProducts.tsx


var tuple = function tuple() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args;
};

var Categories = tuple('basic', 'extension', 'ecology');
var ANTV_DOMAIN = 'antv.vision';
var getProducts_getProducts = function getProducts(_ref) {
  var t = _ref.t,
      language = _ref.language,
      _ref$isChinaMirrorHos = _ref.isChinaMirrorHost,
      isChinaMirrorHost = _ref$isChinaMirrorHos === void 0 ? false : _ref$isChinaMirrorHos;
  var hosts = {};
  ['g2', 'g2plot', 'g6', 'l7', 'f2', 'graphin', 'g', 'x6', 'ava'].forEach(function (name) {
    hosts[name] = isChinaMirrorHost ? Object(utils["b" /* getChinaMirrorHost */])(name + "." + ANTV_DOMAIN) : name + "." + ANTV_DOMAIN;
  });
  var products = [
    /* {
       title: 'G2',
       icon:
         'https://gw.alipayobjects.com/zos/antfincdn/trEfLRh5pc/G2%252520keshihuatuxingyufa.svg',
       slogan: t('可视化引擎'),
       description: t('数据驱动，高度易用，可扩展的可视化图形语法。'),
       category: Categories[0],
       links: [
         {
           icon: <HomeOutlined />,
           title: t('产品首页'),
           url: `https://${hosts.g2}/${language}`,
         },
         {
           icon: <PieChartOutlined />,
           title: t('图表示例'),
           url: `https://${hosts.g2}/${language}/examples`,
         },
         {
           icon: <ReadOutlined />,
           title: t('使用文档'),
           url: `https://${hosts.g2}/${language}/docs/manual`,
         },
         {
           icon: <ReadOutlined />,
           title: t('API 文档'),
           url: `https://${hosts.g2}/${language}/docs/api`,
         },
         {
           icon: <HistoryOutlined />,
           title: t('更新日志'),
           url: `https://github.com/antvis/g2/blob/master/CHANGELOG.md`,
           openExternal: true,
         },
         {
           icon: <GithubOutlined />,
           title: t('GitHub 仓库'),
           url: `https://github.com/antvis/g2`,
           openExternal: true,
         },
         {
           icon: '🇨🇳',
           title: t('国内镜像'),
           url: `https://antv-g2.gitee.io`,
           openExternal: true,
         },
       ],
     },
     {
       title: 'G6',
       icon:
         'https://gw.alipayobjects.com/zos/antfincdn/zS1wZZJVcJ/G6%252520tukeshihuayinqing.svg',
       slogan: t('图可视化引擎'),
       description: t('便捷的关系数据可视化引擎与图分析工具。'),
       category: Categories[0],
       links: [
         {
           icon: <HomeOutlined />,
           title: t('产品首页'),
           url: `https://${hosts.g6}/${language}`,
         },
         {
           icon: <PieChartOutlined />,
           title: t('图表示例'),
           url: `https://${hosts.g6}/${language}/examples`,
         },
         {
           icon: <ReadOutlined />,
           title: t('使用文档'),
           url: `https://${hosts.g6}/${language}/docs/manual`,
         },
         {
           icon: <ReadOutlined />,
           title: t('API 文档'),
           url: `https://${hosts.g6}/${language}/docs/api/GlobalAPI`,
         },
         {
           icon: <HistoryOutlined />,
           title: t('更新日志'),
           url: `https://github.com/antvis/g6/blob/master/CHANGELOG.md`,
           openExternal: true,
         },
         {
           icon: <GithubOutlined />,
           title: t('GitHub 仓库'),
           url: `https://github.com/antvis/g6`,
           openExternal: true,
         },
         {
           icon: '🇨🇳',
           title: t('国内镜像'),
           url: `https://antv-g6.gitee.io`,
           openExternal: true,
         },
       ],
     },
     {
       title: 'F2',
       icon:
         'https://gw.alipayobjects.com/zos/antfincdn/D%26fDbWqVkv/F2%252520yidongduankeshihuafangan.svg',
       slogan: t('移动可视化方案'),
       description: t(
         '专注于移动端的可视化解决方案，兼容 H5/小程序/Weex 等多端环境',
       ),
       category: Categories[0],
       links: [
         {
           icon: <HomeOutlined />,
           title: t('产品首页'),
           url: `https://${hosts.f2}/${language}`,
         },
         {
           icon: <PieChartOutlined />,
           title: t('图表示例'),
           url: `https://${hosts.f2}/${language}/examples`,
         },
         {
           icon: <ReadOutlined />,
           title: t('使用文档'),
           url: `https://${hosts.f2}/${language}/docs/tutorial/getting-started`,
         },
         {
           icon: <ReadOutlined />,
           title: t('API 文档'),
           url: `https://${hosts.f2}/${language}/docs/api`,
         },
         {
           icon: <HistoryOutlined />,
           title: t('更新日志'),
           url: `https://github.com/antvis/f2/blob/master/CHANGELOG.md`,
           openExternal: true,
         },
         {
           icon: <GithubOutlined />,
           title: t('GitHub 仓库'),
           url: `https://github.com/antvis/f2`,
           openExternal: true,
         },
         {
           icon: '🇨🇳',
           title: t('国内镜像'),
           url: `https://antv-f2.gitee.io`,
           openExternal: true,
         },
       ],
     },
     {
       title: 'L7',
       icon:
         'https://gw.alipayobjects.com/zos/antfincdn/OI%26h7HXH33/L7%252520dilikongjianshujukeshihua.svg',
       slogan: t('地理空间数据可视化'),
       description: t('高性能/高渲染质量的地理空间数据可视化框架。'),
       category: Categories[0],
       links: [
         {
           icon: <HomeOutlined />,
           title: t('产品首页'),
           url: `https://${hosts.l7}/${language}`,
         },
         {
           icon: <PieChartOutlined />,
           title: t('图表示例'),
           url: `https://${hosts.l7}/${language}/examples`,
         },
         {
           icon: <ReadOutlined />,
           title: t('使用文档'),
           url: `https://${hosts.l7}/${language}/docs/tutorial`,
         },
         {
           icon: <ReadOutlined />,
           title: t('API 文档'),
           url: `https://${hosts.l7}/${language}/docs/API`,
         },
         {
           icon: <HistoryOutlined />,
           title: t('更新日志'),
           url: `https://github.com/antvis/L7/blob/master/CHANGELOG.md`,
           openExternal: true,
         },
         {
           icon: <GithubOutlined />,
           title: t('GitHub 仓库'),
           url: `https://github.com/antvis/L7`,
           openExternal: true,
         },
         {
           icon: '🇨🇳',
           title: t('国内镜像'),
           url: `https://antv-l7.gitee.io`,
           openExternal: true,
         },
       ],
     },
     {
       title: 'G2Plot',
       icon: 'https://gw.alipayobjects.com/zos/antfincdn/SlbIagEvT7/G2plot.svg',
       slogan: t('开箱即用的图表库'),
       description: t('开箱即用、易于配置、极致体验的通用图表库。'),
       category: Categories[1],
       links: [
         {
           icon: <HomeOutlined />,
           title: t('产品首页'),
           url: `https://${hosts.g2plot}/${language}`,
         },
         {
           icon: <PieChartOutlined />,
           title: t('图表示例'),
           url: `https://${hosts.g2plot}/${language}/examples`,
         },
         {
           icon: <ReadOutlined />,
           title: t('使用文档'),
           url: `https://${hosts.g2plot}/${language}/docs/manual`,
         },
         {
           icon: <HistoryOutlined />,
           title: t('更新日志'),
           url: `https://github.com/antvis/g2plot/blob/master/CHANGELOG.md`,
           openExternal: true,
         },
         {
           icon: <GithubOutlined />,
           title: t('GitHub 仓库'),
           url: `https://github.com/antvis/g2plot`,
           openExternal: true,
         },
         {
           icon: '🇨🇳',
           title: t('国内镜像'),
           url: `https://antv-g2plot.gitee.io`,
           openExternal: true,
         },
       ],
     },
     {
       title: 'Graphin',
       icon: 'https://gw.alipayobjects.com/zos/antfincdn/0b4HzOcEJY/Graphin.svg',
       slogan: t(''),
       description: t('基于 G6 封装的图分析应用组件。'),
       category: Categories[1],
       links: [
         {
           icon: <HomeOutlined />,
           title: t('产品首页'),
           url: `https://${hosts.graphin}/${language}`,
         },
         {
           icon: <ReadOutlined />,
           title: t('使用文档'),
           url: `https://${hosts.graphin}/${language}/docs/manual/introduction`,
         },
         {
           icon: <ReadOutlined />,
           title: t('API 文档'),
           url: `https://${hosts.graphin}/${language}/docs/api/graphin`,
         },
         {
           icon: <HistoryOutlined />,
           title: t('更新日志'),
           url: `https://github.com/antvis/graphin/blob/master/CHANGELOG.md`,
           openExternal: true,
         },
         {
           icon: <GithubOutlined />,
           title: t('GitHub 仓库'),
           url: `https://github.com/antvis/graphin`,
           openExternal: true,
         },
         {
           icon: '🇨🇳',
           title: t('国内镜像'),
           url: `https://antv-graphin.gitee.io`,
           openExternal: true,
         },
       ],
     },
     {
       title: 'ChartCube',
       icon:
         'https://gw.alipayobjects.com/zos/antfincdn/Zr74jx8YNX/chartcube.svg',
       slogan: t('图表魔方'),
       description: t('AntV 在线图表制作利器。'),
       category: Categories[1],
       links: [
         {
           icon: <HomeOutlined />,
           title: t('产品首页'),
           url: `https://chartcube.alipay.com`,
           openExternal: true,
         },
         {
           icon: <AreaChartOutlined />,
           title: t('生成图表'),
           url: `https://chartcube.alipay.com/guide`,
           openExternal: true,
         },
         {
           icon: <YuqueOutlined />,
           title: t('语雀社区'),
           url: `https://www.yuque.com/chartcube`,
           openExternal: true,
         },
         {
           icon: <DingdingOutlined />,
           title: t('钉钉服务群'),
           url: `dingtalk://dingtalkclient/action/joingroup?cid=8305538734`,
           openExternal: true,
         },
       ],
     },
     {
       title: t('墨者学院'),
       icon:
         'https://gw.alipayobjects.com/zos/antfincdn/12j36RPVldO/mozhexueyuan.svg',
       description: t('数据可视化社团'),
       category: Categories[2],
       links: [
         {
           title: t('学院首页'),
           url: `https://www.yuque.com/mo-college`,
           openExternal: true,
         },
       ],
     },
     {
       title: 'BizCharts',
       icon:
         'https://gw.alipayobjects.com/zos/antfincdn/Q1pbg%26O2TM/BizCharts.svg',
       description: t('基于商业场景下的数据可视化解决方案'),
       category: Categories[2],
       links: [
         {
           title: t('产品首页'),
           url: 'https://bizcharts.net',
           openExternal: true,
         },
       ],
     },
     {
       title: 'Viser',
       icon: 'https://gw.alipayobjects.com/zos/antfincdn/QAyW5h99HVa/Viser.svg',
       description: t('基于 G2 实现的可视化解决方案'),
       category: Categories[2],
       links: [
         {
           title: t('产品首页'),
           url: `https://viserjs.github.io/`,
           openExternal: true,
         },
       ],
     },
    */
  ];
  return products;
};
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/hooks.ts
var hooks = __webpack_require__("b0rI");

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/Products.tsx








var Products_Products = function Products(_ref) {
  var _classNames;

  var show = _ref.show,
      _ref$rootDomain = _ref.rootDomain,
      rootDomain = _ref$rootDomain === void 0 ? '' : _ref$rootDomain,
      language = _ref.language,
      className = _ref.className;

  var _useTranslation = Object(es["b" /* useTranslation */])(),
      t = _useTranslation.t,
      i18n = _useTranslation.i18n;

  var _useChinaMirrorHost = Object(hooks["a" /* useChinaMirrorHost */])(),
      isChinaMirrorHost = _useChinaMirrorHost[0];

  var data = getProducts_getProducts({
    t: t,
    language: language || i18n.language,
    rootDomain: rootDomain,
    isChinaMirrorHost: isChinaMirrorHost
  });
  return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("div", {
    className: classnames_default()(Product_module_default.a.products, className, (_classNames = {}, _classNames[Product_module_default.a.show] = !!show, _classNames))
  }, react_default.a.createElement("div", {
    className: Product_module_default.a.container
  }, react_default.a.createElement("h3", null, t('基础产品')), react_default.a.createElement("ul", null, data.filter(function (item) {
    return item.category === 'basic';
  }).map(function (product) {
    return react_default.a.createElement(components_Product, {
      key: product.title,
      name: product.title,
      slogan: product.slogan || '',
      description: product.description,
      url: (product.links || [])[0].url,
      icon: product.icon,
      links: product.links,
      language: language || i18n.language
    });
  })), react_default.a.createElement("h3", null, t('拓展产品')), react_default.a.createElement("ul", null, data.filter(function (item) {
    return item.category === 'extension';
  }).map(function (product) {
    return react_default.a.createElement(components_Product, {
      key: product.title,
      name: product.title,
      slogan: product.slogan || '',
      description: product.description,
      url: (product.links || [])[0].url,
      icon: product.icon,
      links: product.links,
      language: language || i18n.language
    });
  })), react_default.a.createElement("h3", null, t('周边生态')), react_default.a.createElement("ul", null, data.filter(function (item) {
    return item.category === 'ecology';
  }).map(function (product) {
    return react_default.a.createElement(components_Product, {
      key: product.title,
      name: product.title,
      slogan: product.slogan || '',
      description: product.description,
      url: (product.links || [])[0].url,
      icon: product.icon,
      language: language || i18n.language
    });
  })))), react_default.a.createElement("div", {
    className: Product_module_default.a.mask
  }));
};

/* harmony default export */ var components_Products = (Products_Products);
// EXTERNAL MODULE: ../node_modules/shallowequal/index.js
var shallowequal = __webpack_require__("F56x");
var shallowequal_default = /*#__PURE__*/__webpack_require__.n(shallowequal);

// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/components/Header.module.less
var Header_module = __webpack_require__("aaoD");
var Header_module_default = /*#__PURE__*/__webpack_require__.n(Header_module);

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/NavMenuItems.tsx










var getDocument = function getDocument(navs, slug) {
  if (slug === void 0) {
    slug = '';
  }

  return navs.find(function (doc) {
    return doc.slug === slug;
  }) || {
    title: {}
  };
};

var NavMenuItems_capitalize = function capitalize(s) {
  if (typeof s !== 'string') {
    return '';
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
};

var NavMenuItems_NavMenuItems = function NavMenuItems(_ref) {
  var _ref$navs = _ref.navs,
      navs = _ref$navs === void 0 ? [] : _ref$navs,
      path = _ref.path;

  var _useTranslation = Object(es["b" /* useTranslation */])(),
      i18n = _useTranslation.i18n;

  return react_default.a.createElement(react_default.a.Fragment, null, navs.map(function (nav) {
    var _classNames;

    var href = "/" + i18n.language + "/" + nav.slug;
    var title = NavMenuItems_capitalize(getDocument(navs, nav.slug).title[i18n.language]);
    var className = classnames_default()('header-menu-item-active', (_classNames = {}, _classNames[Header_module_default.a.activeItem] = path.startsWith(href) || shallowequal_default()(path.split('/').slice(0, 4), href.split('/').slice(0, 4)), _classNames));
    return react_default.a.createElement("li", {
      key: title,
      className: className
    }, nav.target === '_blank' ? react_default.a.createElement("a", {
      href: href,
      target: "_blank",
      rel: "noopener noreferrer"
    }, title) : react_default.a.createElement(gatsby_browser_entry["Link"], {
      to: href
    }, title));
  }));
};

/* harmony default export */ var components_NavMenuItems = (NavMenuItems_NavMenuItems);
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/images/antv.svg
var antv = __webpack_require__("xJ2c");
var antv_default = /*#__PURE__*/__webpack_require__.n(antv);

// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/images/translation.svg
var translation = __webpack_require__("BYsm");
var translation_default = /*#__PURE__*/__webpack_require__.n(translation);

// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/images/external-link.svg
var external_link = __webpack_require__("sZHf");
var external_link_default = /*#__PURE__*/__webpack_require__.n(external_link);

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/Header.tsx



























/* eslint jsx-a11y/anchor-is-valid: 0 */
















var Header_Option = es_select.Option;
var Header_redirectToChinaMirror = function redirectToChinaMirror(githubUrl) {
  var chinaMirrorHost = Object(utils["b" /* getChinaMirrorHost */])();

  if (chinaMirrorHost !== window.location.host) {
    window.location.href = window.location.href.replace(window.location.host, chinaMirrorHost);
    return;
  }

  var _GitUrlParse = lib_default()(githubUrl),
      name = _GitUrlParse.name;

  if (!name.includes('.') && !name.includes('-')) {
    window.location.href = window.location.href.replace(window.location.host, "antv-" + name + ".gitee.io");
    return;
  }

  message.info('镜像本地调试暂时无法跳转。');
};

var Header_Header = function Header(_ref) {
  var _classNames, _classNames2, _classNames3, _React$createElement;

  var _ref$subTitle = _ref.subTitle,
      subTitle = _ref$subTitle === void 0 ? '' : _ref$subTitle,
      subTitleHref = _ref.subTitleHref,
      _ref$pathPrefix = _ref.pathPrefix,
      pathPrefix = _ref$pathPrefix === void 0 ? '' : _ref$pathPrefix,
      _ref$path = _ref.path,
      path = _ref$path === void 0 ? '' : _ref$path,
      _ref$navs = _ref.navs,
      navs = _ref$navs === void 0 ? [] : _ref$navs,
      _ref$showSearch = _ref.showSearch,
      showSearch = _ref$showSearch === void 0 ? false : _ref$showSearch,
      _ref$showGithubCorner = _ref.showGithubCorner,
      showGithubCorner = _ref$showGithubCorner === void 0 ? false : _ref$showGithubCorner,
      _ref$showAntVProducts = _ref.showAntVProductsCard,
      showAntVProductsCard = _ref$showAntVProducts === void 0 ? false : _ref$showAntVProducts,
      _ref$showLanguageSwit = _ref.showLanguageSwitcher,
      showLanguageSwitcher = _ref$showLanguageSwit === void 0 ? false : _ref$showLanguageSwit,
      _ref$showChinaMirror = _ref.showChinaMirror,
      showChinaMirror = _ref$showChinaMirror === void 0 ? false : _ref$showChinaMirror,
      logo = _ref.logo,
      onLanguageChange = _ref.onLanguageChange,
      siteUrl = _ref.siteUrl,
      _ref$githubUrl = _ref.githubUrl,
      githubUrl = _ref$githubUrl === void 0 ? 'https://github.com/antvis' : _ref$githubUrl,
      defaultLanguage = _ref.defaultLanguage,
      _ref$Link = _ref.Link,
      Link = _ref$Link === void 0 ? 'a' : _ref$Link,
      transparent = _ref.transparent,
      isHomePage = _ref.isHomePage,
      _ref$rootDomain = _ref.rootDomain,
      rootDomain = _ref$rootDomain === void 0 ? '' : _ref$rootDomain,
      docsearchOptions = _ref.docsearchOptions,
      versions = _ref.versions;

  var _useTranslation = Object(es["b" /* useTranslation */])(),
      t = _useTranslation.t,
      i18n = _useTranslation.i18n;

  var lang = typeof defaultLanguage !== 'undefined' ? defaultLanguage : i18n.language || '';
  var SubTitleLink = (subTitleHref || '').startsWith('http') ? 'a' : Link;

  var _useState = Object(react["useState"])(false),
      productMenuVisible = _useState[0],
      setProductMenuVisible = _useState[1];

  var productMenuHovering = false;

  var onProductMouseEnter = function onProductMouseEnter(e) {
    productMenuHovering = true;
    e.persist();
    setTimeout(function () {
      if (e.target instanceof Element && e.target.matches(':hover')) {
        setProductMenuVisible(true);
      }
    }, 200);
  };

  var onProductMouseLeave = function onProductMouseLeave(e) {
    e.persist();
    productMenuHovering = false;
    setTimeout(function () {
      if (productMenuHovering) {
        return;
      }

      setProductMenuVisible(false);
    }, 200);
  };

  var onToggleProductMenuVisible = function onToggleProductMenuVisible() {
    setProductMenuVisible(!productMenuVisible);
  };

  var _useState2 = Object(react["useState"])(false),
      popupMenuVisible = _useState2[0],
      setPopupMenuVisible = _useState2[1];

  var onTogglePopupMenuVisible = function onTogglePopupMenuVisible() {
    setPopupMenuVisible(!popupMenuVisible);
  };

  var _img$link$logo = Object.assign({
    img: react_default.a.createElement(antv_default.a, null),
    link: ''
  }, logo),
      img = _img$link$logo.img,
      link = _img$link$logo.link;

  Object(react["useEffect"])(function () {
    if (popupMenuVisible) {
      setPopupMenuVisible(false);
    }
  }, [path]); // 移动端下弹出菜单时，禁止页面滚动

  Object(react["useEffect"])(function () {
    if (popupMenuVisible) {
      document.documentElement.style.overflow = 'hidden';
    } else {
      document.documentElement.style.overflow = '';
    }

    return function () {
      document.documentElement.style.overflow = '';
    };
  }, [popupMenuVisible]);
  var isWide = Object(useMedia["a" /* default */])('(min-width: 767.99px)', true);
  var menuIcon = !isWide ? react_default.a.createElement(icons_MenuOutlined, {
    className: Header_module_default.a.menuIcon,
    onClick: onTogglePopupMenuVisible
  }) : null;
  var productItemProps = isWide ? {
    onMouseEnter: onProductMouseEnter,
    onMouseLeave: onProductMouseLeave
  } : {
    onClick: onToggleProductMenuVisible
  };

  var _GitUrlParse2 = lib_default()(githubUrl),
      name = _GitUrlParse2.name;

  var chinaMirrorUrl = name ? "https://antv-" + name + ".gitee.io" : '';

  var _useLogoLink = Object(hooks["b" /* useLogoLink */])({
    siteUrl: siteUrl,
    lang: lang,
    link: link
  }),
      logoLink = _useLogoLink[0];

  var _useState3 = Object(react["useState"])(false),
      chinaMirrorHintVisible = _useState3[0],
      updateChinaMirrorHintVisible = _useState3[1];

  Object(react["useEffect"])(function () {
    var timeout = setTimeout(function () {
      if (lang !== 'zh' || window.location.host.includes('chartcube') || window.location.host.includes('gitee.io') || localStorage.getItem('china-mirror-no-more-hint') || !isWide) {
        return;
      }

      updateChinaMirrorHintVisible(true);
    }, 5000);
    return function () {
      clearTimeout(timeout);
    };
  });
  var menu = react_default.a.createElement("ul", {
    className: classnames_default()(Header_module_default.a.menu, (_classNames = {}, _classNames[Header_module_default.a.popup] = !isWide, _classNames[Header_module_default.a.popupHidden] = !popupMenuVisible, _classNames))
  }, navs && navs.length ? react_default.a.createElement(components_NavMenuItems, {
    navs: navs,
    path: path
  }) : null, showChinaMirror ? react_default.a.createElement(popover_Popover, {
    title: null,
    content: react_default.a.createElement("div", {
      style: {
        width: 300
      }
    }, react_default.a.createElement("div", null, react_default.a.createElement("span", {
      role: "img",
      "aria-labelledby": "\u4E2D\u56FD"
    }, "\uD83C\uDDE8\uD83C\uDDF3"), ' ', "AntV \u7CFB\u5217\u7F51\u7AD9\u90E8\u7F72\u5728 gh-pages \u4E0A\uFF0C\u82E5\u8BBF\u95EE\u901F\u5EA6\u4E0D\u4F73\uFF0C\u53EF\u4EE5\u524D\u5F80\u56FD\u5185\u955C\u50CF\u7AD9\u70B9\u3002"), react_default.a.createElement("div", {
      style: {
        marginTop: 16,
        textAlign: 'right'
      }
    }, react_default.a.createElement(es_button["a" /* default */], {
      onClick: function onClick() {
        return updateChinaMirrorHintVisible(false);
      },
      size: "small",
      style: {
        marginRight: 8
      }
    }, "\u6682\u65F6\u5173\u95ED"), react_default.a.createElement(es_button["a" /* default */], {
      type: "primary",
      size: "small",
      onClick: function onClick() {
        localStorage.setItem('china-mirror-no-more-hint', Date.now().toString());
        updateChinaMirrorHintVisible(false);
      }
    }, "\u4E0D\u518D\u63D0\u9192"))),
    visible: chinaMirrorHintVisible,
    placement: "bottomRight",
    align: {
      offset: [-12, -16]
    }
  }, react_default.a.createElement("li", {
    style: {
      display: logoLink.includes('gitee') ? 'none' : ''
    }
  }, react_default.a.createElement("a", {
    href: chinaMirrorUrl,
    onClick: function onClick(e) {
      e.preventDefault();
      Header_redirectToChinaMirror(githubUrl);
    }
  }, t('国内镜像'), react_default.a.createElement("i", {
    className: Header_module_default.a.export
  }, react_default.a.createElement(external_link_default.a, null))))) : null, showAntVProductsCard ? react_default.a.createElement("li", productItemProps, react_default.a.createElement("a", null, t('所有产品'), react_default.a.createElement("img", {
    src: "https://gw.alipayobjects.com/zos/antfincdn/FLrTNDvlna/antv.png",
    alt: "antv logo arrow",
    className: classnames_default()(Header_module_default.a.arrow, (_classNames2 = {}, _classNames2[Header_module_default.a.open] = productMenuVisible, _classNames2))
  })), react_default.a.createElement(components_Products, {
    className: Header_module_default.a.productsMenu,
    show: productMenuVisible,
    rootDomain: rootDomain,
    language: defaultLanguage
  })) : null, versions ? react_default.a.createElement("li", null, react_default.a.createElement(es_select, {
    defaultValue: Object.keys(versions)[0],
    className: Header_module_default.a.versions,
    bordered: false,
    size: "small",
    onChange: function onChange(value) {
      window.location.href = value;
    }
  }, Object.keys(versions).map(function (version) {
    var url = versions[version];

    if (url.startsWith('http')) {
      return react_default.a.createElement(Header_Option, {
        key: url,
        value: url
      }, version);
    }

    return null;
  }))) : null, showLanguageSwitcher && react_default.a.createElement("li", null, react_default.a.createElement(dropdown, {
    placement: "bottomRight",
    overlay: react_default.a.createElement(es_menu["a" /* default */], {
      defaultSelectedKeys: [lang],
      selectable: true,
      onSelect: function onSelect(_ref2) {
        var key = _ref2.key;

        if (key === lang) {
          return;
        }

        if (onLanguageChange) {
          onLanguageChange(key);
          return;
        }

        if (path.endsWith("/" + lang)) {
          Object(gatsby_browser_entry["navigate"])("/" + key);
          return;
        }

        Object(gatsby_browser_entry["navigate"])(path.replace(pathPrefix, '').replace("/" + lang + "/", "/" + key + "/"));
      }
    }, react_default.a.createElement(es_menu["a" /* default */].Item, {
      key: "en"
    }, react_default.a.createElement(es_icons_CheckOutlined, {
      style: {
        visibility: lang === 'en' ? 'visible' : 'hidden',
        color: '#52c41a'
      }
    }), "English"), react_default.a.createElement(es_menu["a" /* default */].Item, {
      key: "zh"
    }, react_default.a.createElement(es_icons_CheckOutlined, {
      style: {
        visibility: lang === 'zh' ? 'visible' : 'hidden',
        color: '#52c41a'
      }
    }), "\u7B80\u4F53\u4E2D\u6587")),
    className: Header_module_default.a.translation
  }, react_default.a.createElement(translation_default.a, null))), showGithubCorner && react_default.a.createElement("li", {
    className: Header_module_default.a.githubCorner
  }, react_default.a.createElement("a", {
    href: githubUrl,
    target: "_blank",
    rel: "noopener noreferrer"
  }, react_default.a.createElement(icons_GithubOutlined, null))));
  return react_default.a.createElement("header", {
    className: classnames_default()(Header_module_default.a.header, (_classNames3 = {}, _classNames3[Header_module_default.a.transparent] = !!transparent && !productMenuVisible, _classNames3[Header_module_default.a.isHomePage] = !!isHomePage, _classNames3[Header_module_default.a.fixed] = popupMenuVisible, _classNames3))
  }, react_default.a.createElement("div", {
    className: Header_module_default.a.container
  }, react_default.a.createElement("div", {
    className: Header_module_default.a.left
  }, react_default.a.createElement("h1", null, react_default.a.createElement("a", {
    href: logoLink
  }, img)), subTitle && react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("span", {
    className: Header_module_default.a.divider
  }), react_default.a.createElement("h2", {
    className: Header_module_default.a.subProduceName
  }, react_default.a.createElement(SubTitleLink, (_React$createElement = {}, _React$createElement[SubTitleLink === 'a' ? 'href' : 'to'] = typeof subTitleHref === 'undefined' ? "/" + lang : subTitleHref, _React$createElement), subTitle))), showSearch && react_default.a.createElement(components_Search, {
    docsearchOptions: docsearchOptions
  })), react_default.a.createElement("nav", {
    className: Header_module_default.a.nav
  }, menu, menuIcon)));
};

/* harmony default export */ var components_Header = (Header_Header);
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/components/PageLoading.tsx + 2 modules
var PageLoading = __webpack_require__("NYms");

// EXTERNAL MODULE: ../node_modules/rc-footer/es/index.js
var rc_footer_es = __webpack_require__("Wpb7");
var es_default = /*#__PURE__*/__webpack_require__.n(rc_footer_es);

// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/components/Footer.module.less
var Footer_module = __webpack_require__("7KvB");
var Footer_module_default = /*#__PURE__*/__webpack_require__.n(Footer_module);

// EXTERNAL MODULE: ../node_modules/rc-footer/assets/index.less
var assets = __webpack_require__("MKzE");

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/components/Footer.tsx







var OLD_SITE_DOMAIN = 'https://antv-2018.alipay.com';

var Footer_Footer = function Footer(_ref) {
  var columns = _ref.columns,
      bottom = _ref.bottom,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? 'dark' : _ref$theme,
      language = _ref.language,
      _ref$rootDomain = _ref.rootDomain,
      rootDomain = _ref$rootDomain === void 0 ? '' : _ref$rootDomain;

  var _useTranslation = Object(es["b" /* useTranslation */])(),
      t = _useTranslation.t,
      i18n = _useTranslation.i18n;

  var lang = language || i18n.language;

  var _useChinaMirrorHost = Object(hooks["a" /* useChinaMirrorHost */])(),
      isChinaMirrorHost = _useChinaMirrorHost[0];

  var products = getProducts_getProducts({
    t: t,
    language: lang,
    rootDomain: rootDomain,
    isChinaMirrorHost: isChinaMirrorHost
  });
  var more = {
    icon: react_default.a.createElement("img", {
      src: "https://gw.alipayobjects.com/zos/rmsportal/nBVXkrFdWHxbZlmMbsaH.svg",
      alt: "more products"
    }),
    title: t('更多产品'),
    items: [{
      icon: react_default.a.createElement("img", {
        src: "https://gw.alipayobjects.com/zos/rmsportal/KDpgvguMpGfqaHPjicRK.svg",
        alt: "Ant Design"
      }),
      title: 'Ant Design',
      url: 'https://ant.design',
      description: t('企业级 UI 设计语言'),
      openExternal: true
    }, {
      icon: react_default.a.createElement("img", {
        src: "https://gw.alipayobjects.com/zos/rmsportal/XuVpGqBFxXplzvLjJBZB.svg",
        alt: "yuque"
      }),
      title: t('语雀'),
      url: 'https://yuque.com',
      description: t('知识创作与分享工具'),
      openExternal: true
    }, {
      icon: react_default.a.createElement("img", {
        src: "https://gw.alipayobjects.com/zos/antfincdn/sAEs8aHCnd/yunfengdie.png",
        alt: "yunfengdie"
      }),
      title: t('云凤蝶'),
      url: 'https://yunfengdie.com',
      description: t('中台建站平台'),
      openExternal: true
    }, {
      icon: react_default.a.createElement("img", {
        src: "https://gw.alipayobjects.com/zos/antfincdn/v2%24rh7lqpu/82f338dd-b0a6-41bc-9a86-58aaa9df217b.png",
        alt: "Egg"
      }),
      title: 'Egg',
      url: 'https://eggjs.org',
      description: t('企业级 Node 开发框架'),
      openExternal: true
    }, {
      icon: react_default.a.createElement("img", {
        src: "https://gw.alipayobjects.com/zos/rmsportal/DMDOlAUhmktLyEODCMBR.ico",
        alt: "kitchen"
      }),
      title: 'Kitchen',
      description: t('Sketch 工具集'),
      url: 'https://kitchen.alipay.com',
      openExternal: true
    }, {
      icon: react_default.a.createElement("img", {
        src: "https://gw.alipayobjects.com/zos/rmsportal/nBVXkrFdWHxbZlmMbsaH.svg",
        alt: "xtech"
      }),
      title: t('蚂蚁体验科技'),
      url: 'https://xtech.antfin.com/',
      openExternal: true
    }]
  };
  var defaultColumns = products.filter(function (product) {
    return product.category !== 'ecology';
  }).map(function (product) {
    return {
      title: react_default.a.createElement("span", null, product.title, react_default.a.createElement("span", {
        className: Footer_module_default.a.description
      }, product.slogan)),
      items: product.links
    };
  });
  return react_default.a.createElement(es_default.a, {
    maxColumnsPerRow: 4,
    theme: theme,
    columns: columns || defaultColumns,
    className: Footer_module_default.a.footer,
    bottom: bottom || react_default.a.createElement("div", {
      className: Footer_module_default.a.bottom
    }, react_default.a.createElement("div", null, "\xA9 ", new Date().getFullYear(), " \u2764 UCan  \u2764", ' '))
  });
};

/* harmony default export */ var components_Footer = (Footer_Footer);
// EXTERNAL MODULE: ../@antv/gatsby-theme-antv/site/layouts/layout.module.less
var layout_module = __webpack_require__("hedj");
var layout_module_default = /*#__PURE__*/__webpack_require__.n(layout_module);

// CONCATENATED MODULE: ../@antv/gatsby-theme-antv/site/layouts/layout.tsx

















esm_i18next.use(es["a" /* initReactI18next */]) // passes i18n down to react-i18next
.init({
  initImmediate: false,
  fallbackLng: 'zh',
  keySeparator: false,
  react: {
    useSuspense: false
  }
});
var layout_lngs = ['zh', 'en'];

function parseNulltoUndefined(value) {
  if (value === null) {
    return undefined;
  }

  return value;
}

var layout_Layout = function Layout(_ref) {
  var children = _ref.children,
      location = _ref.location;

  // https://github.com/gatsbyjs/gatsby/issues/13867#issuecomment-489481343
  if (location.pathname.includes('offline-plugin-app-shell-fallback')) {
    return react_default.a.createElement(PageLoading["a" /* default */], null);
  }

  var query = "1099894806";
  var _staticQueryData$data = _1099894806.data,
      site = _staticQueryData$data.site,
      locales = _staticQueryData$data.locales;
  var _site$siteMetadata = site.siteMetadata,
      title = _site$siteMetadata.title,
      _site$siteMetadata$na = _site$siteMetadata.navs,
      navs = _site$siteMetadata$na === void 0 ? [] : _site$siteMetadata$na,
      githubUrl = _site$siteMetadata.githubUrl,
      siteUrl = _site$siteMetadata.siteUrl,
      _site$siteMetadata$lo = _site$siteMetadata.logoUrl,
      logoUrl = _site$siteMetadata$lo === void 0 ? '' : _site$siteMetadata$lo,
      showLanguageSwitcher = _site$siteMetadata.showLanguageSwitcher,
      showSearch = _site$siteMetadata.showSearch,
      showChinaMirror = _site$siteMetadata.showChinaMirror,
      showGithubCorner = _site$siteMetadata.showGithubCorner,
      showAntVProductsCard = _site$siteMetadata.showAntVProductsCard,
      _site$siteMetadata$re = _site$siteMetadata.redirects,
      redirects = _site$siteMetadata$re === void 0 ? [] : _site$siteMetadata$re,
      docsearchOptions = _site$siteMetadata.docsearchOptions,
      versions = _site$siteMetadata.versions;
  var resources = {};

  try {
    resources = JSON.parse(locales.internal.content);
  } catch (e) {// empty
  }

  var pathPrefix = Object(gatsby_browser_entry["withPrefix"])('/').replace(/\/$/, '');
  var path = location.pathname.replace(pathPrefix, '');
  var currentLangKey = Object(dist["getCurrentLangKey"])(layout_lngs, 'zh', path);
  var isHomePage = path === '/' || path === "/" + currentLangKey || path === "/" + currentLangKey + "/";
  esm_i18next.init({
    lng: currentLangKey
  });

  if (!esm_i18next.options.resources) {
    esm_i18next.init({
      resources: resources
    });
  }

  if (location.pathname === pathPrefix || children && children.type && children.type.noLayout) {
    return children;
  }

  var getRediectUrl = function getRediectUrl() {
    var list = redirects || [];

    for (var i = 0; i < list.length; i += 1) {
      var _ref2 = list[i],
          _ref2$from = _ref2.from,
          from = _ref2$from === void 0 ? '' : _ref2$from,
          to = _ref2.to,
          keepUrl = _ref2.keepUrl; // 支持字符串和正则表达式比较

      if (location.pathname !== from && !new RegExp(from).test(location.pathname)) {
        return;
      }

      if (keepUrl && new RegExp(from).test(location.pathname)) {
        return location.pathname.replace(new RegExp(from), to);
      } // 如果没有指定 to，则直接用替换成老版本的域名


      return to || "" + OLD_SITE_DOMAIN + location.pathname;
    }
  };

  var rediectUrl = getRediectUrl();
  var logoProps = logoUrl ? {
    logo: {
      img: react_default.a.createElement("img", {
        src: logoUrl,
        alt: "logo"
      })
    }
  } : {};
  return react_default.a.createElement(react_default.a.Fragment, null, rediectUrl && react_default.a.createElement(Helmet_default.a, null, react_default.a.createElement("meta", {
    httpEquiv: "refresh",
    content: "0;url=" + rediectUrl
  })), react_default.a.createElement(Seo["a" /* default */], {
    title: siteUrl === 'https://antv.vision' ? '' : title,
    lang: esm_i18next.language
  }), react_default.a.createElement(components_Header, Object.assign({
    subTitle: siteUrl === 'https://antv.vision' ? '' : title,
    path: path,
    pathPrefix: pathPrefix,
    navs: navs,
    siteUrl: siteUrl,
    githubUrl: githubUrl,
    Link: gatsby_browser_entry["Link"],
    transparent: isHomePage,
    isHomePage: isHomePage,
    showSearch: parseNulltoUndefined(showSearch),
    showGithubCorner: parseNulltoUndefined(showGithubCorner),
    showAntVProductsCard: parseNulltoUndefined(showAntVProductsCard),
    showChinaMirror: parseNulltoUndefined(showChinaMirror),
    showLanguageSwitcher: parseNulltoUndefined(showLanguageSwitcher),
    docsearchOptions: docsearchOptions,
    versions: versions
  }, logoProps)), react_default.a.createElement("main", {
    className: layout_module_default.a.main
  }, children), react_default.a.createElement(components_Footer, {
    githubUrl: githubUrl,
    rootDomain: "https://antv.vision"
  }));
};

/* harmony default export */ var layout = __webpack_exports__["default"] = (layout_Layout);

/***/ }),

/***/ "vXgj":
/***/ (function(module, exports, __webpack_require__) {

var _isArray = __webpack_require__("GwS+");
/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */


module.exports = function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;

    if (length === 0) {
      return fn();
    }

    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
};

/***/ }),

/***/ "vXvS":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findDOMNode; });
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("xARA");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Return if a node is a DOM node. Else will return by `findDOMNode`
 */

function findDOMNode(node) {
  if (node instanceof HTMLElement) {
    return node;
  }

  return react_dom__WEBPACK_IMPORTED_MODULE_0___default.a.findDOMNode(node);
}

/***/ }),

/***/ "vbmX":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("5hJT");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _CloseOutlined = _interopRequireDefault(__webpack_require__("Hb9A"));

var _AntdIcon = _interopRequireDefault(__webpack_require__("CxZ5"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY


var CloseOutlined = function CloseOutlined(props, ref) {
  return _react["default"].createElement(_AntdIcon["default"], Object.assign({}, props, {
    ref: ref,
    icon: _CloseOutlined["default"]
  }));
};

CloseOutlined.displayName = 'CloseOutlined';

var _default = _react["default"].forwardRef(CloseOutlined);

exports["default"] = _default;

/***/ }),

/***/ "vf9c":
/***/ (function(module) {

module.exports = JSON.parse("[]");

/***/ }),

/***/ "vgDc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("7lGJ");

__webpack_require__("PAbq");

__webpack_require__("3y5y");

__webpack_require__("yIlq");

__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("75LO");

__webpack_require__("+jjx");

__webpack_require__("ABKx");

__webpack_require__("d3/y");

function _defineEnumerableProperties(obj, descs) {
  for (var key in descs) {
    var desc = descs[key];
    desc.configurable = desc.enumerable = true;
    if ("value" in desc) desc.writable = true;
    Object.defineProperty(obj, key, desc);
  }

  return obj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------
// --[ Dependencies ]---------------------------------------------------


var warnDeprecation = __webpack_require__("GFZo");

var extend = __webpack_require__("0ONX");

var assertObject = __webpack_require__("mbwt"); // --[ Constants and Aliases ]------------------------------------------


var TYPE = Symbol["for"]('@@folktale:adt:type');
var TAG = Symbol["for"]('@@folktale:adt:tag');
var ANY = Symbol["for"]('@@folktale:adt:default');
var META = Symbol["for"]('@@meta:magical');
var keys = Object.keys; // --[ Helpers ]--------------------------------------------------------
//
// Returns an array of own enumerable values in an object.
//

function values(object) {
  return keys(object).map(function (key) {
    return object[key];
  });
} //
// Transforms own enumerable key/value pairs.
//


function mapObject(object, transform) {
  return keys(object).reduce(function (result, key) {
    result[key] = transform(key, object[key]);
    return result;
  }, {});
} //
// Gets a custom error message for the matchWith function.
// 


function getMatchWithErrorMessage(method, property) {
  return 'Variant "' + property + '" not covered in pattern.\nThis could mean you did not include all variants in your Union\'s matchWith function.\n\nFor example, if you had this Union:\n\nconst Operation = union({\n    Add: (a, b) => ({ a, b }),\n    Subtract: (a, b) => ({ a, b }),\n})\n\nBut wrote this matchWith:\n\nop.matchWith({\n    Add: ({ a, b }) => a + b\n    // Subtract not implemented!\n})\n\nIt would throw this error because we need to check against \'Subtract\'. Check your matchWith function\'s argument, \nit\'s possibly missing the \'' + property + '\' method in the object you\'ve passed.';
} // --[ Variant implementation ]-----------------------------------------
//
// Defines the variants given a set of patterns and an ADT namespace.
//


function defineVariants(typeId, patterns, adt) {
  return mapObject(patterns, function (name, constructor) {
    var _constructor, _ref, _extend, _mutatorMap, _tag, _type, _constructor2, _extend2, _mutatorMap2; // ---[ Variant Internals ]-----------------------------------------


    function InternalConstructor() {}

    InternalConstructor.prototype = Object.create(adt);
    extend(InternalConstructor.prototype, (_extend = {}, _defineProperty(_extend, TAG, name), _constructor = 'constructor', _mutatorMap = {}, _mutatorMap[_constructor] = _mutatorMap[_constructor] || {}, _mutatorMap[_constructor].get = function () {
      return InternalConstructor;
    }, _ref = 'is' + name, _mutatorMap[_ref] = _mutatorMap[_ref] || {}, _mutatorMap[_ref].get = function () {
      warnDeprecation('.is' + name + ' is deprecated. Use ' + name + '.hasInstance(value)\ninstead to check if a value belongs to the ADT variant.');
      return true;
    }, _defineProperty(_extend, 'matchWith', function matchWith(pattern) {
      assertObject(typeId + '\'s ' + name + '#matchWith', pattern);

      if (name in pattern) {
        return pattern[name](this);
      } else if (ANY in pattern) {
        return pattern[ANY]();
      } else {
        throw new Error(getMatchWithErrorMessage(pattern, name));
      }
    }), _defineEnumerableProperties(_extend, _mutatorMap), _extend));

    function makeInstance() {
      var result = new InternalConstructor(); // eslint-disable-line prefer-const

      extend(result, constructor.apply(undefined, arguments) || {});
      return result;
    }

    extend(makeInstance, (_extend2 = {}, _defineProperty(_extend2, META, constructor[META]), _tag = 'tag', _mutatorMap2 = {}, _mutatorMap2[_tag] = _mutatorMap2[_tag] || {}, _mutatorMap2[_tag].get = function () {
      return name;
    }, _type = 'type', _mutatorMap2[_type] = _mutatorMap2[_type] || {}, _mutatorMap2[_type].get = function () {
      return typeId;
    }, _constructor2 = 'constructor', _mutatorMap2[_constructor2] = _mutatorMap2[_constructor2] || {}, _mutatorMap2[_constructor2].get = function () {
      return InternalConstructor;
    }, _defineProperty(_extend2, 'prototype', InternalConstructor.prototype), _defineProperty(_extend2, 'hasInstance', function hasInstance(value) {
      return Boolean(value) && adt.hasInstance(value) && value[TAG] === name;
    }), _defineEnumerableProperties(_extend2, _mutatorMap2), _extend2));
    return makeInstance;
  });
} // --[ ADT Implementation ]--------------------------------------------

/*~
 * authors:
 *   - Quildreen Motta
 * 
 * stability: experimental
 * type: |
 *   (String, Object (Array String)) => Union
 */


var union = function union(typeId, patterns) {
  var _extend3;

  var UnionNamespace = Object.create(Union);
  var variants = defineVariants(typeId, patterns, UnionNamespace);
  extend(UnionNamespace, variants, (_extend3 = {}, _defineProperty(_extend3, TYPE, typeId), _defineProperty(_extend3, 'variants', values(variants)), _defineProperty(_extend3, 'hasInstance', function hasInstance(value) {
    return Boolean(value) && value[TYPE] === this[TYPE];
  }), _extend3));
  return UnionNamespace;
};
/*~ ~belongsTo : union */


var Union = {
  /*~
   * type: |
   *   Union . (...(Variant, Union) => Any) => Union
   */
  derive: function derive() {
    var _this = this;

    for (var _len = arguments.length, derivations = Array(_len), _key = 0; _key < _len; _key++) {
      derivations[_key] = arguments[_key];
    }

    derivations.forEach(function (derivation) {
      _this.variants.forEach(function (variant) {
        return derivation(variant, _this);
      });
    });
    return this;
  }
}; // --[ Exports ]--------------------------------------------------------

union.Union = Union;
union.typeSymbol = TYPE;
union.tagSymbol = TAG;
union.any = ANY;
module.exports = union;

/***/ }),

/***/ "vhWV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("V7cS");

exports.__esModule = true;
exports.parsePath = parsePath;

function parsePath(path) {
  var pathname = path || "/";
  var search = "";
  var hash = "";
  var hashIndex = pathname.indexOf("#");

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf("?");

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === "?" ? "" : search,
    hash: hash === "#" ? "" : hash
  };
}

/***/ }),

/***/ "vmge":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("mthV"),
    Success = _require.Success,
    Failure = _require.Failure;
/*~
 * stability: stable
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   forall a, b:
 *     (Result a b) => Validation a b
 */


var resultToValidation = function resultToValidation(aResult) {
  return aResult.matchWith({
    Error: function Error(_ref) {
      var value = _ref.value;
      return Failure(value);
    },
    Ok: function Ok(_ref2) {
      var value = _ref2.value;
      return Success(value);
    }
  });
};

module.exports = resultToValidation;

/***/ }),

/***/ "vmon":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getVendorPrefixes */
/* unused harmony export getVendorPrefixedEventName */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return animationEndName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return transitionEndName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return supportTransition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getTransitionName; });
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("Z8gF");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("W1QL");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("K/PF");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("t91x");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("75LO");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);





var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement); // ================= Transition =================
// Event wrapper. Copy from react source code

function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
  return prefixes;
}

function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };

  if (domSupport) {
    if (!('AnimationEvent' in win)) {
      delete prefixes.animationend.animation;
    }

    if (!('TransitionEvent' in win)) {
      delete prefixes.transitionend.transition;
    }
  }

  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDOM, typeof window !== 'undefined' ? window : {});
var style = {};

if (canUseDOM) {
  style = document.createElement('div').style;
}

var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }

  var prefixMap = vendorPrefixes[eventName];

  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;

    for (var i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];

      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }

  return '';
}
var animationEndName = getVendorPrefixedEventName('animationend');
var transitionEndName = getVendorPrefixedEventName('transitionend');
var supportTransition = !!(animationEndName && transitionEndName);
function getTransitionName(transitionName, transitionType) {
  if (!transitionName) return null;

  if (typeof transitionName === 'object') {
    var type = transitionType.replace(/-\w/g, function (match) {
      return match[1].toUpperCase();
    });
    return transitionName[type];
  }

  return transitionName + '-' + transitionType;
}

/***/ }),

/***/ "w37R":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Notice; });
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("PAbq");
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("1qKx");
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("d3/y");
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("+jjx");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("ABKx");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("xARA");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("8Jek");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_7__);






function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}





var Notice = /*#__PURE__*/function (_Component) {
  _inherits(Notice, _Component);

  function Notice() {
    var _this;

    _classCallCheck(this, Notice);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Notice).apply(this, arguments));

    _this.close = function (e) {
      if (e) {
        e.stopPropagation();
      }

      _this.clearCloseTimer();

      _this.props.onClose();
    };

    _this.startCloseTimer = function () {
      if (_this.props.duration) {
        _this.closeTimer = window.setTimeout(function () {
          _this.close();
        }, _this.props.duration * 1000);
      }
    };

    _this.clearCloseTimer = function () {
      if (_this.closeTimer) {
        clearTimeout(_this.closeTimer);
        _this.closeTimer = null;
      }
    };

    return _this;
  }

  _createClass(Notice, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startCloseTimer();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.duration !== prevProps.duration || this.props.update) {
        this.restartCloseTimer();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearCloseTimer();
    }
  }, {
    key: "restartCloseTimer",
    value: function restartCloseTimer() {
      this.clearCloseTimer();
      this.startCloseTimer();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          prefixCls = _this$props.prefixCls,
          className = _this$props.className,
          closable = _this$props.closable,
          closeIcon = _this$props.closeIcon,
          style = _this$props.style,
          onClick = _this$props.onClick,
          children = _this$props.children,
          holder = _this$props.holder;
      var componentClass = "".concat(prefixCls, "-notice");
      var node = react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement("div", {
        className: classnames__WEBPACK_IMPORTED_MODULE_7___default()(componentClass, className, _defineProperty({}, "".concat(componentClass, "-closable"), closable)),
        style: style,
        onMouseEnter: this.clearCloseTimer,
        onMouseLeave: this.startCloseTimer,
        onClick: onClick
      }, react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement("div", {
        className: "".concat(componentClass, "-content")
      }, children), closable ? react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement("a", {
        tabIndex: 0,
        onClick: this.close,
        className: "".concat(componentClass, "-close")
      }, closeIcon || react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement("span", {
        className: "".concat(componentClass, "-close-x")
      })) : null);

      if (holder) {
        return react_dom__WEBPACK_IMPORTED_MODULE_6___default.a.createPortal(node, holder);
      }

      return node;
    }
  }]);

  return Notice;
}(react__WEBPACK_IMPORTED_MODULE_5__["Component"]);


Notice.defaultProps = {
  onClose: function onClose() {},
  duration: 1.5,
  style: {
    right: '50%'
  }
};

/***/ }),

/***/ "w4Md":
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = __webpack_require__("vXgj");

var _curry3 = __webpack_require__("a2XJ");
/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */


module.exports = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

/***/ }),

/***/ "wEu9":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "wQpU":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("V7cS");

exports.__esModule = true;

exports["default"] = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

/***/ }),

/***/ "wV56":
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__("a2XJ");

var _reduce = __webpack_require__("o2D/");
/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *                -               -10
 *               / \              / \
 *              -   4           -6   4
 *             / \              / \
 *            -   3   ==>     -3   3
 *           / \              / \
 *          -   2           -1   2
 *         / \              / \
 *        0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */


module.exports = _curry3(_reduce);

/***/ }),

/***/ "wWt5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Wave; });
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("V7cS");
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9ovy");
/* harmony import */ var core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("PAbq");
/* harmony import */ var core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_create__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1qKx");
/* harmony import */ var core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("d3/y");
/* harmony import */ var core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_define_property__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("+jjx");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ABKx");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("xARA");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var css_animation_es_Event__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("G8Im");
/* harmony import */ var _raf__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("mTAF");
/* harmony import */ var _config_provider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("Bfez");








function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}






var styleForPesudo; // Where el is the DOM element you'd like to test for visibility

function isHidden(element) {
  if (false) {}

  return !element || element.offsetParent === null;
}

function isNotGrey(color) {
  // eslint-disable-next-line no-useless-escape
  var match = (color || '').match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);

  if (match && match[1] && match[2] && match[3]) {
    return !(match[1] === match[2] && match[2] === match[3]);
  }

  return true;
}

var Wave = /*#__PURE__*/function (_React$Component) {
  _inherits(Wave, _React$Component);

  function Wave() {
    var _this;

    _classCallCheck(this, Wave);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Wave).apply(this, arguments));
    _this.animationStart = false;
    _this.destroy = false;

    _this.onClick = function (node, waveColor) {
      if (!node || isHidden(node) || node.className.indexOf('-leave') >= 0) {
        return;
      }

      var insertExtraNode = _this.props.insertExtraNode;
      _this.extraNode = document.createElement('div');

      var _assertThisInitialize = _assertThisInitialized(_this),
          extraNode = _assertThisInitialize.extraNode;

      extraNode.className = 'ant-click-animating-node';

      var attributeName = _this.getAttributeName();

      node.setAttribute(attributeName, 'true'); // Not white or transparnt or grey

      styleForPesudo = styleForPesudo || document.createElement('style');

      if (waveColor && waveColor !== '#ffffff' && waveColor !== 'rgb(255, 255, 255)' && isNotGrey(waveColor) && !/rgba\(\d*, \d*, \d*, 0\)/.test(waveColor) && // any transparent rgba color
      waveColor !== 'transparent') {
        // Add nonce if CSP exist
        if (_this.csp && _this.csp.nonce) {
          styleForPesudo.nonce = _this.csp.nonce;
        }

        extraNode.style.borderColor = waveColor;
        styleForPesudo.innerHTML = "\n      [ant-click-animating-without-extra-node='true']::after, .ant-click-animating-node {\n        --antd-wave-shadow-color: ".concat(waveColor, ";\n      }");

        if (!document.body.contains(styleForPesudo)) {
          document.body.appendChild(styleForPesudo);
        }
      }

      if (insertExtraNode) {
        node.appendChild(extraNode);
      }

      css_animation_es_Event__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].addStartEventListener(node, _this.onTransitionStart);
      css_animation_es_Event__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].addEndEventListener(node, _this.onTransitionEnd);
    };

    _this.onTransitionStart = function (e) {
      if (_this.destroy) return;
      var node = Object(react_dom__WEBPACK_IMPORTED_MODULE_8__["findDOMNode"])(_assertThisInitialized(_this));

      if (!e || e.target !== node) {
        return;
      }

      if (!_this.animationStart) {
        _this.resetEffect(node);
      }
    };

    _this.onTransitionEnd = function (e) {
      if (!e || e.animationName !== 'fadeEffect') {
        return;
      }

      _this.resetEffect(e.target);
    };

    _this.bindAnimationEvent = function (node) {
      if (!node || !node.getAttribute || node.getAttribute('disabled') || node.className.indexOf('disabled') >= 0) {
        return;
      }

      var onClick = function onClick(e) {
        // Fix radio button click twice
        if (e.target.tagName === 'INPUT' || isHidden(e.target)) {
          return;
        }

        _this.resetEffect(node); // Get wave color from target


        var waveColor = getComputedStyle(node).getPropertyValue('border-top-color') || // Firefox Compatible
        getComputedStyle(node).getPropertyValue('border-color') || getComputedStyle(node).getPropertyValue('background-color');
        _this.clickWaveTimeoutId = window.setTimeout(function () {
          return _this.onClick(node, waveColor);
        }, 0);
        _raf__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"].cancel(_this.animationStartId);
        _this.animationStart = true; // Render to trigger transition event cost 3 frames. Let's delay 10 frames to reset this.

        _this.animationStartId = Object(_raf__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"])(function () {
          _this.animationStart = false;
        }, 10);
      };

      node.addEventListener('click', onClick, true);
      return {
        cancel: function cancel() {
          node.removeEventListener('click', onClick, true);
        }
      };
    };

    _this.renderWave = function (_ref) {
      var csp = _ref.csp;
      var children = _this.props.children;
      _this.csp = csp;
      return children;
    };

    return _this;
  }

  _createClass(Wave, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var node = Object(react_dom__WEBPACK_IMPORTED_MODULE_8__["findDOMNode"])(this);

      if (!node || node.nodeType !== 1) {
        return;
      }

      this.instance = this.bindAnimationEvent(node);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.instance) {
        this.instance.cancel();
      }

      if (this.clickWaveTimeoutId) {
        clearTimeout(this.clickWaveTimeoutId);
      }

      this.destroy = true;
    }
  }, {
    key: "getAttributeName",
    value: function getAttributeName() {
      var insertExtraNode = this.props.insertExtraNode;
      return insertExtraNode ? 'ant-click-animating' : 'ant-click-animating-without-extra-node';
    }
  }, {
    key: "resetEffect",
    value: function resetEffect(node) {
      if (!node || node === this.extraNode || !(node instanceof Element)) {
        return;
      }

      var insertExtraNode = this.props.insertExtraNode;
      var attributeName = this.getAttributeName();
      node.setAttribute(attributeName, 'false'); // edge has bug on `removeAttribute` #14466

      if (styleForPesudo) {
        styleForPesudo.innerHTML = '';
      }

      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {
        node.removeChild(this.extraNode);
      }

      css_animation_es_Event__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].removeStartEventListener(node, this.onTransitionStart);
      css_animation_es_Event__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].removeEndEventListener(node, this.onTransitionEnd);
    }
  }, {
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_7__["createElement"](_config_provider__WEBPACK_IMPORTED_MODULE_11__[/* ConfigConsumer */ "a"], null, this.renderWave);
    }
  }]);

  return Wave;
}(react__WEBPACK_IMPORTED_MODULE_7__["Component"]);



/***/ }),

/***/ "wc+d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("W1QL");

__webpack_require__("K/PF");

__webpack_require__("t91x");

__webpack_require__("3DBk");

__webpack_require__("yIlq");

__webpack_require__("Z8gF");

__webpack_require__("9ovy");

__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.redirectToHome = exports.nPaths = exports.getUrlForLang = exports.getSlugAndLang = exports.getLangs = exports.getI18nBase = exports.getValidLangKey = exports.getUserLangKey = exports.getPagesPaths = exports.getCurrentLangKey = exports.getBrowserLanguage = exports.isInPagesPaths = exports.isHomePage = exports.addLangKeyToSlug = undefined;

var _startsWith = __webpack_require__("cpHF");

var _startsWith2 = _interopRequireDefault(_startsWith);

var _curry = __webpack_require__("NU6T");

var _curry2 = _interopRequireDefault(_curry);

var _getCurrentLangKey = __webpack_require__("QHSJ");

var _getCurrentLangKey2 = _interopRequireDefault(_getCurrentLangKey);

var _getValidLangKey = __webpack_require__("l5BI");

var _getValidLangKey2 = _interopRequireDefault(_getValidLangKey);

var _getBrowserLanguage = __webpack_require__("ylPP");

var _getBrowserLanguage2 = _interopRequireDefault(_getBrowserLanguage);

var _redirectToHome = __webpack_require__("1qWy");

var _redirectToHome2 = _interopRequireDefault(_redirectToHome);

var _getUserLangKey = __webpack_require__("nsWf");

var _getUserLangKey2 = _interopRequireDefault(_getUserLangKey);

var _getSlugAndLang = __webpack_require__("H8M3");

var _getSlugAndLang2 = _interopRequireDefault(_getSlugAndLang);

var _getPagesPaths = __webpack_require__("aOS5");

var _getPagesPaths2 = _interopRequireDefault(_getPagesPaths);

var _isInPagesPaths = __webpack_require__("mWFu");

var _isInPagesPaths2 = _interopRequireDefault(_isInPagesPaths);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Gets the number of paths in a url
 * @param {*} url pathName
 * @returns {Number} number of paths
 */


var nPaths = function nPaths(url) {
  return (url.match(/\//g) || []).length - 1;
};
/**
 * Checks if the url is /, /en/ or /pt/
 * @param {*} url this.props.location
 * @returns {Boolean} is home or not
 */


var isHomePage = function isHomePage(url) {
  return nPaths(url) <= 1;
};
/**
 * Add lang to slug
 * @param {String} slug  Slug to add lang
 * @param {String} langKey langKey to add
 * @param {{langKeyDefault: string, prefixDefault: boolean }} options prefixDefault: boolean indicating whether the the urls for the default land should be prefix or not
 * @returns {String} new slug
 */


var addLangKeyToSlug = (0, _curry2["default"])(function (slug, langKey, options) {
  return langKey !== options.langKeyDefault || options.prefixDefault ? '/' + langKey + slug : '' + slug;
});
/**
 * Get url to the language
 * @param {String} homeLink  link for the home page
 * @param {String} url  browser url
 * @param {String} langKey default browser language key
 * @returns {String} new url
 */

var getUrlForLang = (0, _curry2["default"])(function (homeLink, url, langKey) {
  return url === '/' || !(0, _startsWith2["default"])(homeLink, url) ? '/' + langKey + '/' : url.replace(homeLink, '/' + langKey + '/');
});
/**
 * Get langs to create Menu
 * @param {[String]} langs lang keys ['en', 'fr', 'pt']
 * @param {String} currentLangKey current Lang Key
 * @param {func} getUrlForLang getUrlForLang curried, waiting for langKey
 * @returns {Array} langs menu data
 */

var getLangs = (0, _curry2["default"])(function (langs, currentLangKey, getUrlForLang) {
  return langs.map(function (langKey) {
    return {
      langKey: langKey,
      selected: currentLangKey === langKey,
      link: getUrlForLang(langKey)
    };
  });
});
/**
 * Get i18n obj for the given langKey or first when not found
 * @param {*} i18n Translations object
 * @param {*} langKey langKey
 * @returns {*} i18n[langKey] or i18n[defaultLangKey]
 */

var getI18nBase = (0, _curry2["default"])(function (i18n, langKey) {
  return i18n[langKey] || Object.values(i18n)[0];
});
exports.addLangKeyToSlug = addLangKeyToSlug;
exports.isHomePage = isHomePage;
exports.isInPagesPaths = _isInPagesPaths2["default"];
exports.getBrowserLanguage = _getBrowserLanguage2["default"];
exports.getCurrentLangKey = _getCurrentLangKey2["default"];
exports.getPagesPaths = _getPagesPaths2["default"];
exports.getUserLangKey = _getUserLangKey2["default"];
exports.getValidLangKey = _getValidLangKey2["default"];
exports.getI18nBase = getI18nBase;
exports.getLangs = getLangs;
exports.getSlugAndLang = _getSlugAndLang2["default"];
exports.getUrlForLang = getUrlForLang;
exports.nPaths = nPaths;
exports.redirectToHome = _redirectToHome2["default"];

/***/ }),

/***/ "wiq9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = getWindow;

function getWindow(node) {
  return node === node.window ? node : node.nodeType === 9 ? node.defaultView || node.parentWindow : false;
}

module.exports = exports["default"];

/***/ }),

/***/ "wjI5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "wp6D":
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__("OFPg");

var drop = __webpack_require__("g2V6");
/**
 * Returns a new list containing the last `n` elements of the given list.
 * If `n > list.length`, returns a list of `list.length` elements.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements to return.
 * @param {Array} xs The collection to consider.
 * @return {Array}
 * @see R.dropLast
 * @example
 *
 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(3, 'ramda');               //=> 'mda'
 */


module.exports = _curry2(function takeLast(n, xs) {
  return drop(n >= 0 ? xs.length - n : 0, xs);
});

/***/ }),

/***/ "wv3L":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__("eR4j");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__("KyLU");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2["default"] === "function" && typeof _iterator2["default"] === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof _symbol2["default"] === "function" && obj.constructor === _symbol2["default"] && obj !== _symbol2["default"].prototype ? "symbol" : typeof obj;
};

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = typeof _symbol2["default"] === "function" && _typeof(_iterator2["default"]) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2["default"] === "function" && obj.constructor === _symbol2["default"] && obj !== _symbol2["default"].prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "wyB9":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9ovy");

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("Dln1"));else {}
})(function (CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
  var Pos = CodeMirror.Pos;
  var matching = {
    "(": ")>",
    ")": "(<",
    "[": "]>",
    "]": "[<",
    "{": "}>",
    "}": "{<",
    "<": ">>",
    ">": "<<"
  };

  function bracketRegex(config) {
    return config && config.bracketRegex || /[(){}[\]]/;
  }

  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line),
        pos = where.ch - 1;
    var afterCursor = config && config.afterCursor;
    if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
    var re = bracketRegex(config); // A cursor is defined as between two characters, but in in vim command mode
    // (i.e. not insert mode), the cursor is visually represented as a
    // highlighted box on top of the 2nd character. Otherwise, we allow matches
    // from before or after the cursor.

    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return {
      from: Pos(where.line, pos),
      to: found && found.pos,
      match: found && found.ch == match.charAt(0),
      forward: dir > 0
    };
  } // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up


  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = config && config.maxScanLineLength || 10000;
    var maxScanLines = config && config.maxScanLines || 1000;
    var stack = [];
    var re = bracketRegex(config);
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);

    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1,
          end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);

      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);

        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if (match && match.charAt(1) == ">" == dir > 0) stack.push(ch);else if (!stack.length) return {
            pos: Pos(lineNo, pos),
            ch: ch
          };else stack.pop();
        }
      }
    }

    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }

  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [],
        ranges = cm.listSelections();

    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);

      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {
          className: style
        }));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {
          className: style
        }));
      }
    }

    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.focus();

      var clear = function clear() {
        cm.operation(function () {
          for (var i = 0; i < marks.length; i++) {
            marks[i].clear();
          }
        });
      };

      if (autoclear) setTimeout(clear, 800);else return clear;
    }
  }

  function doMatchBrackets(cm) {
    cm.operation(function () {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }

      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchBrackets);

      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
    }

    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
    }
  });
  CodeMirror.defineExtension("matchBrackets", function () {
    matchBrackets(this, true);
  });
  CodeMirror.defineExtension("findMatchingBracket", function (pos, config, oldConfig) {
    // Backwards-compatibility kludge
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? {
          strict: true
        } : null;
      } else {
        oldConfig.strict = config;
        config = oldConfig;
      }
    }

    return findMatchingBracket(this, pos, config);
  });
  CodeMirror.defineExtension("scanForBracket", function (pos, dir, style, config) {
    return scanForBracket(this, pos, dir, style, config);
  });
});

/***/ }),

/***/ "x9u5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("Kz1y");
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);


function omit(obj, fields) {
  var shallowCopy = babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, obj);

  for (var i = 0; i < fields.length; i++) {
    var key = fields[i];
    delete shallowCopy[key];
  }

  return shallowCopy;
}

/* harmony default export */ __webpack_exports__["a"] = (omit);

/***/ }),

/***/ "xCUo":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");

var _isArray = __webpack_require__("GwS+");

var _isString = __webpack_require__("74ju");
/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */


module.exports = _curry1(function isArrayLike(x) {
  if (_isArray(x)) {
    return true;
  }

  if (!x) {
    return false;
  }

  if (typeof x !== 'object') {
    return false;
  }

  if (_isString(x)) {
    return false;
  }

  if (x.nodeType === 1) {
    return !!x.length;
  }

  if (x.length === 0) {
    return true;
  }

  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }

  return false;
});

/***/ }),

/***/ "xI3J":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__("Bsg+");
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ "xJ2c":
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__("mXGw");

function Antv (props) {
    return React.createElement("svg",props,[React.createElement("title",{"key":0},"logo"),React.createElement("desc",{"key":1},"Created with Sketch."),React.createElement("defs",{"key":2},[React.createElement("linearGradient",{"id":"linearGradient-1","x1":".004%","x2":"100.131%","y1":"49.993%","y2":"49.993%","key":0},[React.createElement("stop",{"offset":"0%","stopColor":"#6500FF","key":0}),React.createElement("stop",{"offset":"16%","stopColor":"#6A09FF","key":1}),React.createElement("stop",{"offset":"43%","stopColor":"#7623FF","key":2}),React.createElement("stop",{"offset":"77%","stopColor":"#8A4CFF","key":3}),React.createElement("stop",{"offset":"99%","stopColor":"#996BFF","key":4})]),React.createElement("linearGradient",{"id":"linearGradient-2","x1":"50.004%","x2":"50.004%","y1":"100.012%","y2":"0%","key":1},[React.createElement("stop",{"offset":"0%","stopColor":"#6500FF","key":0}),React.createElement("stop",{"offset":"16%","stopColor":"#6909FF","key":1}),React.createElement("stop",{"offset":"43%","stopColor":"#7523FF","key":2}),React.createElement("stop",{"offset":"77%","stopColor":"#894CFF","key":3}),React.createElement("stop",{"offset":"99%","stopColor":"#976BFF","key":4})]),React.createElement("linearGradient",{"id":"linearGradient-3","x1":"49.854%","x2":"49.854%","y1":"100.255%","y2":"0%","key":2},[React.createElement("stop",{"offset":"0%","stopColor":"#FF6E06","key":0}),React.createElement("stop",{"offset":"28%","stopColor":"#FF770C","key":1}),React.createElement("stop",{"offset":"75%","stopColor":"#FF911C","key":2}),React.createElement("stop",{"offset":"100%","stopColor":"#FFA126","key":3})]),React.createElement("linearGradient",{"id":"linearGradient-4","x1":"57351%","x2":"57351%","y1":"59860%","y2":"35023%","key":3},[React.createElement("stop",{"offset":"0%","stopColor":"#FF6E06","key":0}),React.createElement("stop",{"offset":"28%","stopColor":"#FF770C","key":1}),React.createElement("stop",{"offset":"75%","stopColor":"#FF911C","key":2}),React.createElement("stop",{"offset":"100%","stopColor":"#FFA126","key":3})])]),React.createElement("g",{"id":"首页","fill":"none","fillRule":"evenodd","stroke":"none","strokeWidth":"1","transform":"translate(-40.000000, -21.000000)","key":3},React.createElement("g",{"id":"logo","fillRule":"nonzero","transform":"translate(40.000000, 21.000000)"},[React.createElement("g",{"id":"text","fill":"#000","transform":"translate(40.000000, 4.000000)","key":0},[React.createElement("path",{"id":"Shape","d":"M8.7405,1.2915 C8.51971803,0.727507979 7.97591631,0.356402076 7.37025,0.356402076 C6.76458369,0.356402076 6.22078197,0.727507979 6,1.2915 L0.0915,16.224 C0.303214856,16.7668034 0.833635444,17.1176139 1.416,17.1 C1.99787286,17.1149847 2.52631953,16.7624868 2.736,16.2195 L4.236,12.1845 L10.464,12.1845 L11.964,16.2195 C12.1824954,16.7696588 12.7145414,17.1308265 13.3065,17.1308265 C13.8984586,17.1308265 14.4305046,16.7696588 14.649,16.2195 L8.7405,1.2915 Z M4.875,10.3245 L7.3125,3.7755 L7.38,3.7755 L9.8175,10.3245 L4.875,10.3245 Z","key":0}),React.createElement("path",{"id":"Shape","d":"M23.616,4.8675 C21.711,4.8675 20.3625,5.5605 19.6155,6.885 L19.5705,6.885 L19.5705,4.992 C19.3939707,4.49572722 18.9242345,4.16424813 18.3975,4.16424813 C17.8707655,4.16424813 17.4010293,4.49572722 17.2245,4.992 L17.2245,16.23 C17.3727212,16.7871906 17.8771818,17.1750009 18.45375,17.1750009 C19.0303182,17.1750009 19.5347788,16.7871906 19.683,16.23 L19.683,9.741 C19.683,7.971 20.907,6.792 22.7655,6.792 C24.5655,6.792 25.542,7.7445 25.542,9.4515 L25.542,16.23 C25.6902212,16.7871906 26.1946818,17.1750009 26.77125,17.1750009 C27.3478182,17.1750009 27.8522788,16.7871906 28.0005,16.23 L28.0005,9.03 C28.002,6.4395 26.3355,4.8675 23.616,4.8675 Z","key":1}),React.createElement("path",{"id":"Shape","d":"M37.164,15.2175 C37.005,15.2385 36.5865,15.27 36.3255,15.27 C35.2935,15.27 34.818,14.82 34.818,13.842 L34.818,7.5555 L37.176,7.5555 C37.4674337,7.35650372 37.6417542,7.0263925 37.6417542,6.6735 C37.6417542,6.3206075 37.4674337,5.99049628 37.176,5.7915 L37.176,5.7795 L34.818,5.7795 L34.818,3.2625 L34.809,3.2625 C34.5697886,2.81087163 34.1005678,2.5284255 33.5895,2.5284255 C33.0784322,2.5284255 32.6092114,2.81087163 32.37,3.2625 L32.37,5.787 L30.669,5.787 L30.669,5.8035 C30.3813594,6.00305662 30.2097838,6.33091436 30.2097838,6.681 C30.2097838,7.03108564 30.3813594,7.35894338 30.669,7.5585 L32.37,7.5585 L32.37,14.0655 C32.37,16.239 33.3225,17.097 35.7825,17.097 C36.246017,17.1013951 36.708959,17.063235 37.1655,16.983 C37.4531479,16.7817619 37.6244786,16.4528028 37.6244786,16.10175 C37.6244786,15.7506972 37.4531479,15.4217381 37.1655,15.2205 L37.164,15.2175 Z","key":2}),React.createElement("path",{"id":"Shape","d":"M53.9085,1.041 C53.6915775,0.484686746 53.1556096,0.118403837 52.5585,0.118403837 C51.9613904,0.118403837 51.4254225,0.484686746 51.2085,1.041 L46.7325,13.365 L46.665,13.365 L42.21,1.041 L42.219,1.041 C41.991677,0.479831031 41.4467137,0.112610372 40.84125,0.112610372 C40.2357863,0.112610372 39.690823,0.479831031 39.4635,1.041 L45.3,15.9735 C45.402,16.5915 45.9855,17.067 46.692,17.067 C47.3985,17.067 47.9805,16.593 48.084,15.9735 L53.9085,1.041 Z","key":3})]),React.createElement("g",{"id":"Shape","key":1},[React.createElement("path",{"fill":"url(#linearGradient-1)","d":"M1.96144278,0.00379393843 C1.93278766,0.00379393843 1.90413254,0.00379393843 1.87375812,0.00597764254 C1.82628614,0.00725146994 1.80317101,0.00888924802 1.78005588,0.0108909768 C1.73258391,0.015258385 1.70450189,0.0186249288 1.67661091,0.0226283864 C1.63448789,0.0291794987 1.61271,0.0329099932 1.59093211,0.0370954261 C1.53906635,0.0471950576 1.51213054,0.0529272809 1.48548128,0.0594783932 C1.453101,0.0676672836 1.4290307,0.0742183959 1.40524695,0.0810424713 C1.36006738,0.0949635849 1.34096397,0.101150747 1.32186056,0.107519884 C1.2750572,0.123715689 1.25079587,0.132814456 1.22672557,0.142459149 C1.184316,0.16001977 1.16769603,0.167116808 1.15107606,0.174395822 L1.12242094,0.187225084 C1.10331753,0.196323851 1.08421412,0.205422618 1.06511071,0.214521385 L1.03387663,0.230899166 C1.01811632,0.239361019 1.002356,0.247822873 0.986882238,0.256557689 L0.955934712,0.274573248 L0.917250303,0.29832103 L0.888595186,0.316882515 C0.869491775,0.329438814 0.850388363,0.342268075 0.831284952,0.3553703 L0.797758465,0.38075586 L0.76738404,0.40341179 L0.734717207,0.42879735 L0.706062089,0.452545133 C0.686958678,0.468013037 0.66871492,0.483844892 0.651330815,0.500040697 L0.627833619,0.521331812 C0.616562606,0.531704407 0.605482628,0.542258976 0.594593683,0.552995522 L0.57424855,0.573194785 C0.550942388,0.596669604 0.528304845,0.620690349 0.506335922,0.64525702 C0.4888563,0.66518332 0.477967356,0.677739619 0.467364963,0.69056888 L0.451891199,0.709403328 C0.441288806,0.722505553 0.430686412,0.73669963 0.420657121,0.748710002 C0.392766141,0.78592396 0.373089627,0.813220261 0.354177249,0.840698538 L0.343288305,0.856803356 C0.333736599,0.871179408 0.324184893,0.885737435 0.314633188,0.900477438 L0.304317345,0.917401145 L0.296293912,0.931049295 L4.0804887,3.1453528 L4.88168578,4 C4.79792689,3.87330151 4.79075687,3.71385419 4.86283506,3.58079687 C4.93491326,3.44773955 5.07548957,3.36091705 5.23242441,3.35253173 L18.126081,3.35253173 C18.1716426,3.35580729 18.2172042,3.35799099 18.2636255,3.35799099 C19.2247383,3.34437937 19.997179,2.59972948 19.9999923,1.68409514 C20.0028056,0.768460793 19.234954,0.0195165058 18.2739414,0.000545926027 L1.96144278,0.00379393843 Z","key":0}),React.createElement("path",{"fill":"url(#linearGradient-2)","d":"M22.7438388,11.3151867 L16.3508566,22.3257033 C16.274965,22.4547197 16.1378066,22.5359862 15.9875806,22.5409448 C15.8373546,22.5459034 15.6950786,22.4738603 15.6107503,22.3501325 L11.5484958,15.3552589 C11.5151833,15.2756059 11.4759174,15.1985462 11.4310276,15.1247266 L4.67293385,3.45883542 C4.28425,2.75990644 4.28254958,1.91173703 4.66842791,1.21127254 C5.05430624,0.510808047 5.77401391,0.0556169131 6.57558023,0.00506221373 L1.98726011,0.000850295183 C1.70028191,-0.00773775303 1.4151096,0.0488237358 1.15340515,0.166238297 C1.11086057,0.18570672 1.07725788,0.202180002 1.04412582,0.219589265 C0.955459897,0.268541118 0.934752357,0.281176874 0.914233068,0.29428062 L0.814836879,0.361671317 C0.763726906,0.399952977 0.748102127,0.412307938 0.732665597,0.424850095 C0.693227147,0.457796658 0.67910837,0.470151619 0.665177844,0.482693776 C0.629598526,0.514985152 0.611526491,0.532394415 0.594019208,0.550084473 C0.559381142,0.585183794 0.543756362,0.601844272 0.528508083,0.618879143 C0.501964783,0.648362572 0.484739875,0.668860576 0.467797343,0.689639374 C0.436736033,0.727546641 0.420923003,0.748325439 0.405392349,0.769385032 C0.385908437,0.795779721 0.370095407,0.819085671 0.354564752,0.842672415 C0.3274567,0.884230011 0.312490797,0.908378344 0.298089644,0.933369061 C-0.0900333359,1.52939569 -0.081932791,2.25296668 0.269004964,2.83322512 L0.435324156,3.12188194 L14.3089991,27.0174998 C14.4452697,27.2688135 14.6373487,27.4859373 14.870644,27.6523763 C14.9087647,27.679239 14.9399202,27.6999242 14.9717345,27.719767 C15.0597415,27.7702164 15.0811079,27.781729 15.1027567,27.7927736 L15.2100594,27.8435974 C15.2692642,27.8684945 15.2880892,27.8757952 15.3069142,27.8829087 C15.3553887,27.9000371 15.3731784,27.9060274 15.3910621,27.9118305 C15.4370894,27.926151 15.4610913,27.9328901 15.4853756,27.9393484 C15.5335677,27.9512353 15.5558753,27.9563832 15.5782771,27.9612503 C15.6169626,27.9693934 15.6435059,27.9738861 15.6700492,27.978098 C15.7186178,27.9851179 15.7445963,27.9887682 15.7708572,27.9912954 C15.8041776,27.9941033 15.8324151,27.9960689 15.8606527,27.9977536 C15.9100684,27.9977536 15.9383059,28 15.9665435,28 C16.0055113,28 16.0292309,28 16.052668,27.9983152 C16.1029309,27.9969113 16.1286271,27.9949457 16.1551704,27.9921378 C16.1882083,27.9893298 16.2164458,27.9856795 16.2424244,27.9817484 C16.2892987,27.9744477 16.3133007,27.9702358 16.3370202,27.9654623 C16.3740114,27.9581616 16.3997076,27.9519841 16.4254037,27.9458066 C16.4708662,27.9339197 16.4916679,27.928023 16.5123754,27.9216583 C16.5536022,27.9090226 16.5773218,27.9008795 16.6010413,27.8924557 C16.6464097,27.8759824 16.6634463,27.8692433 16.6803889,27.8621299 C16.7264161,27.842755 16.7478766,27.833208 16.7690548,27.8239418 L16.8402134,27.7882809 C16.8972533,27.7573935 16.9127839,27.7486889 16.9277498,27.7397034 C17.014345,27.6850421 17.0367468,27.6697856 17.0587721,27.6540611 C17.0796679,27.6390854 17.1047052,27.6202721 17.133884,27.5976214 C17.1766168,27.563926 17.2177495,27.5284523 17.2572821,27.4912002 C17.3084862,27.4427164 17.3481129,27.401346 17.3857629,27.3581036 C17.4284017,27.3092454 17.4652987,27.2624463 17.500125,27.2137752 C17.5353279,27.1645426 17.5680834,27.1136251 17.5983917,27.061023 L17.9739512,26.4216537 L18.0558401,26.2812564 L25.73589,13.0558322 C26.070421,12.5242035 26.0883782,11.8538976 25.7827856,11.3053117 C25.4771931,10.7567258 24.8962203,10.4163314 24.2655606,10.4163633 C23.6317102,10.4178657 23.048049,10.7619023 22.7438388,11.3151867 Z","key":1}),React.createElement("path",{"fill":"url(#linearGradient-3)","d":"M30.1437101,0 L23.6847716,0 C22.749424,0.0183223345 22,0.84716472 22,1.86331122 C22,2.87945772 22.749424,3.7083001 23.6847716,3.72662244 C23.7299585,3.72662244 23.7743086,3.72419862 23.8186587,3.72056289 L26.7432558,3.72056289 C26.957527,3.75250166 27.1172208,3.95131508 27.117303,4.1862392 C27.1173323,4.23951108 27.1089352,4.29239242 27.0924781,4.34257556 L25.5505446,7.24358449 C25.0967914,8.1471655 25.403314,9.27921269 26.235182,9.77208267 C27.0670501,10.2649526 28.1092519,9.93200556 28.5630051,9.02842455 L31.7528661,3.02795647 C31.782061,2.97321855 31.8089314,2.91686475 31.8334773,2.85889507 L31.8365456,2.85132063 C31.8516079,2.81516532 31.8657404,2.77850505 31.8789432,2.74133982 L31.8811746,2.73558325 C31.8870322,2.71861651 31.8928898,2.7013468 31.8984684,2.68407709 L31.9068363,2.65741507 C31.9142745,2.63337886 31.9212478,2.60903968 31.9277562,2.58439751 C31.9316612,2.57046055 31.9352873,2.55622061 31.9389135,2.54228365 C31.9425396,2.52834669 31.9453289,2.51531866 31.9483971,2.50198765 C31.9514654,2.48865664 31.9559283,2.46714524 31.9595544,2.44957255 C31.9620648,2.43715048 31.9645752,2.4247284 31.9668066,2.41230633 C31.9710836,2.38867409 31.9749886,2.36483986 31.9785217,2.34080365 C31.9800094,2.33090639 31.981404,2.32080714 31.9827057,2.31050591 C31.9860529,2.28505581 31.9891211,2.25930272 31.9916315,2.23354964 C31.9916315,2.22991391 31.9916315,2.22658116 31.9916315,2.22294543 C31.9944208,2.19264769 31.9963734,2.16234995 31.997768,2.13387007 C31.997768,2.12619464 31.997768,2.11841822 31.997768,2.1105408 C31.997768,2.08024306 31.9999995,2.04994532 31.9999995,2.01964757 C32.00077,0.905181759 31.1697259,0.00100355849 30.1437101,0 Z","key":2}),React.createElement("path",{"fill":"url(#linearGradient-4)","d":"M19.8878401,7.40978464 C19.7383064,7.15620152 19.4618641,6.99998235 19.1626937,7.00000003 L12.8373895,7.00000003 C12.5382281,6.9999242 12.261761,7.15608029 12.1121725,7.40962229 C11.962584,7.66316428 11.9626109,7.97555472 12.112243,8.22907204 L15.2751831,13.5903738 C15.4247323,13.8438523 15.7011,14 16.0001856,14 C16.2992712,14 16.5756388,13.8438523 16.725188,13.5903738 L19.8878401,8.22935388 C20.0373866,7.97586547 20.0373866,7.66355488 19.8878401,7.41006648 L19.8878401,7.40978464 Z","key":3})])]))]);
}

Antv.defaultProps = {"width":"94","height":"28","version":"1.1","viewBox":"0 0 94 28"};

module.exports = Antv;

Antv.default = Antv;


/***/ }),

/***/ "xTM7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toArray; });
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("+3V6");
/* harmony import */ var core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_is_array__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7lGJ");
/* harmony import */ var core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_for_each__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("xVO4");
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_3__);




function toArray(children) {
  var ret = [];
  react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.forEach(children, function (child) {
    if (child === undefined || child === null) {
      return;
    }

    if (Array.isArray(child)) {
      ret = ret.concat(toArray(child));
    } else if (Object(react_is__WEBPACK_IMPORTED_MODULE_3__["isFragment"])(child) && child.props) {
      ret = ret.concat(toArray(child.props.children));
    } else {
      ret.push(child);
    }
  });
  return ret;
}

/***/ }),

/***/ "xVO4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__("9K2m");
} else {}

/***/ }),

/***/ "xp7Y":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ../node_modules/rc-pagination/es/locale/en_US.js
/* harmony default export */ var en_US = ({
  // Options.jsx
  items_per_page: '/ page',
  jump_to: 'Go to',
  jump_to_confirm: 'confirm',
  page: '',
  // Pagination.jsx
  prev_page: 'Previous Page',
  next_page: 'Next Page',
  prev_5: 'Previous 5 Pages',
  next_5: 'Next 5 Pages',
  prev_3: 'Previous 3 Pages',
  next_3: 'Next 3 Pages'
});
// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/rc-picker/es/locale/en_US.js
var locale_en_US = __webpack_require__("8tsl");
var en_US_default = /*#__PURE__*/__webpack_require__.n(locale_en_US);

// CONCATENATED MODULE: ../node_modules/antd/es/time-picker/locale/en_US.js
var locale = {
  placeholder: 'Select time',
  rangePlaceholder: ['Start time', 'End time']
};
/* harmony default export */ var time_picker_locale_en_US = (locale);
// CONCATENATED MODULE: ../node_modules/antd/es/date-picker/locale/en_US.js


function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}


 // Merge into a locale object

var en_US_locale = {
  lang: _extends({
    placeholder: 'Select date',
    yearPlaceholder: 'Select year',
    monthPlaceholder: 'Select month',
    weekPlaceholder: 'Select week',
    rangePlaceholder: ['Start date', 'End date'],
    rangeYearPlaceholder: ['Start year', 'End year'],
    rangeMonthPlaceholder: ['Start month', 'End month'],
    rangeWeekPlaceholder: ['Start week', 'End week']
  }, en_US_default.a),
  timePickerLocale: _extends({}, time_picker_locale_en_US)
}; // All settings at:
// https://github.com/ant-design/ant-design/blob/master/components/date-picker/locale/example.json

/* harmony default export */ var date_picker_locale_en_US = (en_US_locale);
// CONCATENATED MODULE: ../node_modules/antd/es/calendar/locale/en_US.js

/* harmony default export */ var calendar_locale_en_US = (date_picker_locale_en_US);
// CONCATENATED MODULE: ../node_modules/antd/es/locale/default.js




/* harmony default export */ var locale_default = __webpack_exports__["a"] = ({
  locale: 'en',
  Pagination: en_US,
  DatePicker: date_picker_locale_en_US,
  TimePicker: time_picker_locale_en_US,
  Calendar: calendar_locale_en_US,
  global: {
    placeholder: 'Please select'
  },
  Table: {
    filterTitle: 'Filter menu',
    filterConfirm: 'OK',
    filterReset: 'Reset',
    selectAll: 'Select current page',
    selectInvert: 'Invert current page',
    selectionAll: 'Select all data',
    sortTitle: 'Sort',
    expand: 'Expand row',
    collapse: 'Collapse row'
  },
  Modal: {
    okText: 'OK',
    cancelText: 'Cancel',
    justOkText: 'OK'
  },
  Popconfirm: {
    okText: 'OK',
    cancelText: 'Cancel'
  },
  Transfer: {
    titles: ['', ''],
    searchPlaceholder: 'Search here',
    itemUnit: 'item',
    itemsUnit: 'items'
  },
  Upload: {
    uploading: 'Uploading...',
    removeFile: 'Remove file',
    uploadError: 'Upload error',
    previewFile: 'Preview file',
    downloadFile: 'Download file'
  },
  Empty: {
    description: 'No Data'
  },
  Icon: {
    icon: 'icon'
  },
  Text: {
    edit: 'Edit',
    copy: 'Copy',
    copied: 'Copied',
    expand: 'Expand'
  },
  PageHeader: {
    back: 'Back'
  }
});

/***/ }),

/***/ "xtsi":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("DbwS");__webpack_require__("t91x");var plugins=__webpack_require__("LeKB");var _require$publicLoader=__webpack_require__("emEt").publicLoader,getResourcesForPathname=_require$publicLoader.getResourcesForPathname,getResourcesForPathnameSync=_require$publicLoader.getResourcesForPathnameSync,getResourceURLsForPathname=_require$publicLoader.getResourceURLsForPathname,loadPage=_require$publicLoader.loadPage,loadPageSync=_require$publicLoader.loadPageSync;exports.apiRunner=function(api,args,defaultReturn,argTransform){if(args===void 0){args={};}// Hooks for gatsby-cypress's API handler
if(undefined){if(window.___apiHandler){window.___apiHandler(api);}else if(window.___resolvedAPIs){window.___resolvedAPIs.push(api);}else{window.___resolvedAPIs=[api];}}var results=plugins.map(function(plugin){if(!plugin.plugin[api]){return undefined;}// Deprecated April 2019. Use `loadPageSync` instead
args.getResourcesForPathnameSync=getResourcesForPathnameSync;// Deprecated April 2019. Use `loadPage` instead
args.getResourcesForPathname=getResourcesForPathname;args.getResourceURLsForPathname=getResourceURLsForPathname;args.loadPage=loadPage;args.loadPageSync=loadPageSync;var result=plugin.plugin[api](args,plugin.options);if(result&&argTransform){args=argTransform({args:args,result:result,plugin:plugin});}return result;});// Filter out undefined results.
results=results.filter(function(result){return typeof result!=="undefined";});if(results.length>0){return results;}else if(defaultReturn){return[defaultReturn];}else{return[];}};exports.apiRunnerAsync=function(api,args,defaultReturn){return plugins.reduce(function(previous,next){return next.plugin[api]?previous.then(function(){return next.plugin[api](args,next.options);}):previous;},Promise.resolve());};

/***/ }),

/***/ "y/En":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

__webpack_require__("ABKx");

__webpack_require__("d3/y");

var REACT_STATICS = {
  childContextTypes: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }

    return targetComponent;
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),

/***/ "y/N9":
/***/ (function(module, exports) {

/**
 * This file automatically generated from `pre-publish.js`.
 * Do not manually edit.
 */
module.exports = {
  "area": true,
  "base": true,
  "br": true,
  "col": true,
  "embed": true,
  "hr": true,
  "img": true,
  "input": true,
  "keygen": true,
  "link": true,
  "menuitem": true,
  "meta": true,
  "param": true,
  "source": true,
  "track": true,
  "wbr": true
};

/***/ }),

/***/ "yBJb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "yCBR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = __webpack_require__("vgDc"),
    typeSymbol = _require.typeSymbol;

module.exports = function (type) {
  return function (method, value) {
    var typeName = type[typeSymbol];

    if ({}.FOLKTALE_ASSERTIONS !== 'none' && !type.isPrototypeOf(value)) {
      console.warn(typeName + '.' + method + ' expects a value of the same type, but was given ' + value + '.');

      if ({}.FOLKTALE_ASSERTIONS !== 'minimal') {
        console.warn('\nThis could mean that you\'ve provided the wrong value to the method, in\nwhich case this is a bug in your program, and you should try to track\ndown why the wrong value is getting here.\n\nBut this could also mean that you have more than one ' + typeName + ' library\ninstantiated in your program. This is not **necessarily** a bug, it\ncould happen for several reasons:\n\n 1) You\'re loading the library in Node, and Node\'s cache didn\'t give\n    you back the same instance you had previously requested.\n\n 2) You have more than one Code Realm in your program, and objects\n    created from the same library, in different realms, are interacting.\n\n 3) You have a version conflict of folktale libraries, and objects\n    created from different versions of the library are interacting.\n\nIf your situation fits the cases (1) or (2), you are okay, as long as\nthe objects originate from the same version of the library. Folktale\ndoes not rely on reference checking, only structural checking. However\nyou\'ll want to watch out if you\'re modifying the ' + typeName + "'s prototype,\nbecause you'll have more than one of them, and you'll want to make\nsure you do the same change in all of them \u2014 ideally you shouldn't\nbe modifying the object, though.\n\nIf your situation fits the case (3), you are *probably* okay if the\nversion difference isn't a major one. However, at this point the\nbehaviour of your program using " + typeName + ' is undefined, and you should\ntry looking into why the version conflict is happening.\n\nParametric modules can help ensuring your program only has a single\ninstance of the folktale library. Check out the Folktale Architecture\ndocumentation for more information.\n      ');
      }
    }
  };
};

/***/ }),

/***/ "yIlq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__("X6VK");
var $map = __webpack_require__("1wfo")(1);

$export($export.P + $export.F * !__webpack_require__("/6rt")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "yMzA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

var _module$exports;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------


var Result = __webpack_require__("sfhO");

var _require = __webpack_require__("vgDc"),
    typeSymbol = _require.typeSymbol;
/*~
 * stability: stable
 * name: module folktale/result
 */


module.exports = (_module$exports = {
  Error: Result.Error,
  Ok: Result.Ok,
  hasInstance: Result.hasInstance,
  of: Result.of,
  fromJSON: Result.fromJSON
}, _defineProperty(_module$exports, typeSymbol, Result[typeSymbol]), _defineProperty(_module$exports, 'try', __webpack_require__("fy0x")), _defineProperty(_module$exports, 'fromNullable', function fromNullable(aNullable, fallbackValue) {
  var nullableToResult = __webpack_require__("QVtb");

  if (arguments.length > 1) {
    // eslint-disable-line prefer-rest-params 
    return nullableToResult(aNullable, fallbackValue);
  } else {
    return nullableToResult(aNullable);
  }
}), _defineProperty(_module$exports, 'fromValidation', function fromValidation(aValidation) {
  return __webpack_require__("f7TZ")(aValidation);
}), _defineProperty(_module$exports, 'fromMaybe', function fromMaybe(aMaybe, failureValue) {
  return __webpack_require__("pS6Z")(aMaybe, failureValue);
}), _module$exports);

/***/ }),

/***/ "yO+b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("bztI"), __esModule: true };

/***/ }),

/***/ "yRvC":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _LoadingOutlined = _interopRequireDefault(__webpack_require__("6kVO"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _LoadingOutlined;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "ylPP":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Get browser language.
 *
 * @return {String} langKey
 */

var getBrowserLanguage = function getBrowserLanguage() {
  if (typeof window === 'undefined') {
    return null;
  }

  var first = window.navigator.languages ? window.navigator.languages[0] : null;
  var lang = first || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage;
  return lang;
};

exports["default"] = getBrowserLanguage;

/***/ }),

/***/ "z6KD":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("P56o");
var core = __webpack_require__("R5TD");
var LIBRARY = __webpack_require__("wEu9");
var wksExt = __webpack_require__("fxUj");
var defineProperty = __webpack_require__("U1KF").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "zAXs":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("V7cS");
/* harmony import */ var core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_index_of__WEBPACK_IMPORTED_MODULE_0__);


/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,

  /**
   * BACKSPACE
   */
  BACKSPACE: 8,

  /**
   * TAB
   */
  TAB: 9,

  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,

  /**
   * ENTER
   */
  ENTER: 13,

  /**
   * SHIFT
   */
  SHIFT: 16,

  /**
   * CTRL
   */
  CTRL: 17,

  /**
   * ALT
   */
  ALT: 18,

  /**
   * PAUSE
   */
  PAUSE: 19,

  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,

  /**
   * ESC
   */
  ESC: 27,

  /**
   * SPACE
   */
  SPACE: 32,

  /**
   * PAGE_UP
   */
  PAGE_UP: 33,

  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,

  /**
   * END
   */
  END: 35,

  /**
   * HOME
   */
  HOME: 36,

  /**
   * LEFT
   */
  LEFT: 37,

  /**
   * UP
   */
  UP: 38,

  /**
   * RIGHT
   */
  RIGHT: 39,

  /**
   * DOWN
   */
  DOWN: 40,

  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,

  /**
   * INSERT
   */
  INSERT: 45,

  /**
   * DELETE
   */
  DELETE: 46,

  /**
   * ZERO
   */
  ZERO: 48,

  /**
   * ONE
   */
  ONE: 49,

  /**
   * TWO
   */
  TWO: 50,

  /**
   * THREE
   */
  THREE: 51,

  /**
   * FOUR
   */
  FOUR: 52,

  /**
   * FIVE
   */
  FIVE: 53,

  /**
   * SIX
   */
  SIX: 54,

  /**
   * SEVEN
   */
  SEVEN: 55,

  /**
   * EIGHT
   */
  EIGHT: 56,

  /**
   * NINE
   */
  NINE: 57,

  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,

  /**
   * A
   */
  A: 65,

  /**
   * B
   */
  B: 66,

  /**
   * C
   */
  C: 67,

  /**
   * D
   */
  D: 68,

  /**
   * E
   */
  E: 69,

  /**
   * F
   */
  F: 70,

  /**
   * G
   */
  G: 71,

  /**
   * H
   */
  H: 72,

  /**
   * I
   */
  I: 73,

  /**
   * J
   */
  J: 74,

  /**
   * K
   */
  K: 75,

  /**
   * L
   */
  L: 76,

  /**
   * M
   */
  M: 77,

  /**
   * N
   */
  N: 78,

  /**
   * O
   */
  O: 79,

  /**
   * P
   */
  P: 80,

  /**
   * Q
   */
  Q: 81,

  /**
   * R
   */
  R: 82,

  /**
   * S
   */
  S: 83,

  /**
   * T
   */
  T: 84,

  /**
   * U
   */
  U: 85,

  /**
   * V
   */
  V: 86,

  /**
   * W
   */
  W: 87,

  /**
   * X
   */
  X: 88,

  /**
   * Y
   */
  Y: 89,

  /**
   * Z
   */
  Z: 90,

  /**
   * META
   */
  META: 91,

  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,

  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,

  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,

  /**
   * NUM_ONE
   */
  NUM_ONE: 97,

  /**
   * NUM_TWO
   */
  NUM_TWO: 98,

  /**
   * NUM_THREE
   */
  NUM_THREE: 99,

  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,

  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,

  /**
   * NUM_SIX
   */
  NUM_SIX: 102,

  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,

  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,

  /**
   * NUM_NINE
   */
  NUM_NINE: 105,

  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,

  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,

  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,

  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,

  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,

  /**
   * F1
   */
  F1: 112,

  /**
   * F2
   */
  F2: 113,

  /**
   * F3
   */
  F3: 114,

  /**
   * F4
   */
  F4: 115,

  /**
   * F5
   */
  F5: 116,

  /**
   * F6
   */
  F6: 117,

  /**
   * F7
   */
  F7: 118,

  /**
   * F8
   */
  F8: 119,

  /**
   * F9
   */
  F9: 120,

  /**
   * F10
   */
  F10: 121,

  /**
   * F11
   */
  F11: 122,

  /**
   * F12
   */
  F12: 123,

  /**
   * NUMLOCK
   */
  NUMLOCK: 144,

  /**
   * SEMICOLON
   */
  SEMICOLON: 186,

  /**
   * DASH
   */
  DASH: 189,

  /**
   * EQUALS
   */
  EQUALS: 187,

  /**
   * COMMA
   */
  COMMA: 188,

  /**
   * PERIOD
   */
  PERIOD: 190,

  /**
   * SLASH
   */
  SLASH: 191,

  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,

  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,

  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,

  /**
   * BACKSLASH
   */
  BACKSLASH: 220,

  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,

  /**
   * WIN_KEY
   */
  WIN_KEY: 224,

  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,

  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================

  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;

    if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    } // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.


    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;

      default:
        return true;
    }
  },

  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }

    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }

    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    } // Safari sends zero key code for non-latin characters.


    if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }

    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;

      default:
        return false;
    }
  }
};
/* harmony default export */ __webpack_exports__["a"] = (KeyCode);

/***/ }),

/***/ "zFdY":
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__("AN6r");

var empty = __webpack_require__("T/r7");

var equals = __webpack_require__("LGMZ");
/**
 * Returns `true` if the given value is its type's empty value; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> Boolean
 * @param {*} x
 * @return {Boolean}
 * @see R.empty
 * @example
 *
 *      R.isEmpty([1, 2, 3]);   //=> false
 *      R.isEmpty([]);          //=> true
 *      R.isEmpty('');          //=> true
 *      R.isEmpty(null);        //=> false
 *      R.isEmpty({});          //=> true
 *      R.isEmpty({length: 0}); //=> false
 */


module.exports = _curry1(function isEmpty(x) {
  return x != null && equals(x, empty(x));
});

/***/ }),

/***/ "zGEu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("yIlq");

__webpack_require__("d3/y");

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var react_1 = __importDefault(__webpack_require__("mXGw"));

var classnames_1 = __importDefault(__webpack_require__("8Jek"));

var Column = function Column(_ref) {
  var prefixCls = _ref.prefixCls,
      icon = _ref.icon,
      title = _ref.title,
      _ref$items = _ref.items,
      items = _ref$items === void 0 ? [] : _ref$items,
      style = _ref.style,
      className = _ref.className;
  return react_1["default"].createElement("div", {
    className: classnames_1["default"]("".concat(prefixCls, "-column"), className),
    style: style
  }, (title || icon) && react_1["default"].createElement("h2", null, icon && react_1["default"].createElement("span", {
    className: "".concat(prefixCls, "-column-icon")
  }, icon), title), items.map(function (item, i) {
    var LinkComponent = item.LinkComponent || 'a';
    return react_1["default"].createElement("div", {
      className: classnames_1["default"]("".concat(prefixCls, "-item"), item.className),
      style: item.style,
      key: i
    }, react_1["default"].createElement(LinkComponent, {
      href: item.url,
      to: typeof LinkComponent !== 'string' ? item.url : undefined,
      target: item.openExternal ? '_blank' : undefined
    }, item.icon && react_1["default"].createElement("span", {
      className: "".concat(prefixCls, "-item-icon")
    }, item.icon), item.title), item.description && react_1["default"].createElement(react_1["default"].Fragment, null, react_1["default"].createElement("span", {
      className: "".concat(prefixCls, "-item-separator")
    }, "-"), react_1["default"].createElement("span", {
      className: "".concat(prefixCls, "-item-description")
    }, item.description)));
  }));
};

exports["default"] = Column;

/***/ }),

/***/ "zIP/":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("1Alt")('meta');
var isObject = __webpack_require__("Bsg+");
var has = __webpack_require__("ezc+");
var setDesc = __webpack_require__("U1KF").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("E7Vc")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "zIds":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("at5L");
var hiddenKeys = __webpack_require__("fQty").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "zJT+":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "zSCU":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = exports.connect = exports.Provider = undefined;

var _Provider2 = __webpack_require__("YOo+");

var _Provider3 = _interopRequireDefault(_Provider2);

var _connect2 = __webpack_require__("XMvD");

var _connect3 = _interopRequireDefault(_connect2);

var _create2 = __webpack_require__("Cbd+");

var _create3 = _interopRequireDefault(_create2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports.Provider = _Provider3["default"];
exports.connect = _connect3["default"];
exports.create = _create3["default"];

/***/ }),

/***/ "zUWx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = function (methodName) {
  return function (object) {
    throw new TypeError(object + " does not have a method '" + methodName + "'.");
  };
};

/***/ }),

/***/ "zWQs":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "zeFm":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("T/1i");
var toLength = __webpack_require__("gou2");
var toAbsoluteIndex = __webpack_require__("+eav");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "zlqh":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("9dxi")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "znB+":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ SiderContext; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ Sider_Sider; });

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.array.index-of.js
var es6_array_index_of = __webpack_require__("V7cS");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.create.js
var es6_object_create = __webpack_require__("PAbq");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__("1qKx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("5hJT");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.object.define-property.js
var es6_object_define_property = __webpack_require__("d3/y");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__("+jjx");

// EXTERNAL MODULE: ../node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("ABKx");

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ../node_modules/omit.js/es/index.js
var es = __webpack_require__("x9u5");

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/BarsOutlined.js
var BarsOutlined = __webpack_require__("oRxD");
var BarsOutlined_default = /*#__PURE__*/__webpack_require__.n(BarsOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/RightOutlined.js
var RightOutlined = __webpack_require__("rwvH");
var RightOutlined_default = /*#__PURE__*/__webpack_require__.n(RightOutlined);

// EXTERNAL MODULE: ../node_modules/@ant-design/icons/LeftOutlined.js
var LeftOutlined = __webpack_require__("6Dst");
var LeftOutlined_default = /*#__PURE__*/__webpack_require__.n(LeftOutlined);

// EXTERNAL MODULE: ../node_modules/antd/es/layout/layout.js
var layout = __webpack_require__("tvu5");

// EXTERNAL MODULE: ../node_modules/antd/es/config-provider/context.js + 4 modules
var config_provider_context = __webpack_require__("Bfez");

// CONCATENATED MODULE: ../node_modules/antd/es/_util/isNumeric.js
var isNumeric = function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};

/* harmony default export */ var _util_isNumeric = (isNumeric);
// CONCATENATED MODULE: ../node_modules/antd/es/layout/Sider.js








function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










var dimensionMaxMap = {
  xs: '479.98px',
  sm: '575.98px',
  md: '767.98px',
  lg: '991.98px',
  xl: '1199.98px',
  xxl: '1599.98px'
};
var SiderContext = react["createContext"]({});

var generateId = function () {
  var i = 0;
  return function () {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    i += 1;
    return "".concat(prefix).concat(i);
  };
}();

var Sider_InternalSider = /*#__PURE__*/function (_React$Component) {
  _inherits(InternalSider, _React$Component);

  function InternalSider(props) {
    var _this;

    _classCallCheck(this, InternalSider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(InternalSider).call(this, props));

    _this.responsiveHandler = function (mql) {
      _this.setState({
        below: mql.matches
      });

      var onBreakpoint = _this.props.onBreakpoint;

      if (onBreakpoint) {
        onBreakpoint(mql.matches);
      }

      if (_this.state.collapsed !== mql.matches) {
        _this.setCollapsed(mql.matches, 'responsive');
      }
    };

    _this.setCollapsed = function (collapsed, type) {
      if (!('collapsed' in _this.props)) {
        _this.setState({
          collapsed: collapsed
        });
      }

      var onCollapse = _this.props.onCollapse;

      if (onCollapse) {
        onCollapse(collapsed, type);
      }
    };

    _this.toggle = function () {
      var collapsed = !_this.state.collapsed;

      _this.setCollapsed(collapsed, 'clickTrigger');
    };

    _this.belowShowChange = function () {
      _this.setState(function (_ref) {
        var belowShow = _ref.belowShow;
        return {
          belowShow: !belowShow
        };
      });
    };

    _this.renderSider = function (_ref2) {
      var _classNames;

      var getPrefixCls = _ref2.getPrefixCls;

      var _a = _this.props,
          customizePrefixCls = _a.prefixCls,
          className = _a.className,
          theme = _a.theme,
          collapsible = _a.collapsible,
          reverseArrow = _a.reverseArrow,
          trigger = _a.trigger,
          style = _a.style,
          width = _a.width,
          collapsedWidth = _a.collapsedWidth,
          zeroWidthTriggerStyle = _a.zeroWidthTriggerStyle,
          others = __rest(_a, ["prefixCls", "className", "theme", "collapsible", "reverseArrow", "trigger", "style", "width", "collapsedWidth", "zeroWidthTriggerStyle"]);

      var prefixCls = getPrefixCls('layout-sider', customizePrefixCls);
      var divProps = Object(es["a" /* default */])(others, ['collapsed', 'defaultCollapsed', 'onCollapse', 'breakpoint', 'onBreakpoint', 'siderHook', 'zeroWidthTriggerStyle']);
      var rawWidth = _this.state.collapsed ? collapsedWidth : width; // use "px" as fallback unit for width

      var siderWidth = _util_isNumeric(rawWidth) ? "".concat(rawWidth, "px") : String(rawWidth); // special trigger when collapsedWidth == 0

      var zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? react["createElement"]("span", {
        onClick: _this.toggle,
        className: "".concat(prefixCls, "-zero-width-trigger ").concat(prefixCls, "-zero-width-trigger-").concat(reverseArrow ? 'right' : 'left'),
        style: zeroWidthTriggerStyle
      }, react["createElement"](BarsOutlined_default.a, null)) : null;
      var iconObj = {
        expanded: reverseArrow ? react["createElement"](RightOutlined_default.a, null) : react["createElement"](LeftOutlined_default.a, null),
        collapsed: reverseArrow ? react["createElement"](LeftOutlined_default.a, null) : react["createElement"](RightOutlined_default.a, null)
      };
      var status = _this.state.collapsed ? 'collapsed' : 'expanded';
      var defaultTrigger = iconObj[status];
      var triggerDom = trigger !== null ? zeroWidthTrigger || react["createElement"]("div", {
        className: "".concat(prefixCls, "-trigger"),
        onClick: _this.toggle,
        style: {
          width: siderWidth
        }
      }, trigger || defaultTrigger) : null;

      var divStyle = _extends(_extends({}, style), {
        flex: "0 0 ".concat(siderWidth),
        maxWidth: siderWidth,
        minWidth: siderWidth,
        width: siderWidth
      });

      var siderCls = classnames_default()(className, prefixCls, "".concat(prefixCls, "-").concat(theme), (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-collapsed"), !!_this.state.collapsed), _defineProperty(_classNames, "".concat(prefixCls, "-has-trigger"), collapsible && trigger !== null && !zeroWidthTrigger), _defineProperty(_classNames, "".concat(prefixCls, "-below"), !!_this.state.below), _defineProperty(_classNames, "".concat(prefixCls, "-zero-width"), parseFloat(siderWidth) === 0), _classNames));
      return react["createElement"]("aside", _extends({
        className: siderCls
      }, divProps, {
        style: divStyle
      }), react["createElement"]("div", {
        className: "".concat(prefixCls, "-children")
      }, _this.props.children), collapsible || _this.state.below && zeroWidthTrigger ? triggerDom : null);
    };

    _this.uniqueId = generateId('ant-sider-');
    var matchMedia;

    if (typeof window !== 'undefined') {
      matchMedia = window.matchMedia;
    }

    if (matchMedia && props.breakpoint && props.breakpoint in dimensionMaxMap) {
      _this.mql = matchMedia("(max-width: ".concat(dimensionMaxMap[props.breakpoint], ")"));
    }

    var collapsed;

    if ('collapsed' in props) {
      collapsed = props.collapsed;
    } else {
      collapsed = props.defaultCollapsed;
    }

    _this.state = {
      collapsed: collapsed,
      below: false
    };
    return _this;
  }

  _createClass(InternalSider, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.mql) {
        this.mql.addListener(this.responsiveHandler);
        this.responsiveHandler(this.mql);
      }

      if (this.props.siderHook) {
        this.props.siderHook.addSider(this.uniqueId);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.mql) {
        this.mql.removeListener(this.responsiveHandler);
      }

      if (this.props.siderHook) {
        this.props.siderHook.removeSider(this.uniqueId);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var collapsed = this.state.collapsed;
      var collapsedWidth = this.props.collapsedWidth;
      return react["createElement"](SiderContext.Provider, {
        value: {
          siderCollapsed: collapsed,
          collapsedWidth: collapsedWidth
        }
      }, react["createElement"](config_provider_context["a" /* ConfigConsumer */], null, this.renderSider));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps) {
      if ('collapsed' in nextProps) {
        return {
          collapsed: nextProps.collapsed
        };
      }

      return null;
    }
  }]);

  return InternalSider;
}(react["Component"]);

Sider_InternalSider.defaultProps = {
  collapsible: false,
  defaultCollapsed: false,
  reverseArrow: false,
  width: 200,
  collapsedWidth: 80,
  style: {},
  theme: 'dark'
}; // eslint-disable-next-line react/prefer-stateless-function

var Sider_Sider = /*#__PURE__*/function (_React$Component2) {
  _inherits(Sider, _React$Component2);

  function Sider() {
    _classCallCheck(this, Sider);

    return _possibleConstructorReturn(this, _getPrototypeOf(Sider).apply(this, arguments));
  }

  _createClass(Sider, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return react["createElement"](layout["a" /* LayoutContext */].Consumer, null, function (context) {
        return react["createElement"](Sider_InternalSider, _extends({}, context, _this2.props));
      });
    }
  }]);

  return Sider;
}(react["Component"]);



/***/ }),

/***/ "zqvS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("d3/y");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _InfoCircleFilled = _interopRequireDefault(__webpack_require__("QW2R"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _default = _InfoCircleFilled;
exports["default"] = _default;
module.exports = _default;

/***/ }),

/***/ "zuwH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("Z8gF");var offsetY=0;var getTargetOffset=function getTargetOffset(hash){var id=window.decodeURI(hash.replace("#",""));if(id!==""){var element=document.getElementById(id);if(element){var scrollTop=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop;var clientTop=document.documentElement.clientTop||document.body.clientTop||0;return element.getBoundingClientRect().top+scrollTop-clientTop-offsetY;}}return null;};exports.onInitialClientRender=function(_,pluginOptions){if(pluginOptions.offsetY){offsetY=pluginOptions.offsetY;}requestAnimationFrame(function(){var offset=getTargetOffset(window.location.hash);if(offset!==null){window.scrollTo(0,offset);}});};exports.shouldUpdateScroll=function(_ref){var location=_ref.routerProps.location;var offset=getTargetOffset(location.hash);return offset!==null?[0,offset]:true;};

/***/ }),

/***/ "zx98":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__("XQta");
var validate = __webpack_require__("SsG5");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__("AkS8")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ })

},[["UxWs",12,0,2]]]);
//# sourceMappingURL=app-19c4b6443e6d64c28fbd.js.map